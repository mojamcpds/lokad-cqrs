<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lokad.Cloud.Storage</name>
    </assembly>
    <members>
        <member name="T:Lokad.Cloud.Storage.Infrastructure.IIntermediateDataSerializer">
            <summary>
            Optional extension for custom formatters supporting an
            intermediate xml representation for inspection and recovery.
            </summary>
            <remarks>
            This extension can be implemented even when the serializer
            is not xml based but in a format that can be transformed
            to xml easily in a robust way (i.e. more robust than
            deserializing to a full object). Note that formatters
            should be registered in IoC as IBinaryFormatter, not by
            this extension interface.
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Infrastructure.IIntermediateDataSerializer.UnpackXml(System.IO.Stream)">
            <summary>Unpack and transform an object from a stream to xml.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Infrastructure.IIntermediateDataSerializer.RepackXml(System.Xml.Linq.XElement,System.IO.Stream)">
            <summary>Transform and repack an object from xml to a stream.</summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Infrastructure.AzurePolicies">
            <summary>
            Azure retry policies for corner-situation and server errors.
            </summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Infrastructure.AzurePolicies.#cctor">
            <summary>
            Static Constructor
            </summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Infrastructure.AzurePolicies.TransientServerErrorBackOff">
            <summary>
            Retry policy to temporarily back off in case of transient Azure server
            errors, system overload or in case the denial of service detection system
            thinks we're a too heavy user. Blocks the thread while backing off to
            prevent further requests for a while (per thread).
            </summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Infrastructure.AzurePolicies.TransientTableErrorBackOff">
            <summary>Similar to <see cref="P:Lokad.Cloud.Storage.Infrastructure.AzurePolicies.TransientServerErrorBackOff"/>, yet
            the Table Storage comes with its own set or exceptions/.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Infrastructure.AzurePolicies.SlowInstantiation">
            <summary>
            Very patient retry policy to deal with container, queue or table instantiation
            that happens just after a deletion.
            </summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Lists.CloudList`1">
            <summary>Strong-typed utility wrapper for the <see cref="T:Lokad.Cloud.Storage.Lists.IListStorage"/>.</summary>
            <remarks>
            The purpose of the <c>CloudList{T}</c> is to provide a strong-typed access to the
            table storage in the client code. Indeed, the row table storage provider typically
            let you (potentially) mix different types into a single table.
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.#ctor(Lokad.Cloud.Storage.Lists.IListStorage,System.String)">
            <remarks></remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Get(System.String,System.String)">
            <seealso cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String,System.String)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Get">
            <seealso cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Get(System.String)">
            <seealso cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String,System.String)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Get(System.String,System.String,System.String)">
            <seealso cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Get(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Insert(System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{`0}})">
            <seealso cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Insert``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}})"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Insert(Lokad.Cloud.Storage.Lists.ListEntry{`0})">
            <seealso cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Insert``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}})"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Update(System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{`0}})">
            <seealso cref="!:IListStorage.Update&lt;T&gt;(string, IEnumerable&lt;ListEntry&lt;T&gt;&gt;)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Update(Lokad.Cloud.Storage.Lists.ListEntry{`0})">
            <seealso cref="!:IListStorage.Update&lt;T&gt;(string, IEnumerable&lt;ListEntry&lt;T&gt;&gt;)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Upsert(System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{`0}})">
            <seealso cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Upsert``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}})"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Upsert(Lokad.Cloud.Storage.Lists.ListEntry{`0})">
            <seealso cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Upsert``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}})"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Delete(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <seealso cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Delete``1(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.CloudList`1.Delete(System.String,System.String)">
            <seealso cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Delete``1(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})"/>
        </member>
        <member name="P:Lokad.Cloud.Storage.Lists.CloudList`1.Name">
            <summary>Name of the underlying table.</summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Lists.MemoryListStorage">
            <summary>Mock in-memory listStorage Provider.</summary>
            <remarks>
            All the methods of <see cref="T:Lokad.Cloud.Storage.Lists.MemoryListStorage"/> are thread-safe.
            </remarks>
        </member>
        <member name="T:Lokad.Cloud.Storage.Lists.IListStorage">
            <summary>Abstraction for the Table Storage.</summary>
            <remarks>This provider represents a logical abstraction of the Table Storage,
            not the Table Storage itself. In particular, implementations handle paging
            and query splitting internally. Also, this provider implicitly relies on
            serialization to handle generic entities (not constrained by the few datatypes
            available to the Table Storage).</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.IListStorage.CreateList(System.String)">
            <summary>Creates a new table if it does not exist already.</summary>
            <returns><c>true</c> if a new table has been created.
            <c>false</c> if the table already exists.
            </returns>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.IListStorage.DeleteList(System.String)">
            <summary>Deletes a table if it exists.</summary>
            <returns><c>true</c> if the table has been deleted.
            <c>false</c> if the table does not exist.
            </returns>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.IListStorage.GetLists">
            <summary>Returns the list of all the tables that exist in the storage.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String)">
            <summary>Iterates through all entities of a given table.</summary>
            <remarks>The enumeration is typically expected to be lazy, iterating through
            all the entities with paged request. If the table does not exist, an
            empty enumeration is returned.
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String,System.String)">
            <summary>Iterates through all entities of a given table and partition.</summary>
            <remarks><para>The enumeration is typically expected to be lazy, iterating through
            all the entities with paged request. If the table does not exists, or if the partition
            does not exists, an empty enumeration is returned.</para>
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String,System.String,System.String,System.String)">
            <summary>Iterates through a range of entities of a given table and partition.</summary>
            <param name="tableName">Name of the Table.</param>
            <param name="partitionKey">Name of the partition which can not be null.</param>
            <param name="startRowKey">Inclusive start row key. If <c>null</c>, no start range
            constraint is enforced.</param>
            <param name="endRowKey">Exclusive end row key. If <c>null</c>, no ending range
            constraint is enforced.</param>
            <remarks>
            The enumeration is typically expected to be lazy, iterating through
            all the entities with paged request.The enumeration is ordered by row key.
            If the table or the partition key does not exist, the returned enumeration is empty.
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Iterates through all entities specified by their row keys.</summary>
            <param name="tableName">The name of the table. This table should exists otherwise the method will fail.</param>
            <param name="partitionKey">Partition key (can not be null).</param>
            <param name="rowKeys">lazy enumeration of non null string representing rowKeys.</param>
            <remarks>The enumeration is typically expected to be lazy, iterating through
            all the entities with paged request. If the table or the partition key does not exist,
            the returned enumeration is empty.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.IListStorage.Insert``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}})">
             <summary>Inserts a collection of new entities into the table storage.</summary>
             <remarks>
             <para>The call is expected to fail on the first encountered already-existing
             entity. Results are not garanteed if one or several entities already exist.
             </para>
             <para>There is no upper limit on the number of entities provided through
             the enumeration. The implementations are expected to lazily iterates
             and to create batch requests as the move forward.
             </para>
             <para>If the table does not exist then it should be created.</para>
             <warning>Idempotence is not enforced.</warning>
             </remarks>
            <exception cref="T:System.InvalidOperationException"> if an already existing entity has been encountered.</exception>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.IListStorage.Update``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}},System.Boolean)">
            <summary>Updates a collection of existing entities into the table storage.</summary>
            <remarks>
            <para>The call is expected to fail on the first non-existing entity. 
            Results are not garanteed if one or several entities do not exist already.
            </para>
            <para>If <paramref name="force"/> is <c>false</c>, the call is expected to
            fail if one or several entities have changed in the meantime. If <c>true</c>,
            the entities are overwritten even if they've been changed remotely in the meantime.
            </para>
            <para>There is no upper limit on the number of entities provided through
            the enumeration. The implementations are expected to lazily iterates
            and to create batch requests as the move forward.
            </para>
            <para>Idempotence of the implementation is required.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException"> thrown if the table does not exist
            or an non-existing entity has been encountered.</exception>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.IListStorage.Upsert``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}})">
            <summary>Updates or insert a collection of existing entities into the table storage.</summary>
            <remarks>
            <para>New entities will be inserted. Existing entities will be updated,
            even if they have changed remotely in the meantime.
            </para>
            <para>There is no upper limit on the number of entities provided through
            the enumeration. The implementations are expected to lazily iterates
            and to create batch requests as the move forward.
            </para>
            <para>If the table does not exist then it should be created.</para>
            <para>Idempotence of the implementation is required.</para>
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.IListStorage.Delete``1(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Deletes all specified entities.</summary>
            <param name="listName">Name of the table.</param>
            <param name="partitionKey">The partition key (assumed to be non null).</param>
            <param name="rowKeys">Lazy enumeration of non null string representing the row keys.</param>
            <remarks>
            <para>
            The implementation is expected to lazily iterate through all row keys
            and send batch deletion request to the underlying storage.</para>
            <para>Idempotence of the method is required.</para>
            <para>The method should not fail if the table does not exist.</para>
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.IListStorage.Delete``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}},System.Boolean)">
            <summary>Deletes a collection of entities.</summary>
            <remarks>
            <para>
            The implementation is expected to lazily iterate through all row keys
            and send batch deletion request to the underlying storage.</para>
            <para>Idempotence of the method is required.</para>
            <para>The method should not fail if the table does not exist.</para>
            <para>If <paramref name="force"/> is <c>false</c>, the call is expected to
            fail if one or several entities have changed remotely in the meantime. If <c>true</c>,
            the entities are deleted even if they've been changed remotely in the meantime.
            </para>
            </remarks>
        </member>
        <member name="F:Lokad.Cloud.Storage.Lists.MemoryListStorage._tables">
            <summary>In memory table storage : entries per table (designed for simplicity instead of performance)</summary>
        </member>
        <member name="F:Lokad.Cloud.Storage.Lists.MemoryListStorage._serializer">
            <summary>Formatter as requiered to handle FatEntities.</summary>
        </member>
        <member name="F:Lokad.Cloud.Storage.Lists.MemoryListStorage._syncRoot">
            <summary>naive global lock to make methods thread-safe.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.#ctor">
            <summary>
            Constructor for <see cref="T:Lokad.Cloud.Storage.Lists.MemoryListStorage"/>.
            </summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.CreateList(System.String)">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.CreateList(System.String)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.DeleteList(System.String)">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.DeleteList(System.String)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.GetLists">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.GetLists"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.GetInternal``1(System.String,System.Func{Lokad.Cloud.Storage.Lists.MemoryListStorage.MockTableEntry,System.Boolean})">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.Get``1(System.String)">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.Get``1(System.String,System.String)">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String,System.String)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.Get``1(System.String,System.String,System.String,System.String)">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.Get``1(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Get``1(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.Insert``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}})">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Insert``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}})"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.Update``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}},System.Boolean)">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Update``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}},System.Boolean)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.Upsert``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}})">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Update``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}},System.Boolean)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.Delete``1(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Delete``1(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.MemoryListStorage.Delete``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}},System.Boolean)">
            <see cref="M:Lokad.Cloud.Storage.Lists.IListStorage.Delete``1(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})"/>
        </member>
        <member name="T:Lokad.Cloud.Storage.Documents.MemoryDocumentStorage">
            <summary>Mock in-memory Blob Storage.</summary>
            <remarks>
            All the methods of <see cref="T:Lokad.Cloud.Storage.Documents.MemoryDocumentStorage"/> are thread-safe.
            </remarks>
        </member>
        <member name="T:Lokad.Cloud.Storage.Documents.IDocumentStorage">
            <summary>Abstraction for the Blob Storage.</summary>
            <remarks>
            This provider represents a <em>logical</em> blob storage, not the actual
            Blob Storage. In particular, this provider deals with overflowing buffers
            that need to be split in smaller chunks to be uploaded.
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.CreateContainer(System.String)">
            <summary>Create a new document container.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.DeleteContainer(System.String)">
            <summary>Delete a document container.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.List(System.String,System.String)">
            <summary>Iterates over the blobs considering the specified prefix.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.Get(System.String,System.String,System.Type,System.String@)">
            <summary>Get a blob, if available.</summary>
            <param name="containerName">Name of the container.</param>
            <param name="blobName">Name of the blob.</param>
            <param name="type">The type of the blob.</param>
            <param name="etag">Identifier assigned by the storage to the blob
            that can be used to distinguish be successive version of the blob 
            (useful to check for blob update).</param>
            <returns>
            If there is no such blob, the returned object
            has its property HasValue set to <c>false</c>.
            </returns>
            <remarks>This method should only be used when the caller does not know the type of the
            object stored in the blob at compile time, but it can only be determined at run time.
            In all other cases, you should use the generic overloads of the method.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.Get``1(System.String,System.String,System.String@)">
            <summary>Gets a blob.</summary>
            <typeparam name="T">Blob type.</typeparam>
            <param name="containerName">Name of the container.</param>
            <param name="blobName">Name of the blob.</param>
            <param name="etag">Identifier assigned by the storage to the blob
            that can be used to distinguish be successive version of the blob 
            (useful to check for blob update).</param>
            <returns>
            If there is no such blob, the returned object
            has its property HasValue set to <c>false</c>.
            </returns>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.GetRange``1(System.String,System.String[],System.String[]@)">
            <summary>
            Gets a range of blobs.
            </summary>
            <typeparam name="T">Blob type.</typeparam>
            <param name="containerName">Name of the container.</param>
            <param name="blobNames">Names of the blobs.</param>
            <param name="etags">Etag identifiers for all returned blobs.</param>
            <returns>For each requested blob, an element in the array is returned in the same order.
            If a specific blob was not found, the corresponding <b>etags</b> array element is <c>null</c>.</returns>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.GetIfModified``1(System.String,System.String,System.String,System.String@)">
            <summary>Gets a blob only if the etag has changed meantime.</summary>
            <typeparam name="T">Type of the blob.</typeparam>
            <param name="containerName">Name of the container.</param>
            <param name="blobName">Name of the blob.</param>
            <param name="oldEtag">Old etag value. If this value is <c>null</c>, the blob will always
            be retrieved (except if the blob does not exist anymore).</param>
            <param name="newEtag">New etag value. Will be <c>null</c> if the blob no more exist,
            otherwise will be set to the current etag value of the blob.</param>
            <returns>
            If the blob has not been modified or if there is no such blob,
            then the returned object has its property HasValue set to <c>false</c>.
            </returns>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.GetEtag(System.String,System.String)">
            <summary>
            Gets the current etag of the blob, or <c>null</c> if the blob does not exists.
            </summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.GetAsXml(System.String,System.String,System.String@)">
            <summary>
            Gets a blob in intermediate XML representation for inspection and recovery,
            if supported by the serialization formatter.
            </summary>
            <param name="containerName">Name of the container.</param>
            <param name="blobName">Name of the blob.</param>
            <param name="etag">Identifier assigned by the storage to the blob
            that can be used to distinguish be successive version of the blob 
            (useful to check for blob update).</param>
            <returns>
            If there is no such blob or the formatter supports no XML representation,
            the returned object has its property HasValue set to <c>false</c>.
            </returns>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.PutBlob(System.String,System.String,System.Object,System.Type,System.Boolean,System.String@)">
            <summary>Puts a blob and optionally overwrite.</summary>
            <param name="containerName">Name of the container.</param>
            <param name="blobName">Name of the blob.</param>
            <param name="item">Item to be put.</param>
            <param name="type">The type of the blob.</param>
            <param name="overwrite">Indicates whether existing blob should be overwritten
            if it exists.</param>
            <param name="etag">New etag (identifier used to track for blob change) if
            the blob is written, or <c>null</c> if no blob is written.</param>
            <remarks>Creates the container if it does not exist beforehand.</remarks>
            <returns><c>true</c> if the blob has been put and <c>false</c> if the blob already
            exists but could not be overwritten.</returns>
            <remarks>This method should only be used when the caller does not know the type of the
            object stored in the blob at compile time, but it can only be determined at run time.
            In all other cases, you should use the generic overloads of the method.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.UpdateIfNotModified``1(System.String,System.String,System.Func{Lokad.Maybe{``0},Lokad.Result{``0}},Lokad.Result{``0}@)">
            <summary>Update a blob while guaranteeing an atomic update process.</summary>
            <param name="containerName"></param>
            <param name="blobName"></param>
            <param name="updater">The function takes a <c>T</c> object to update
            and returns a <see cref="T:Lokad.Result`1"/> if update has succeed,
            because the updater can optionally decide not to succeed with the update
            (in case where the update no more relevant for example.</param>
            <param name="result">Result returned by the updated.</param>
            <returns><c>true</c> if the update is successful.
            If the blob is updated between the retrieval and the update attempt,
            then no update is performed and the method returns <c>false</c>.</returns>
            <remarks>If there is not such blob available, the update is performed with
            the default <c>T</c> value.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.UpdateIfNotModified``1(System.String,System.String,System.Func{Lokad.Maybe{``0},``0},``0@)">
            <seealso cref="!:UpdateIfNotModified&lt;T&gt;(string,string,System.Func&lt;T,Lokad.Result&lt;T&gt;&gt;,out Lokad.Result&lt;T&gt;)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.UpdateIfNotModified``1(System.String,System.String,System.Func{Lokad.Maybe{``0},Lokad.Result{``0}})">
            <summary>Update a blob while guaranteeing an atomic update process.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.UpdateIfNotModified``1(System.String,System.String,System.Func{Lokad.Maybe{``0},``0})">
            <seealso cref="!:UpdateIfNotModified&lt;T&gt;(string,string,System.Func&lt;T,Lokad.Result&lt;T&gt;&gt;)"/>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.IDocumentStorage.Delete(System.String,System.String)">
            <summary>Deletes a blob.</summary>
        </member>
        <member name="F:Lokad.Cloud.Storage.Documents.MemoryDocumentStorage._syncRoot">
            <summary>naive global lock to make methods thread-safe.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Documents.MemoryDocumentStorage.Containers">
            <summary> Containers Property.</summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Documents.UntypedDocumentName">
            <summary>
            Base class for untyped hierarchical blob names. Implementations should
            not inherit <see cref="T:Lokad.Cloud.Storage.Documents.UntypedDocumentName"/>c&gt; but <see cref="T:Lokad.Cloud.Storage.Documents.DocumentName`1"/> instead.
            </summary>
        </member>
        <member name="F:Lokad.Cloud.Storage.Documents.UntypedDocumentName.DateFormatInBlobName">
            <summary>Sortable pattern for date times.</summary>
            <remarks>Hyphens can be eventually used to refine further the iteration.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.UntypedDocumentName.Print``1(``0)">
            <summary>Do not use directly, call <see cref="M:Lokad.Cloud.Storage.Documents.UntypedDocumentName.ToString"/> instead.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.UntypedDocumentName.Parse``1(System.String)">
            <summary>Parse a hierarchical blob name.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.UntypedDocumentName.GetContainerName``1">
            <summary>Returns the <see cref="P:Lokad.Cloud.Storage.Documents.UntypedDocumentName.ContainerName"/> value without
            having an instance at hand.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Documents.UntypedDocumentName.ContainerName">
            <summary>Name of the container (to be used as a short-hand while
            operating with the <see cref="T:Lokad.Cloud.Storage.Documents.IDocumentStorage"/>).</summary>
            <remarks>Do not introduce an extra field for the property as
            it would be incorporated in the blob name. Instead, just
            return a constant string.</remarks>
        </member>
        <member name="T:Lokad.Cloud.Storage.Infrastructure.CloudFormatter">
            <summary>
            Formatter based on <c>DataContractSerializer</c> and <c>NetDataContractSerializer</c>. 
            The formatter targets storage of persistent or transient data in the cloud storage.
            </summary>
            <remarks>
            If a <c>DataContract</c> attribute is present, then the <c>DataContractSerializer</c>
            is favored. If not, then the <c>NetDataContractSerializer</c> is used instead.
            This class is not <b>thread-safe</b>.
            </remarks>
        </member>
        <member name="T:Lokad.Cloud.Storage.Queues.MemoryQueueStorage">
            <summary>Mock in-memory Queue Storage.</summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Queues.IQueueStorage">
            <summary>Abstraction of the Queue Storage.</summary>
            <remarks>
            This provider represents a <em>logical</em> queue, not the actual
            Queue Storage. In particular, the provider implementation deals
            with overflowing messages (that is to say messages larger than 8kb)
            on its own.
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.List(System.String)">
            <summary>Gets the list of queues whose name start with the specified prefix.</summary>
            <param name="prefix">If <c>null</c> or empty, returns all queues.</param>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.Get``1(System.String,System.Int32,System.TimeSpan,System.Int32)">
            <summary>Gets messages from a queue.</summary>
            <typeparam name="T">Type of the messages.</typeparam>
            <param name="queueName">Identifier of the queue to be pulled.</param>
            <param name="count">Maximal number of messages to be retrieved.</param>
            <param name="visibilityTimeout">
            The visibility timeout, indicating when the not yet deleted message should
            become visible in the queue again.
            </param>
            <param name="maxProcessingTrials">
            Maximum number of message processing trials, before the message is considered as
            being poisonous, removed from the queue and persisted to the 'failing-messages' store.
            </param>
            <returns>Enumeration of messages, possibly empty.</returns>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.Put``1(System.String,``0)">
            <summary>Put a message on a queue.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.PutRange``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>Put messages on a queue.</summary>
            <typeparam name="T">Type of the messages.</typeparam>
            <param name="queueName">Identifier of the queue where messages are put.</param>
            <param name="messages">Messages to be put.</param>
            <remarks>If the queue does not exist, it gets created.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.Clear(System.String)">
            <summary>Clear all the messages from the specified queue.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.Delete``1(``0)">
            <summary>Deletes a message being processed from the queue.</summary>
            <returns><c>True</c> if the message has been deleted.</returns>
            <remarks>Message must have first been retrieved through <see cref="M:Lokad.Cloud.Storage.Queues.IQueueStorage.Get``1(System.String,System.Int32,System.TimeSpan,System.Int32)"/>.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.DeleteRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Deletes messages being processed from the queue.</summary>
            <typeparam name="T">Type of the messages.</typeparam>
            <param name="messages">Messages to be removed.</param>
            <returns>The number of messages actually deleted.</returns>
            <remarks>Messages must have first been retrieved through <see cref="M:Lokad.Cloud.Storage.Queues.IQueueStorage.Get``1(System.String,System.Int32,System.TimeSpan,System.Int32)"/>.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.Abandon``1(``0)">
            <summary>
            Abandon a message being processed and put it visibly back on the queue.
            </summary>
            <typeparam name="T">Type of the message.</typeparam>
            <param name="message">Message to be abandoned.</param>
            <returns><c>True</c> if the original message has been deleted.</returns>
            <remarks>Message must have first been retrieved through <see cref="M:Lokad.Cloud.Storage.Queues.IQueueStorage.Get``1(System.String,System.Int32,System.TimeSpan,System.Int32)"/>.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.AbandonRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Abandon a set of messages being processed and put them visibly back on the queue.
            </summary>
            <typeparam name="T">Type of the messages.</typeparam>
            <param name="messages">Messages to be abandoned.</param>
            <returns>The number of original messages actually deleted.</returns>
            <remarks>Messages must have first been retrieved through <see cref="M:Lokad.Cloud.Storage.Queues.IQueueStorage.Get``1(System.String,System.Int32,System.TimeSpan,System.Int32)"/>.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.Persist``1(``0,System.String,System.String)">
            <summary>
            Persist a message being processed to a store and remove it from the queue.
            </summary>
            <typeparam name="T">Type of the message.</typeparam>
            <param name="message">Message to be persisted.</param>
            <param name="storeName">Name of the message persistence store.</param>
            <param name="reason">Optional reason text on why the message has been taken out of the queue.</param>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.PersistRange``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>
            Persist a set of messages being processed to a store and remove them from the queue.
            </summary>
            <typeparam name="T">Type of the messages.</typeparam>
            <param name="messages">Messages to be persisted.</param>
            <param name="storeName">Name of the message persistence store.</param>
            <param name="reason">Optional reason text on why the messages have been taken out of the queue.</param>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.ListPersisted(System.String)">
            <summary>
            Enumerate the keys of all persisted messages of the provided store.
            </summary>
            <param name="storeName">Name of the message persistence store.</param>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.GetPersisted(System.String,System.String)">
            <summary>
            Get details of a persisted message for inspection and recovery.
            </summary>
            <param name="storeName">Name of the message persistence store.</param>
            <param name="key">Unique key of the persisted message as returned by ListPersisted.</param>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.DeletePersisted(System.String,System.String)">
            <summary>
            Delete a persisted message.
            </summary>
            <param name="storeName">Name of the message persistence store.</param>
            <param name="key">Unique key of the persisted message as returned by ListPersisted.</param>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.RestorePersisted(System.String,System.String)">
            <summary>
            Put a persisted message back to the queue and delete it.
            </summary>
            <param name="storeName">Name of the message persistence store.</param>
            <param name="key">Unique key of the persisted message as returned by ListPersisted.</param>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.DeleteQueue(System.String)">
            <summary>Deletes a queue.</summary>
            <returns><c>true</c> if the queue name has been actually deleted.</returns>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.GetApproximateCount(System.String)">
            <summary>Gets the approximate number of items in this queue.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.IQueueStorage.GetApproximateLatency(System.String)">
            <summary>Gets the approximate age of the top message of this queue.</summary>
        </member>
        <member name="F:Lokad.Cloud.Storage.Queues.MemoryQueueStorage._sync">
            <summary>Root used to synchronize accesses to <c>_inprocess</c>.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.MemoryQueueStorage.#ctor">
            <summary>Default constructor.</summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Queues.DelayedMessage">
            <summary>Used as a wrapper for delayed messages (stored in the
            blob storage waiting to be pushed into a queue).</summary>
            <seealso cref="!:DelayedQueue.PutWithDelay&lt;T&gt;(T,System.DateTime)"/>
            <remarks>
            Due to genericity, this message is not tagged with <c>DataContract</c>.
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.DelayedMessage.#ctor(System.String,System.Object)">
            <summary>Full constructor.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.DelayedMessage.QueueName">
            <summary>Name of the queue where the inner message will be put
            once the delay is expired.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.DelayedMessage.InnerMessage">
            <summary>Inner message.</summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Documents.DocumentName`1">
            <summary>
            Base class for strongly typed hierarchical references to blobs of a
            strongly typed content.
            </summary>
            <typeparam name="T">Type contained in the blob.</typeparam>
            <remarks>
            The type <c>T</c> is handy to strengthen the 
            <see cref="!:StorageExtensions"/>.
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.DelayedMessageName.#ctor">
            <summary>Empty constructor, used for prefixing.</summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Queues.DelayedQueue">
            <summary>Allows to put messages in a queue, delaying them as needed.</summary>
            <remarks>A <see cref="T:Lokad.Cloud.Storage.Documents.IDocumentStorage"/> is used for storing messages that 
            must be enqueued with a delay.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.DelayedQueue.#ctor(Lokad.Cloud.Storage.Documents.IDocumentStorage)">
            <summary>Initializes a new instance of the <see cref="T:Lokad.Cloud.Storage.Queues.DelayedQueue"/> class.</summary>
            <param name="provider">The blob storage provider.</param>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.DelayedQueue.PutWithDelay``1(``0,System.DateTimeOffset)">
            <summary>Put a message into the queue implicitly associated to the type <c>T</c> at the
            time specified by the <c>triggerTime</c>.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.DelayedQueue.PutWithDelay``1(``0,System.DateTimeOffset,System.String)">
            <summary>Put a message into the queue identified by <c>queueName</c> at the
            time specified by the <c>triggerTime</c>.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.DelayedQueue.PutRangeWithDelay``1(System.Collections.Generic.IEnumerable{``0},System.DateTimeOffset)">
            <summary>Put messages into the queue implicitly associated to the type <c>T</c> at the
            time specified by the <c>triggerTime</c>.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.DelayedQueue.PutRangeWithDelay``1(System.Collections.Generic.IEnumerable{``0},System.DateTimeOffset,System.String)">
            <summary>Put messages into the queue identified by <c>queueName</c> at the
            time specified by the <c>triggerTime</c>.</summary>
            <remarks>This method acts as a delayed put operation, the message not being put
            before the <c>triggerTime</c> is reached.</remarks>
        </member>
        <member name="T:Lokad.Cloud.Storage.Lists.ListEntry`1">
            <summary>Entity to be stored by the <see cref="T:Lokad.Cloud.Storage.Lists.IListStorage"/>.</summary>
            <typeparam name="T">Type of the value carried by the entity.</typeparam>
            <remarks>Once serialized the <c>listEntry.Value</c> should weight less
            than 720KB to be compatible with Table Storage limitations on entities.</remarks>
        </member>
        <member name="P:Lokad.Cloud.Storage.Lists.ListEntry`1.RowKey">
            <summary>Indexed system property.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Lists.ListEntry`1.PartitionKey">
            <summary>Indexed system property.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Lists.ListEntry`1.Timestamp">
            <summary>Flag indicating last update. Populated by the Table Storage.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Lists.ListEntry`1.ETag">
            <summary>ETag. Indicates changes. Populated by the Table Storage.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Lists.ListEntry`1.Value">
            <summary>Value carried by the entity.</summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Documents.AzureDocumentStorage">
            <summary>Provides access to the Blob Storage.</summary>
            <remarks>
            All the methods of <see cref="T:Lokad.Cloud.Storage.Documents.AzureDocumentStorage"/> are thread-safe.
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.AzureDocumentStorage.UploadBlobContent(Microsoft.WindowsAzure.StorageClient.CloudBlob,System.IO.Stream,System.Boolean,System.String)">
            <param name="overwrite">If <c>false</c>, then no write happens if the blob already exists.</param>
            <param name="expectedEtag">When specified, no writing occurs unless the blob etag
            matches the one specified as argument.</param>
            <returns></returns>
        </member>
        <member name="T:Lokad.Cloud.Storage.Queues.MessageWrapper">
            <summary>The purpose of the <see cref="T:Lokad.Cloud.Storage.Queues.MessageWrapper"/> is to gracefully
            handle messages that are too large of the queue storage (or messages that 
            happen to be already stored in the Blob Storage).</summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Lists.AzureListStorage">
            <summary>Implementation based on the Table Storage of Windows Azure.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.AzureListStorage.#ctor(Microsoft.WindowsAzure.StorageClient.CloudTableClient,Lokad.Serialization.IDataSerializer)">
            <summary>IoC constructor.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.AzureListStorage.UpsertInternal``1(System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}})">
            <remarks>Upsert is making several storage calls to emulate the 
            missing semantic from the Table Storage.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.AzureListStorage.SliceEntities``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>Slice entities according the payload limitation of
            the transaction group, plus the maximal number of entities to
            be embedded into a single transaction.</summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Lists.ListStorageEntity">
            <summary>This entity is basically a workaround the 64KB limitation
            for entity properties. 15 properties represents a total storage
            capability of 960KB (entity limit is at 1024KB).</summary>
            <remarks>This class is basically a hack against the Table Storage
            to work-around the 64KB limitation for properties.</remarks>
        </member>
        <member name="F:Lokad.Cloud.Storage.Lists.ListStorageEntity.MaxByteCapacity">
            <summary>
            Maximal entity size is 1MB. Out of that, we keep only
            960kb (1MB - 64kb as a safety margin). Then, it should be taken
            into account that byte[] are Base64 encoded which represent
            a penalty overhead of 4/3 - hence the reduced capacity.
            </summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.ListStorageEntity.GetPayload">
            <summary>Returns an upper bound approximation of the payload associated to
            the entity once serialized as XML Atom (used for communication with the
            Table Storage).</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.ListStorageEntity.Convert``1(Lokad.Cloud.Storage.Lists.ListStorageEntity,Lokad.Serialization.IDataSerializer,System.String)">
            <summary>Converts a <c>listStorageEntity</c> toward a <c>listEntry</c>.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.ListStorageEntity.Convert``1(Lokad.Cloud.Storage.Lists.ListEntry{``0},Lokad.Serialization.IDataSerializer)">
            <summary>Converts a <c>listEntry</c> toward a <c>listStorageEntity</c>.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.ListStorageExtensions.Get``1(Lokad.Cloud.Storage.Lists.IListStorage,System.String,System.String,System.String)">
            <summary>Gets the specified cloud entity if it exists.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.ListStorageExtensions.GetTable``1(Lokad.Cloud.Storage.Lists.IListStorage,System.String)">
            <summary>Gets a strong typed wrapper around the table storage provider.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.ListStorageExtensions.Update``1(Lokad.Cloud.Storage.Lists.IListStorage,System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}})">
            <summary>Updates a collection of existing entities into the table storage.</summary>
            <remarks>
            <para>The call is expected to fail on the first non-existing entity. 
            Results are not garanteed if one or several entities do not exist already.
            </para>
            <para>The call is also expected to fail if one or several entities have
            changed remotely in the meantime. Use the overloaded method with the additional
            force parameter to change this behavior if needed.
            </para>
            <para>There is no upper limit on the number of entities provided through
            the enumeration. The implementations are expected to lazily iterates
            and to create batch requests as the move forward.
            </para>
            <para>Idempotence of the implementation is required.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException"> thrown if the table does not exist
            or an non-existing entity has been encountered.</exception>
        </member>
        <member name="M:Lokad.Cloud.Storage.Lists.ListStorageExtensions.Delete``1(Lokad.Cloud.Storage.Lists.IListStorage,System.String,System.Collections.Generic.IEnumerable{Lokad.Cloud.Storage.Lists.ListEntry{``0}})">
            <summary>Deletes a collection of entities.</summary>
            <remarks>
            <para>
            The implementation is expected to lazily iterate through all row keys
            and send batch deletion request to the underlying storage.</para>
            <para>Idempotence of the method is required.</para>
            <para>The method should not fail if the table does not exist.</para>
            <para>The call is expected to fail if one or several entities have
            changed remotely in the meantime. Use the overloaded method with the additional
            force parameter to change this behavior if needed.
            </para>
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.DocumentStorageExtensions.RetryUpdate(System.Func{System.Boolean})">
            <summary>Retry an update method until it succeeds. Timing
            increases to avoid overstressing the storage for nothing.</summary>
            <param name="func"></param>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.DocumentStorageExtensions.GetBlob``1(Lokad.Cloud.Storage.Documents.IDocumentStorage,System.String,System.String)">
            <summary>Gets a blob.</summary>
            <returns>
            If there is no such blob, the returned object
            has its property HasValue set to <c>false</c>.
            </returns>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.DocumentStorageExtensions.GetBlobOrDelete``1(Lokad.Cloud.Storage.Documents.IDocumentStorage,System.String,System.String)">
            <summary>Gets the corresponding object. If the deserialization fails
            just delete the existing copy.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.DocumentStorageExtensions.GetBlobOrDelete``1(Lokad.Cloud.Storage.Documents.IDocumentStorage,Lokad.Cloud.Storage.Documents.DocumentName{``0})">
            <summary>Gets the corresponding object. If the deserialization fails
            just delete the existing copy.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.DocumentStorageExtensions.PutBlob``1(Lokad.Cloud.Storage.Documents.IDocumentStorage,System.String,System.String,``0)">
            <summary>Puts a blob (overwrite if the blob already exists).</summary>
            <remarks>Creates the container if it does not exist beforehand.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.DocumentStorageExtensions.PutBlob``1(Lokad.Cloud.Storage.Documents.IDocumentStorage,System.String,System.String,``0,System.Boolean)">
            <summary>Puts a blob and optionally overwrite.</summary>
            <remarks>Creates the container if it does not exist beforehand.</remarks>
            <returns><c>true</c> if the blob has been put and <c>false</c> if the blob already
            exists but could not be overwritten.</returns>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.DocumentStorageExtensions.PutBlob``1(Lokad.Cloud.Storage.Documents.IDocumentStorage,System.String,System.String,``0,System.Boolean,System.String@)">
            <summary>Puts a blob and optionally overwrite.</summary>
            <param name="containerName">Name of the container.</param>
            <param name="blobName">Name of the blob.</param>
            <param name="item">Item to be put.</param>
            <param name="overwrite">Indicates whether existing blob should be overwritten
            if it exists.</param>
            <param name="etag">New etag (identifier used to track for blob change) if
            the blob is written, or <c>null</c> if no blob is written.</param>
            <remarks>Creates the container if it does not exist beforehand.</remarks>
            <returns><c>true</c> if the blob has been put and <c>false</c> if the blob already
            exists but could not be overwritten.</returns>
        </member>
        <member name="T:Lokad.Cloud.Storage.Primitives.CloudCounter">
            <summary>Simple non-sharded counter.</summary>
            <remarks>The content of the counter is stored in a single blob value.</remarks>
        </member>
        <member name="F:Lokad.Cloud.Storage.Primitives.CloudCounter.Aleph">
            <summary>Constant value provided for the cloud enumeration pattern
            over a queue.</summary>
            <remarks>The constant value is <c>2^48</c>, expected to be sufficiently
            large to avoid any arithmetic overflow with <c>long</c> values.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Primitives.CloudCounter.#ctor(Lokad.Cloud.Storage.Documents.IDocumentStorage,Lokad.Cloud.Storage.Documents.DocumentName{System.Decimal})">
            <summary>Shorthand constructor.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Primitives.CloudCounter.#ctor(Lokad.Cloud.Storage.Documents.IDocumentStorage,System.String,System.String)">
            <summary>Full constructor.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Primitives.CloudCounter.GetValue">
            <summary>Returns the value of the counter (or zero if there is no value to
            be returned).</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Primitives.CloudCounter.Increment(System.Decimal)">
            <summary>Atomic increment the counter value.</summary>
            <remarks>If the counter does not exist before hand, it gets created with a zero value.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Primitives.CloudCounter.Reset(System.Decimal)">
            <summary>Reset the counter at the given value.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Primitives.CloudCounter.Delete">
            <summary>Deletes the counter.</summary>
            <returns><c>true</c> if the counter has actually been deleted by the call,
            and <c>false</c> otherwise.</returns>
        </member>
        <member name="P:Lokad.Cloud.Storage.Primitives.CloudCounter.ContainerName">
            <summary>Container that is storing the counter.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Primitives.CloudCounter.BlobName">
            <summary>Blob that is storing the counter.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.QueueStorageExtensions.Get``1(Lokad.Cloud.Storage.Queues.IQueueStorage,System.String,System.Int32)">
            <summary>Gets messages from a queue with a visibility timeout of 2 hours and a maximum of 50 processing trials.</summary>
            <typeparam name="T">Type of the messages.</typeparam>
            <param name="queueName">Identifier of the queue to be pulled.</param>
            <param name="count">Maximal number of messages to be retrieved.</param>
            <returns>Enumeration of messages, possibly empty.</returns>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.QueueStorageExtensions.Get``1(Lokad.Cloud.Storage.Queues.IQueueStorage,System.String,System.Int32,System.Int32)">
            <summary>Gets messages from a queue with a visibility timeout of 2 hours.</summary>
            <typeparam name="T">Type of the messages.</typeparam>
            <param name="queueName">Identifier of the queue to be pulled.</param>
            <param name="count">Maximal number of messages to be retrieved.</param>
            <param name="maxProcessingTrials">
            Maximum number of message processing trials, before the message is considered as
            being poisonous, removed from the queue and persisted to the 'failing-messages' store.
            </param>
            <returns>Enumeration of messages, possibly empty.</returns>
        </member>
        <member name="T:Lokad.Cloud.Storage.Documents.TemporaryDocumentName`1">
            <summary>
            Reference to a unique blob with a fixed limited lifespan.
            </summary>
            <remarks>
            Used in conjunction with the <see cref="!:GarbageCollectorService"/>. Use as
            base class for custom temporary blobs with additional attributes, or use
            the method 
            <see cref="M:Lokad.Cloud.Storage.Documents.TemporaryDocumentName`1.GetNew(System.DateTimeOffset)"/> to instantiate a new instance
            directly linked to the garbage collected container.
            </remarks>
            <typeparam name="T">Type referred by the blob name.</typeparam>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.TemporaryDocumentName`1.#ctor(System.DateTimeOffset,System.String)">
            <summary>
            Explicit constructor.
            </summary>
            <param name="expiration">
            Date that triggers the garbage collection.
            </param>
            <param name="suffix">
            Static suffix (typically used to avoid overlaps between temporary blob name
            inheritor). If the provided suffix is <c>null</c>then the 
            default prefix <c>GetType().FullName</c> is used instead.
            </param>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.TemporaryDocumentName`1.GetNew(System.DateTimeOffset)">
            <summary>
            Gets a full name to a temporary blob.
            </summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Documents.TemporaryDocumentName`1.GetNew(System.DateTimeOffset,System.String)">
            <summary>
            Gets a full name to a temporary blob.
            </summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Documents.TemporaryDocumentName`1.ContainerName">
            <summary>
            Returns the garbage collected container.
            </summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Infrastructure.IRuntimeFinalizer">
            <summary>Collects objects that absolutely need to be disposed
            before the runtime gets shut down.</summary>
            <remarks>
            There is no garanty that registered objects will actually be disposed.
            When a VM is shutdown, a small grace period (30s) is offered to clean-up
            resources before the OS itself is aborted. The runtime finalizer
            should be kept for very critical clean-ups to be performed during the
            grace period.
            
            Typically, the runtime finalizer is used to abandon in-process queue
            messages and lease on blobs. Any extra object that you register here
            is likely to negatively impact more prioritary clean-ups. Use with care.
            
            Implementations must be thread-safe.
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Infrastructure.IRuntimeFinalizer.Register(System.IDisposable)">
            <summary>Register a object for high priority finalization if runtime is terminating.</summary>
            <remarks>The method is idempotent, once an object is registered,
            registering the object again has no effect.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Infrastructure.IRuntimeFinalizer.Unregister(System.IDisposable)">
            <summary>Unregister a object from high priority finalization.</summary>
            <remarks>The method is idempotent, once an object is unregistered,
            unregistering the object again has no effect.</remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Infrastructure.IRuntimeFinalizer.FinalizeRuntime">
            <summary>
            Finalize high-priority resources hold by the runtime. This method
            should only be called ONCE upon runtime finalization.
            </summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Queues.AzureQueueStorage">
            <summary>Provides access to the Queue Storage (plus the Blob Storage when
            messages are overflowing).</summary>
            <remarks>
            <para>
            Overflowing messages are stored in blob storage and normally deleted as with
            their originating correspondence in queue storage.
            </para>
            <para>All the methods of <see cref="T:Lokad.Cloud.Storage.Queues.AzureQueueStorage"/> are thread-safe.</para>
            </remarks>
        </member>
        <member name="F:Lokad.Cloud.Storage.Queues.AzureQueueStorage._sync">
            <summary>Root used to synchronize accesses to <c>_inprocess</c>. 
            Caution: do not hold the lock while performing operations on the cloud
            storage.</summary>
        </member>
        <member name="F:Lokad.Cloud.Storage.Queues.AzureQueueStorage._inProcessMessages">
            <summary>Mapping object --> Queue Message Id. Use to delete messages afterward.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.AzureQueueStorage.#ctor(Microsoft.WindowsAzure.StorageClient.CloudQueueClient,Lokad.Cloud.Storage.Documents.IDocumentStorage,Lokad.Serialization.IDataSerializer,Lokad.Cloud.Storage.Infrastructure.IRuntimeFinalizer)">
            <summary>IoC constructor.</summary>
            <param name="documentStorage">Not null.</param>
            <param name="queueStorage">Not null.</param>
            <param name="serializer">Not null.</param>
            <param name="runtimeFinalizer">May be null (handy for strict O/C mapper
            scenario).</param>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.AzureQueueStorage.Dispose">
            <summary>
            Disposing the provider will cause an abandon on all currently messages currently
            in-process. At the end of the life-cycle of the provider, normally there is no
            message in-process.
            </summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.AzureQueueStorage.DeleteQueue(System.String)">
            <summary>
            Deletes a queue.
            </summary>
            <returns><c>true</c> if the queue name has been actually deleted.</returns>
            <remarks>
            This implementation takes care of deleting overflowing blobs as
            well.
            </remarks>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.AzureQueueStorage.GetApproximateCount(System.String)">
            <summary>
            Gets the approximate number of items in this queue.
            </summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.AzureQueueStorage.GetApproximateLatency(System.String)">
            <summary>
            Gets the approximate age of the top message of this queue.
            </summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Queues.InProcessMessage">
            <summary>Represents a set of value-identical messages that are being processed by workers, 
            i.e. were hidden from the queue because of calls to Get{T}.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.InProcessMessage.QueueName">
            <summary>Name of the queue where messages are originating from.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.InProcessMessage.RawMessages">
            <summary>The multiple, different raw <see cref="T:Microsoft.WindowsAzure.StorageClient.CloudQueueMessage"/> 
            objects as returned from the queue storage.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.InProcessMessage.IsOverflowing">
            <summary>A flag indicating whether the original message was bigger than the max 
            allowed size and was  therefore wrapped in <see cref="T:Lokad.Cloud.Storage.Queues.MessageWrapper"/>.</summary>
        </member>
        <member name="F:Lokad.Cloud.Storage.Queues.OverflowingMessageDocumentName`1.QueueName">
            <summary>Indicates the name of the queue where the message has been originally pushed.</summary>
        </member>
        <member name="F:Lokad.Cloud.Storage.Queues.OverflowingMessageDocumentName`1.MessageId">
            <summary>Message identifiers as specified by the queue storage itself.</summary>
        </member>
        <member name="M:Lokad.Cloud.Storage.Queues.OverflowingMessageDocumentName`1.GetNew(System.String)">
            <summary>Used to iterate over all the overflowing messages 
            associated to a queue.</summary>
        </member>
        <member name="F:Lokad.Cloud.Storage.Queues.PersistedMessageDocumentName.StoreName">
            <summary>Indicates the name of the swap out store where the message is persisted.</summary>
        </member>
        <member name="T:Lokad.Cloud.Storage.Queues.PersistedMessage">
            <summary>
            Persisted message details for inspection and recovery.
            </summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.PersistedMessage.QueueName">
            <summary>Identifier of the originating message queue.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.PersistedMessage.StoreName">
            <summary>Name of the message persistence store.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.PersistedMessage.Key">
            <summary>Unique key of the persisted message as returned by ListPersisted.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.PersistedMessage.InsertionTime">
            <summary>Time when the message was inserted into the message queue.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.PersistedMessage.PersistenceTime">
            <summary>Time when the message was persisted and removed from the message queue.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.PersistedMessage.DequeueCount">
            <summary>The number of times the message has been dequeued.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.PersistedMessage.Reason">
            <summary>Optional reason text why the message was persisted.</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.PersistedMessage.DataXml">
            <summary>XML representation of the message, if possible and supported by the serializer</summary>
        </member>
        <member name="P:Lokad.Cloud.Storage.Queues.PersistedMessage.IsDataAvailable">
            <summary>True if the raw message data is available and can be restored.</summary>
            <remarks>Can be true even if DataXML is not available.</remarks>
        </member>
        <member name="T:Lokad.Cloud.Storage.Infrastructure.TypeMapper">
            <summary>Maps types to storage names, and vice-versa.</summary>
            <remarks>
            Spec on queue names: http://msdn.microsoft.com/en-us/library/dd179349.aspx
            Spec on container names: http://msdn.microsoft.com/en-us/library/dd135715.aspx
            </remarks>
        </member>
    </members>
</doc>
