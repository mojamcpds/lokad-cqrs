<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Lokad.Cqrs.AzureStarter.Core</name>
  </assembly>
  <members>
    <member name="T:Lokad.Cqrs.Default.IConsumeMessage">
      <summary>
            Default CQRS interface for interface-base domain setup
            </summary>
    </member>
    <member name="T:Lokad.Cqrs.Default.IConsume`1">
      <summary>
            Default CQRS interface for interface-base domain setup
            </summary>
    </member>
    <member name="M:Lokad.Cqrs.Default.IConsume`1.Consume(`0)">
      <summary>
            Consumes the specified message.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="T:Lokad.Cqrs.Default.IMessage">
      <summary>
            Default CQRS message interface for the domain setup
            </summary>
    </member>
    <member name="T:Lokad.Cqrs.Default.IEntity">
      <summary>
            Default CQRS entity
            </summary>
    </member>
    <member name="T:Lokad.Cqrs.Default.IScheduledTask">
      <summary>
            Default interface for use by the TaskScheduler feature
            </summary>
      <remarks>See http://code.google.com/p/lokad-cqrs/wiki/ScheduledTasks</remarks>
    </member>
    <member name="M:Lokad.Cqrs.Default.IScheduledTask.Execute">
      <summary>
            Executes some event that happens at the predefined moments of time.
            Each worker instance will have an independent scheduler.
            </summary>
      <returns>Amount of time to sleep till the next run</returns>
    </member>
    <member name="T:Lokad.DisposableAction">
      <summary>
            Class that allows action to be executed, when it is disposed
            </summary>
    </member>
    <member name="M:Lokad.DisposableAction.#ctor(System.Action)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.DisposableAction" /> class.
            </summary>
      <param name="action">The action.</param>
    </member>
    <member name="M:Lokad.DisposableAction.Dispose">
      <summary>
            Executes the action
            </summary>
    </member>
    <member name="T:Lokad.Enforce">
      <summary>
            Helper class allows to follow the principles defined by Microsoft P&amp;P team.
            </summary>
    </member>
    <member name="M:Lokad.Enforce.Argument``1(System.Func{``0})">
      <summary>
        <para>Throws exception if the provided object is null. </para>
        <code>Enforce.Argument(() =&gt; args);</code>
      </summary>
      <typeparam name="TValue">type of the class to check</typeparam>
      <param name="argumentReference">The argument reference to check.</param>
      <exception cref="T:System.ArgumentNullException">If the class reference is null.</exception>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.Arguments``2(System.Func{``0},System.Func{``1})">
      <summary>
        <para>Throws exception if one of the provided objects is null. </para>
        <code>Enforce.Arguments(() =&gt; controller, () =&gt; service);</code>
      </summary>
      <param name="first">The first argument to check for</param>
      <param name="second">The second argument to check for.</param>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.Arguments``3(System.Func{``0},System.Func{``1},System.Func{``2})">
      <summary>
        <para>Throws exception if one of the provided objects is null. </para>
        <code>Enforce.Arguments(() =&gt; controller, () =&gt; service, () =&gt; parameters);</code>
      </summary>
      <typeparam name="T1">The type of the first argument.</typeparam>
      <typeparam name="T2">The type of the second argument.</typeparam>
      <typeparam name="T3">The type of the third argument.</typeparam>
      <param name="first">The first argument to check</param>
      <param name="second">The second argument to check.</param>
      <param name="third">The third argument to check.</param>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.Arguments``4(System.Func{``0},System.Func{``1},System.Func{``2},System.Func{``3})">
      <summary>
        <para>Throws exception if one of the provided objects is null. </para>
        <code>Enforce.Arguments(() =&gt; controller, () =&gt; service, () =&gt; parameters);</code>
      </summary>
      <typeparam name="T1">The type of the first argument.</typeparam>
      <typeparam name="T2">The type of the second argument.</typeparam>
      <typeparam name="T3">The type of the third argument.</typeparam>
      <typeparam name="T4">The type of the fourth argument.</typeparam>
      <param name="first">The first argument to check.</param>
      <param name="second">The second argument to check.</param>
      <param name="third">The third argument to check.</param>
      <param name="fourth">The fourth argument to check.</param>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.Arguments``5(System.Func{``0},System.Func{``1},System.Func{``2},System.Func{``3},System.Func{``4})">
      <summary>
        <para>Throws exception if one of the provided objects is null. </para>
        <code>Enforce.Arguments(() =&gt; controller, () =&gt; service, () =&gt; parameters);</code>
      </summary>
      <typeparam name="T1">The type of the first argument.</typeparam>
      <typeparam name="T2">The type of the second argument.</typeparam>
      <typeparam name="T3">The type of the third argument.</typeparam>
      <typeparam name="T4">The type of the fourth argument.</typeparam>
      <typeparam name="T5">The type of the fifth argument.</typeparam>
      <param name="first">The first argument to check.</param>
      <param name="second">The second argument to check.</param>
      <param name="third">The third argument to check.</param>
      <param name="fourth">The fourth argument to check.</param>
      <param name="fifth">The fifth argument to check.</param>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.ArgumentNotEmpty(System.Func{System.String})">
      <summary>
            Throws proper exception if the provided string argument is null or empty. 
            </summary>
      <returns>Original string.</returns>
      <exception cref="T:System.ArgumentException">If the string argument is null or empty.</exception>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.That(System.Boolean,System.String)">
      <summary>
            Throws exception if the check does not pass.
            </summary>
      <param name="check">if set to <c>true</c> then check will pass.</param>
      <param name="name">The name of the assertion.</param>
      <exception cref="T:System.InvalidOperationException">If the assertion has failed.</exception>
    </member>
    <member name="M:Lokad.Enforce.That(System.Boolean,System.String,System.Object[])">
      <summary>
            Throws exception if the check does not pass.
            </summary>
      <param name="check">if set to <c>true</c> then check will pass.</param>
      <param name="message">The message.</param>
      <param name="arguments">The format arguments.</param>
      <exception cref="T:System.InvalidOperationException">If the assertion has failed.</exception>
    </member>
    <member name="M:Lokad.Enforce.That(System.Boolean)">
      <summary>
            Throws exception if the check does not pass.
            </summary>
      <exception cref="T:System.InvalidOperationException">If the assertion has failed.</exception>
    </member>
    <member name="M:Lokad.Enforce.With``1(System.Boolean,System.String,System.Object[])">
      <summary>
            Throws <typeparamref name="TException" /> if the <paramref name="check" />
            failes
            </summary>
      <typeparam name="TException">The type of the exception.</typeparam>
      <param name="check">Check that should be true.</param>
      <param name="message">The message.</param>
      <param name="args">String arguments.</param>
      <exception cref="T:System.Exception">of <typeparamref name="TException" /> type</exception>
    </member>
    <member name="M:Lokad.Enforce.Argument(System.Boolean,System.String,System.String)">
      <summary> Throws exception if the argument fails the <paramref name="check" /></summary>
      <param name="check">Throw exception if false.</param>
      <param name="paramName">Name of the param.</param>
      <param name="checkName">Name of the check.</param>
      <exception cref="T:System.ArgumentException">When the argument fails the check</exception>
    </member>
    <member name="M:Lokad.Enforce.NotNull``1(System.Func{``0})">
      <summary>
            Throws proper exception if the class reference is null.
            </summary>
      <typeparam name="TValue">
      </typeparam>
      <param name="value">Class reference to check.</param>
      <exception cref="T:System.InvalidOperationException">If class reference is null.</exception>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.NotNull``1(``0)">
      <summary>
            Throws proper exception if the class reference is null.
            </summary>
      <typeparam name="TValue">
      </typeparam>
      <param name="value">Class reference to check.</param>
      <exception cref="T:System.InvalidOperationException">If class reference is null.</exception>
    </member>
    <member name="M:Lokad.Enforce.NotNull``1(``0,System.String)">
      <summary>
            Throws proper exception if the class reference is null.
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="value">Class reference to check.</param>
      <param name="name">The name.</param>
      <exception cref="T:System.InvalidOperationException">If class reference is null.</exception>
    </member>
    <member name="M:Lokad.Enforce.ArgumentNotNull``1(``0,System.String)">
      <summary>
            Throws proper exception if the provided class reference is null.
            Can be used for inline checks.
            </summary>
      <typeparam name="TValue">Class type</typeparam>
      <param name="value">Class reference to check.</param>
      <param name="argumentName">Name of the argument.</param>
      <returns>Original reference.</returns>
      <exception cref="T:System.ArgumentNullException">If the class reference is null.</exception>
    </member>
    <member name="M:Lokad.Enforce.Argument``1(System.Func{``0},Lokad.Rules.Rule{``0}[])">
      <summary>
            Runs the rules against single argument, using scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)" /></summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="argumentReference">The argument reference.</param>
      <param name="rules">The rules.</param>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
      <exception cref="T:System.ArgumentException">When any rule fails</exception>
    </member>
    <member name="M:Lokad.Enforce.Argument``1(System.Func{System.Collections.Generic.IEnumerable{``0}},Lokad.Rules.Rule{``0}[])">
      <summary>
            Runs the rules against single collection, using scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)" /></summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="items">The items to validate.</param>
      <param name="rules">The rules.</param>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
      <exception cref="T:System.ArgumentException">When any rule fails</exception>
    </member>
    <member name="M:Lokad.Enforce.That``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary> Runs the rules against single argument, 
            using scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)" />.
             </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="item">The item to validate.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">When check fails</exception>
    </member>
    <member name="M:Lokad.Enforce.That``1(System.Collections.Generic.IEnumerable{``0},Lokad.Rules.Rule{``0}[])">
      <summary> Runs the rules against single collection, using 
            scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)" />.</summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="items">The items to validate.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">When check fails</exception>
    </member>
    <member name="M:Lokad.Enforce.That``1(System.Func{``0},Lokad.Rules.Rule{``0}[])">
      <summary> Runs the rules against single item, using 
            scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)" />.</summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="argumentReference">The item to validate.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">When check fails</exception>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="M:Lokad.Enforce.That``1(System.Func{System.Collections.Generic.IEnumerable{``0}},Lokad.Rules.Rule{``0}[])">
      <summary> Runs the rules against collection, 
            using scope that fails on <see cref="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)" /></summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="collectionReference">The items to validate.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">When check fails</exception>
      <remarks>Silverlight 2.0 does not support fast resolution of variable names, yet</remarks>
    </member>
    <member name="T:Lokad.Errors">
      <summary>
            Helper class for generating exceptions
            </summary>
    </member>
    <member name="M:Lokad.Errors.KeyInvalid">
      <summary>
            Creates new instance of <see cref="T:Lokad.KeyInvalidException" /></summary>
      <returns>new exception instance</returns>
    </member>
    <member name="M:Lokad.Errors.KeyInvalid(System.Object)">
      <summary>
            Creates new instance of <see cref="T:Lokad.KeyInvalidException" /></summary>
      <param name="value">The value.</param>
      <returns>new exception instance</returns>
    </member>
    <member name="M:Lokad.Errors.Resolution(System.Type,System.Object,System.Exception)">
      <summary>
            Creates new instance of the <see cref="T:Lokad.ResolutionException" /></summary>
      <param name="valueType">Type of the service.</param>
      <param name="key">The service key.</param>
      <param name="inner">The inner.</param>
      <returns>new exception instance</returns>
    </member>
    <member name="M:Lokad.Errors.Resolution(System.Type,System.Exception)">
      <summary>
            Creates new instance of the <see cref="T:Lokad.ResolutionException" /></summary>
      <param name="valueType">Type of the service.</param>
      <param name="inner">The inner.</param>
      <returns>new exception instance</returns>
    </member>
    <member name="M:Lokad.Errors.KeyInvalid(System.Object,System.Exception)">
      <summary>
            Creates new instance of <see cref="T:Lokad.KeyInvalidException" /></summary>
      <param name="value">The value.</param>
      <param name="inner">The inner.</param>
      <returns>new exception instance</returns>
    </member>
    <member name="M:Lokad.Errors.InvalidOperation(System.String,System.Object[])">
      <summary>
            Creates new instance of <see cref="T:System.InvalidOperationException" /></summary>
      <param name="message">The message.</param>
      <param name="args">The arguments of the format string.</param>
      <returns>new exception instance</returns>
    </member>
    <member name="M:Lokad.Errors.NotSupported(System.String,System.Object[])">
      <summary>
            Creates new instance of <see cref="T:System.NotSupportedException" /></summary>
      <param name="message">The message.</param>
      <param name="args">The arguments of the format string.</param>
      <returns>new exception instance</returns>
    </member>
    <member name="M:Lokad.Errors.Inner(System.Exception)">
      <summary>
            Returns inner exception, while preserving the stack trace
            </summary>
      <param name="e">The target invocation exception to unwrap.</param>
      <returns>inner exception</returns>
    </member>
    <member name="T:System.Linq.ArrayExtensionsForLinq">
      <summary>
            Array extensions that belong to the LINQ namespace
            </summary>
    </member>
    <member name="M:System.Linq.ArrayExtensionsForLinq.Append``1(``0[],``0[])">
      <summary>
            Joins arrays together
            </summary>
      <typeparam name="T">type of the arrays</typeparam>
      <param name="self">The first array to join.</param>
      <param name="second">The second array to join.</param>
      <returns>Joined array</returns>
    </member>
    <member name="T:Lokad.ExtendArray">
      <summary>
            Shortcuts for some common array operations
            </summary>
    </member>
    <member name="M:Lokad.ExtendArray.Convert``2(``0[],System.Converter{``0,``1})">
      <summary>
            Shorthand extension method for converting the arrays
            </summary>
      <typeparam name="TSource">The type of the source array.</typeparam>
      <typeparam name="TTarget">The type of the target array.</typeparam>
      <param name="source">The array to convert.</param>
      <param name="converter">The converter.</param>
      <returns>target array instance</returns>
    </member>
    <member name="M:Lokad.ExtendArray.Convert``2(``0[],System.Func{``0,System.Int32,``1})">
      <summary>
            Shorthand extension method for converting the arrays
            </summary>
      <typeparam name="TSource">The type of the source array.</typeparam>
      <typeparam name="TTarget">The type of the target array.</typeparam>
      <param name="source">The array to convert.</param>
      <param name="converter">The converter, where the second parameter is an index of item being converted.</param>
      <returns>target array instance</returns>
    </member>
    <member name="M:Lokad.ExtendArray.ForEach``1(``0[],System.Action{``0})">
      <summary>
            Applies the action to each item in the array
            </summary>
      <typeparam name="T">type of the items in the array</typeparam>
      <param name="self">The array to walk through.</param>
      <param name="action">The action.</param>
      <returns>Same array instance</returns>
    </member>
    <member name="M:Lokad.ExtendArray.SliceArray``1(``0[],System.Int32)">
      <summary>
            Slices array into array of arrays of length up to <paramref name="sliceLength" /></summary>
      <typeparam name="T">Type of the items int the array</typeparam>
      <param name="array">The array.</param>
      <param name="sliceLength">Length of the slice.</param>
      <returns>array of sliced arrays</returns>
      <exception cref="T:System.ArgumentNullException">When source array is null</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">When <paramref name="sliceLength" /> is invalid</exception>
    </member>
    <member name="T:Lokad.ExtendDouble">
      <summary>
            Some helper shortcuts for the <see cref="T:System.Double" /></summary>
    </member>
    <member name="M:Lokad.ExtendDouble.Round(System.Double,System.Int32)">
      <summary>
            Rounds the specified double with the provided number 
            of fractional digits.
            </summary>
      <param name="value">The value to round.</param>
      <param name="digits">The digits.</param>
      <returns>rounded value</returns>
    </member>
    <member name="M:Lokad.ExtendDouble.Minutes(System.Double)">
      <summary>Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of minutes.</summary>
      <param name="minutes">number of minutes</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
      <example>3D.Minutes()</example>
    </member>
    <member name="M:Lokad.ExtendDouble.Hours(System.Double)">
      <summary>Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of hours.</summary>
      <param name="hours">number of hours</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
      <example>3D.Hours()</example>
    </member>
    <member name="M:Lokad.ExtendDouble.Seconds(System.Double)">
      <summary>Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of seconds.</summary>
      <param name="seconds">number of seconds</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
      <example>2D.Seconds()</example>
    </member>
    <member name="M:Lokad.ExtendDouble.Milliseconds(System.Double)">
      <summary>Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of milliseconds.</summary>
      <param name="milliseconds">milliseconds for this timespan</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
    </member>
    <member name="M:Lokad.ExtendDouble.Days(System.Double)">
      <summary>
            Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of days.
            </summary>
      <param name="days">Number of days, accurate to the milliseconds.</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
    </member>
    <member name="T:Lokad.ExtendICollection">
      <summary>
            Simple helper extensions for <see cref="T:System.Collections.Generic.ICollection`1" /></summary>
    </member>
    <member name="M:Lokad.ExtendICollection.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds all items to the target collection
            </summary>
      <typeparam name="T">type of the item within the collection</typeparam>
      <param name="collection">The collection</param>
      <param name="items">items to add to the collection</param>
      <returns>same collection instance</returns>
    </member>
    <member name="M:Lokad.ExtendICollection.RemoveRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Removes all items from the target collection
            </summary>
      <typeparam name="T">type of the item within the collection</typeparam>
      <param name="collection">The collection.</param>
      <param name="items">The items.</param>
      <returns>same collection instance</returns>
    </member>
    <member name="M:Lokad.ExtendICollection.IsEmpty``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Shortcut to determine whether the specified <see cref="T:System.Collections.Generic.ICollection`1" /> is empty.
            </summary>
      <typeparam name="T">items in the collection</typeparam>
      <param name="self">The collection.</param>
      <returns>
        <c>true</c> if the specified self is empty; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Lokad.ExtendIDictionary">
      <summary>
            Extensions for <see cref="T:System.Collections.Generic.IDictionary`2" /></summary>
    </member>
    <member name="M:Lokad.ExtendIDictionary.AsProvider``2(System.Collections.Generic.IDictionary{``0,``1})">
      <summary>
            Wraps the dictionary with the read-only provider instance
            </summary>
      <typeparam name="TKey">The type of the key.</typeparam>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="self">The dictionary.</param>
      <returns>provider instance that wraps the dictionary</returns>
    </member>
    <member name="M:Lokad.ExtendIDictionary.AsProvider``1(System.Collections.Generic.IDictionary{System.String,``0})">
      <summary>
            Wraps the provider with the read-only provider instance
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="self">The dictionary.</param>
      <returns>provider instance that wraps the dictionary</returns>
    </member>
    <member name="M:Lokad.ExtendIDictionary.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
      <summary>
            Returns <paramref name="defaultValue" /> if the given <paramref name="key" />
            is not present within the dictionary
            </summary>
      <typeparam name="TKey">The type of the key.</typeparam>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="self">The dictionary.</param>
      <param name="key">The key to look for.</param>
      <param name="defaultValue">The default value.</param>
      <returns>value matching <paramref name="key" /> or <paramref name="defaultValue" /> if none is found</returns>
    </member>
    <member name="M:Lokad.ExtendIDictionary.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
      <summary>
            Gets the value from the <paramref name="dictionary" /> in form of the <see cref="T:Lokad.Maybe`1" />.
            </summary>
      <typeparam name="TKey">The type of the key.</typeparam>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="dictionary">The dictionary.</param>
      <param name="key">The key.</param>
      <returns>value from the dictionary</returns>
    </member>
    <member name="T:System.Linq.ExtendIEnumerable">
      <summary>
            Helper methods for the <see cref="T:System.Collections.Generic.IEnumerable`1" /></summary>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Performs the specified <see cref="T:System.Action`1" /> against every element of <see cref="T:System.Collections.Generic.IEnumerable`1" /></summary>
      <typeparam name="T">
      </typeparam>
      <param name="enumerable">Enumerable to extend</param>
      <param name="action">Action to perform</param>
      <exception cref="T:System.ArgumentNullException">When any parameter is null</exception>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
      <summary>
            Performs the specified <see cref="T:System.Action`1" /> against every element of <see cref="T:System.Collections.Generic.IEnumerable`1" /></summary>
      <typeparam name="T">
      </typeparam>
      <param name="enumerable">Enumerable to extend</param>
      <param name="action">Action to perform; second parameter represents the index</param>
      <exception cref="T:System.ArgumentNullException">When any parameter is null</exception>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Applies the specified action to the target <paramref name="enumerable" />.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="action">The action to execute against every item.</param>
      <returns>enumerator</returns>
      <exception cref="T:System.ArgumentNullException">when one of the values is null</exception>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
      <summary>
            Applies the specified action to the target <paramref name="enumerable" />.
            </summary>
      <typeparam name="TSource">Type of the elements in <paramref name="enumerable" /></typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="action">The action to execute against every item; second
            parameter represents the index.</param>
      <returns>enumerator</returns>
      <exception cref="T:System.ArgumentNullException">when one of the values is null</exception>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
      <summary>
            Returns <em>True</em> as soon as the first member of <paramref name="enumerable" />
            mathes <paramref name="predicate" /></summary>
      <typeparam name="TSource">Type of the elements in <paramref name="enumerable" /></typeparam>
      <param name="enumerable">The enumerable</param>
      <param name="predicate">The predicate.</param>
      <returns>true if the <paramref name="enumerable" /> contains any elements
            matching <paramref name="predicate" /></returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.Exists``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Checks if the provided enumerable has anything
            </summary>
      <typeparam name="TSource">Type of the elements in <paramref name="enumerable" /></typeparam>
      <param name="enumerable">The enumerable.</param>
      <returns>true if the sequence contains any elements</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0[])">
      <summary>
            Appends the <paramref name="items" /> to the <paramref name="enumerable" />.
            </summary>
      <typeparam name="TSource">type of the elements in <paramref name="enumerable" /></typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="items">The item.</param>
      <returns>new sequence</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Appends the specified <paramref name="range" /> to the <paramref name="enumerable" />.
            </summary>
      <typeparam name="T">type of the item to operate with</typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="range">The range.</param>
      <returns>new enumerator instance</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0[])">
      <summary>
            Prepends the specified <paramref name="enumerable" /> with the <paramref name="items" />.
            </summary>
      <typeparam name="T">type of the item to operate with</typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="items">The item.</param>
      <returns>new enumerator instance</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.ToSet``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Converts the enumerable to <see cref="T:System.Collections.Generic.HashSet`1" /></summary>
      <typeparam name="T">
      </typeparam>
      <param name="enumerable">The enumerable.</param>
      <returns>hashset instance</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.ToSet``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
      <summary>
            Converts the enumerable to <see cref="T:System.Collections.Generic.HashSet`1" /></summary>
      <typeparam name="TKey">The type of the key.</typeparam>
      <typeparam name="TItem">The type of the item.</typeparam>
      <param name="enumerable">The enumerable.</param>
      <param name="selector">The selector.</param>
      <returns>hashset instance</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Returns the minimum value in a generic sequence, using the provided comparer
            </summary>
      <typeparam name="T">Type of the elements of <paramref name="source" /></typeparam>
      <param name="source">Original sequence.</param>
      <param name="comparer">The comparer.</param>
      <returns>Maximum value</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Returns the maximum value in a generic sequence using the provided comparer.
            </summary>
      <typeparam name="T">Type of the elements of <paramref name="source" /></typeparam>
      <param name="source">Original sequence.</param>
      <param name="comparer">The comparer.</param>
      <returns>Maximum value</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.Join(System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Concatenates a specified separator between each element of a specified <paramref name="strings" />, 
            yielding a single concatenated string.
            </summary>
      <param name="strings">The strings.</param>
      <param name="separator">The separator.</param>
      <returns>concatenated string</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,System.Int32},System.Int32)">
      <summary>
        <para>Performs lazy splitting of the provided collection into collections of <paramref name="sliceLength" />.</para>
        <para>Each collection will have total <em>weight</em> equal or less than <paramref name="maxSliceWeight" /></para>
      </summary>
      <typeparam name="TItem">The type of the item.</typeparam>
      <param name="source">The source collection to slice.</param>
      <param name="sliceLength">Length of the slice.</param>
      <param name="weightDelegate">Function to calculate <em>weight</em> of each item in the collection</param>
      <param name="maxSliceWeight">The max item weight.</param>
      <returns>enumerator over the results</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
            Performs lazy splitting of the provided collection into collections of <paramref name="sliceLength" /></summary>
      <typeparam name="TItem">The type of the item.</typeparam>
      <param name="source">The source.</param>
      <param name="sliceLength">Maximum length of the slice.</param>
      <returns>lazy enumerator of the collection of arrays</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.ToJaggedArray``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Converts collection of collections to jagged array
            </summary>
      <typeparam name="T">type of the items in collection</typeparam>
      <param name="collection">The collection.</param>
      <returns>jagged array</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            Shorthand extension method for converting enumerables into the arrays
            </summary>
      <typeparam name="TSource">The type of the source array.</typeparam>
      <typeparam name="TTarget">The type of the target array.</typeparam>
      <param name="self">The collection to convert.</param>
      <param name="converter">The converter.</param>
      <returns>target array instance</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})">
      <summary>
            Shorthand extension method for converting enumerables into the arrays
            </summary>
      <typeparam name="TSource">The type of the source array.</typeparam>
      <typeparam name="TTarget">The type of the target array.</typeparam>
      <param name="self">The collection to convert.</param>
      <param name="converter">The converter, where the second parameter is an index of item being converted.</param>
      <returns>target array instance</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.FirstOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Retrieves first value from the <paramref name="sequence" /></summary>
      <typeparam name="TSource">The type of the source sequence.</typeparam>
      <param name="sequence">The source.</param>
      <param name="predicate">The predicate.</param>
      <returns>first value</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.FirstOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Retrieves first value from the <paramref name="sequence" /></summary>
      <typeparam name="TSource">The type of the source sequence.</typeparam>
      <param name="sequence">The source.</param>
      <returns>first value or empty result, if it is not found</returns>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.ToIndexed``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Applies the integral indexer to the sequence in a lazy manner
            </summary>
      <typeparam name="TSource">The type of the source.</typeparam>
      <param name="source">The sequence.</param>
      <returns>indexed sequence</returns>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="source" /> is null</exception>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.ToIndexDictionary``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Enumerates and returns a mapping that associated the items with their respective
            indices (positions) within the enumeration.
            </summary>
      <typeparam name="TSource">The type of the source.</typeparam>
      <param name="source">The source.</param>
      <returns>a dictionary</returns>
      <remarks>
        <para>Typical usage is <c>coll.ToIndex()["foo"]</c> that returns
            the position of the item <c>"foo"</c> in the initial collection.</para>
        <para>if multiple similar entries are present in the original collection,
            index of the first entry is recorded.
            </para>
      </remarks>
    </member>
    <member name="M:System.Linq.ExtendIEnumerable.SelectValues``1(System.Collections.Generic.IEnumerable{Lokad.Maybe{``0}})">
      <summary>
            Selects the values from a sequence of optionals.
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="sequence">The sequence.</param>
      <returns>enumerable that contains values</returns>
    </member>
    <member name="T:Lokad.ExtendInt32">
      <summary> Extensions to the <see cref="T:System.Int32" /></summary>
    </member>
    <member name="M:Lokad.ExtendInt32.Kb(System.Int32)">
      <summary>
            Returns kilobytes
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.ExtendInt32.Mb(System.Int32)">
      <summary>
            Returns megabytes
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.ExtendInt32.Minutes(System.Int32)">
      <summary>Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of minutes.</summary>
      <param name="minutes">number of minutes</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
      <example>3.Minutes()</example>
    </member>
    <member name="M:Lokad.ExtendInt32.Seconds(System.Int32)">
      <summary>
            Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of seconds.
            </summary>
      <param name="seconds">number of seconds</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
      <example>2.Seconds()</example>
    </member>
    <member name="M:Lokad.ExtendInt32.Milliseconds(System.Int32)">
      <summary>
            Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of milliseconds.
            </summary>
      <param name="milliseconds">milliseconds for this timespan</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
    </member>
    <member name="M:Lokad.ExtendInt32.Days(System.Int32)">
      <summary>
            Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of days.
            </summary>
      <param name="days">Number of days.</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
    </member>
    <member name="M:Lokad.ExtendInt32.Hours(System.Int32)">
      <summary>
            Returns a <see cref="T:System.TimeSpan" /> that represents a specified number of hours.
            </summary>
      <param name="hours">Number of hours.</param>
      <returns>A <see cref="T:System.TimeSpan" /> that represents a value.</returns>
    </member>
    <member name="T:Lokad.ExtendStream">
      <summary>
            Simple helper extensions for the <see cref="T:System.IO.Stream" /></summary>
    </member>
    <member name="M:Lokad.ExtendStream.Compress(System.IO.Stream)">
      <summary>
            Wraps the specified stream with Compression stream
            </summary>
      <param name="stream">The stream to compress</param>
      <returns>compressing stream</returns>
    </member>
    <member name="M:Lokad.ExtendStream.Compress(System.IO.Stream,System.Boolean)">
      <summary>
            Wraps the specified stream with Compression stream
            </summary>
      <param name="stream">The stream the stream to compress.</param>
      <param name="leaveOpen">
        <c>true</c> to leave the stream open; overwise <c>false</c>.</param>
      <returns>compressing stream</returns>
    </member>
    <member name="M:Lokad.ExtendStream.Decompress(System.IO.Stream)">
      <summary>
            Wraps the stream with Decompressing stream
            </summary>
      <param name="stream">The stream to decompress.</param>
      <returns>decompressing stream</returns>
    </member>
    <member name="M:Lokad.ExtendStream.Decompress(System.IO.Stream,System.Boolean)">
      <summary>
            Wraps the stream with Decompressing stream
            </summary>
      <param name="stream">The stream to decompress.</param>
      <param name="leaveOpen">
        <c>true</c> to leave the stream open; overwise <c>false</c>.</param>
      <returns>decompressing stream</returns>
    </member>
    <member name="M:Lokad.ExtendStream.PumpTo(System.IO.Stream,System.IO.Stream,System.Int32)">
      <summary>
            Copies contents of this stream to the target stream
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <param name="bufferSize">Size of the buffer.</param>
      <returns>total amount of bytes copied</returns>
    </member>
    <member name="M:Lokad.ExtendStream.PumpTo(System.IO.Stream,System.IO.Stream,System.Byte[])">
      <summary>
            Copies contents of this stream to the target stream, using the provided buffer
            </summary>
      <param name="source">The source.</param>
      <param name="target">The target.</param>
      <param name="buffer">The buffer.</param>
      <returns>total amount of bytes copied</returns>
    </member>
    <member name="T:System.Linq.Indexer`1">
      <summary>
            Indexing wrapper that contains value and its integral position.
            </summary>
      <typeparam name="TSource">type of the underlying item</typeparam>
    </member>
    <member name="P:System.Linq.Indexer`1.Index">
      <summary>
            Gets the integral position of the item.
            </summary>
      <value>The integral position of the item.</value>
    </member>
    <member name="P:System.Linq.Indexer`1.IsFirst">
      <summary>
            Gets a value indicating whether this instance is first.
            </summary>
      <value>
        <c>true</c> if this instance is first; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:System.Linq.Indexer`1.Value">
      <summary>
            Gets the value.
            </summary>
      <value>The value.</value>
    </member>
    <member name="T:Lokad.GuidUtil">
      <summary>
            Guid comb generator as in NHibernate
            </summary>
    </member>
    <member name="M:Lokad.GuidUtil.NewComb">
      <summary>
            Generates new COMB Guid
            </summary>
      <returns>new comb guid</returns>
    </member>
    <member name="M:Lokad.GuidUtil.NewStringSortable">
      <summary>
            Creates GUIDs that have same uniqueness as COMB, but are string-sortable
            </summary>
      <returns>String-sortable GUID</returns>
    </member>
    <member name="T:Lokad.IProvider`2">
      <summary>
            Interface that abstracts away providers
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <remarks>
            things like IDataCache (from the Database layers) or IResolver (from the IoC layers) 
            are just samples of this interface
            </remarks>
    </member>
    <member name="M:Lokad.IProvider`2.Get(`0)">
      <summary>
            Retrieves <typeparamref name="TValue" /> given the
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
      <exception cref="T:Lokad.ResolutionException">when the key can not be resolved</exception>
    </member>
    <member name="T:Lokad.INamedProvider`1">
      <summary>
            Shortcut interface for <see cref="T:Lokad.IProvider`2" /> that uses <see cref="T:System.String" /> as the key.
            </summary>
      <typeparam name="TValue">
      </typeparam>
    </member>
    <member name="T:Lokad.Cqrs.IDataContractMapper">
      <summary>
            Class responsible for mapping types to contracts and vise-versa
            </summary>
    </member>
    <member name="M:Lokad.Cqrs.IDataContractMapper.GetContractNameByType(System.Type)">
      <summary>
            Gets the contract name by the type
            </summary>
      <param name="messageType">Type of the message.</param>
      <returns>contract name (if found)</returns>
    </member>
    <member name="M:Lokad.Cqrs.IDataContractMapper.GetTypeByContractName(System.String)">
      <summary>
            Gets the type by contract name.
            </summary>
      <param name="contractName">Name of the contract.</param>
      <returns>type that could be used for contract deserialization (if found)</returns>
    </member>
    <member name="T:Lokad.Cqrs.IDataSerializer">
      <summary>
            Generic data serializer interface.
            </summary>
    </member>
    <member name="M:Lokad.Cqrs.IDataSerializer.Serialize(System.Object,System.IO.Stream)">
      <summary>
            Serializes the object to the specified stream
            </summary>
      <param name="instance">The instance.</param>
      <param name="destinationStream">The destination stream.</param>
    </member>
    <member name="M:Lokad.Cqrs.IDataSerializer.Deserialize(System.IO.Stream,System.Type)">
      <summary>
            Deserializes the object from specified source stream.
            </summary>
      <param name="sourceStream">The source stream.</param>
      <param name="type">The type of the object to deserialize.</param>
      <returns>deserialized object</returns>
    </member>
    <member name="T:Lokad.Cqrs.IMessageSerializer">
      <summary>
            Joins data serializer and contract mapper
            </summary>
    </member>
    <member name="T:Lokad.Cqrs.ISupportSyntaxForSerialization">
      <summary>
            Syntax support for .Serialization configurations.
            </summary>
    </member>
    <member name="M:Lokad.Cqrs.ISupportSyntaxForSerialization.RegisterSerializer``1">
      <summary>
            Registers the specified data serializer as singleton implementing <see cref="T:Lokad.Cqrs.IMessageSerializer" />, <see cref="T:Lokad.Cqrs.IDataSerializer" /> and <see cref="T:Lokad.Cqrs.IDataContractMapper" />. It can import <see cref="!:IKnowSerializationTypes" /></summary>
      <typeparam name="TSerializer">The type of the serializer.</typeparam>
    </member>
    <member name="T:Lokad.KeyInvalidException">
      <summary>
            This exception is thrown when the key is not valid (i.e.: not found)
            </summary>
      <remarks> TODO: add proper implementation.</remarks>
    </member>
    <member name="M:Lokad.KeyInvalidException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.KeyInvalidException" /> class.
            </summary>
    </member>
    <member name="M:Lokad.KeyInvalidException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.KeyInvalidException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Lokad.KeyInvalidException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.KeyInvalidException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="inner">The inner.</param>
    </member>
    <member name="M:Lokad.KeyInvalidException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.KeyInvalidException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="info" /> parameter is null.
            </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
    </member>
    <member name="T:Lokad.ILog">
      <summary>
            Shared interface to abstract away from the specific
            logging library
            </summary>
    </member>
    <member name="M:Lokad.ILog.Log(Lokad.LogLevel,System.Object)">
      <summary> Writes the message to the logger </summary>
      <param name="level">The importance level</param>
      <param name="message">The actual message</param>
    </member>
    <member name="M:Lokad.ILog.Log(Lokad.LogLevel,System.Exception,System.Object)">
      <summary>
            Writes the exception and associated information 
            to the logger
            </summary>
      <param name="level">The importance level</param>
      <param name="ex">The actual exception</param>
      <param name="message">Information related to the exception</param>
    </member>
    <member name="M:Lokad.ILog.IsEnabled(Lokad.LogLevel)">
      <summary>
            Determines whether the messages of specified level are being logged down
            </summary>
      <param name="level">The level.</param>
      <returns>
        <c>true</c> if the specified level is logged; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Lokad.Diagnostics.DebugLog">
      <summary>
            Simple <see cref="T:Lokad.ILog" /> that writes to the <see cref="P:System.Diagnostics.Trace.Listeners" />, if the
            <em>DEBUG</em> symbol is defined
            </summary>
      <remarks>Use Logging stack, if more flexibility is needed</remarks>
    </member>
    <member name="F:Lokad.Diagnostics.DebugLog.Instance">
      <summary>  Singleton instance </summary>
    </member>
    <member name="F:Lokad.Diagnostics.DebugLog.Provider">
      <summary>
            Named provider for the <see cref="T:Lokad.Diagnostics.DebugLog" /></summary>
    </member>
    <member name="M:Lokad.Diagnostics.DebugLog.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.DebugLog" /> class.
            </summary>
      <param name="logName">Name of the log.</param>
    </member>
    <member name="T:Lokad.ExtendILogProvider">
      <summary>
            Extension methods for the <see cref="T:Lokad.INamedProvider`1" />
            of <see cref="T:Lokad.ILog" /></summary>
    </member>
    <member name="M:Lokad.ExtendILogProvider.CreateLog``1(Lokad.INamedProvider{Lokad.ILog})">
      <summary>
            Creates new log using the type as name.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Lokad.ExtendILogProvider.LogForType``1(Lokad.ILogProvider)">
      <summary>
            Creates new log with using <see cref="P:System.Type.FullName" /> for the name.
            </summary>
      <typeparam name="T">type to use for naming</typeparam>
      <param name="logProvider">The log provider.</param>
      <returns>new instance of the log</returns>
    </member>
    <member name="M:Lokad.ExtendILogProvider.LogForType(Lokad.ILogProvider,System.Object)">
      <summary>
            Creates new log with using <see cref="P:System.Type.FullName" /> for the name.
            </summary>
      <param name="logProvider">The log provider.</param>
      <param name="instance">The instance to retrieve type for naming from.</param>
      <returns>new instance of the log</returns>
    </member>
    <member name="M:Lokad.ExtendILogProvider.LogForName``1(Lokad.ILogProvider)">
      <summary>
            Creates new log with named with class name.
            </summary>
      <typeparam name="T">type to use for naming</typeparam>
      <param name="logProvider">The log provider.</param>
      <returns>new instance of the log</returns>
    </member>
    <member name="M:Lokad.ExtendILogProvider.LogForName(Lokad.ILogProvider,System.Object)">
      <summary>
            Creates new log with named with the class name.
            </summary>
      <param name="logProvider">The log provider.</param>
      <param name="instance">The instance to retrieve type for naming from.</param>
      <returns>new instance of the log</returns>
    </member>
    <member name="M:Lokad.ExtendILogProvider.LogForNamespace``1(Lokad.ILogProvider)">
      <summary>
            Creates new log with using <see cref="P:System.Type.Namespace" /> for the name.
            </summary>
      <typeparam name="T">type to use for naming</typeparam>
      <param name="logProvider">The log provider.</param>
      <returns>new instance of the log</returns>
    </member>
    <member name="M:Lokad.ExtendILogProvider.LogForNamespace(Lokad.ILogProvider,System.Object)">
      <summary>
            Creates new log with using <see cref="P:System.Type.Namespace" /> for the name.
            </summary>
      <param name="logProvider">The log provider.</param>
      <param name="instance">The instance to retrieve type for naming from.</param>
      <returns>new instance of the log</returns>
    </member>
    <member name="T:Lokad.ExtendISupportSyntaxForLogging">
      <summary>
            Extends logging syntax
            </summary>
    </member>
    <member name="M:Lokad.ExtendISupportSyntaxForLogging.LogToTrace``1(``0)">
      <summary>
            Registers the <see cref="T:Lokad.Diagnostics.TraceLog" /></summary>
      <typeparam name="TModule">The type of the module.</typeparam>
      <param name="module">The module.</param>
      <returns>same module for the inlining</returns>
    </member>
    <member name="M:Lokad.ExtendISupportSyntaxForLogging.LogToNull``1(``0)">
      <summary>
            Registers the <see cref="T:Lokad.Diagnostics.NullLog" /></summary>
      <typeparam name="TModule">The type of the module.</typeparam>
      <param name="module">The module.</param>
      <returns>same module for the inlining</returns>
    </member>
    <member name="T:Lokad.ILogExtensions">
      <summary>
            Helper extensions for any class that implements <see cref="T:Lokad.ILog" /></summary>
    </member>
    <member name="M:Lokad.ILogExtensions.IsDebugEnabled(Lokad.ILog)">
      <summary>
            Determines whether the specified log is recording debug messages.
            </summary>
      <param name="log">The log.</param>
      <returns>
        <c>true</c> if the specified log is recording debug messages; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.ILogExtensions.Debug(Lokad.ILog,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Debug" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.DebugFormat(Lokad.ILog,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Debug" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.Debug(Lokad.ILog,System.Exception,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Debug" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.DebugFormat(Lokad.ILog,System.Exception,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Debug" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.IsInfoEnabled(Lokad.ILog)">
      <summary>
            Determines whether the specified log is recording info messages.
            </summary>
      <param name="log">The log.</param>
      <returns>
        <c>true</c> if the specified log is recording info messages; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.ILogExtensions.Info(Lokad.ILog,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Info" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.InfoFormat(Lokad.ILog,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Info" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.Info(Lokad.ILog,System.Exception,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Info" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.InfoFormat(Lokad.ILog,System.Exception,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Info" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.IsWarnEnabled(Lokad.ILog)">
      <summary>
            Determines whether the specified log is recording warning messages.
            </summary>
      <param name="log">The log.</param>
      <returns>
        <c>true</c> if the specified log is recording warning messages; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.ILogExtensions.Warn(Lokad.ILog,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Warn" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.WarnFormat(Lokad.ILog,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Warn" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.Warn(Lokad.ILog,System.Exception,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Warn" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.WarnFormat(Lokad.ILog,System.Exception,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Warn" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.IsErrorEnabled(Lokad.ILog)">
      <summary>
            Determines whether the specified log is recording error messages.
            </summary>
      <param name="log">The log.</param>
      <returns>
        <c>true</c> if the specified log is recording error messages; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.ILogExtensions.Error(Lokad.ILog,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Error" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.ErrorFormat(Lokad.ILog,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Error" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.Error(Lokad.ILog,System.Exception,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Error" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.ErrorFormat(Lokad.ILog,System.Exception,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Error" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.IsFatalEnabled(Lokad.ILog)">
      <summary>
            Determines whether the specified log is recording Fatal messages.
            </summary>
      <param name="log">The log.</param>
      <returns>
        <c>true</c> if the specified log is recording datal messages; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.ILogExtensions.Fatal(Lokad.ILog,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Fatal" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.FatalFormat(Lokad.ILog,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Fatal" /> level
            </summary>
      <param name="log">Log instance being extended</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="M:Lokad.ILogExtensions.Fatal(Lokad.ILog,System.Exception,System.Object)">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Fatal" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="message">Message</param>
    </member>
    <member name="M:Lokad.ILogExtensions.FatalFormat(Lokad.ILog,System.Exception,System.String,System.Object[])">
      <summary>
            Writes message with <see cref="F:Lokad.LogLevel.Fatal" /> level and
            appends the specified <see cref="T:System.Exception" /></summary>
      <param name="log">Log instance being extended</param>
      <param name="ex">Exception to add to the message</param>
      <param name="format">Format string as in 
            <see cref="M:System.String.Format(System.String,System.Object[])" /></param>
      <param name="args">Arguments</param>
    </member>
    <member name="T:Lokad.ILogProvider">
      <summary>
            Creates logs using the name
            </summary>
    </member>
    <member name="T:Lokad.ISupportSyntaxForLogging">
      <summary>
            Syntax extensions for Logging configurations
            </summary>
    </member>
    <member name="M:Lokad.ISupportSyntaxForLogging.RegisterLogProvider(Lokad.ILogProvider)">
      <summary>
            Registers the specified log provider instance as singleton.
            </summary>
      <param name="provider">The provider.</param>
    </member>
    <member name="T:Lokad.LambdaLogProvider">
      <summary>
            Log provider, that uses lambda expression
            </summary>
    </member>
    <member name="M:Lokad.LambdaLogProvider.#ctor(System.Func{System.String,Lokad.ILog})">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.LambdaLogProvider" /> class.
            </summary>
      <param name="factory">The factory.</param>
    </member>
    <member name="T:Lokad.LogLevel">
      <summary>
            Degines the importance level associated with the log
            entry in <see cref="T:Lokad.ILog" /></summary>
    </member>
    <member name="F:Lokad.LogLevel.Debug">
      <summary> Message is intended for debugging </summary>
    </member>
    <member name="F:Lokad.LogLevel.Info">
      <summary> Informatory message </summary>
    </member>
    <member name="F:Lokad.LogLevel.Warn">
      <summary> The message is about potential problem in the system </summary>
    </member>
    <member name="F:Lokad.LogLevel.Error">
      <summary> Some error has occured </summary>
    </member>
    <member name="F:Lokad.LogLevel.Fatal">
      <summary> Message is associated with the critical problem </summary>
    </member>
    <member name="F:Lokad.LogLevel.Max">
      <summary>
            Highest possible level
            </summary>
    </member>
    <member name="F:Lokad.LogLevel.Min">
      <summary> Smallest logging level</summary>
    </member>
    <member name="T:Lokad.Diagnostics.NullLog">
      <summary>
        <see cref="T:Lokad.ILog" /> that does not do anything
            </summary>
    </member>
    <member name="F:Lokad.Diagnostics.NullLog.Instance">
      <summary>
            Singleton instance of the <see cref="T:Lokad.ILog" /></summary>
    </member>
    <member name="F:Lokad.Diagnostics.NullLog.Provider">
      <summary>
            Named provider for the <see cref="T:Lokad.Diagnostics.NullLog" /></summary>
    </member>
    <member name="T:Lokad.Diagnostics.TraceLog">
      <summary>
            Simple <see cref="T:Lokad.ILog" /> that writes to the <see cref="P:System.Diagnostics.Trace.Listeners" /></summary>
      <remarks>Use Logging stack, if more flexibility is needed</remarks>
    </member>
    <member name="F:Lokad.Diagnostics.TraceLog.Instance">
      <summary>  Singleton instance </summary>
    </member>
    <member name="F:Lokad.Diagnostics.TraceLog.Provider">
      <summary>
            Named provider for the <see cref="T:Lokad.Diagnostics.TraceLog" /></summary>
    </member>
    <member name="M:Lokad.Diagnostics.TraceLog.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Diagnostics.TraceLog" /> class.
            </summary>
      <param name="logName">Name of the log.</param>
    </member>
    <member name="T:Lokad.Messaging.CommunicationType">
      <summary>
            Message types for the <see cref="T:Lokad.Cqrs.Messaging.ICommunicator" /></summary>
    </member>
    <member name="F:Lokad.Messaging.CommunicationType.Normal">
      <summary>
      </summary>
    </member>
    <member name="F:Lokad.Messaging.CommunicationType.Error">
      <summary>
      </summary>
    </member>
    <member name="F:Lokad.Messaging.CommunicationType.Chat">
      <summary>
      </summary>
    </member>
    <member name="F:Lokad.Messaging.CommunicationType.Groupchat">
      <summary>
      </summary>
    </member>
    <member name="F:Lokad.Messaging.CommunicationType.Headline">
      <summary>
      </summary>
    </member>
    <member name="T:Lokad.Cqrs.Messaging.ICommunicator">
      <summary>
            Real-time notification interface
            </summary>
    </member>
    <member name="M:Lokad.Cqrs.Messaging.ICommunicator.Notify(System.String,System.String,Lokad.Messaging.CommunicationType)">
      <summary>
            Notifies the specified recipient (reliability is determined by the implementation.
            </summary>
      <param name="recipient">The recipient.</param>
      <param name="body">The body.</param>
      <param name="options">The options.</param>
    </member>
    <member name="T:Lokad.Messaging.NullCommunicator">
      <summary>
            Realtime notifier, that does not do anything
            </summary>
    </member>
    <member name="F:Lokad.Messaging.NullCommunicator.Instance">
      <summary>
            Singleton instance of the <see cref="T:Lokad.Cqrs.Messaging.ICommunicator" /></summary>
    </member>
    <member name="M:Lokad.Messaging.NullCommunicator.Notify(System.String,System.String,Lokad.Messaging.CommunicationType)">
      <summary>
            Notifies the specified recipient (reliability is determined by the implementation.
            </summary>
      <param name="recipient">The recipient.</param>
      <param name="body">The body.</param>
      <param name="options">The options.</param>
    </member>
    <member name="T:Lokad.Maybe`1">
      <summary>
            Helper class that indicates nullable value in a good-citizenship code
            </summary>
      <typeparam name="T">underlying type</typeparam>
    </member>
    <member name="F:Lokad.Maybe`1.Empty">
      <summary>
            Default empty instance.
            </summary>
    </member>
    <member name="M:Lokad.Maybe`1.GetValue(System.Func{`0})">
      <summary>
            Retrieves value from this instance, using a 
            <paramref name="defaultValue" /> if it is absent.
            </summary>
      <param name="defaultValue">The default value.</param>
      <returns>value</returns>
    </member>
    <member name="M:Lokad.Maybe`1.GetValue(`0)">
      <summary>
            Retrieves value from this instance, using a 
            <paramref name="defaultValue" /> if it is absent.
            </summary>
      <param name="defaultValue">The default value.</param>
      <returns>value</returns>
    </member>
    <member name="M:Lokad.Maybe`1.GetValue(System.Func{Lokad.Maybe{`0}})">
      <summary>
            Retrieves value from this instance, using a <paramref name="defaultValue" />
            factory, if it is absent
            </summary>
      <param name="defaultValue">The default value to provide.</param>
      <returns>maybe value</returns>
    </member>
    <member name="M:Lokad.Maybe`1.GetValue(Lokad.Maybe{`0})">
      <summary>
            Retrieves value from this instance, using a <paramref name="defaultValue" />
            if it is absent
            </summary>
      <param name="defaultValue">The default value to provide.</param>
      <returns>maybe value</returns>
    </member>
    <member name="M:Lokad.Maybe`1.Apply(System.Action{`0})">
      <summary>
            Applies the specified action to the value, if it is present.
            </summary>
      <param name="action">The action.</param>
      <returns>same instance for inlining</returns>
    </member>
    <member name="M:Lokad.Maybe`1.Handle(System.Action)">
      <summary>
            Executes the specified action, if the value is absent
            </summary>
      <param name="action">The action.</param>
      <returns>same instance for inlining</returns>
    </member>
    <member name="M:Lokad.Maybe`1.ExposeException(System.Func{System.Exception})">
      <summary>
            Exposes the specified exception if maybe does not have value.
            </summary>
      <param name="exception">The exception.</param>
      <returns>actual value</returns>
      <exception cref="T:System.Exception">if maybe does not have value</exception>
    </member>
    <member name="M:Lokad.Maybe`1.ExposeException(System.String)">
      <summary>
            Throws the exception if maybe does not have value.
            </summary>
      <returns>actual value</returns>
      <exception cref="T:System.InvalidOperationException">if maybe does not have value</exception>
    </member>
    <member name="M:Lokad.Maybe`1.ExposeException(System.String,System.Object[])">
      <summary>
            Throws the exception if maybe does not have value.
            </summary>
      <returns>actual value</returns>
      <exception cref="T:System.InvalidOperationException">if maybe does not have value</exception>
    </member>
    <member name="M:Lokad.Maybe`1.Combine``1(System.Func{`0,Lokad.Maybe{``0}})">
      <summary>
            Combines this optional with the pipeline function
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="combinator">The combinator (pipeline funcion).</param>
      <returns>optional result</returns>
    </member>
    <member name="M:Lokad.Maybe`1.Convert``1(System.Func{`0,``0})">
      <summary>
            Converts this instance to <see cref="T:Lokad.Maybe`1" />, 
            while applying <paramref name="converter" /> if there is a value.
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="converter">The converter.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.Maybe`1.Convert``1(System.Func{`0,``0},System.Func{``0})">
      <summary>
            Retrieves converted value, using a 
            <paramref name="defaultValue" /> if it is absent.
            </summary>
      <typeparam name="TTarget">type of the conversion target</typeparam>
      <param name="converter">The converter.</param>
      <param name="defaultValue">The default value.</param>
      <returns>value</returns>
    </member>
    <member name="M:Lokad.Maybe`1.Convert``1(System.Func{`0,``0},``0)">
      <summary>
            Retrieves converted value, using a 
            <paramref name="defaultValue" /> if it is absent.
            </summary>
      <typeparam name="TTarget">type of the conversion target</typeparam>
      <param name="converter">The converter.</param>
      <param name="defaultValue">The default value.</param>
      <returns>value</returns>
    </member>
    <member name="M:Lokad.Maybe`1.Equals(Lokad.Maybe{`0})">
      <summary>
            Determines whether the specified <see cref="T:Lokad.Maybe`1" /> is equal to the current <see cref="T:Lokad.Maybe`1" />.
            </summary>
      <param name="maybe">The <see cref="T:Lokad.Maybe" /> to compare with.</param>
      <returns>true if the objects are equal</returns>
    </member>
    <member name="M:Lokad.Maybe`1.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Lokad.Maybe`1.GetHashCode">
      <summary>
            Serves as a hash function for this instance.
            </summary>
      <returns>
            A hash code for the current <see cref="T:Lokad.Maybe`1" />.
            </returns>
    </member>
    <member name="M:Lokad.Maybe`1.op_Equality(Lokad.Maybe{`0},Lokad.Maybe{`0})">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Lokad.Maybe`1.op_Inequality(Lokad.Maybe{`0},Lokad.Maybe{`0})">
      <summary>
            Implements the operator !=.
            </summary>
      <param name="left">The left.</param>
      <param name="right">The right.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Lokad.Maybe`1.op_Implicit(`0)~Lokad.Maybe{`0}">
      <summary>
            Performs an implicit conversion from <typeparamref name="T" /> to <see cref="T:Lokad.Maybe`1" />.
            </summary>
      <param name="item">The item.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Lokad.Maybe`1.op_Explicit(Lokad.Maybe{`0})~`0">
      <summary>
            Performs an explicit conversion from <see cref="T:Lokad.Maybe`1" /> to <typeparamref name="T" />.
            </summary>
      <param name="item">The item.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Lokad.Maybe`1.Join``1(``0)">
      <summary>
            Converts maybe into result, using the specified error as the failure
            descriptor
            </summary>
      <typeparam name="TError">The type of the failure.</typeparam>
      <param name="error">The error.</param>
      <returns>result describing current maybe</returns>
    </member>
    <member name="M:Lokad.Maybe`1.JoinMessage(System.String)">
      <summary>
            Converts maybe into result, using the specified error as the failure
            descriptor
            </summary>
      <returns>result describing current maybe</returns>
    </member>
    <member name="M:Lokad.Maybe`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:Lokad.Maybe`1.Value">
      <summary>
            Gets the underlying value.
            </summary>
      <value>The value.</value>
    </member>
    <member name="P:Lokad.Maybe`1.HasValue">
      <summary>
            Gets a value indicating whether this instance has value.
            </summary>
      <value>
        <c>true</c> if this instance has value; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Lokad.Maybe">
      <summary>
            Helper routines for <see cref="T:Lokad.Maybe`1" /></summary>
    </member>
    <member name="F:Lokad.Maybe.Bool">
      <summary>
            Optional empty boolean
            </summary>
    </member>
    <member name="F:Lokad.Maybe.String">
      <summary>
            Optional empty string
            </summary>
    </member>
    <member name="M:Lokad.Maybe.From``1(``0)">
      <summary>
            Creates new <see cref="T:Lokad.Maybe`1" /> from the provided value
            </summary>
      <typeparam name="TSource">The type of the source.</typeparam>
      <param name="item">The item.</param>
      <returns>
        <see cref="T:Lokad.Maybe`1" /> that matches the provided value</returns>
      <exception cref="T:System.ArgumentNullException">if argument is a null reference</exception>
    </member>
    <member name="T:Lokad.MaybeParse">
      <summary>
            	Helper routines for converting strings into Maybe
            </summary>
    </member>
    <member name="M:Lokad.MaybeParse.Enum``1(System.String)">
      <summary>
            	Tries to parse the specified string into the enum, returning empty result
            	on failure. We ignore case in this scenario.
            </summary>
      <typeparam name="TEnum">
            	The type of the enum.
            </typeparam>
      <param name="value">The value.</param>
      <returns>
            	either enum or an empty result
            </returns>
    </member>
    <member name="M:Lokad.MaybeParse.Enum``1(System.String,System.Boolean)">
      <summary>
            	Tries to parse the specified string into the enum, returning empty result
            	on failure
            </summary>
      <typeparam name="TEnum">
            	The type of the enum.
            </typeparam>
      <param name="value">The value.</param>
      <param name="ignoreCase">
            	if set to
            	<c>true</c>
            	then parsing will ignore case.
            </param>
      <returns>
            	either enum or an empty result
            </returns>
    </member>
    <member name="M:Lokad.MaybeParse.Decimal(System.String)">
      <summary>
            	Tries to parse the specified value into Decimal, returning
            	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <returns>
            	either parsed Decimal or an empty result
            </returns>
      <seealso cref="M:System.Decimal.TryParse(System.String,System.Decimal@)" />
    </member>
    <member name="M:Lokad.MaybeParse.Decimal(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
      <summary>
            	Tries to parse the specified value into decimal, returning
            	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <param name="numberStyles">
            	The number styles to use.
            </param>
      <param name="formatProvider">
            	The format provider to use.
            </param>
      <returns>
            	either parsed decimal or an empty result
            </returns>
      <seealso cref="M:System.Decimal.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Decimal@)" />
    </member>
    <member name="M:Lokad.MaybeParse.DecimalInvariant(System.String)">
      <summary>
            	Tries to parse the specified value into decimal, using the invariant culture
            	info and returning	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <returns>
            	either parsed decimal or an empty result
            </returns>
    </member>
    <member name="M:Lokad.MaybeParse.Int32(System.String)">
      <summary>
            	Tries to parse the specified value into Int32, returning
            	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <returns>
            	either parsed Int32 or an empty result
            </returns>
      <seealso cref="M:System.Int32.TryParse(System.String,System.Int32@)" />
    </member>
    <member name="M:Lokad.MaybeParse.Int32(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
      <summary>
            	Tries to parse the specified value into Int32, returning
            	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <param name="numberStyles">
            	The number styles to use.
            </param>
      <param name="formatProvider">
            	The format provider to use.
            </param>
      <returns>
            	either parsed Int32 or an empty result
            </returns>
      <seealso cref="M:System.Int32.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)" />
    </member>
    <member name="M:Lokad.MaybeParse.Int32Invariant(System.String)">
      <summary>
            	Tries to parse the specified string value into Int32, 
            	using an invariant culture and returning empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <returns>
            	either parsed Int32 or an empty result
            </returns>
      <seealso cref="M:System.Int32.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)" />
    </member>
    <member name="M:Lokad.MaybeParse.Int64(System.String)">
      <summary>
            	Tries to parse the specified value into Int64, returning
            	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <returns>
            	either parsed Int64 or an empty result
            </returns>
      <seealso cref="M:System.Int64.TryParse(System.String,System.Int64@)" />
    </member>
    <member name="M:Lokad.MaybeParse.Int64(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
      <summary>
            	Tries to parse the specified value into Int64, returning
            	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <param name="numberStyles">
            	The number styles to use.
            </param>
      <param name="formatProvider">
            	The format provider to use.
            </param>
      <returns>
            	either parsed Int64 or an empty result
            </returns>
      <seealso cref="M:System.Int64.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)" />
    </member>
    <member name="M:Lokad.MaybeParse.Int64Invariant(System.String)">
      <summary>
            	Tries to parse the specified string value into Int64, 
            	using an invariant culture and returning empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <returns>
            	either parsed Int64 or an empty result
            </returns>
      <seealso cref="M:System.Int64.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)" />
    </member>
    <member name="M:Lokad.MaybeParse.Double(System.String)">
      <summary>
            	Tries to parse the specified value into Double, returning
            	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <returns>
            	either parsed Double or an empty result
            </returns>
      <seealso cref="M:System.Double.TryParse(System.String,System.Double@)" />
    </member>
    <member name="M:Lokad.MaybeParse.Double(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
      <summary>
            	Tries to parse the specified value into Double, returning
            	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <param name="numberStyles">
            	The number styles to use.
            </param>
      <param name="formatProvider">
            	The format provider to use.
            </param>
      <returns>
            	either parsed Double or an empty result
            </returns>
      <seealso cref="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
    </member>
    <member name="M:Lokad.MaybeParse.DoubleInvariant(System.String)">
      <summary>
            	Attempts to parse the specified value into Double, 
            	using invariant culture and returning
            	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <returns>
            	either parsed Double or an empty result
            </returns>
      <seealso cref="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
    </member>
    <member name="M:Lokad.MaybeParse.Single(System.String)">
      <summary>
            	Tries to parse the specified value into Single, returning
            	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <returns>
            	either parsed Single or an empty result
            </returns>
      <seealso cref="M:System.Single.TryParse(System.String,System.Single@)" />
    </member>
    <member name="M:Lokad.MaybeParse.Single(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
      <summary>
            	Tries to parse the specified value into Single, returning
            	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <param name="numberStyles">
            	The number styles to use.
            </param>
      <param name="formatProvider">
            	The format provider to use.
            </param>
      <returns>
            	either parsed Single or an empty result
            </returns>
      <seealso cref="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
    </member>
    <member name="M:Lokad.MaybeParse.SingleInvariant(System.String)">
      <summary>
            	Tries to parse the specified value into Single, using invariant culture
            	and returning 	empty result on failure.
            </summary>
      <param name="value">The value.</param>
      <returns>
            	either parsed Single or an empty result
            </returns>
      <seealso cref="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
    </member>
    <member name="T:Lokad.Result`1">
      <summary>
            Helper class that allows to pass out method call results without using exceptions
            </summary>
      <typeparam name="T">type of the associated data</typeparam>
    </member>
    <member name="M:Lokad.Result`1.CreateError(System.String,System.Object[])">
      <summary>  Creates failure result </summary>
      <param name="errorFormatString">format string for the error message</param>
      <param name="args">The arguments.</param>
      <returns>result that is a failure</returns>
      <exception cref="T:System.ArgumentNullException">if format string is null</exception>
    </member>
    <member name="M:Lokad.Result`1.CreateSuccess(`0)">
      <summary>
            Creates the success result.
            </summary>
      <param name="value">The value.</param>
      <returns>result encapsulating the success value</returns>
      <exception cref="T:System.ArgumentNullException">if value is a null reference type</exception>
    </member>
    <member name="M:Lokad.Result`1.Convert``1(System.Func{`0,``0})">
      <summary>
            Converts value of this instance
            using the provided <paramref name="converter" /></summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="converter">The converter.</param>
      <returns>Converted result</returns>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="converter" /> is null</exception>
    </member>
    <member name="M:Lokad.Result`1.CreateError(System.String)">
      <summary>
            Creates the error result.
            </summary>
      <param name="error">The error.</param>
      <returns>result encapsulating the error value</returns>
      <exception cref="T:System.ArgumentNullException">if error is null</exception>
    </member>
    <member name="M:Lokad.Result`1.op_Implicit(`0)~Lokad.Result{`0}">
      <summary>
            Performs an implicit conversion from <typeparamref name="T" /> to <see cref="T:Lokad.Result`1" />.
            </summary>
      <param name="value">The item.</param>
      <returns>The result of the conversion.</returns>
      <exception cref="T:System.ArgumentNullException">if <paramref name="value" /> is a reference type that is null</exception>
    </member>
    <member name="M:Lokad.Result`1.Combine``1(System.Func{`0,Lokad.Result{``0}})">
      <summary>
            Combines this <see cref="T:Lokad.Result`1" /> with the result returned
            by <paramref name="converter" />.
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="converter">The converter.</param>
      <returns>Combined result.</returns>
    </member>
    <member name="M:Lokad.Result`1.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Lokad.Result`1.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Lokad.Result`1.Equals(Lokad.Result{`0})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
    </member>
    <member name="M:Lokad.Result`1.Apply(System.Action{`0})">
      <summary>
            Applies the specified <paramref name="action" />
            to this <see cref="T:Lokad.Result`1" />, if it has value.
            </summary>
      <param name="action">The action to apply.</param>
      <returns>returns same instance for inlining</returns>
      <exception cref="T:System.ArgumentNullException">if <paramref name="action" /> is null</exception>
    </member>
    <member name="M:Lokad.Result`1.Handle(System.Action{System.String})">
      <summary>
            Handles the specified handler.
            </summary>
      <param name="handler">The handler.</param>
      <returns>same instance for the inlining</returns>
    </member>
    <member name="M:Lokad.Result`1.ToMaybe``1(System.Func{`0,``0})">
      <summary>
            Converts this <see cref="T:Lokad.Result`1" /> to <see cref="T:Lokad.Maybe`1" />, 
            using the <paramref name="converter" /> to perform the value conversion.
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="converter">The reflector.</param>
      <returns>
        <see cref="T:Lokad.Maybe`1" /> that represents the original value behind the <see cref="T:Lokad.Result`1" /> after the conversion</returns>
    </member>
    <member name="M:Lokad.Result`1.ToMaybe">
      <summary>
            Converts this <see cref="T:Lokad.Result`1" /> to <see cref="T:Lokad.Maybe`1" />, 
            with the original value reference, if there is any.
            </summary>
      <returns>
        <see cref="T:Lokad.Maybe`1" /> that represents the original value behind the <see cref="T:Lokad.Result`1" />.</returns>
    </member>
    <member name="M:Lokad.Result`1.ExposeException(System.Func{System.String,System.Exception})">
      <summary>
            Exposes result failure as the exception (providing compatibility, with the exception -expecting code).
            </summary>
      <param name="exception">The function to generate exception, provided the error string.</param>
      <returns>result value</returns>
    </member>
    <member name="M:Lokad.Result`1.op_Implicit(System.String)~Lokad.Result{`0}">
      <summary>
            Performs an implicit conversion from <see cref="T:System.String" /> to <see cref="T:Lokad.Result`1" />.
            </summary>
      <param name="error">The error.</param>
      <returns>The result of the conversion.</returns>
      <exception cref="T:System.ArgumentNullException">If value is a null reference type</exception>
    </member>
    <member name="M:Lokad.Result`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:Lokad.Result`1.ErrorMessage">
      <summary>
            Error message associated with this failure
            </summary>
    </member>
    <member name="P:Lokad.Result`1.IsSuccess">
      <summary>
            Gets a value indicating whether this result is valid.
            </summary>
      <value>
        <c>true</c> if this result is valid; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Lokad.Result`1.Value">
      <summary>
            item associated with this result
            </summary>
    </member>
    <member name="P:Lokad.Result`1.Error">
      <summary>
            Error message associated with this failure
            </summary>
    </member>
    <member name="T:Lokad.Result`2">
      <summary>
            Improved version of the Result[T], that could serve as a basis for it.
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <typeparam name="TError">The type of the error.</typeparam>
      <remarks>It is to be moved up-stream if found useful in other projects.</remarks>
    </member>
    <member name="M:Lokad.Result`2.CreateSuccess(`0)">
      <summary>
            Creates the success result.
            </summary>
      <param name="value">The value.</param>
      <returns>result encapsulating the success value</returns>
      <exception cref="T:System.ArgumentNullException">if value is a null reference type</exception>
    </member>
    <member name="M:Lokad.Result`2.CreateError(`1)">
      <summary>
            Creates the error result.
            </summary>
      <param name="error">The error.</param>
      <returns>result encapsulating the error value</returns>
      <exception cref="T:System.ArgumentNullException">if error is a null reference type</exception>
    </member>
    <member name="M:Lokad.Result`2.op_Implicit(`0)~Lokad.Result{`0,`1}">
      <summary>
            Performs an implicit conversion from <typeparamref name="TValue" /> to <see cref="T:Lokad.Result`2" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
      <exception cref="T:System.ArgumentNullException">If value is a null reference type</exception>
    </member>
    <member name="M:Lokad.Result`2.op_Implicit(`1)~Lokad.Result{`0,`1}">
      <summary>
            Performs an implicit conversion from <typeparamref name="TError" /> to <see cref="T:Lokad.Result`2" />.
            </summary>
      <param name="error">The error.</param>
      <returns>The result of the conversion.</returns>
      <exception cref="T:System.ArgumentNullException">If value is a null reference type</exception>
    </member>
    <member name="M:Lokad.Result`2.Equals(Lokad.Result{`0,`1})">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <param name="other">An object to compare with this object.</param>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
    </member>
    <member name="M:Lokad.Result`2.Apply(System.Action{`0})">
      <summary>
            Applies the specified <paramref name="action" />
            to this <see cref="T:Lokad.Result`1" />, if it has value.
            </summary>
      <param name="action">The action to apply.</param>
      <returns>returns same instance for inlining</returns>
      <exception cref="T:System.ArgumentNullException">if <paramref name="action" /> is null</exception>
    </member>
    <member name="M:Lokad.Result`2.Handle(System.Action{`1})">
      <summary>
            Handles the specified handler.
            </summary>
      <param name="handler">The handler.</param>
      <returns>same instance for the inlining</returns>
    </member>
    <member name="M:Lokad.Result`2.Convert``1(System.Func{`0,``0})">
      <summary>
            Converts value of this instance
            using the provided <paramref name="converter" /></summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="converter">The converter.</param>
      <returns>Converted result</returns>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="converter" /> is null</exception>
    </member>
    <member name="M:Lokad.Result`2.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Lokad.Result`2.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Lokad.Result`2.Combine``1(System.Func{`0,Lokad.Result{``0,`1}})">
      <summary>
            Combines this <see cref="T:Lokad.Result`1" /> with the result returned
            by <paramref name="converter" />.
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="converter">The converter.</param>
      <returns>Combined result.</returns>
    </member>
    <member name="M:Lokad.Result`2.ToMaybe``1(System.Func{`0,``0})">
      <summary>
            Converts this <see cref="T:Lokad.Result`1" /> to <see cref="T:Lokad.Maybe`1" />, 
            using the <paramref name="converter" /> to perform the value conversion.
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="converter">The reflector.</param>
      <returns>
        <see cref="T:Lokad.Maybe`1" /> that represents the original value behind the <see cref="T:Lokad.Result`1" /> after the conversion</returns>
    </member>
    <member name="M:Lokad.Result`2.ToMaybe">
      <summary>
            Converts this <see cref="T:Lokad.Result`1" /> to <see cref="T:Lokad.Maybe`1" />, 
            with the original value reference, if there is any.
            </summary>
      <returns>
        <see cref="T:Lokad.Maybe`1" /> that represents the original value behind the <see cref="T:Lokad.Result`1" />.</returns>
    </member>
    <member name="M:Lokad.Result`2.ExposeException(System.Func{`1,System.Exception})">
      <summary>
            Exposes result failure as the exception (providing compatibility, with the exception -expecting code).
            </summary>
      <param name="exception">The function to generate exception, provided the error string.</param>
      <returns>result value</returns>
    </member>
    <member name="M:Lokad.Result`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:Lokad.Result`2.Value">
      <summary>
            item associated with this result
            </summary>
    </member>
    <member name="P:Lokad.Result`2.Error">
      <summary>
            Error message associated with this failure
            </summary>
    </member>
    <member name="P:Lokad.Result`2.IsSuccess">
      <summary>
            Gets a value indicating whether this result is valid.
            </summary>
      <value>
        <c>true</c> if this result is valid; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Lokad.Result">
      <summary> Helper class for creating <see cref="T:Lokad.Result`1" /> instances </summary>
    </member>
    <member name="M:Lokad.Result.CreateSuccess``1(``0)">
      <summary> Creates success result </summary>
      <typeparam name="TValue">The type of the result.</typeparam>
      <param name="value">The item.</param>
      <returns>new result instance</returns>
      <seealso cref="M:Lokad.Result`1.CreateSuccess(`0)" />
    </member>
    <member name="M:Lokad.Result.Success``1(``0)">
      <summary> Creates success result </summary>
      <typeparam name="TValue">The type of the result.</typeparam>
      <param name="value">The item.</param>
      <returns>new result instance</returns>
      <seealso cref="M:Lokad.Result`1.CreateSuccess(`0)" />
    </member>
    <member name="T:Lokad.ResultResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Lokad.ResultResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Lokad.ResultResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Lokad.ResultResources.Dont_access_error_on_valid_result">
      <summary>
              Looks up a localized string similar to Code should not access error message when the result is valid..
            </summary>
    </member>
    <member name="P:Lokad.ResultResources.Dont_access_result_on_error_X">
      <summary>
              Looks up a localized string similar to Code should not access value when the result has failed. Error is: '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.ResultResources.Dont_access_value_when_maybe_is_empty">
      <summary>
              Looks up a localized string similar to Code should not access value when it is not available..
            </summary>
    </member>
    <member name="T:Lokad.NamedProvider`1">
      <summary>
            This class provides way to create providers out of lambda shortcuts
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:Lokad.NamedProvider`1.#ctor(System.Func{System.String,`0})">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.NamedProvider`1" /> class.
            </summary>
      <param name="resolver">The resolver.</param>
    </member>
    <member name="M:Lokad.NamedProvider`1.Get(System.String)">
      <summary>
            Retrieves <typeparamref name="T" /> given the <paramref name="key" /></summary>
      <param name="key">
      </param>
      <returns>
      </returns>
      <exception cref="T:Lokad.ResolutionException">when the key cannot be resolved</exception>
    </member>
    <member name="T:Lokad.NamedProvider">
      <summary>
            Shortcuts for <see cref="T:Lokad.NamedProvider`1" /></summary>
    </member>
    <member name="M:Lokad.NamedProvider.For``1(System.Func{System.String,``0})">
      <summary>
            Creates new instance of the <see cref="T:Lokad.INamedProvider`1" /> out of
            the provider function (shortcut syntax)
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="providerFunction">The provider function.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.Provider`2">
      <summary>
            This class provides short-cut for creating providers
            out of lambda expressions.
            </summary>
      <typeparam name="TKey">The type of the key.</typeparam>
      <typeparam name="TValue">The type of the value.</typeparam>
    </member>
    <member name="M:Lokad.Provider`2.#ctor(System.Func{`0,`1})">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Provider`2" /> class.
            </summary>
      <param name="resolver">The resolver.</param>
      <exception cref="T:System.ArgumentNullException">When 
            <paramref name="resolver" /> is null</exception>
    </member>
    <member name="M:Lokad.Provider`2.Get(`0)">
      <summary>
            Retrieves <typeparamref name="TValue" /> given the
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
      <exception cref="T:Lokad.ResolutionException">when the key is invalid for
            the provider</exception>
    </member>
    <member name="T:Lokad.Provider`1">
      <summary>
            Helper class that simplifies creation of <see cref="T:Lokad.Provider`2" /></summary>
      <typeparam name="TKey">type of the Key items</typeparam>
    </member>
    <member name="M:Lokad.Provider`1.For``1(System.Func{`0,``0})">
      <summary>
            Creates the provider, letting compiler to figure out
            the value type. This allows to use anonymous types locally as well
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="func">The function that is the provider.</param>
      <returns>new provider instance</returns>
    </member>
    <member name="T:Lokad.Quality.AssertionConditionAttribute">
      <summary>
            Indicates the condition parameter of the assertion method. 
            The method itself should be marked by <see cref="T:Lokad.Quality.AssertionMethodAttribute" /> attribute.
            The mandatory argument of the attribute is the assertion type.
            </summary>
      <seealso cref="T:Lokad.Quality.AssertionConditionType" />
      <remarks>This attribute helps R# in code analysis</remarks>
    </member>
    <member name="M:Lokad.Quality.AssertionConditionAttribute.#ctor(Lokad.Quality.AssertionConditionType)">
      <summary>
            Initializes new instance of AssertionConditionAttribute
            </summary>
      <param name="conditionType">Specifies condition type</param>
    </member>
    <member name="P:Lokad.Quality.AssertionConditionAttribute.ConditionType">
      <summary>
            Gets condition type
            </summary>
    </member>
    <member name="T:Lokad.Quality.AssertionConditionType">
      <summary>
            Specifies assertion type. If the assertion method argument satisifes the condition, then the execution continues. 
            Otherwise, execution is assumed to be halted
            </summary>
    </member>
    <member name="F:Lokad.Quality.AssertionConditionType.IS_TRUE">
      <summary>
            Indicates that the marked parameter should be evaluated to true
            </summary>
    </member>
    <member name="F:Lokad.Quality.AssertionConditionType.IS_FALSE">
      <summary>
            Indicates that the marked parameter should be evaluated to false
            </summary>
    </member>
    <member name="F:Lokad.Quality.AssertionConditionType.IS_NULL">
      <summary>
            Indicates that the marked parameter should be evaluated to null value
            </summary>
    </member>
    <member name="F:Lokad.Quality.AssertionConditionType.IS_NOT_NULL">
      <summary>
            Indicates that the marked parameter should be evaluated to not null value
            </summary>
    </member>
    <member name="T:Lokad.Quality.AssertionMethodAttribute">
      <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if one of the conditions is satisfied. 
            To set the condition, mark one of the parameters with <see cref="T:Lokad.Quality.AssertionConditionAttribute" /> attribute
            </summary>
      <seealso cref="T:Lokad.Quality.AssertionConditionAttribute" />
      <remarks>This attribute helps R# in code analysis</remarks>
    </member>
    <member name="T:Lokad.Quality.ImplicitUseFlags">
      <summary>
            Used by <see cref="T:Lokad.Quality.MeansImplicitUseAttribute" /></summary>
    </member>
    <member name="F:Lokad.Quality.ImplicitUseFlags.STANDARD">
      <summary>
            Standard
            </summary>
    </member>
    <member name="F:Lokad.Quality.ImplicitUseFlags.ALL_MEMBERS_USED">
      <summary>
            All members used
            </summary>
    </member>
    <member name="T:Lokad.Quality.InvokerParameterNameAttribute">
      <summary>
            Indicates that the function argument should be string literal and match one  of the parameters of the caller function.
            For example, <see cref="T:System.ArgumentNullException" /> has such parameter.
            </summary>
      <remarks>This attribute helps R# in code analysis</remarks>
    </member>
    <member name="T:Lokad.Quality.MeansImplicitUseAttribute">
      <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes as unused (as well as by other usage inspections)
            </summary>
      <remarks>This attribute helps R# in code analysis</remarks>
    </member>
    <member name="M:Lokad.Quality.MeansImplicitUseAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quality.MeansImplicitUseAttribute" /> class with <see cref="F:Lokad.Quality.ImplicitUseFlags.STANDARD" />.
            </summary>
    </member>
    <member name="M:Lokad.Quality.MeansImplicitUseAttribute.#ctor(Lokad.Quality.ImplicitUseFlags)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Quality.MeansImplicitUseAttribute" /> class.
            </summary>
      <param name="flags">The flags.</param>
    </member>
    <member name="P:Lokad.Quality.MeansImplicitUseAttribute.Flags">
      <summary>
            Gets the flags.
            </summary>
      <value>The flags.</value>
    </member>
    <member name="T:Lokad.Quality.NoCodeCoverageAttribute">
      <summary>
            Attribute used to inform code coverage tool to ignore marked code block
            </summary>
    </member>
    <member name="P:Lokad.Quality.NoCodeCoverageAttribute.Justification">
      <summary> Gets or sets the justification for removing 
            the member from the unit test code coverage. </summary>
      <value>The justification.</value>
    </member>
    <member name="T:Lokad.Quality.NotNullAttribute">
      <summary>
            Indicates that the value of marked element could never be <c>null</c></summary>
    </member>
    <member name="T:Lokad.Quality.StringFormatMethodAttribute">
      <summary>
            Indicates that marked method builds string by format pattern and (optional) arguments. 
            Parameter, which contains format string, should be given in constructor.
            The format string should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> -like form
            </summary>
      <remarks>
            This attribute helps R# in code analysis
            </remarks>
    </member>
    <member name="M:Lokad.Quality.StringFormatMethodAttribute.#ctor(System.String)">
      <summary>
            Initializes new instance of StringFormatMethodAttribute
            </summary>
      <param name="formatParameterName">Specifies which parameter of an annotated method should be treated as format-string</param>
    </member>
    <member name="P:Lokad.Quality.StringFormatMethodAttribute.FormatParameterName">
      <summary>
            Gets format parameter name
            </summary>
    </member>
    <member name="T:Lokad.Quality.UsedImplicitlyAttribute">
      <summary>
            Indicates that the marked symbol is used implicitly (ex. reflection, external library), 
            so this symbol will not be marked as unused (as well as by other usage inspections)
            </summary>
      <remarks>This attribute helps R# in code analysis</remarks>
    </member>
    <member name="T:Lokad.Rand">
      <summary>
            Helper class that allows to implement non-deterministic 
            reproducible testing.
            </summary>
      <remarks>
            Keep in mind, that this implementation is not thread-safe.
            </remarks>
    </member>
    <member name="T:Lokad.Rand.String">
      <summary>
            Helper random methods related to strings
            </summary>
    </member>
    <member name="M:Lokad.Rand.String.NextSentence(System.Int32,System.Int32)">
      <summary>
            Gets the Lorem Ipsum sentence with random word count.
            </summary>
      <param name="lowerBound">The lower bound for the word count (inclusive).</param>
      <param name="upperBound">The upper bound for the word count (exclusive).</param>
      <returns>random sentence of Lorem ipsum</returns>
    </member>
    <member name="M:Lokad.Rand.String.NextWord">
      <summary>
            Gets random word from the Lorem Ipsum dictionary.
            </summary>
      <returns>random word from the Lorem Ipsum dictionary</returns>
    </member>
    <member name="M:Lokad.Rand.String.NextText(System.Int32,System.Int32)">
      <summary>
            Gets the Lorem ipsum text with the random word count.
            </summary>
      <param name="lowerBound">The lower bound for the word count (inclusive).</param>
      <param name="upperBound">The upper bound for the word count (exclusive).</param>
      <returns>random text of Lorem Ipsum</returns>
    </member>
    <member name="M:Lokad.Rand.ResetToDefault">
      <summary>
            Resets everything to the default, using <see cref="T:System.Random" /> generator and random seed. 
            </summary>
    </member>
    <member name="M:Lokad.Rand.ResetToDefault(System.Int32)">
      <summary>
            Resets everything to the default, using <see cref="T:System.Random" /> generator and the specified
            rand seed.
            </summary>
      <param name="randSeed">The rand seed.</param>
    </member>
    <member name="M:Lokad.Rand.Reset">
      <summary>
            Resets the random generator, using the provided activator
            </summary>
    </member>
    <member name="M:Lokad.Rand.Reset(System.Func{System.Func{System.Int32,System.Int32}})">
      <summary>
            Overrides with the current activator
            </summary>
      <param name="activator">The activator.</param>
    </member>
    <member name="M:Lokad.Rand.Next">
      <summary>
            Generates random value between 0 and <see cref="F:System.Int32.MaxValue" /> (exclusive)
            </summary>
      <returns>random integer</returns>
    </member>
    <member name="M:Lokad.Rand.Next(System.Int32)">
      <summary>
            Generates random value between 0 and <paramref name="upperBound" /> (exclusive)
            </summary>
      <param name="upperBound">The upper bound.</param>
      <returns>random integer</returns>
    </member>
    <member name="M:Lokad.Rand.Next(System.Int32,System.Int32)">
      <summary>
            Generates random value between <paramref name="lowerBound" />
            and <paramref name="upperBound" /> (exclusive)
            </summary>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <returns>random integer</returns>
    </member>
    <member name="M:Lokad.Rand.NextItem``1(``0[])">
      <summary> Picks random item from the provided array </summary>
      <typeparam name="TItem">The type of the item.</typeparam>
      <param name="items">The items.</param>
      <returns>random item from the array</returns>
    </member>
    <member name="M:Lokad.Rand.NextEnum``1">
      <summary> Picks random <see cref="T:System.Enum" /></summary>
      <typeparam name="TEnum">The type of the enum.</typeparam>
      <returns>random Enum value</returns>
    </member>
    <member name="M:Lokad.Rand.NextEnumExceptDefault``1">
      <summary> Picks random <see cref="T:System.Enum" /> where the item is not equal to
            default(TEnum)</summary>
      <typeparam name="TEnum">The type of the enum.</typeparam>
      <returns>random Enum value</returns>
    </member>
    <member name="M:Lokad.Rand.NextBool(System.Double)">
      <summary>
            Returns <em>true</em> with the specified probability.
            </summary>
      <param name="probability">The probability (between 0 and 1).</param>
      <returns>
        <em>true</em> with the specified probability</returns>
    </member>
    <member name="M:Lokad.Rand.NextBool">
      <summary>
            Returns either <em>true</em> or <em>false</em></summary>
      <returns>either <em>true</em> or <em>false</em></returns>
    </member>
    <member name="M:Lokad.Rand.NextMaybe``1(``0)">
      <summary>
            Creates random optional that might have the value
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="value">The value.</param>
      <returns>optional that might have the value</returns>
    </member>
    <member name="M:Lokad.Rand.NextGuid">
      <summary> Picks random <see cref="T:System.Guid" /></summary>
      <returns>random value</returns>
    </member>
    <member name="M:Lokad.Rand.NextGuids(System.Int32)">
      <summary>
            Creates an array of random <see cref="T:System.Guid" /></summary>
      <param name="count">Number of items in the array.</param>
      <returns>random value</returns>
    </member>
    <member name="M:Lokad.Rand.NextGuids(System.Int32,System.Int32)">
      <summary>
            Creates an array of random <see cref="T:System.Guid" /> and random length.
            </summary>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.Rand.NextDouble">
      <summary> Returns random double value with lowered precision </summary>
      <returns>random double value</returns>
    </member>
    <member name="M:Lokad.Rand.NextDate">
      <summary>
            Returns a random date between 1700-01-01 and 2100-01-01
            </summary>
      <returns>random value</returns>
    </member>
    <member name="M:Lokad.Rand.NextDate(System.Int32,System.Int32)">
      <summary>
            Returns a random date between the specified range.
            </summary>
      <param name="minYear">The min year.</param>
      <param name="maxYear">The max year.</param>
      <returns>new random date</returns>
    </member>
    <member name="M:Lokad.Rand.NextString(System.Int32,System.Int32)">
      <summary>
            Generates random string with the length between 
            <paramref name="lowerBound" /> and <paramref name="upperBound" /> (exclusive)
            </summary>
      <param name="lowerBound">The lower bound for the string length.</param>
      <param name="upperBound">The upper bound for the string length.</param>
      <returns>new random string</returns>
    </member>
    <member name="M:Lokad.Rand.NextItems``1(``0[],System.Int32)">
      <summary>
            Gets a random subset from the array
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="items">The items.</param>
      <param name="count">The count.</param>
      <returns>array that contains <paramref name="count" /> items from the original array</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">when <paramref name="count" /> 
            is bigger than the length of <paramref name="items" /></exception>
    </member>
    <member name="T:Lokad.Range">
      <summary>
            Helper class with shortcut methods for managing enumerations.
            Useful for inlining object generation in tests
            </summary>
    </member>
    <member name="M:Lokad.Range.Empty``1">
      <summary> Returns empty enumerator </summary>
      <typeparam name="T">type of the item to enumerate</typeparam>
      <returns>singleton instance of the empty enumerator</returns>
    </member>
    <member name="M:Lokad.Range.Create(System.Int32)">
      <summary>
            returns enumeration from 0 with <paramref name="count" /> numbers
            </summary>
      <param name="count">Number of items to create</param>
      <returns>enumerable</returns>
    </member>
    <member name="M:Lokad.Range.Create(System.Int32,System.Int32)">
      <summary>
            Creates sequence of the integral numbers within the specified range
            </summary>
      <param name="start">The value of the first integer in sequence.</param>
      <param name="count">The number of values in the sequence.</param>
      <returns>sequence of the integral numbers within the specified range</returns>
    </member>
    <member name="M:Lokad.Range.Repeat``1(``0,System.Int32)">
      <summary>
            Creates sequence that consists of a repeated value.
            </summary>
      <typeparam name="TResult">The type of the value to repeat.</typeparam>
      <param name="item">The value to repeat.</param>
      <param name="count">The number of times to repeat.</param>
      <returns>sequence that consists of a repeated value</returns>
    </member>
    <member name="M:Lokad.Range.Create``1(System.Func{System.Int32,``0})">
      <summary>
            Creates the generator to iterate from 1 to <see cref="F:System.Int32.MaxValue" />.
            </summary>
      <typeparam name="T">type of the item to generate</typeparam>
      <param name="generator">The generator.</param>
      <returns>new enumerator</returns>
    </member>
    <member name="M:Lokad.Range.Create``1(System.Int32,System.Func{System.Int32,``0})">
      <summary>
            Creates the enumerable using the provided generator.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="count">The count.</param>
      <param name="generator">The generator.</param>
      <returns>enumerable instance</returns>
    </member>
    <member name="M:Lokad.Range.Create``1(System.Int32,System.Func{``0})">
      <summary>
            Creates the enumerable using the provided generator.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="count">The count.</param>
      <param name="generator">The generator.</param>
      <returns>enumerable instance</returns>
    </member>
    <member name="M:Lokad.Range.Array``1(System.Int32,System.Func{System.Int32,``0})">
      <summary>
            Creates the array populated with the provided generator
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="count">The count.</param>
      <param name="generator">The generator.</param>
      <returns>array</returns>
    </member>
    <member name="M:Lokad.Range.Array(System.Int32)">
      <summary>
            Creates the array of integers
            </summary>
      <param name="count">The count.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Lokad.Reflection.Express">
      <summary>
            Helper class for the Expression-based strongly-typed reflection
            </summary>
    </member>
    <member name="M:Lokad.Reflection.Express.MethodWithLambda(System.Linq.Expressions.LambdaExpression)">
      <summary>
            Gets the <see cref="T:System.Reflection.MethodInfo" /> 
            from the provided <paramref name="method" />.
            </summary>
      <param name="method">The method expression.</param>
      <returns>method information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.ConstructorWithLamda(System.Linq.Expressions.LambdaExpression)">
      <summary> Gets the <see cref="T:System.Reflection.ConstructorInfo" /> from the 
            provided <paramref name="constructor" /> lambda. </summary>
      <param name="constructor">The constructor expression.</param>
      <returns>constructor information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.MemberWithLambda(System.Linq.Expressions.LambdaExpression)">
      <summary> Gets the <see cref="T:System.Reflection.MemberInfo" /> (field or property) 
            from the  provided <paramref name="member" /></summary>
      <param name="member">The property expression.</param>
      <returns>member information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.PropertyWithLambda(System.Linq.Expressions.LambdaExpression)">
      <summary> Gets the <see cref="T:System.Reflection.PropertyInfo" /> from the provided
            <paramref name="property" /> expression. </summary>
      <param name="property">The property expression.</param>
      <returns>property information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.FieldWithLambda(System.Linq.Expressions.LambdaExpression)">
      <summary> Gets the <see cref="T:System.Reflection.FieldInfo" /> from the provided 
            <paramref name="field" /> expression. </summary>
      <param name="field">The field expression.</param>
      <returns>field information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.Method(System.Linq.Expressions.Expression{System.Action})">
      <summary> Gets the <see cref="T:System.Reflection.MethodInfo" /> 
            from the provided <paramref name="method" />.
            </summary>
      <param name="method">The method expression.</param>
      <returns>method information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.Constructor``1(System.Linq.Expressions.Expression{System.Func{``0}})">
      <summary>
            Gets the <see cref="T:System.Reflection.ConstructorInfo" /> 
            from the provided <paramref name="constructorExpression" />.
            </summary>
      <param name="constructorExpression">The constructor expression.</param>
      <returns>constructor information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.Property``1(System.Linq.Expressions.Expression{System.Func{``0}})">
      <summary> Gets the <see cref="T:System.Reflection.PropertyInfo" /> from the provided
            <paramref name="property" /> expression. </summary>
      <param name="property">The property expression.</param>
      <returns>property information</returns>
    </member>
    <member name="M:Lokad.Reflection.Express.Field``1(System.Linq.Expressions.Expression{System.Func{``0}})">
      <summary> Gets the <see cref="T:System.Reflection.FieldInfo" /> from the provided 
            <paramref name="field" /> expression. </summary>
      <param name="field">The field expression.</param>
      <returns>field information</returns>
    </member>
    <member name="T:Lokad.Reflection.Express`1">
      <summary>
            Helper class for the Expression-based strongly-typed reflection
            </summary>
    </member>
    <member name="M:Lokad.Reflection.Express`1.Method(System.Linq.Expressions.Expression{System.Action{`0}})">
      <summary> Gets the <see cref="T:System.Reflection.MethodInfo" /> from 
            the provided <paramref name="method" /> expression. </summary>
      <param name="method">The expression.</param>
      <returns>method information</returns>
      <seealso cref="M:Lokad.Reflection.Express.MethodWithLambda(System.Linq.Expressions.LambdaExpression)" />
    </member>
    <member name="M:Lokad.Reflection.Express`1.Property``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary> Gets the <see cref="T:System.Reflection.PropertyInfo" /> from the provided
            <paramref name="property" /> expression. </summary>
      <param name="property">The property expression.</param>
      <returns>property information</returns>
      <seealso cref="M:Lokad.Reflection.Express.MemberWithLambda(System.Linq.Expressions.LambdaExpression)" />
      <seealso cref="M:Lokad.Reflection.Express.PropertyWithLambda(System.Linq.Expressions.LambdaExpression)" />
    </member>
    <member name="M:Lokad.Reflection.Express`1.Field``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary> Gets the <see cref="T:System.Reflection.FieldInfo" /> from the provided 
            <paramref name="field" /> expression. </summary>
      <param name="field">The field expression.</param>
      <returns>field information</returns>
      <seealso cref="M:Lokad.Reflection.Express.MemberWithLambda(System.Linq.Expressions.LambdaExpression)" />
      <seealso cref="M:Lokad.Reflection.Express.FieldWithLambda(System.Linq.Expressions.LambdaExpression)" />
    </member>
    <member name="T:Lokad.Reflection.Reflect">
      <summary>
            Helper class for the IL-based strongly-typed reflection
            </summary>
      <remarks>This class is not supported by Silverlight 2.0, yet</remarks>
    </member>
    <member name="M:Lokad.Reflection.Reflect.Variable``1(System.Func{``0})">
      <summary>
            Retrieves via IL the information of the <b>local</b> variable passed in the expression.
            <code>
            var myVar = "string";
            var info = Reflect.Variable(() =&gt; myVar)
            </code></summary>
      <typeparam name="T">
      </typeparam>
      <param name="expression">The expression containing the local variable to reflect.</param>
      <returns>information about the variable (if able to retrieve)</returns>
      <exception cref="T:Lokad.Reflection.ReflectLambdaException">if the provided expression is not a simple variable reference</exception>
    </member>
    <member name="M:Lokad.Reflection.Reflect.VariableSafely``1(System.Func{``0})">
      <summary>
            Retrieves via IL the information of the <b>local</b> variable passed in the expression.
            <code>
            var myVar = "string";
            var info = Reflect.Variable(() =&gt; myVar)
            </code></summary>
      <typeparam name="T">
      </typeparam>
      <param name="expression">The expression containing the local variable to reflect.</param>
      <returns>information about the variable (if able to retrieve)</returns>
    </member>
    <member name="M:Lokad.Reflection.Reflect.Property``1(System.Func{``0})">
      <summary>
            Retrieves via IL the <em>getter method</em> for the property being reflected.
            <code>
            var i2 = new
            {
              MyProperty = "Value"
            }; 
            var info = Reflect.Property(() =&gt; i2.Property);
            // info will have name of "get_MyProperty"
            </code></summary>
      <typeparam name="T">type of the property to reflect</typeparam>
      <param name="expression">The expression.</param>
      <returns>getter method for the property.</returns>
      <exception cref="T:Lokad.Reflection.ReflectLambdaException">if reference is not a simple property</exception>
    </member>
    <member name="M:Lokad.Reflection.Reflect.PropertySafely``1(System.Func{``0})">
      <summary>
            Retrieves via IL the <em>getter method</em> for the property being reflected.
            <code>
            var i2 = new
            {
              MyProperty = "Value"
            }; 
            var info = Reflect.Property(() =&gt; i2.Property);
            // info will have name of "get_MyProperty"
            </code></summary>
      <typeparam name="T">type of the property to reflect</typeparam>
      <param name="expression">The expression.</param>
      <returns>getter method for the property.</returns>
    </member>
    <member name="T:Lokad.Reflection.ReflectLambdaException">
      <summary>
            Exception thrown, when <see cref="T:Lokad.Reflection.Reflect" /> fails to parse some lambda
            </summary>
    </member>
    <member name="M:Lokad.Reflection.ReflectLambdaException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Reflection.ReflectLambdaException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="T:Lokad.ResolutionException">
      <summary>
            Exception that is thrown by <see cref="!:IResolver" /> or <see cref="T:Lokad.IProvider`2" /></summary>
    </member>
    <member name="M:Lokad.ResolutionException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.ResolutionException" /> class.
            </summary>
    </member>
    <member name="M:Lokad.ResolutionException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.ResolutionException" /> class.
            </summary>
      <param name="message">The message related to this exception.</param>
    </member>
    <member name="M:Lokad.ResolutionException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.ResolutionException" /> class.
            </summary>
      <param name="message">The message related to this exception.</param>
      <param name="inner">The inner exception.</param>
    </member>
    <member name="M:Lokad.ResolutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.ResolutionException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="info" /> parameter is null.
            </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
    </member>
    <member name="T:Lokad.Rules.BufferIs">
      <summary>
            Validation rules for byte arrays
            </summary>
    </member>
    <member name="M:Lokad.Rules.BufferIs.Limited(System.Int32)">
      <summary>
            Composes validator ensuring that size of the buffer 
            is equal or less to the speicifed limit 
            </summary>
      <param name="length">The length.</param>
      <returns>new rule validator instance</returns>
    </member>
    <member name="M:Lokad.Rules.BufferIs.WithValidHash(System.Int32)">
      <summary>
            Composes validator ensuring that buffer has valid hash
            </summary>
      <param name="hash">The hash.</param>
      <returns>new instance of the rule validato</returns>
      <seealso cref="M:Lokad.BufferUtil.CalculateSimpleHashCode(System.Byte[])" />
    </member>
    <member name="T:Lokad.Rules.DateIs">
      <summary> Rules for the <see cref="T:System.DateTime" /></summary>
    </member>
    <member name="M:Lokad.Rules.DateIs.SqlCompatible(System.DateTime,Lokad.Rules.IScope)">
      <summary>
            Verifies that it is ok to send this date directly into the MS SQL DB
            </summary>
      <param name="dateTime">The dateTime to validate.</param>
      <param name="scope">validation scope</param>
    </member>
    <member name="T:Lokad.Rules.DoubleIs">
      <summary>
            Rules for the <see cref="T:System.Double" /></summary>
    </member>
    <member name="M:Lokad.Rules.DoubleIs.Valid(System.Double,Lokad.Rules.IScope)">
      <summary>
            Checks if the specified double is valid.
            </summary>
      <param name="value">The value.</param>
      <param name="scope">The scope.</param>
    </member>
    <member name="T:Lokad.Rules.Is">
      <summary>
            Generic rules 
            </summary>
    </member>
    <member name="M:Lokad.Rules.Is.NotEqual``1(System.IEquatable{``0})">
      <summary>
            Composes the validator ensuring that the provided value does not equal to <paramref name="item" /></summary>
      <typeparam name="T">type of the item to compare</typeparam>
      <param name="item">The item.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.Equal``1(System.IEquatable{``0})">
      <summary>
            Composes the validator ensuring that the provided value equals to <paramref name="item" /></summary>
      <typeparam name="T">type of the item to compare</typeparam>
      <param name="item">The item.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.Value``1(``0)">
      <summary>
            Composes the validator ensuring that the provided value equals to <paramref name="item" /></summary>
      <typeparam name="T">type of the item to compare</typeparam>
      <param name="item">The item.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.SameAs``1(``0)">
      <summary>
            Composes the validator ensuring that the provided object is same as <paramref name="item" /></summary>
      <typeparam name="T">type of the item to compare</typeparam>
      <param name="item">The item.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.NotDefault``1(``0,Lokad.Rules.IScope)">
      <summary>
            Returns error if the provided value type has default value
            </summary>
      <typeparam name="T">value type to check</typeparam>
      <param name="item">The item.</param>
      <param name="scope">The scope.</param>
    </member>
    <member name="M:Lokad.Rules.Is.Default``1(``0,Lokad.Rules.IScope)">
      <summary>
            Returns error if provided value type has been initialized
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="item">The item.</param>
      <param name="scope">The scope.</param>
    </member>
    <member name="M:Lokad.Rules.Is.Within``1(System.IComparable{``0},System.IComparable{``0})">
      <summary>
            Composes the range validator that ensures that the supplied value belongs
            to the interval from <paramref name="minValue" /> to <paramref name="maxValue" />
            (inclusive).
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="minValue">The min value.</param>
      <param name="maxValue">The max value.</param>
      <returns>new validator instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.Between``1(System.IComparable{``0},System.IComparable{``0})">
      <summary>
            Composes the range validator that ensures that the supplied value belongs
            to the interval between <paramref name="lowerBound" /> and <paramref name="upperBound" />
            (exclusive)
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="lowerBound">The lower bound.</param>
      <param name="upperBound">The upper bound.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.GreaterThan``1(System.IComparable{``0})">
      <summary>
            Creates the rule to ensure that the validated value is greater than
            the specified <paramref name="comparable" /></summary>
      <typeparam name="T">type of the item to run rule against</typeparam>
      <param name="comparable">The comparable.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.AtLeast``1(System.IComparable{``0})">
      <summary>
            Creates the rule to ensure that the validated value is greater than
            or equal to the specified <paramref name="comparable" /></summary>
      <typeparam name="T">type of the item to run rule against</typeparam>
      <param name="comparable">The comparable.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.AtMost``1(System.IComparable{``0})">
      <summary>
            Creates the rule to ensure that the validated value is less than
            or equal to the specified <paramref name="comparable" /></summary>
      <typeparam name="T">type of the item to run rule against</typeparam>
      <param name="comparable">The comparable.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.LessThan``1(System.IComparable{``0})">
      <summary>
            Creates the rule to ensure that the validated value is less than
            the specified <paramref name="comparable" /></summary>
      <typeparam name="T">type of the item to run rule against</typeparam>
      <param name="comparable">The comparable.</param>
      <returns>new rule instance</returns>
    </member>
    <member name="M:Lokad.Rules.Is.True``1(System.Linq.Expressions.Expression{System.Predicate{``0}})">
      <summary>
        <para>Compiles the rule out of the specified expression.</para>
      </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="expression">The expression.</param>
      <returns>compiled rule instance</returns>
    </member>
    <member name="T:Lokad.Rules.MaybeIs">
      <summary>
            Common rules for handling Maybe{T} values.
            </summary>
    </member>
    <member name="M:Lokad.Rules.MaybeIs.EmptyOr``1(Lokad.Rules.Rule{``0}[])">
      <summary>
            Generates rule that is valid if the provided optional
            is either empty or passes the supplied value rules
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="valueRules">The value rules.</param>
      <returns>new validation rule</returns>
    </member>
    <member name="M:Lokad.Rules.MaybeIs.ValidAnd``1(Lokad.Rules.Rule{``0}[])">
      <summary>
            Generates the rule that ensures the provided optional to be
            valid and passing the provided rules
            </summary>
      <typeparam name="TValue">The type of the value.</typeparam>
      <param name="valueRules">The value rules.</param>
      <returns>new validation rules</returns>
    </member>
    <member name="T:Lokad.Rules.StringIs">
      <summary>
            Common string rules
            </summary>
    </member>
    <member name="F:Lokad.Rules.StringIs.EmailRegex">
      <summary>
            Originally http://fightingforalostcause.net/misc/2006/compare-email-regex.php,
            but modified to have less negative results 
            </summary>
    </member>
    <member name="F:Lokad.Rules.StringIs.NotEmpty">
      <summary>
            Reports error if the associated string is empty
            </summary>
    </member>
    <member name="F:Lokad.Rules.StringIs.ValidForXmlSerialization">
      <summary>
            String validator that detects possible issues 
            for passing strings through the ASP.NET Web services
            </summary>
    </member>
    <member name="F:Lokad.Rules.StringIs.WithoutLeadingWhiteSpace">
      <summary> String validator checking for presence of 
            white-space characters in the beginning of string </summary>
    </member>
    <member name="F:Lokad.Rules.StringIs.WithoutTrailingWhiteSpace">
      <summary> String validator checking for presence of 
            white-space characters in the end of string </summary>
    </member>
    <member name="F:Lokad.Rules.StringIs.WithoutUppercase">
      <summary> String validator checking for presence of uppercase 
            characters </summary>
    </member>
    <member name="M:Lokad.Rules.StringIs.ValidEmail(System.String,Lokad.Rules.IScope)">
      <summary>
            Determines whether the string is valid email address
            </summary>
      <param name="email">string to validate</param>
      <param name="scope">validation scope.</param>
    </member>
    <member name="M:Lokad.Rules.StringIs.ValidServerConnection(System.String,Lokad.Rules.IScope)">
      <summary>
            Determines whether the string is valid server connection (with optional port)
            </summary>
      <param name="host">The host name to validate.</param>
      <param name="scope">The validation scope.</param>
    </member>
    <member name="M:Lokad.Rules.StringIs.Limited(System.Int32,System.Int32)">
      <summary>
            Composes the string validator ensuring string length is within the supplied rangs
            </summary>
      <param name="minLength">Min string length.</param>
      <param name="maxLength">Max string length.</param>
      <returns>new validator instance</returns>
    </member>
    <member name="M:Lokad.Rules.StringIs.Limited(System.Int32)">
      <summary>
            Composes the string validator ensuring string length is shorter than
            <paramref name="maxLength" /></summary>
      <param name="maxLength">Max string length.</param>
      <returns>new validator instance</returns>
    </member>
    <member name="M:Lokad.Rules.StringIs.Without(System.Char[])">
      <summary>
            String validator that ensures absence of any illegal characters
            </summary>
      <param name="illegalCharacters">The illegal characters.</param>
      <returns>new validator instance</returns>
    </member>
    <member name="T:Lokad.Rules.ExtendIScope">
      <summary> /// <para>Extensions that encapsulate some repetitive tasks
             of setting scopes, and calling validation rules.</para><para>Basically that's the class that links together scope 
             and validation logics.</para></summary>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.Error(Lokad.Rules.IScope,System.String,System.Object[])">
      <summary> Outputs formatted <see cref="F:Lokad.Rules.RuleLevel.Error" /> 
            message into the  <paramref name="scope" /> using the 
            <see cref="P:System.Globalization.CultureInfo.InvariantCulture" /></summary>
      <param name="scope">The scope.</param>
      <param name="message">The message (see <see cref="M:System.String.Format(System.String,System.Object)" />).</param>
      <param name="args">The arguments.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.Error(Lokad.Rules.IScope,System.String)">
      <summary> Outputs <see cref="F:Lokad.Rules.RuleLevel.Error" /> 
            message into the  <paramref name="scope" /></summary>
      <param name="scope">The scope.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.Warn(Lokad.Rules.IScope,System.String,System.Object[])">
      <summary> Outputs formatted <see cref="F:Lokad.Rules.RuleLevel.Warn" /> 
            message into the  <paramref name="scope" /> using the 
            <see cref="P:System.Globalization.CultureInfo.InvariantCulture" /></summary>
      <param name="scope">The scope.</param>
      <param name="message">The message (see <see cref="M:System.String.Format(System.String,System.Object)" />).</param>
      <param name="args">The arguments.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.Warn(Lokad.Rules.IScope,System.String)">
      <summary> Outputs <see cref="F:Lokad.Rules.RuleLevel.Warn" /> 
            message into the  <paramref name="scope" /></summary>
      <param name="scope">The scope.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.Info(Lokad.Rules.IScope,System.String,System.Object[])">
      <summary> Outputs formatted <see cref="F:Lokad.Rules.RuleLevel.None" /> 
            message into the  <paramref name="scope" /> using the 
            <see cref="P:System.Globalization.CultureInfo.InvariantCulture" /></summary>
      <param name="scope">The scope.</param>
      <param name="message">The message (see <see cref="M:System.String.Format(System.String,System.Object)" />).</param>
      <param name="args">The arguments.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.Info(Lokad.Rules.IScope,System.String)">
      <summary> Outputs <see cref="F:Lokad.Rules.RuleLevel.None" /> 
            message into the  <paramref name="scope" /></summary>
      <param name="scope">The scope.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.IsError(Lokad.Rules.IScope)">
      <summary> Determines whether the specified <paramref name="scope" />
            is in the <see cref="F:Lokad.Rules.RuleLevel.Error" /> state. </summary>
      <param name="scope">The scope.</param>
      <returns>
        <c>true</c> if the specified scope is in <see cref="F:Lokad.Rules.RuleLevel.Error" /> 
            state; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.IsNone(Lokad.Rules.IScope)">
      <summary> Determines whether the specified <paramref name="scope" />
            is in the <see cref="F:Lokad.Rules.RuleLevel.None" /> state. </summary>
      <param name="scope">The scope.</param>
      <returns>
        <c>true</c> if the specified scope is in <see cref="F:Lokad.Rules.RuleLevel.None" /> 
            state; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.IsWarn(Lokad.Rules.IScope)">
      <summary> Determines whether the specified <paramref name="scope" />
            is in the <see cref="F:Lokad.Rules.RuleLevel.Warn" /> state. </summary>
      <param name="scope">The scope.</param>
      <returns>
        <c>true</c> if the specified scope is in <see cref="F:Lokad.Rules.RuleLevel.Warn" /> 
            state; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.Validate``1(Lokad.INamedProvider{Lokad.Rules.IScope},``0,System.String,Lokad.Rules.Rule{``0}[])">
      <summary>
            Validates some member using the <paramref name="scopeProvider" />.
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="scopeProvider">The scope provider.</param>
      <param name="item">The item to validate.</param>
      <param name="name">The name of the variable that holds item to validate.</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.Validate``1(Lokad.Rules.IScope,``0,System.String,Lokad.Rules.Rule{``0}[])">
      <summary> Validates some member using the provided <paramref name="parentScope" />.
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="parentScope">The parent scope.</param>
      <param name="item">The item to validate.</param>
      <param name="name">The name of the variable that holds item to validate.</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.Validate``1(Lokad.Rules.IScope,System.Func{``0},Lokad.Rules.Rule{``0}[])">
      <summary>
            Validates some member using the provided <paramref name="parentScope" />.
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="parentScope">The parent scope.</param>
      <param name="property">The property reference.</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.ValidateMany``1(Lokad.Rules.IScope,System.Func{System.Collections.Generic.IEnumerable{``0}},Lokad.Rules.Rule{``0}[])">
      <summary>
            Validates some <see cref="T:System.Collections.Generic.IEnumerable`1" /> member using the provided <paramref name="parentScope" />.
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="parentScope">The parent scope.</param>
      <param name="propertyReference">Reference to collection property to validate.</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.ValidateMany``1(Lokad.Rules.IScope,System.Collections.Generic.IEnumerable{``0},System.String,Lokad.Rules.Rule{``0}[])">
      <summary>
            Validates some <see cref="T:System.Collections.Generic.IEnumerable`1" /> member using the provided <paramref name="parentScope" />.
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="parentScope">The parent scope.</param>
      <param name="items">The collection to validate.</param>
      <param name="name">The name of the variable that holds item to validate.</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.ValidateMany``1(Lokad.Rules.IScope,System.Collections.Generic.ICollection{``0},System.String,System.Int32,Lokad.Rules.Rule{``0}[])">
      <summary>
            Validates some <see cref="T:System.Collections.Generic.IEnumerable`1" /> member using the provided <paramref name="parentScope" />.
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="parentScope">The parent scope.</param>
      <param name="items">The collection to validate.</param>
      <param name="name">The name of the variable that holds item to validate.</param>
      <param name="limit">The limit (if collection is bigger, then validation will not continue).</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.ValidateInScope``1(Lokad.Rules.IScope,``0,Lokad.Rules.Rule{``0}[])">
      <summary>
            Runs the specified rules against the provided object in the current scope
            </summary>
      <typeparam name="T">type of the object being validated</typeparam>
      <param name="scope">The scope.</param>
      <param name="item">The item to validate.</param>
      <param name="rules">The rules to execute.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.ValidateInScope``1(Lokad.Rules.IScope,System.Collections.Generic.IEnumerable{``0},Lokad.Rules.Rule{``0}[])">
      <summary>
            Runs validation rules against some some <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
      <typeparam name="T">type of the items being validated</typeparam>
      <param name="parentScope">The parent scope.</param>
      <param name="items">Collection of the items to validate</param>
      <param name="rules">The rules to run.</param>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.Lower(Lokad.Rules.IScope)">
      <summary>
            Creates a wrapper that lowers the importance of messages
            being passed to the specified <paramref name="scope" />.
            </summary>
      <param name="scope">The scope to wrap.</param>
      <returns>new instance of the wrapper</returns>
    </member>
    <member name="M:Lokad.Rules.ExtendIScope.Raise(Lokad.Rules.IScope)">
      <summary>
            Creates a wrapper that boosts the <see cref="T:Lokad.Rules.RuleLevel" /> of
            messages being passed to the specified<paramref name="scope" />.
            </summary>
      <param name="scope">The scope to wrap.</param>
      <returns>new instance of the wrapper</returns>
    </member>
    <member name="T:Lokad.Rules.IScope">
      <summary>
            Concept from the xLim2. That's simple nesting logger that is used by
            the validation rules. 
            </summary>
      <remarks>
        <para>It has logical the extensibility (not implemented, because there
            does not seem to be any need) for maintaining the error level in
            attached and detached scopes. Warnings, Fatals or Info messages
            could be added here (full ILogScope if needed).</para>
        <para>  Same extensibility
            could be turned on for capturing detailed validation info on complex
            long-running validation scenarios (you'd hate to debug these). </para>
        <para> Note, that in order to maintain .NET 2.0 compatibility,
            is is recommended to use interface-declared methods instead of the
            extensions (or use some extension weaver).</para>
      </remarks>
    </member>
    <member name="M:Lokad.Rules.IScope.Create(System.String)">
      <summary>
            Creates the nested scope with the specified name.
            </summary>
      <param name="name">New name for the nested scope.</param>
      <returns>Nested (and linked) scope instance</returns>
    </member>
    <member name="M:Lokad.Rules.IScope.Write(Lokad.Rules.RuleLevel,System.String)">
      <summary>
            Writes <paramref name="message" /> with the specified
            <paramref name="level" /> to the <see cref="T:Lokad.Rules.IScope" /></summary>
      <param name="level">The level.</param>
      <param name="message">The message.</param>
    </member>
    <member name="P:Lokad.Rules.IScope.Level">
      <summary>
            Gets the current <see cref="T:Lokad.Rules.RuleLevel" /> of this scope
            </summary>
      <value>The level.</value>
    </member>
    <member name="T:Lokad.Rules.Rule`1">
      <summary>
             Typed delegate for holding the validation logics
            </summary>
      <param name="obj">Object to validate</param>
      <param name="scope">Scope that will hold all validation results</param>
      <typeparam name="T">type of the item to validate</typeparam>
    </member>
    <member name="T:Lokad.Rules.RuleException">
      <summary>
            Exception that is thrown when some validation error is encountered
            </summary>
      <remarks>
            TODO: add proper implementation
            </remarks>
    </member>
    <member name="M:Lokad.Rules.RuleException.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="reference">The reference.</param>
    </member>
    <member name="M:Lokad.Rules.RuleException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Lokad.Rules.RuleException.#ctor(System.Collections.Generic.IEnumerable{Lokad.Rules.RuleMessage})">
      <summary> Initializes a new instance of the <see cref="T:Lokad.Rules.RuleException" /> class. </summary>
      <param name="messages">The messages.</param>
    </member>
    <member name="M:Lokad.Rules.RuleException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="info" /> parameter is null.
            </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
    </member>
    <member name="T:Lokad.Rules.RuleLevel">
      <summary>
            Levels leveraged by the <see cref="T:Lokad.Rules.Rule`1" /> implementations
            </summary>
    </member>
    <member name="F:Lokad.Rules.RuleLevel.None">
      <summary> Default value for the purposes of good citizenship </summary>
    </member>
    <member name="F:Lokad.Rules.RuleLevel.Warn">
      <summary> The rule raises a warning </summary>
    </member>
    <member name="F:Lokad.Rules.RuleLevel.Error">
      <summary> The rule raises an error </summary>
    </member>
    <member name="T:Lokad.Rules.RuleMessage">
      <summary> Rule message </summary>
    </member>
    <member name="M:Lokad.Rules.RuleMessage.#ctor(System.String,Lokad.Rules.RuleLevel,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.RuleMessage" /> class.
            </summary>
      <param name="path">The path.</param>
      <param name="level">The level.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Lokad.Rules.RuleMessage.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:Lokad.Rules.RuleMessage.Path">
      <summary>
            Gets the object path for the current message.
            </summary>
      <value>The path object path.</value>
    </member>
    <member name="P:Lokad.Rules.RuleMessage.Level">
      <summary>
            Gets the <see cref="T:Lokad.Rules.RuleLevel" /> associated with this message.
            </summary>
      <value>The level.</value>
    </member>
    <member name="P:Lokad.Rules.RuleMessage.Message">
      <summary>
            Gets the message.
            </summary>
      <value>The message.</value>
    </member>
    <member name="T:Lokad.Rules.RuleMessages">
      <summary>
            Collection of messages with the associated highest level
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleMessages.Level">
      <summary>
            The highest level within the collection
            </summary>
      <value>The level.</value>
    </member>
    <member name="P:Lokad.Rules.RuleMessages.IsError">
      <summary>
            Gets a value indicating whether this instance has a message 
            of  <see cref="F:Lokad.Rules.RuleLevel.Error" /> or higher.
            </summary>
      <value>
        <c>true</c> if this instance has message of 
            <see cref="F:Lokad.Rules.RuleLevel.Error" /> or higher ; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Lokad.Rules.RuleMessages.IsWarn">
      <summary>
            Gets a value indicating whether this instance has a message 
            of <see cref="F:Lokad.Rules.RuleLevel.Warn" /> or higher.
            </summary>
      <value>
        <c>true</c> if this instance has message of 
            <see cref="F:Lokad.Rules.RuleLevel.Warn" /> or higher ; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Lokad.Rules.RuleMessages.IsSuccess">
      <summary>
            Gets a value indicating whether this instance does not have any messages
            of <see cref="F:Lokad.Rules.RuleLevel.Warn" /> or higher
            </summary>
      <value>
        <c>true</c> if this instance does not have any messages
            of <see cref="F:Lokad.Rules.RuleLevel.Warn" /> or higher; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Lokad.Rules.RuleResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Buffer_cant_be_longer_than_X">
      <summary>
              Looks up a localized string similar to Byte array should not be longer than {0} bytes..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Buffer_must_have_valid_hash">
      <summary>
              Looks up a localized string similar to Byte array should have valid hash..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Collection_X_cant_be_null">
      <summary>
              Looks up a localized string similar to Collection of type '{0}' should not be null..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Date_must_be_greater_than_X">
      <summary>
              Looks up a localized string similar to Date must be greater than '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Double_must_represent_valid_value">
      <summary>
              Looks up a localized string similar to Double should represent a valid value..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Expression_X_must_be_true">
      <summary>
              Looks up a localized string similar to Expression should be true: {0}..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Maybe_X_cant_be_empty">
      <summary>
              Looks up a localized string similar to Optional '{0}' should not be empty..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Object_must_be_same_as_reference">
      <summary>
              Looks up a localized string similar to Object should be same as the provided reference..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Object_X_cant_be_null">
      <summary>
              Looks up a localized string similar to Object of type '{0}' should not be null..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.RuleException_header">
      <summary>
              Looks up a localized string similar to Rule messages:.
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_be_empty">
      <summary>
              Looks up a localized string similar to String should not be empty..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_be_longer_than_X">
      <summary>
              Looks up a localized string similar to String should not be longer than {0} characters..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_be_shorter_than_X">
      <summary>
              Looks up a localized string similar to String should not be shorter than {0} characters..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_contain_unicode_control_characters">
      <summary>
              Looks up a localized string similar to String should not contain unicode control characters..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_contain_uppercase">
      <summary>
              Looks up a localized string similar to String should not have uppercase characters..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_contain_X_characters">
      <summary>
              Looks up a localized string similar to String should not contain following characters: {0}..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_end_with_whitespace">
      <summary>
              Looks up a localized string similar to String should not end with trailing white-space character..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_cant_start_with_whitespace">
      <summary>
              Looks up a localized string similar to String should not start with white-space character..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_must_be_valid_email">
      <summary>
              Looks up a localized string similar to String should be a valid email address..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.String_must_be_valid_host">
      <summary>
              Looks up a localized string similar to String should be a valid host name..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Value_cant_be_equal_to_X">
      <summary>
              Looks up a localized string similar to Value should not be equal to '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Value_cant_be_greater_than_X">
      <summary>
              Looks up a localized string similar to Value should not be greater than '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Value_cant_be_less_than_X">
      <summary>
              Looks up a localized string similar to Value should not be less than '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Value_must_be_equal_to_X">
      <summary>
              Looks up a localized string similar to Value should be equal to '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Value_must_be_greater_than_X">
      <summary>
              Looks up a localized string similar to Value should be greater than '{0}'..
            </summary>
    </member>
    <member name="P:Lokad.Rules.RuleResources.Value_must_be_less_than_X">
      <summary>
              Looks up a localized string similar to Value should be less than '{0}'..
            </summary>
    </member>
    <member name="T:Lokad.Rules.Scope">
      <summary>
            Helper class that invokes different scopes
            </summary>
    </member>
    <member name="F:Lokad.Rules.Scope.RulePathSeprator">
      <summary>
            Rule path separator char
            </summary>
    </member>
    <member name="M:Lokad.Rules.Scope.WhenError(Lokad.Rules.RuleLevel)">
      <summary>
            Returns true if <paramref name="level" />
            is <see cref="F:Lokad.Rules.RuleLevel.Error" /> or higher
            </summary>
      <param name="level">The level to check.</param>
      <returns>true if the condition is met</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.WhenAny(Lokad.Rules.RuleLevel)">
      <summary>
            Returns true if <paramref name="level" />
            is not <see cref="F:Lokad.Rules.RuleLevel.None" /></summary>
      <param name="level">The level.</param>
      <returns>true if the condition is met</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.WhenWarn(Lokad.Rules.RuleLevel)">
      <summary>
            Returns true if <paramref name="ruleLevel" />
            is <see cref="F:Lokad.Rules.RuleLevel.Warn" /> or higher
            </summary>
      <param name="ruleLevel">The rule level.</param>
      <returns>true if the condition is met</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.WhenNone(Lokad.Rules.RuleLevel)">
      <summary>
            Returns true if <paramref name="ruleLevel" />
            is <see cref="F:Lokad.Rules.RuleLevel.None" /> or higher
            </summary>
      <param name="ruleLevel">The rule level.</param>
      <returns>true if the condition is met</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.ForValidation(System.String,System.Predicate{Lokad.Rules.RuleLevel})">
      <summary>
            Creates scope that runs full check and then fails with 
            <see cref="T:Lokad.Rules.RuleException" />, if the resulting 
            <see cref="T:Lokad.Rules.RuleLevel" />  matches the <paramref name="predicate" /></summary>
      <param name="name">The name for the scope.</param>
      <param name="predicate">The predicate.</param>
      <returns>new scope instance</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.ForEnforce(System.String,System.Predicate{Lokad.Rules.RuleLevel})">
      <summary>
            Creates scope that throws <see cref="T:Lokad.Rules.RuleException" /> as soon as
            first message matching <paramref name="predicate" /> is received.
            </summary>
      <param name="scopeName">Name of the scope.</param>
      <param name="predicate">The predicate.</param>
      <returns>new scope instance</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.ForEnforceArgument(System.String,System.Predicate{Lokad.Rules.RuleLevel})">
      <summary>
            Creates scope that throws <see cref="T:System.ArgumentException" /> as soon as
            first message matching <paramref name="predicate" /> is received.
            </summary>
      <param name="scopeName">Name of the scope.</param>
      <param name="predicate">The predicate.</param>
      <returns>new scope instance</returns>
    </member>
    <member name="M:Lokad.Rules.Scope.IsError``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary>  Determines whether the specified item has problems of 
            <see cref="F:Lokad.Rules.RuleLevel.Error" /> or higher.  </summary>
      <typeparam name="TItem">type of the item to run rules against</typeparam>
      <param name="item">The item to run rules against.</param>
      <param name="rules">The rules to execute.</param>
      <returns>
        <c>true</c> if the specified item is in error state; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.Rules.Scope.IsValid``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary>  Determines whether the specified item does not have any problems </summary>
      <typeparam name="TItem">type of the item to run rules against</typeparam>
      <param name="item">The item to run rules against.</param>
      <param name="rules">The rules to execute.</param>
      <returns>
        <c>true</c> if the specified item is in error state; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.Rules.Scope.IsWarn``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary>  Determines whether the specified item has problems of 
            <see cref="F:Lokad.Rules.RuleLevel.Warn" /> or higher.  </summary>
      <typeparam name="TItem">type of the item to run rules against</typeparam>
      <param name="item">The item to run rules against.</param>
      <param name="rules">The rules to execute.</param>
      <returns>
        <c>true</c> if the specified item is in warning state; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Lokad.Rules.Scope.GetMessages``1(``0,System.String,Lokad.Rules.Rule{``0}[])">
      <summary> Collects all rule messages associated with the 
            specified <paramref name="item" /></summary>
      <typeparam name="TItem">The type of the item to run the rules against.</typeparam>
      <param name="item">The item to run the rules against.</param>
      <param name="name">The name of the scope.</param>
      <param name="rules">The rules to execute.</param>
      <returns>read-only collection of <see cref="T:Lokad.Rules.RuleMessage" /></returns>
    </member>
    <member name="M:Lokad.Rules.Scope.GetMessages(System.String,System.Action{Lokad.Rules.IScope})">
      <summary>
            Gets the messages created by action being executed against the scope.
            </summary>
      <param name="name">The name for the scope.</param>
      <param name="scopeAction">The scope action.</param>
      <returns>read-only collection of <see cref="T:Lokad.Rules.RuleMessage" /></returns>
    </member>
    <member name="M:Lokad.Rules.Scope.GetMessages``1(System.Func{``0},Lokad.Rules.Rule{``0}[])">
      <summary>
            Collects all rule messages associated with the
            specified <paramref name="itemReference" /></summary>
      <typeparam name="TItem">The type of the item to run the rules against.</typeparam>
      <param name="itemReference">The item reference.</param>
      <param name="rules">The rules to execute.</param>
      <returns>
            read-only collection of <see cref="T:Lokad.Rules.RuleMessage" /></returns>
    </member>
    <member name="M:Lokad.Rules.Scope.GetMessagesForMany``1(System.Func{System.Collections.Generic.IEnumerable{``0}},Lokad.Rules.Rule{``0}[])">
      <summary>
            Collects all rule messages associated with the
            specified <paramref name="sequenceReference" /></summary>
      <typeparam name="TItem">The type of the item to run the rules against.</typeparam>
      <param name="sequenceReference">The sequence reference.</param>
      <param name="rules">The rules to execute.</param>
      <returns> read-only collection of <see cref="T:Lokad.Rules.RuleMessage" /></returns>
    </member>
    <member name="M:Lokad.Rules.Scope.GetMessagesForMany``1(System.Collections.Generic.IEnumerable{``0},System.String,Lokad.Rules.Rule{``0}[])">
      <summary> Collects all rule messages associated with the 
            specified <paramref name="items" /></summary>
      <typeparam name="TItem">The type of the item to run the rules against.</typeparam>
      <param name="items">The item to run the rules against.</param>
      <param name="name">The name of the scope.</param>
      <param name="rules">The rules to execute.</param>
      <returns>read-only collection of <see cref="T:Lokad.Rules.RuleMessage" /></returns>
    </member>
    <member name="M:Lokad.Rules.Scope.Validate``1(``0,Lokad.Rules.Rule{``0}[])">
      <summary>
            Runs full validation scan of the specified item and throws error
            if the level is not <see cref="F:Lokad.Rules.RuleLevel.None" /></summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="item">The item to validate.</param>
      <param name="rules">The rules.</param>
      <exception cref="T:Lokad.Rules.RuleException">if any rules have failed</exception>
    </member>
    <member name="M:Lokad.Rules.Scope.ValidateMany``1(System.Collections.Generic.IEnumerable{``0},Lokad.Rules.Rule{``0}[])">
      <summary>
            Runs full validation scan of the specified collection
            </summary>
      <typeparam name="T">type of the item to validate</typeparam>
      <param name="items">The collection to validate.</param>
      <param name="rules">The validators.</param>
      <exception cref="T:Lokad.Rules.RuleException">if any rules have failed</exception>
    </member>
    <member name="M:Lokad.Rules.Scope.ComposePath(System.String,System.String)">
      <summary>
            Composes the path for the <see cref="T:Lokad.Rules.Rule`1" />.
            </summary>
      <param name="prefix">The prefix.</param>
      <param name="suffix">The suffix.</param>
      <returns>composed path</returns>
      <exception cref="T:System.ArgumentException">if path parameters are null or empty</exception>
    </member>
    <member name="M:Lokad.Rules.Scope.ForLogging(System.String,System.Text.StringBuilder)">
      <summary>
            Creates new scope for logging into the provided string builder
            </summary>
      <param name="scopeName">Name of the scope.</param>
      <param name="log">The builder to write to.</param>
      <returns>composed scope</returns>
    </member>
    <member name="T:Lokad.Rules.DelayedScope">
      <summary>
            This scope is just like <see cref="T:Lokad.Rules.SimpleScope" />
            but it delays name resolution
            </summary>
    </member>
    <member name="T:Lokad.Rules.ModifierScope">
      <summary>
            Simple <see cref="T:Lokad.Rules.IScope" /> implementation that allows to 
            modify the behavior of the underlying scopes
            </summary>
    </member>
    <member name="T:Lokad.Rules.SimpleScope">
      <summary>
        <see cref="T:Lokad.Rules.IScope" /> that maintains scope path, executes 
            <see cref="T:Lokad.Rules.SimpleScope.Messenger" /> delegate per every message.
            </summary>
    </member>
    <member name="T:Lokad.Rules.SimpleScope.Messenger">
      <summary>
            Delegate for relaying scope messages
            </summary>
    </member>
    <member name="M:Lokad.Rules.SimpleScope.#ctor(System.String,Lokad.Rules.SimpleScope.Messenger)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.SimpleScope" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="messenger">The messenger.</param>
    </member>
    <member name="M:Lokad.Rules.SimpleScope.GetMessages(System.String,System.Action{Lokad.Rules.IScope})">
      <summary>
            Gets the messages reported by the specified action to the scope.
            </summary>
      <param name="name">The name.</param>
      <param name="action">The action.</param>
      <returns>array of rule messages reported</returns>
    </member>
    <member name="T:Lokad.Rules.TrackScope">
      <summary>
        <see cref="T:Lokad.Rules.IScope" /> that merely keeps track of the worst level. 
            </summary>
    </member>
    <member name="M:Lokad.Rules.TrackScope.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Rules.TrackScope" /> class.
            </summary>
    </member>
    <member name="T:Lokad.Settings.ISettingsKeyFilter">
      <summary>
            	Implements filtering interface for the
            	<see cref="T:Lokad.Settings.ISettingsProvider" /></summary>
    </member>
    <member name="M:Lokad.Settings.ISettingsKeyFilter.Filter(System.String)">
      <summary>
            	Filters the path, either accepting it (and optionally altering)
            	or by returning empty result
            </summary>
      <param name="keyPath">The key path.</param>
      <returns>filtered key path</returns>
    </member>
    <member name="T:Lokad.Settings.ISettingsProvider">
      <summary>
            	Simple settings reader
            </summary>
    </member>
    <member name="M:Lokad.Settings.ISettingsProvider.GetValue(System.String)">
      <summary>
            	Gets the value, using the given key name.
            </summary>
      <param name="name">The name.</param>
      <returns>
            	value for the specified key name, or empty result
            </returns>
    </member>
    <member name="M:Lokad.Settings.ISettingsProvider.Filtered(Lokad.Settings.ISettingsKeyFilter)">
      <summary>
            	Creates new provider that contains only values filtered by the acceptor
            </summary>
      <param name="acceptor">The acceptor.</param>
      <returns>
            	new settings provider that had been filtered
            </returns>
    </member>
    <member name="T:Lokad.Cqrs.Storage.IEntityReader">
      <summary>
            Handles read-side operations for the entity storage
            </summary>
    </member>
    <member name="M:Lokad.Cqrs.Storage.IEntityReader.Read(System.Type,System.Object)">
      <summary>
            Retrieves the specified entity from the store, if it is found.
            Underlying storage could be event, cloud blob or whatever
            </summary>
      <param name="type">The type of the state (needed to deserialize).</param>
      <param name="identity">The identity.</param>
      <returns>loaded entity (if found)</returns>
    </member>
    <member name="T:Lokad.Cqrs.AddEntityDelegate">
      <summary>
            The function used to generate a value for an absent key
            </summary>
    </member>
    <member name="T:Lokad.Cqrs.UpdateEntityDelegate">
      <summary>
            The function used to generate a new value for an existing key based on the key's existing value
            </summary>
    </member>
    <member name="T:Lokad.Cqrs.IEntityWriter">
      <summary>
            Handles write operations for the state storage
            </summary>
    </member>
    <member name="M:Lokad.Cqrs.IEntityWriter.Write(System.Type,System.Object,Lokad.Cqrs.AddEntityDelegate,Lokad.Cqrs.UpdateEntityDelegate)">
      <summary>
            Updates an entity if the key already exists or creates a new entity otherwise.
            </summary>
      <param name="type">The type of the entity to patch.</param>
      <param name="key">The identity of the entity to patch.</param>
      <param name="addEntityDelegate">The function used to generate an entity for an absent key.</param>
      <param name="updateEntityDelegate">The function used to generate a new entity for an existing key based on the existing entity.</param>
      <exception cref="T:Lokad.Cqrs.OptimisticConcurrencyException">when updated entity had been changed concurrently</exception>
    </member>
    <member name="M:Lokad.Cqrs.IEntityWriter.Remove(System.Type,System.Object)">
      <summary>
            Deletes the specified entity, given it's type and key
            </summary>
      <param name="type">The type.</param>
      <param name="key">The identity.</param>
    </member>
    <member name="T:Lokad.Cqrs.OptimisticConcurrencyException">
      <summary>
            Exception thrown, when patched entity has been edited in the process
            </summary>
    </member>
    <member name="M:Lokad.Cqrs.OptimisticConcurrencyException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Cqrs.OptimisticConcurrencyException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Lokad.Cqrs.OptimisticConcurrencyException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Cqrs.OptimisticConcurrencyException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="inner">The inner.</param>
    </member>
    <member name="M:Lokad.Cqrs.OptimisticConcurrencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Cqrs.OptimisticConcurrencyException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="info" /> parameter is null.
            </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
    </member>
    <member name="T:Lokad.ISyntax`1">
      <summary>
            Interface for implementing decoupled configuration extensions. It hides
            unnecessary members from the IntelliSense.
            </summary>
      <typeparam name="TTarget">syntax target</typeparam>
    </member>
    <member name="M:Lokad.ISyntax`1.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Lokad.ISyntax`1.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Lokad.ISyntax`1.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Lokad.ISyntax`1.GetType">
      <summary>
            Gets the <see cref="T:System.Type" /> of the current instance.
            </summary>
      <returns>
            The <see cref="T:System.Type" /> instance that represents the exact runtime type of the current instance.
            </returns>
    </member>
    <member name="P:Lokad.ISyntax`1.Target">
      <summary>
            Gets the underlying object.
            </summary>
      <value>The underlying object.</value>
    </member>
    <member name="T:Lokad.Syntax">
      <summary>
            Helper class for creating fluent APIs, that hides unused signatures
            </summary>
    </member>
    <member name="M:Lokad.Syntax.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Lokad.Syntax.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Lokad.Syntax.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Lokad.Syntax.GetType">
      <summary>
            Gets the <see cref="T:System.Type" /> of the current instance.
            </summary>
      <returns>
            The <see cref="T:System.Type" /> instance that represents the exact runtime type of the current instance.
            </returns>
    </member>
    <member name="M:Lokad.Syntax.For``1(``0)">
      <summary>
            Creates the syntax for the specified target
            </summary>
      <typeparam name="TTarget">The type of the target.</typeparam>
      <param name="inner">The inner.</param>
      <returns>new syntax instance</returns>
    </member>
    <member name="T:Lokad.Syntax`1">
      <summary>
            Helper class for creating fluent APIs
            </summary>
      <typeparam name="TTarget">underlying type</typeparam>
    </member>
    <member name="M:Lokad.Syntax`1.#ctor(`0)">
      <summary>
            Initializes a new instance of the <see cref="T:Lokad.Syntax`1" /> class.
            </summary>
      <param name="inner">The underlying instance.</param>
    </member>
    <member name="P:Lokad.Syntax`1.Target">
      <summary>
            Gets the underlying object.
            </summary>
      <value>The underlying object.</value>
    </member>
    <member name="T:Lokad.SystemUtil">
      <summary>
            System utils to improve testability of the code
            </summary>
    </member>
    <member name="F:Lokad.SystemUtil.SleepAction">
      <summary>
        <see cref="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      </summary>
    </member>
    <member name="F:Lokad.SystemUtil.DateTimeProvider">
      <summary>
            Allows to set custom date time implementation for the testing purposes.
            </summary>
    </member>
    <member name="M:Lokad.SystemUtil.Reset">
      <summary>
            Returns all overridable functions to default. To be used by test teardowns
            </summary>
    </member>
    <member name="M:Lokad.SystemUtil.SetSleep(System.Action{System.TimeSpan})">
      <summary>
            Sets the custom sleep routine.
            </summary>
      <param name="sleepRoutine">The sleep routine.</param>
    </member>
    <member name="M:Lokad.SystemUtil.SetDateTimeProvider(System.Func{System.DateTime})">
      <summary>
            Sets the custom date time provider routine.
            </summary>
      <param name="dateTimeProvider">The date time provider.</param>
    </member>
    <member name="M:Lokad.SystemUtil.SetTime(System.DateTime)">
      <summary>
            Shortcut to set the custom date time.
            </summary>
      <param name="time">The time.</param>
    </member>
    <member name="M:Lokad.SystemUtil.Sleep(System.TimeSpan)">
      <summary>
            Invokes the method associated with sleeping. For the production purposes
            this should be a call to <see cref="M:System.Threading.Thread.Sleep(System.TimeSpan)" /></summary>
      <param name="span">The span.</param>
    </member>
    <member name="P:Lokad.SystemUtil.Now">
      <summary>
        <see cref="P:System.DateTime.Now" />
      </summary>
    </member>
    <member name="P:Lokad.SystemUtil.UtcNow">
      <summary>
        <see cref="P:System.DateTime.UtcNow" />
      </summary>
    </member>
    <member name="P:Lokad.SystemUtil.NowOffset">
      <summary>
            Unambiguous date and time with UTC offset, <see cref="P:System.DateTimeOffset.Now" />.
            </summary>
    </member>
    <member name="T:Lokad.ArrayUtil">
      <summary>
            Utility class to manipulate arrays
            </summary>
    </member>
    <member name="F:Lokad.ArrayUtil.EmptyGuid">
      <summary>
            Empty array of <see cref="T:System.Guid" /></summary>
    </member>
    <member name="F:Lokad.ArrayUtil.EmptyInt32">
      <summary>
            Empty array of <see cref="T:System.Int32" /></summary>
    </member>
    <member name="F:Lokad.ArrayUtil.EmptyString">
      <summary>
            Empty array of <see cref="T:System.String" /></summary>
    </member>
    <member name="M:Lokad.ArrayUtil.IsNullOrEmpty(System.Array)">
      <summary>
            Returns <em>True</em> if the provided array is null or empty
            </summary>
      <param name="array">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Lokad.ArrayUtil.Empty``1">
      <summary>
            Returns empty array instance
            </summary>
      <typeparam name="T">type of the item for the array</typeparam>
      <returns>empty array singleton</returns>
    </member>
    <member name="T:Lokad.BufferUtil">
      <summary>
            Helper utilities for working with byte buffers
            </summary>
    </member>
    <member name="M:Lokad.BufferUtil.CalculateSimpleHashCode(System.Byte[])">
      <summary>
            Calculates simple hash code
            </summary>
      <param name="bytes">The bytes to hash.</param>
      <returns>hash for the buffer</returns>
      <exception cref="T:System.ArgumentNullException">if bytes are null</exception>
    </member>
    <member name="T:Lokad.EnumComparer`1">
      <summary>
            A fast and efficient implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> for Enum types.
            Useful for dictionaries that use Enums as their keys. 
            </summary>
      <remarks>
            http://www.codeproject.com/KB/cs/EnumComparer.aspx
            </remarks>
      <example>
        <code>
            var dict = new Dictionary&lt;DayOfWeek, string&gt;(EnumComparer&lt;DayOfWeek&gt;.Instance);
            </code>
      </example>
      <typeparam name="TEnum">The type of the Enum.</typeparam>
    </member>
    <member name="F:Lokad.EnumComparer`1.Instance">
      <summary>
            The singleton accessor.
            </summary>
    </member>
    <member name="M:Lokad.EnumComparer`1.#ctor">
      <summary>
            A private constructor to prevent user instantiation.
            </summary>
    </member>
    <member name="M:Lokad.EnumComparer`1.Equals(`0,`0)">
      <summary>
            Determines whether the specified objects are equal.
            </summary>
      <param name="x">The first object of type <typeparamref name="TEnum" /> to compare.</param>
      <param name="y">The second object of type <typeparamref name="TEnum" /> to compare.</param>
      <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
    </member>
    <member name="M:Lokad.EnumComparer`1.GetHashCode(`0)">
      <summary>
            Returns a hash code for the specified object.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> for which a hash code is to be returned.</param>
      <returns>A hash code for the specified object.</returns>
      <exception cref="T:System.ArgumentNullException">
            The type of <paramref name="obj" /> is a reference type and <paramref name="obj" /> is null.
            </exception>
    </member>
    <member name="M:Lokad.EnumComparer`1.GenerateEquals">
      <summary>
            Generates a comparison method similiar to this:
            <code>
            bool Equals(TEnum x, TEnum y)
            {
                return x == y;
            }
            </code></summary>
      <returns>The generated method.</returns>
    </member>
    <member name="M:Lokad.EnumComparer`1.GenerateGetHashCode">
      <summary>
            Generates a GetHashCode method similar to this:
            <code>
            int GetHashCode(TEnum obj)
            {
                return ((int)obj).GetHashCode();
            }
            </code></summary>
      <returns>The generated method.</returns>
    </member>
    <member name="T:Lokad.EnumUtil">
      <summary>
            Enum helper class from xLim
            </summary>
    </member>
    <member name="M:Lokad.EnumUtil.Parse``1(System.String)">
      <summary>
            Parses the specified string into the <typeparamref name="TEnum" />, ignoring the case
            </summary>
      <typeparam name="TEnum">The type of the enum.</typeparam>
      <param name="value">The value.</param>
      <returns>Parsed enum</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="value" /> is null</exception>
    </member>
    <member name="M:Lokad.EnumUtil.Parse``1(System.String,System.Boolean)">
      <summary>
            Parses the specified string into the <typeparamref name="TEnum" />, ignoring the case
            </summary>
      <typeparam name="TEnum">The type of the enum.</typeparam>
      <param name="value">The value.</param>
      <param name="ignoreCase">if set to <c>true</c> [ignore case].</param>
      <returns>Parsed enum</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="value" /> is null</exception>
    </member>
    <member name="M:Lokad.EnumUtil.ToIdentifier``1(``0)">
      <summary>
            Unwraps the enum by creating a string usable for identifiers and resource lookups.
            </summary>
      <typeparam name="TEnum">The type of the enum.</typeparam>
      <param name="enumItem">The enum item.</param>
      <returns>a string usable for identifiers and resource lookups</returns>
    </member>
    <member name="M:Lokad.EnumUtil.GetValues``1">
      <summary>
            Gets the values associated with the specified enum.
            </summary>
      <typeparam name="TEnum">The type of the enum.</typeparam>
      <returns>array instance of the enum values</returns>
    </member>
    <member name="M:Lokad.EnumUtil.GetValuesWithoutDefault``1">
      <summary>
            Gets the values associated with the specified enum, 
            with the exception of the default value
            </summary>
      <typeparam name="TEnum">The type of the enum.</typeparam>
      <returns>array instance of the enum values</returns>
    </member>
    <member name="T:Lokad.EnumUtil`1">
      <summary>
            Strongly-typed enumeration util
            </summary>
      <typeparam name="TEnum">The type of the enum.</typeparam>
    </member>
    <member name="F:Lokad.EnumUtil`1.Values">
      <summary>
            Values of the <typeparamref name="TEnum" /></summary>
    </member>
    <member name="F:Lokad.EnumUtil`1.ValuesWithoutDefault">
      <summary>
            Values of the <typeparamref name="TEnum" /> without the default value.
            </summary>
    </member>
    <member name="F:Lokad.EnumUtil`1.Comparer">
      <summary>
            Efficient comparer for the enum
            </summary>
    </member>
    <member name="M:Lokad.EnumUtil`1.ConvertSafelyFrom``1(``0)">
      <summary>
            Converts the specified enum safely from the target enum. Matching is done
            via the efficient <see cref="F:Lokad.EnumUtil`1.Comparer" /> initialized with <see cref="M:Lokad.MaybeParse.Enum``1(System.String)" /></summary>
      <typeparam name="TSourceEnum">The type of the source enum.</typeparam>
      <param name="enum">The @enum to convert from.</param>
      <returns>converted enum</returns>
      <exception cref="T:System.ArgumentException"> when conversion is not possible</exception>
    </member>
    <member name="T:Lokad.EnumUtil`2">
      <summary>
            Ensures that enums can be converted between each other
            </summary>
      <typeparam name="TFromEnum">The type of from enum.</typeparam>
      <typeparam name="TToEnum">The type of to enum.</typeparam>
    </member>
    <member name="T:Lokad.StringUtil">
      <summary>
            Helper methods for <see cref="T:System.String" /></summary>
    </member>
    <member name="M:Lokad.StringUtil.FormatInvariant(System.String,System.Object[])">
      <summary>
            Formats the string using InvariantCulture
            </summary>
      <param name="format">The format.</param>
      <param name="args">The args.</param>
      <returns>formatted string</returns>
    </member>
    <member name="M:Lokad.StringUtil.MemberNameToCaption(System.String)">
      <summary>
            Converts "Class.SomeName" to "Class - Some Name"
            </summary>
    </member>
    <member name="T:ProtoBuf.IExtensible">
      <summary>
            Indicates that the implementing type has support for protocol-buffer
            <see cref="T:ProtoBuf.IExtension">extensions</see>.
            </summary>
      <remarks>Can be implemented by deriving from <see cref="T:ProtoBuf.Extensible" />.</remarks>
    </member>
    <member name="M:ProtoBuf.IExtensible.GetExtensionObject(System.Boolean)">
      <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
      <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
      <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
      <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
    </member>
    <member name="T:ProtoBuf.Extensible">
      <summary>
            Simple base class for supporting unexpected fields allowing
            for loss-less round-tips/merge, even if the data is not understod.
            The additional fields are (by default) stored in-memory in a buffer.
            </summary>
      <remarks>As an example of an alternative implementation, you might
            choose to use the file system (temporary files) as the back-end, tracking
            only the paths [such an object would ideally be IDisposable and use
            a finalizer to ensure that the files are removed].</remarks>
      <seealso cref="T:ProtoBuf.IExtensible" />
    </member>
    <member name="M:ProtoBuf.Extensible.GetExtensionObject(System.Boolean)">
      <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
      <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
      <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
      <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
    </member>
    <member name="M:ProtoBuf.Extensible.GetExtensionObject(ProtoBuf.IExtension@,System.Boolean)">
      <summary>
            Provides a simple, default implementation for <see cref="T:ProtoBuf.IExtension">extension</see> support,
            optionally creating it if it does not already exist. Designed to be called by
            classes implementing <see cref="T:ProtoBuf.IExtensible" />.
            </summary>
      <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
      <param name="extensionObject">The extension field to check (and possibly update).</param>
      <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
      <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
    </member>
    <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,``0)">
      <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
      <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
      <typeparam name="TValue">The type of the value to append.</typeparam>
      <param name="instance">The extensible object to append the value to.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="value">The value to append.</param>
    </member>
    <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0)">
      <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
      <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="format">The data-format to use when encoding the value.</param>
      <param name="instance">The extensible object to append the value to.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="value">The value to append.</param>
    </member>
    <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <returns>The effective value of the field, or the default value if not found.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="format">The data-format to use when decoding the value.</param>
      <returns>The effective value of the field, or the default value if not found.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,``0@)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="value">The effective value of the field, or the default value if not found.</param>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <returns>True if data for the field was present, false otherwise.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0@)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="value">The effective value of the field, or the default value if not found.</param>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="format">The data-format to use when decoding the value.</param>
      <returns>True if data for the field was present, false otherwise.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,``0@)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="value">The effective value of the field, or the default value if not found.</param>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="format">The data-format to use when decoding the value.</param>
      <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
      <returns>True if data for the field was present, false otherwise.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
      <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <returns>An enumerator that yields each occurrence of the field.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
      <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="format">The data-format to use when decoding the value.</param>
      <returns>An enumerator that yields each occurrence of the field.</returns>
    </member>
    <member name="T:ProtoBuf.Serializer">
      <summary>
            Provides protocol-buffer serialization capability for concrete, attributed types. 
            </summary>
      <remarks>
            Protocol-buffer serialization is a compact binary format, designed to take
            advantage of sparse data and knowledge of specific data types; it is also
            extensible, allowing a type to be deserialized / merged even if some data is
            not recognised.
            </remarks>
    </member>
    <member name="T:ProtoBuf.Serializer.GlobalOptions">
      <summary>
            Global switches that change the behavior of protobuf-net
            </summary>
    </member>
    <member name="P:ProtoBuf.Serializer.GlobalOptions.InferTagFromName">
      <summary>
            Global default for that
            enables/disables automatic tag generation based on the existing name / order
            of the defined members. See <seealso cref="P:ProtoBuf.ProtoContractAttribute.InferTagFromName" />
            for usage and <b>important warning</b> / explanation.
            You must set the global default before attempting to serialize/deserialize any
            impacted type.
            </summary>
    </member>
    <member name="T:ProtoBuf.Serializer.NonGeneric">
      <summary>
            Provides non-generic, reflection-based access to Serializer functionality
            </summary>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.SerializeWithLengthPrefix(System.IO.Stream,System.Object,ProtoBuf.PrefixStyle,System.Int32)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="destination">The destination stream to write to.</param>
      <param name="tag">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.CanSerialize(System.Type)">
      <summary>
            Can the given type be meaningfully with protobuf-net?
            </summary>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.Serialize(System.IO.Stream,System.Object)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="destination">The destination stream to write to.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.TryDeserializeWithLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,ProtoBuf.Getter{System.Int32,System.Type},System.Object@)">
      <summary>
            Deserialize object of unknown types from in input stream.
            </summary>
      <param name="source">The input stream.</param>
      <param name="style">The prefix style used to encode the lengths.</param>
      <param name="typeReader">The caller must provide a mechanism to resolve a Type from
            the tags encountered in the stream. If the delegate returns null, then the instance
            is skipped - otherwise, the object is deserialized according to type.</param>
      <param name="item">The deserialized instance, or null if the stream terminated.</param>
      <returns>True if an object was idenfified; false if the stream terminated. Note
            that unexpected types are skipped.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.Deserialize(System.Type,System.IO.Stream)">
      <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
      <param name="type">The type to be created.</param>
      <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
      <returns>A new, initialized instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.DeepClone(System.Object)">
      <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
      <param name="instance">The existing instance to be cloned.</param>
      <returns>A new copy, cloned from the supplied instance.</returns>
    </member>
    <member name="F:ProtoBuf.Serializer.ListItemTag">
      <summary>
            The implicit tag used when serializing lists and other enumerable data.
            </summary>
    </member>
    <member name="M:ProtoBuf.Serializer.TryGetTag(System.Reflection.MemberInfo,System.Int32@,System.String@,ProtoBuf.DataFormat@,ProtoBuf.MemberSerializationOptions@)">
      <summary>
            Supports various different property metadata patterns:
            [ProtoMember] is the most specific, allowing the data-format to be set.
            [DataMember], [XmlElement] are supported for compatibility.
            In any event, there must be a unique positive Tag/Order.
            </summary>
    </member>
    <member name="M:ProtoBuf.Serializer.Deserialize``1(System.IO.Stream)">
      <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
      <typeparam name="T">The type to be created.</typeparam>
      <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
      <returns>A new, initialized instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream)">
      <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
      <typeparam name="T">The type to be created.</typeparam>
      <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
      <returns>A new, initialized instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
      <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag" /> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
      <typeparam name="T">The type of object to deserialize.</typeparam>
      <param name="source">The binary stream containing the serialized records.</param>
      <param name="style">The prefix style used in the data.</param>
      <param name="tag">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
      <returns>The sequence of deserialized objects.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle)">
      <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
      <typeparam name="T">The type to be created.</typeparam>
      <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <returns>A new, initialized instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
      <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
      <typeparam name="T">The type to be created.</typeparam>
      <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="tag">The expected tag of the item (only used with base-128 prefix style).</param>
      <returns>A new, initialized instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32@)">
      <summary>Indicates the number of bytes expected for the next message.</summary>
      <param name="source">The stream containing the data to investigate for a length.</param>
      <param name="style">The algorithm used to encode the length.</param>
      <param name="length">The length of the message, if it could be identified.</param>
      <returns>True if a length could be obtained, false otherwise.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.Byte[],System.Int32,System.Int32,ProtoBuf.PrefixStyle,System.Int32@)">
      <summary>Indicates the number of bytes expected for the next message.</summary>
      <param name="buffer">The buffer containing the data to investigate for a length.</param>
      <param name="index">The offset of the first byte to read from the buffer.</param>
      <param name="count">The number of bytes to read from the buffer.</param>
      <param name="style">The algorithm used to encode the length.</param>
      <param name="length">The length of the message, if it could be identified.</param>
      <returns>True if a length could be obtained, false otherwise.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.Merge``1(System.IO.Stream,``0)">
      <summary>
            Applies a protocol-buffer stream to an existing instance.
            </summary>
      <typeparam name="T">The type being merged.</typeparam>
      <param name="instance">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.MergeWithLengthPrefix``1(System.IO.Stream,``0)">
      <summary>
            Applies a protocol-buffer stream to an existing instance, using length-prefixed
            data - useful with network IO.
            </summary>
      <typeparam name="T">The type being merged.</typeparam>
      <param name="instance">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.MergeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
      <summary>
            Applies a protocol-buffer stream to an existing instance, using length-prefixed
            data - useful with network IO.
            </summary>
      <typeparam name="T">The type being merged.</typeparam>
      <param name="instance">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.Serialize``1(System.IO.Stream,``0)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
      <typeparam name="T">The type being serialized.</typeparam>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="destination">The destination stream to write to.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
      <typeparam name="T">The type being serialized.</typeparam>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="destination">The destination stream to write to.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
      <typeparam name="T">The type being serialized.</typeparam>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="destination">The destination stream to write to.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle,System.Int32)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
      <typeparam name="T">The type being serialized.</typeparam>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="destination">The destination stream to write to.</param>
      <param name="tag">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
    </member>
    <member name="M:ProtoBuf.Serializer.CreateFormatter``1">
      <summary>
            Creates a new IFormatter that uses protocol-buffer [de]serialization.
            </summary>
      <typeparam name="T">The type of object to be [de]deserialized by the formatter.</typeparam>
      <returns>A new IFormatter to be used during [de]serialization.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.Serialize``1(System.Runtime.Serialization.SerializationInfo,``0)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied SerializationInfo.
            </summary>
      <typeparam name="T">The type being serialized.</typeparam>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="info">The destination SerializationInfo to write to.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.Merge``1(System.Runtime.Serialization.SerializationInfo,``0)">
      <summary>
            Applies a protocol-buffer from a SerializationInfo to an existing instance.
            </summary>
      <typeparam name="T">The type being merged.</typeparam>
      <param name="instance">The existing instance to be modified (cannot be null).</param>
      <param name="info">The SerializationInfo containing the data to apply to the instance (cannot be null).</param>
    </member>
    <member name="M:ProtoBuf.Serializer.Serialize``1(System.Xml.XmlWriter,``0)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied XmlWriter.
            </summary>
      <typeparam name="T">The type being serialized.</typeparam>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="writer">The destination XmlWriter to write to.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.Merge``1(System.Xml.XmlReader,``0)">
      <summary>
            Applies a protocol-buffer from an XmlReader to an existing instance.
            </summary>
      <typeparam name="T">The type being merged.</typeparam>
      <param name="instance">The existing instance to be modified (cannot be null).</param>
      <param name="reader">The XmlReader containing the data to apply to the instance (cannot be null).</param>
    </member>
    <member name="M:ProtoBuf.Serializer.DeepClone``1(``0)">
      <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
      <typeparam name="T">The type being cloned.</typeparam>
      <param name="instance">The existing instance to be cloned.</param>
      <returns>A new copy, cloned from the supplied instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.ChangeType``2(``0)">
      <summary>
            Serializes a given instance and deserializes it as a different type;
            this can be used to translate between wire-compatible objects (where
            two .NET types represent the same data), or to promote/demote a type
            through an inheritance hierarchy.
            </summary>
      <remarks>No assumption of compatibility is made between the types.</remarks>
      <typeparam name="TOldType">The type of the object being copied.</typeparam>
      <typeparam name="TNewType">The type of the new object to be created.</typeparam>
      <param name="instance">The existing instance to use as a template.</param>
      <returns>A new instane of type TNewType, with the data from TOldType.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.ChangeType``2(``0,ProtoBuf.SerializationContext)">
      <summary>
            As per the public ChangeType, but allows for workspace-sharing to reduce buffer overhead.
            </summary>
    </member>
    <member name="M:ProtoBuf.Serializer.GetProto``1">
      <summary>
            Suggest a .proto definition for the given type
            </summary>
      <typeparam name="T">The type to generate a .proto definition for</typeparam>
      <returns>The .proto definition as a string</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.PrepareSerializer``1">
      <summary>
            Ensures that the serialization algorithm has been prepared for
            the given type; this can be useful in highly threaded code to
            ensure that all types are ready ahead of time, avoiding deadlock
            scenarios.
            </summary>
      <typeparam name="T">The object type to prepare.</typeparam>
    </member>
    <member name="F:ProtoBuf.StreamState.Normal">
      <summary>
            Indicates that an EOF is not anticipated, and so will throw an exception.
            </summary>
    </member>
    <member name="F:ProtoBuf.StreamState.EofExpected">
      <summary>
            Indicates that an EOF is acceptable at the current time and will
            not throw an exception.
            </summary>
    </member>
    <member name="F:ProtoBuf.StreamState.Peeked">
      <summary>
            Indicates that we have previously obtained a field value from
            the stream that should be consumed next.
            </summary>
    </member>
    <member name="F:ProtoBuf.StreamState.Eof">
      <summary>
            Indicates that we have found the end of the stream; this is **only**
            used to commicate to "Try", and should not persist.
            </summary>
    </member>
    <member name="M:ProtoBuf.SerializationContext.Push(System.Object)">
      <summary>
            Allows for recursion detection by capturing
            the call tree; this only takes effect after
            an initial threshold call-depth is reached.
            If the object is already in the call-tree,
            an exception is thrown.
            </summary>
      <param name="obj">The item being processed (start).</param>
    </member>
    <member name="M:ProtoBuf.SerializationContext.Push">
      <summary>
            Only used during debugging for the text nest-level
            </summary>
    </member>
    <member name="M:ProtoBuf.SerializationContext.Pop">
      <summary>
            Only used during debugging for the text nest-level
            </summary>
    </member>
    <member name="M:ProtoBuf.SerializationContext.Pop(System.Object)">
      <summary>
            Removes an object from the call-tree.
            </summary>
      <remarks>The object is not checked for validity (peformance);
            ensure that objects are pushed/popped correctly.</remarks>
      <param name="obj">The item being processed (end).</param>
    </member>
    <member name="M:ProtoBuf.SerializationContext.DecodeUInt32Fixed(System.IO.Stream)">
      <summary>
            Slow (unbuffered) read from a stream; used to avoid issues
            with buffers when performing network IO.
            </summary>
    </member>
    <member name="M:ProtoBuf.SerializationContext.TryDecodeUInt32Fixed(System.IO.Stream,System.UInt32@)">
      <summary>
            Slow (unbuffered) read from a stream; used to avoid issues
            with buffers when performing network IO.
            </summary>
    </member>
    <member name="M:ProtoBuf.SerializationContext.DecodeUInt32(System.IO.Stream)">
      <summary>
            Slow (unbuffered) read from a stream; used to avoid issues
            with buffers when performing network IO.
            </summary>
    </member>
    <member name="M:ProtoBuf.SerializationContext.SkipStringData(System.IO.Stream)">
      <summary>
            Jump a block of data using a base-128 length prefix.
            </summary>
      <param name="source">The input stream.</param>
    </member>
    <member name="M:ProtoBuf.SerializationContext.TryDecodeUInt32(System.IO.Stream,System.UInt32@)">
      <summary>
            Slow (unbuffered) read from a stream; used to avoid issues
            with buffers when performing network IO.
            </summary>
      <returns>True if there is data in the stream and a value can be obtained;
            False if there is no data in the stream; note that an exception is still
            thrown if the data is invalid.</returns>
    </member>
    <member name="M:ProtoBuf.SerializationContext.Fill(System.Int32,System.Boolean)">
      <summary>
            Fills the IO buffer if there is not enough data buffered to complete the current operation.
            </summary>
      <param name="required">The maximum number of bytes required by the current operation.</param>
      <param name="demand">Should an exception be thrown if the data is not available?</param>
    </member>
    <member name="M:ProtoBuf.SerializationContext.Fill">
      <summary>
            Fills the IO buffer, moving any un-consumed data to the beginning of the cache.
            </summary>
    </member>
    <member name="M:ProtoBuf.SerializationContext.Flush(System.Int32)">
      <summary>
            Flushes the IO buffer if there is not enough space to complete the current operation.
            </summary>
      <param name="spaceRequired">The maximum number of bytes required by the current operation.</param>
    </member>
    <member name="M:ProtoBuf.SerializationContext.Flush">
      <summary>
            Flushes the IO buffer, writing any cached data to the underlying stream and resetting the cache.
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.ProtoBehaviorAttribute">
      <summary>
            Uses protocol buffer serialization on the specified operation; note that this
            must be enabled on both the client and server.
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.Variant">
      <summary>
            Base-128 variant-length encoding
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.Fixed64">
      <summary>
            Fixed-length 8-byte encoding
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.String">
      <summary>
            Length-variant-prefixed encoding
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.StartGroup">
      <summary>
            Indicates the start of a group
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.EndGroup">
      <summary>
            Indicates the end of a group
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.Fixed32">
      <summary>
            Fixed-length 4-byte encoding
            </summary>
    </member>
    <member name="T:ProtoBuf.DataFormat">
      <summary>
            Sub-format to use when serializing/deserializing data
            </summary>
    </member>
    <member name="F:ProtoBuf.DataFormat.Default">
      <summary>
            Uses the default encoding for the data-type.
            </summary>
    </member>
    <member name="F:ProtoBuf.DataFormat.ZigZag">
      <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that zigzag variant encoding will be used. This means that values
            with small magnitude (regardless of sign) take a small amount
            of space to encode.
            </summary>
    </member>
    <member name="F:ProtoBuf.DataFormat.TwosComplement">
      <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that two's-complement variant encoding will be used.
            This means that any -ve number will take 10 bytes (even for 32-bit),
            so should only be used for compatibility.
            </summary>
    </member>
    <member name="F:ProtoBuf.DataFormat.FixedSize">
      <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that a fixed amount of space will be used.
            </summary>
    </member>
    <member name="F:ProtoBuf.DataFormat.Group">
      <summary>
            When applied to a sub-message, indicates that the value should be treated
            as group-delimited.
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoIncludeAttribute">
      <summary>
            Indicates the known-types to support for an individual
            message. This serializes each level in the hierarchy as
            a nested message to retain wire-compatibility with
            other protocol-buffer implementations.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.Type)">
      <summary>
            Creates a new instance of the ProtoIncludeAttribute.
            </summary>
      <param name="tag">The unique index (within the type) that will identify this data.</param>
      <param name="knownType">The additional type to serialize/deserialize.</param>
    </member>
    <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.String)">
      <summary>
            Creates a new instance of the ProtoIncludeAttribute.
            </summary>
      <param name="tag">The unique index (within the type) that will identify this data.</param>
      <param name="knownTypeName">The additional type to serialize/deserialize.</param>
    </member>
    <member name="P:ProtoBuf.ProtoIncludeAttribute.Tag">
      <summary>
            Gets the unique index (within the type) that will identify this data.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownTypeName">
      <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownType">
      <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoIncludeAttribute.DataFormat">
      <summary>
            Specifies whether the inherited sype's sub-message should be
            written with a length-prefix (default), or with group markers.
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoContractAttribute">
      <summary>
            Indicates that a type is defined for protocol-buffer serialization.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.Name">
      <summary>
            Gets or sets the defined name of the type.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFirstTag">
      <summary>
            Gets or sets the fist offset to use with implicit field tags;
            only uesd if ImplicitFields is set.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFields">
      <summary>
            Gets or sets the mechanism used to automatically infer field tags
            for members. This option should be used in advanced scenarios only.
            Please review the important notes against the ImplicitFields enumeration.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromName">
      <summary>
            Enables/disables automatic tag generation based on the existing name / order
            of the defined members. This option is not used for members marked
            with ProtoMemberAttribute, as intended to provide compatibility with
            WCF serialization. WARNING: when adding new fields you must take
            care to increase the Order for new elements, otherwise data corruption
            may occur.
            </summary>
      <remarks>If not specified, the default is assumed from <see cref="P:ProtoBuf.Serializer.GlobalOptions.InferTagFromName" />.</remarks>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.DataMemberOffset">
      <summary>
            Specifies an offset to apply to [DataMember(Order=...)] markers;
            this is useful when working with mex-generated classes that have
            a different origin (usually 1 vs 0) than the original data-contract.
            
            This value is added to the Order of each member.
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoEnumAttribute">
      <summary>
            Used to define protocol-buffer specific behavior for
            enumerated values.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoEnumAttribute.HasValue">
      <summary>
            Indicates whether this instance has a customised value mapping
            </summary>
      <returns>true if a specific value is set</returns>
    </member>
    <member name="P:ProtoBuf.ProtoEnumAttribute.Value">
      <summary>
            Gets or sets the specific value to use for this enum during serialization.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoEnumAttribute.Name">
      <summary>
            Gets or sets the defined name of the enum, as used in .proto
            (this name is not used during serialization).
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoMemberAttribute">
      <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag. A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoMemberAttribute.#ctor(System.Int32)">
      <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
      <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.Name">
      <summary>
            Gets or sets the original name defined in the .proto; not used
            during serialization.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.DataFormat">
      <summary>
            Gets or sets the data-format to be used when encoding this value.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.Tag">
      <summary>
            Gets the unique tag used to identify this member within the type.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.IsRequired">
      <summary>
            Gets or sets a value indicating whether this member is mandatory.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.Options">
      <summary>
            Gets or sets a value indicating whether this member is packed (lists/arrays).
            </summary>
    </member>
    <member name="T:ProtoBuf.MemberSerializationOptions">
      <summary>
            Additional (optional) settings that control serialization of members
            </summary>
    </member>
    <member name="F:ProtoBuf.MemberSerializationOptions.None">
      <summary>
            Default; no additional options
            </summary>
    </member>
    <member name="F:ProtoBuf.MemberSerializationOptions.Packed">
      <summary>
            Indicates that repeated elements should use packed (length-prefixed) encoding
            </summary>
    </member>
    <member name="F:ProtoBuf.MemberSerializationOptions.Required">
      <summary>
            Indicates that the given item is required
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoPartialMemberAttribute">
      <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag and MemberName. This allows ProtoMemberAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoPartialMemberAttribute.#ctor(System.Int32,System.String)">
      <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
      <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
      <param name="memberName">Specifies the member to be serialized.</param>
    </member>
    <member name="P:ProtoBuf.ProtoPartialMemberAttribute.MemberName">
      <summary>
            The name of the member to be serialized.
            </summary>
    </member>
    <member name="T:ProtoBuf.SubStream">
      <summary>
            Describes a Stream that wraps an underlying stream but
            which limits the length. This is used for processing
            length-prefied messages (string wire-type) so that no
            complex code is required to manage the end of each
            object.
            </summary>
    </member>
    <member name="T:ProtoBuf.ExtensibleUtil">
      <summary>
            This class acts as an internal wrapper allowing us to do a dynamic
            methodinfo invoke; an't put into Serializer as don't want on public
            API; can't put into Serializer&lt;T&gt; since we need to invoke
            accross classes, which isn't allowed in Silverlight)
            </summary>
    </member>
    <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
      <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
    </member>
    <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValuesTyped``2(``0,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
      <summary>
            Reads the given value(s) from the instance's stream; the serializer
            is inferred from TValue and format. For singletons, each occurrence
            is merged [only applies for sub-objects], and the composed
            value if yielded once; otherwise ("repeated") each occurrence
            is yielded separately.
            </summary>
      <remarks>Needs to be public to be callable thru reflection in Silverlight</remarks>
    </member>
    <member name="M:ProtoBuf.ExtensibleUtil.AppendExtendValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Object)">
      <summary>
            All this does is call AppendExtendValueTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
    </member>
    <member name="M:ProtoBuf.ExtensibleUtil.AppendExtendValueTyped``2(``0,System.Int32,ProtoBuf.DataFormat,``1)">
      <summary>
            Stores the given value into the instance's stream; the serializer
            is inferred from TValue and format.
            </summary>
      <remarks>Needs to be public to be callable thru reflection in Silverlight</remarks>
    </member>
    <member name="T:ProtoBuf.ProtoException">
      <summary>
            Indicates an error during serialization/deserialization of a proto stream.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoException.#ctor">
      <summary>Creates a new ProtoException instance.</summary>
    </member>
    <member name="M:ProtoBuf.ProtoException.#ctor(System.String)">
      <summary>Creates a new ProtoException instance.</summary>
    </member>
    <member name="M:ProtoBuf.ProtoException.#ctor(System.String,System.Exception)">
      <summary>Creates a new ProtoException instance.</summary>
    </member>
    <member name="M:ProtoBuf.ProtoException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Creates a new ProtoException instance.</summary>
    </member>
    <member name="T:ProtoBuf.UnknownType">
      <summary>
            The (non-extensible) UnknownType is used when deserializing
            unexpected groups.
            </summary>
    </member>
    <member name="M:ProtoBuf.AsyncUtility.RunAsync``1(ProtoBuf.AsyncBegin{``0},ProtoBuf.AsyncEnd{``0},System.Action{``0},System.Action{System.Exception})">
      <summary>Simplified calling convention for asynchronous Begin/End operations.</summary>
      <typeparam name="T">The type of data returned by the async operation.</typeparam>
      <param name="begin">The start (Begin*) of the async operation.</param>
      <param name="end">The end (End*) of the async operation.</param>
      <param name="callback">The operation to perform once the operation has completed and a value received.</param>
      <param name="exceptionHandler">Callback to invoke when an excetption is thrown during the async operation.</param>
    </member>
    <member name="T:ProtoBuf.AsyncBegin`1">
      <summary>Defines the start of a Begin/End async operation pair.</summary>
      <typeparam name="T">The type of value returned by the async operation.</typeparam>
      <param name="operation">The operation to be performed.</param>
      <param name="state">User-state to be passed to the operation.</param>
      <returns>A token to the async operation.</returns>
    </member>
    <member name="T:ProtoBuf.AsyncEnd`1">
      <summary>Defines the completion callback of a Begin/End async operation pair.</summary>
      <typeparam name="T">The type of value returned by the async operation.</typeparam>
      <param name="operation">The async operation token.</param>
      <returns>The final value of the async operation.</returns>
    </member>
    <member name="T:ProtoBuf.IExtension">
      <summary>
            Provides addition capability for supporting unexpected fields during
            protocol-buffer serialization/deserialization. This allows for loss-less
            round-trip/merge, even when the data is not fully understood.
            </summary>
    </member>
    <member name="M:ProtoBuf.IExtension.BeginAppend">
      <summary>
            Requests a stream into which any unexpected fields can be persisted.
            </summary>
      <returns>A new stream suitable for storing data.</returns>
    </member>
    <member name="M:ProtoBuf.IExtension.EndAppend(System.IO.Stream,System.Boolean)">
      <summary>
            Indicates that all unexpected fields have now been stored. The
            implementing class is responsible for closing the stream. If
            "commit" is not true the data may be discarded.
            </summary>
      <param name="stream">The stream originally obtained by BeginAppend.</param>
      <param name="commit">True if the append operation completed successfully.</param>
    </member>
    <member name="M:ProtoBuf.IExtension.BeginQuery">
      <summary>
            Requests a stream of the unexpected fields previously stored.
            </summary>
      <returns>A prepared stream of the unexpected fields.</returns>
    </member>
    <member name="M:ProtoBuf.IExtension.EndQuery(System.IO.Stream)">
      <summary>
            Indicates that all unexpected fields have now been read. The
            implementing class is responsible for closing the stream.
            </summary>
      <param name="stream">The stream originally obtained by BeginQuery.</param>
    </member>
    <member name="M:ProtoBuf.IExtension.GetLength">
      <summary>
            Requests the length of the raw binary stream; this is used
            when serializing sub-entities to indicate the expected size.
            </summary>
      <returns>The length of the binary stream representing unexpected data.</returns>
    </member>
    <member name="T:ProtoBuf.BufferExtension">
      <summary>
            Provides a simple buffer-based implementation of an <see cref="T:ProtoBuf.IExtension">extension</see> object.
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoBeforeSerializationAttribute">
      <summary>Specifies a method on the root-contract in an hierarchy to be invoked before serialization.</summary>
    </member>
    <member name="T:ProtoBuf.ProtoAfterSerializationAttribute">
      <summary>Specifies a method on the root-contract in an hierarchy to be invoked after serialization.</summary>
    </member>
    <member name="T:ProtoBuf.ProtoBeforeDeserializationAttribute">
      <summary>Specifies a method on the root-contract in an hierarchy to be invoked before deserialization.</summary>
    </member>
    <member name="T:ProtoBuf.ProtoAfterDeserializationAttribute">
      <summary>Specifies a method on the root-contract in an hierarchy to be invoked after deserialization.</summary>
    </member>
    <member name="T:ProtoBuf.AsyncResult">
      <summary>
            Represents the function to obtain the return value from an asynchronouse operation;
            comparable to Func&lt;object&gt;.
            </summary>
    </member>
    <member name="T:ProtoBuf.Getter`2">
      <summary>
            Returns the required value from an instance; comparable to Func&lt;TEntity,TValue&gt;
            </summary>
    </member>
    <member name="T:ProtoBuf.Setter`2">
      <summary>
            Assigns the required value to an instance; comparable to Action&lt;TEntity,TValue&gt;.
            </summary>
    </member>
    <member name="T:ProtoBuf.ImplicitFields">
      <summary>
            Specifies the method used to infer field tags for members of the type
            under consideration. Tags are deduced using the invariant alphabetic
            sequence of the members' names; this makes implicit field tags very brittle,
            and susceptible to changes such as field names (normally an isolated
            change).
            </summary>
    </member>
    <member name="F:ProtoBuf.ImplicitFields.None">
      <summary>
            No members are serialized implicitly; all members require a suitable
            attribute such as [ProtoMember]. This is the recmomended mode for
            most scenarios.
            </summary>
    </member>
    <member name="F:ProtoBuf.ImplicitFields.AllPublic">
      <summary>
            Public properties and fields are eligible for implicit serialization;
            this treats the public API as a contract.
            </summary>
    </member>
    <member name="F:ProtoBuf.ImplicitFields.AllFields">
      <summary>
            Public and non-public fields are eligible for implicit serialization;
            this acts as a state/implementation serializer.
            </summary>
    </member>
    <member name="T:ProtoBuf.ObjectFactory`1">
      <summary>
            Abstract object factory, used to negate the need for a ": new()" generic constraint
            on Serializer-of-T.
            </summary>
      <typeparam name="T">The type of object to be created.</typeparam>
    </member>
    <member name="T:ProtoBuf.PrefixStyle">
      <summary>
            Specifies the type of prefix that should be applied to messages.
            </summary>
    </member>
    <member name="F:ProtoBuf.PrefixStyle.None">
      <summary>
            No length prefix is applied to the data; the data is terminated only be the end of the stream.
            </summary>
    </member>
    <member name="F:ProtoBuf.PrefixStyle.Base128">
      <summary>
            A base-128 length prefix is applied to the data (efficient for short messages).
            </summary>
    </member>
    <member name="F:ProtoBuf.PrefixStyle.Fixed32">
      <summary>
            A fixed-length (little-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
    </member>
    <member name="T:ProtoBuf.Property.PropertyEnum`2">
      <summary>
            Property implemenation that handles enum values.
            </summary>
      <remarks>All enum wire-values must be in the Int32 range.</remarks>
    </member>
    <member name="T:ProtoBuf.Property.PropertyFactory">
      <summary>
            Utility class for creating/initializing protobuf-net property
            wrappers.
            </summary>
    </member>
    <member name="T:ProtoBuf.Property.PropertyFactory.PassThruCache`1">
      <summary>
            Stores, per T, a pass-thru Getter&lt;T,T&gt; delegate.
            </summary>
    </member>
    <member name="M:ProtoBuf.Property.PropertyFactory.GetPassThru``1">
      <summary>
            Returns a Getter&lt;T,T&gt; delegate that simply returns
            the original value. This allows code re-use between
            different implementations.
            </summary>
      <remarks>Originally an anonymous method was used, but
            this proved problematic with the Mono 2.0 compiler.</remarks>
    </member>
    <member name="M:ProtoBuf.Property.PropertyFactory.CreatePassThru``1(System.Int32,ProtoBuf.DataFormat@)">
      <summary>
            Create a simple Property that can be used standalone
            to encode/decode values for the given type.
            </summary>
    </member>
    <member name="M:ProtoBuf.Property.PropertyFactory.Create``1(System.Reflection.MemberInfo)">
      <summary>
            Create a Property based around a class
            member (PropertyInfo/FieldInfo).
            </summary>
    </member>
    <member name="M:ProtoBuf.Property.PropertyFactory.CreateProperty``1(System.Type,ProtoBuf.DataFormat@,ProtoBuf.MemberSerializationOptions)">
      <summary>
            Responsible for deciding how to encode/decode a given data-type; maybe
            not the most elegant solution, but it is simple and quick.
            </summary>
    </member>
    <member name="T:ProtoBuf.Property.PropertyMessageString`4">
      <summary>
            Serializes an entity using string (length-prefixed) syntax.
            The high number of type arguments is requird to support ancestral serialization;
            there are 2 use-cases:
              direct: for example, a property (base is the highest contract ancestor; prop = actual = the property-type)
              descendent: used internally to cascade inheritance; prop = base = the parent type, actual = the child type
            </summary>
      <typeparam name="TSource">The type declaring the member</typeparam>
      <typeparam name="TProperty">The defined member-type for accessing data</typeparam>
      <typeparam name="TEntityBase">The base-type to use when verifying / instantiating sub-type instances</typeparam>
      <typeparam name="TEntityActual">The type to use for serialization purposes</typeparam>
    </member>
    <member name="T:ProtoBuf.Property.PropertyMessageGroup`4">
      <summary>
            Serializes an entity using group (delimited) syntax.
            The high number of type arguments is requird to support ancestral serialization;
            there are 2 use-cases:
              direct: for example, a property (base is the highest contract ancestor; prop = actual = the property-type)
              descendent: used internally to cascade inheritance; prop = base = the parent type, actual = the child type
            </summary>
      <typeparam name="TSource">The type declaring the member</typeparam>
      <typeparam name="TProperty">The defined member-type for accessing data</typeparam>
      <typeparam name="TEntityBase">The base-type to use when verifying / instantiating sub-type instances</typeparam>
      <typeparam name="TEntityActual">The type to use for serialization purposes</typeparam>
    </member>
    <member name="T:ProtoBuf.ProtoIgnoreAttribute">
      <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields.
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoPartialIgnoreAttribute">
      <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields. This allows
            ProtoIgnoreAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoPartialIgnoreAttribute.#ctor(System.String)">
      <summary>
            Creates a new ProtoPartialIgnoreAttribute instance.
            </summary>
      <param name="memberName">Specifies the member to be ignored.</param>
    </member>
    <member name="P:ProtoBuf.ProtoPartialIgnoreAttribute.MemberName">
      <summary>
            The name of the member to be ignored.
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.ExceptionEventArgs">
      <summary>
            Represents an exception raised through an event.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.ExceptionEventArgs.#ctor(System.Exception)">
      <summary>
            Creates a new instance of ExceptionEventArgs for the gievn exception.
            </summary>
      <param name="exception">
      </param>
    </member>
    <member name="P:ProtoBuf.ServiceModel.ExceptionEventArgs.Exception">
      <summary>
            The exception represented by the event.
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.Client.ITransport">
      <summary>
            Provides the underlying transport for a family of RPC operations.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ITransport.SendRequestAsync(ProtoBuf.ServiceModel.Client.ServiceRequest)">
      <summary>
            Begins an async operation over the transport.
            </summary>
      <param name="request">The operation to perform (includes the facility
            to provide a response for the operation).</param>
    </member>
    <member name="T:ProtoBuf.ServiceModel.Client.HttpBasicTransport">
      <summary>
            Performs RPC using basic http POSTs to a web-server.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.HttpBasicTransport.#ctor(System.String)">
      <summary>Create a new HttpBasicTransport instance.</summary>
      <param name="uri">The endpoint for the service. By default, the servic
            is assumed to be RESTful, and the action is appended as a route; the
            route can be customized by including the "{action}" token in the uri.</param>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.HttpBasicTransport.Dispose">
      <summary>
            Releases any resources associated with the transport.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.HttpBasicTransport.Dispose(System.Boolean)">
      <summary>
            Releases any resources associated with the transport.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.HttpBasicTransport.CheckDisposed">
      <summary>
            Raises an exception if the instance has been disposed.
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.ProtoBehaviorExtension">
      <summary>
            Configuration element to swap out DatatContractSerilaizer with the XmlProtoSerializer for a given endpoint.
            </summary>
      <seealso cref="T:ProtoBuf.ServiceModel.ProtoEndpointBehavior" />
    </member>
    <member name="M:ProtoBuf.ServiceModel.ProtoBehaviorExtension.#ctor">
      <summary>
            Creates a new ProtoBehaviorExtension instance.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.ProtoBehaviorExtension.CreateBehavior">
      <summary>
            Creates a behavior extension based on the current configuration settings.
            </summary>
      <returns>The behavior extension.</returns>
    </member>
    <member name="P:ProtoBuf.ServiceModel.ProtoBehaviorExtension.BehaviorType">
      <summary>
            Gets the type of behavior.
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.ProtoEndpointBehavior">
      <summary>
            Behavior to swap out DatatContractSerilaizer with the XmlProtoSerializer for a given endpoint.
             <example>
            Add the following to the server and client app.config in the system.serviceModel section:
             <behaviors><endpointBehaviors><behavior name="ProtoBufBehaviorConfig"><ProtoBufSerialization /></behavior></endpointBehaviors></behaviors><extensions><behaviorExtensions><add name="ProtoBufSerialization" type="ProtoBuf.ServiceModel.ProtoBehaviorExtension, protobuf-net, Version=1.0.0.255, Culture=neutral, PublicKeyToken=257b51d87d2e4d67" /></behaviorExtensions></extensions>
            
            Configure your endpoints to have a behaviorConfiguration as follows:
            
             <service name="TK.Framework.Samples.ServiceModel.Contract.SampleService"><endpoint address="http://myhost:9003/SampleService" binding="basicHttpBinding" behaviorConfiguration="ProtoBufBehaviorConfig" bindingConfiguration="basicHttpBindingConfig" name="basicHttpProtoBuf" contract="ISampleServiceContract" /></service><client><endpoint address="http://myhost:9003/SampleService" binding="basicHttpBinding" bindingConfiguration="basicHttpBindingConfig" contract="ISampleServiceContract" name="BasicHttpProtoBufEndpoint" behaviorConfiguration="ProtoBufBehaviorConfig" /></client></example></summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.RpcUtils">
      <summary>
            Utility operations common to RPC implementations.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.RpcUtils.IsRequestArgument(System.Reflection.ParameterInfo)">
      <summary>
            Indicates whether the given parameter forms part of a request - i.e.
            is "in" or "ref".
            </summary>
      <param name="parameter">The parameter to test.</param>
      <returns>True if the given parameter is part of a request.</returns>
    </member>
    <member name="M:ProtoBuf.ServiceModel.RpcUtils.IsResponseArgument(System.Reflection.ParameterInfo)">
      <summary>
            Indicates whether the given parameter forms part of a response - i.e.
            is "out" or "ref".
            </summary>
      <param name="parameter">The parameter to test.</param>
      <returns>True if the given parameter is part of a response.</returns>
    </member>
    <member name="M:ProtoBuf.ServiceModel.RpcUtils.GetServiceName(System.Type)">
      <summary>
            Returns the name associated with a service contract.
            </summary>
      <param name="type">The service-contract type.</param>
      <returns>The name of the service.</returns>
    </member>
    <member name="T:ProtoBuf.ServiceModel.Server.ServerBase">
      <summary>
            Provides common functionality required by RPC servers.
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.Server.ServerBase.ServiceBase">
      <summary>
            Represents a service endpoint provided by the server.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.ServerBase.ServiceBase.GetInstance">
      <summary>
            Obtains the instance representing the service endpoint for a call.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.ServerBase.ServiceBase.ReleaseInstance(System.Object)">
      <summary>
            Releases the instance representing the service endpoint for a call.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.ServerBase.ServiceBase.Dispose">
      <summary>
            Releases any resources associated with the endpoint.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.ServerBase.ServiceBase.#ctor(System.Type)">
      <summary>
            Initialises a new service endpoint for the given service type.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.ServerBase.ServiceBase.GetAction(System.String)">
      <summary>
            Obtains the method that represents a given action.
            </summary>
      <param name="name">The name of the action.</param>
      <returns>The method that should be invoked.</returns>
    </member>
    <member name="P:ProtoBuf.ServiceModel.Server.ServerBase.ServiceBase.ServiceName">
      <summary>
            The name of the service endpoint.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.ServerBase.Add``2">
      <summary>
            Adds a per-call service to the server. An instance of the type will
            be created (and disposed if appropriate) per request. 
            </summary>
      <typeparam name="TContract">The type of service-contract to provide.</typeparam>
      <typeparam name="TService">The concrete type that will implement the service.</typeparam>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.ServerBase.Add``1(``0)">
      <summary>
            Adds a singleton service to the server. All requests will be
            serviced by the supplied instance. This instance will be
            disposed (if appropriate) with the server.
            </summary>
      <typeparam name="T">The type of service to provide.</typeparam>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.ServerBase.Dispose``1(``0@)">
      <summary>
            Releases and nulls a given field/variable.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.ServerBase.OnBeforeWriteResponse(System.Object)">
      <summary>
            Performs any pre-response operations required.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.ServerBase.Execute(System.String,System.String,System.Collections.Specialized.NameValueCollection,System.IO.Stream,System.IO.Stream,System.Object)">
      <summary>
            Performs server-side processing of an action, including deserialization
            of arguments, method-invokation, and serialization of the return value and
            any `out`/`ref` arguments.
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.Server.HttpServer">
      <summary>
            Standalone http server compatible with <seealso cref="T:ProtoBuf.ServiceModel.Client.HttpBasicTransport" />.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.HttpServer.#ctor(System.String,System.Type,System.Type)">
      <summary>
            Create a new HttpServer instance for the given service-type.
            </summary>
      <param name="uriPrefix">The base uri on which to listen for messages.</param>
      <param name="serviceContractType">The interface that represents the service contract.</param>
      <param name="serviceImplementationType">The concrete type that implements the service contract.</param>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.HttpServer.#ctor(System.String)">
      <summary>
            Create a new HttpServer instance for the given service-type.
            </summary>
      <param name="uriPrefix">The base uri on which to listen for messages.</param>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.HttpServer.Start">
      <summary>
            Begin listening for messages on the server.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.HttpServer.OnBeforeWriteResponse(System.Object)">
      <summary>
            Performs any pre-response operations required.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Server.HttpServer.Close">
      <summary>
            Stop listening for messages on the server, and release
            any associated resources.
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.Client.ProtoClient`1">
      <summary>
            Provides transport-independent wrapper logic for
            managing RPC calls to the server.
            </summary>
      <typeparam name="TService">The service contract that the client represents.</typeparam>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ProtoClient`1.Dispose">
      <summary>
            Releases any resources associated with the client.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ProtoClient`1.#ctor(ProtoBuf.ServiceModel.Client.ITransport)">
      <summary>
            Create a new client object.
            </summary>
      <param name="transport">The transport implementation to use.</param>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ProtoClient`1.InvokeAsync(System.String,System.Action{ProtoBuf.AsyncResult},System.Object[])">
      <summary>
            Begins an RPC invokation asynchrononously.
            </summary>
      <param name="methodName">The name of the method (on the service interface) to invoke.</param>
      <param name="args">The request payload.</param>
      <param name="callback">The operation to perform when a response is received.</param>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ProtoClient`1.Invoke(System.String,System.Object[])">
      <summary>
            Performs an RPC invokation synchrononously.
            </summary>
      <param name="methodName">The name of the method (on the service interface) to invoke.</param>
      <param name="args">The request payload.</param>
      <returns>The response payload.</returns>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ProtoClient`1.Invoke(System.Reflection.MethodInfo,System.Object[])">
      <summary>
            Performs an RPC invokation synchrononously.
            </summary>
      <param name="method">The method (on the service interface) to invoke.</param>
      <param name="args">The request payload.</param>
      <returns>The response payload.</returns>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ProtoClient`1.InvokeAsync(System.Reflection.MethodInfo,System.Action{ProtoBuf.AsyncResult},System.Object[])">
      <summary>
            Begins an RPC invokation asynchrononously.
            </summary>
      <param name="method">The method (on the service interface) to invoke.</param>
      <param name="args">The request payload.</param>
      <param name="callback">The operation to perform when a response is received.</param>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ProtoClient`1.ResolveAction(System.Reflection.MethodInfo)">
      <summary>
            Identify the action to use for a given method.
            </summary>
      <param name="method">The method requested.</param>
      <returns>The action to use.</returns>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ProtoClient`1.ResolveService(System.Type)">
      <summary>
            Identify the service to use for a given method.
            </summary>
      <param name="serviceType">The service requested.</param>
      <returns>The service to use.</returns>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ProtoClient`1.OnException(System.Exception)">
      <summary>
            Signals that an error occured processing RPC calls.
            </summary>
      <param name="exception">The error details.</param>
    </member>
    <member name="P:ProtoBuf.ServiceModel.Client.ProtoClient`1.Timeout">
      <summary>
            Gets or sets the timeout (in milliseconds) for synchronous RPC operations.
            </summary>
    </member>
    <member name="P:ProtoBuf.ServiceModel.Client.ProtoClient`1.Transport">
      <summary>
            Gets the transport mechanism associated with the client.
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.Client.ServiceRequest">
      <summary>
            Represents an in-progress request (and response mechanism)
            for a basic RPC stack.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ServiceRequest.OnException(System.Exception)">
      <summary>Called by transports; signals that the operation failed.</summary>
      <param name="exception">The details of the failure.</param>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ServiceRequest.OnResponse(System.Object)">
      <summary>Called by transports; signals that the operation succeeded.</summary>
      <param name="responseObject">The server's response the the request.</param>
    </member>
    <member name="M:ProtoBuf.ServiceModel.Client.ServiceRequest.#ctor(System.String,System.String,System.Reflection.MethodInfo,System.Object[],System.Object,System.Action{ProtoBuf.AsyncResult})">
      <summary>Create a new service request.</summary>
      <param name="action">The contract-based name of the operation to perform.</param>
      <param name="service">The contract-based name of the service to use.</param>
      <param name="method">Provides reflection access to the contract member representing the operation.</param>
      <param name="args">The argument values for the method.</param>
      <param name="userState">Caller-defined state for this operation.</param>
      <param name="callback">The operation to perform when this request has completed.</param>
    </member>
    <member name="P:ProtoBuf.ServiceModel.Client.ServiceRequest.UserState">
      <summary>Caller-defined state for this operation.</summary>
    </member>
    <member name="P:ProtoBuf.ServiceModel.Client.ServiceRequest.Args">
      <summary>The object graph representing the query request object.</summary>
    </member>
    <member name="P:ProtoBuf.ServiceModel.Client.ServiceRequest.ResponseObject">
      <summary>The object graph representing the server's response.</summary>
    </member>
    <member name="P:ProtoBuf.ServiceModel.Client.ServiceRequest.Exception">
      <summary> Descripbes any exception raised by the transport.</summary>
    </member>
    <member name="P:ProtoBuf.ServiceModel.Client.ServiceRequest.Action">
      <summary>The contract-based name of the operation to perform.</summary>
    </member>
    <member name="P:ProtoBuf.ServiceModel.Client.ServiceRequest.Service">
      <summary>The contract-based name of the service to ues.</summary>
    </member>
    <member name="P:ProtoBuf.ServiceModel.Client.ServiceRequest.Method">
      <summary>Provides reflection access to the contract member representing the operation.</summary>
    </member>
    <member name="T:Autofac.Builder.ReflectionActivatorData">
      <summary>
            Builder for reflection-based activators.
            </summary>
    </member>
    <member name="M:Autofac.Builder.ReflectionActivatorData.#ctor(System.Type)">
      <summary>
            Specify a reflection activator for the given type.
            </summary>
      <param name="implementor">Type that will be activated.</param>
    </member>
    <member name="P:Autofac.Builder.ReflectionActivatorData.ImplementationType">
      <summary>
            Get the implementation type.
            </summary>
    </member>
    <member name="P:Autofac.Builder.ReflectionActivatorData.ConstructorFinder">
      <summary>
            The constructor finder for the registration.
            </summary>
    </member>
    <member name="P:Autofac.Builder.ReflectionActivatorData.ConstructorSelector">
      <summary>
            The constructor selector for the registration.
            </summary>
    </member>
    <member name="P:Autofac.Builder.ReflectionActivatorData.ConfiguredParameters">
      <summary>
            The explicitly bound constructor parameters.
            </summary>
    </member>
    <member name="P:Autofac.Builder.ReflectionActivatorData.ConfiguredProperties">
      <summary>
            The explicitly bound properties.
            </summary>
    </member>
    <member name="T:Autofac.Builder.IConcreteActivatorData">
      <summary>
            Activator data that can provide an IInstanceActivator instance.
            </summary>
    </member>
    <member name="P:Autofac.Builder.IConcreteActivatorData.Activator">
      <summary>
            The instance activator based on the provided data.
            </summary>
    </member>
    <member name="T:Autofac.Builder.ConcreteReflectionActivatorData">
      <summary>
            Reflection activator data for concrete types.
            </summary>
    </member>
    <member name="M:Autofac.Builder.ConcreteReflectionActivatorData.#ctor(System.Type)">
      <summary>
            Specify a reflection activator for the given type.
            </summary>
      <param name="implementor">Type that will be activated.</param>
    </member>
    <member name="P:Autofac.Builder.ConcreteReflectionActivatorData.Activator">
      <summary>
            The instance activator based on the provided data.
            </summary>
    </member>
    <member name="T:Autofac.Builder.IRegistrationBuilder`3">
      <summary>
            Data structure used to construct registrations.
            </summary>
      <typeparam name="TLimit">The most specific type to which instances of the registration
            can be cast.</typeparam>
      <typeparam name="TActivatorData">Activator builder type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style type.</typeparam>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.ExternallyOwned">
      <summary>
            Configure the component so that instances are never disposed by the container.
            </summary>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.OwnedByLifetimeScope">
      <summary>
            Configure the component so that instances that support IDisposable are
            disposed by the container (default.)
            </summary>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.InstancePerDependency">
      <summary>
            Configure the component so that every dependent component or call to Resolve()
            gets a new, unique instance (default.)
            </summary>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.SingleInstance">
      <summary>
            Configure the component so that every dependent component or call to Resolve()
            gets the same, shared instance.
            </summary>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.InstancePerLifetimeScope">
      <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a single ILifetimeScope gets the same, shared instance. Dependent components in
            different lifetime scopes will get different instances.
            </summary>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.InstancePerMatchingLifetimeScope(System.Object)">
      <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a ILifetimeScope tagged with the provided tag value gets the same, shared instance.
            Dependent components in lifetime scopes that are children of the tagged scope will
            share the parent's instance. If no appropriately tagged scope can be found in the
            hierarchy an <see cref="T:Autofac.Core.DependencyResolutionException" /> is thrown.
            </summary>
      <param name="lifetimeScopeTag">Tag applied to matching lifetime scopes.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.As``1">
      <summary>
            Configure the services that the component will provide. The generic parameter(s) to As()
            will be exposed as TypedService instances.
            </summary>
      <typeparam name="TService">Service type.</typeparam>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.As``2">
      <summary>
            Configure the services that the component will provide. The generic parameter(s) to As()
            will be exposed as TypedService instances.
            </summary>
      <typeparam name="TService1">Service type.</typeparam>
      <typeparam name="TService2">Service type.</typeparam>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.As``3">
      <summary>
            Configure the services that the component will provide. The generic parameter(s) to As()
            will be exposed as TypedService instances.
            </summary>
      <typeparam name="TService1">Service type.</typeparam>
      <typeparam name="TService2">Service type.</typeparam>
      <typeparam name="TService3">Service type.</typeparam>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.As(System.Type[])">
      <summary>
            Configure the services that the component will provide.
            </summary>
      <param name="services">Service types to expose.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.As(Autofac.Core.Service[])">
      <summary>
            Configure the services that the component will provide.
            </summary>
      <param name="services">Services to expose.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.Named(System.String,System.Type)">
      <summary>
            Provide a textual name that can be used to retrieve the component.
            </summary>
      <param name="serviceName">Named service to associate with the component.</param>
      <param name="serviceType">The service type provided by the component.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.Named``1(System.String)">
      <summary>
            Provide a textual name that can be used to retrieve the component.
            </summary>
      <param name="serviceName">Named service to associate with the component.</param>
      <typeparam name="TService">The service type provided by the component.</typeparam>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.Keyed(System.Object,System.Type)">
      <summary>
            Provide a key that can be used to retrieve the component.
            </summary>
      <param name="serviceKey">Key to associate with the component.</param>
      <param name="serviceType">The service type provided by the component.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.Keyed``1(System.Object)">
      <summary>
            Provide a key that can be used to retrieve the component.
            </summary>
      <param name="serviceKey">Key to associate with the component.</param>
      <typeparam name="TService">The service type provided by the component.</typeparam>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.OnPreparing(System.Action{Autofac.Core.PreparingEventArgs})">
      <summary>
            Add a handler for the Preparing event. This event allows manipulating of the parameters
            that will be provided to the component.
            </summary>
      <param name="handler">The event handler.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.OnActivating(System.Action{Autofac.Core.IActivatingEventArgs{`0}})">
      <summary>
            Add a handler for the Activating event.
            </summary>
      <param name="handler">The event handler.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.OnActivated(System.Action{Autofac.Core.IActivatedEventArgs{`0}})">
      <summary>
            Add a handler for the Activated event.
            </summary>
      <param name="handler">The event handler.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.PropertiesAutowired">
      <summary>
            Configure the component so that any properties whose types are registered in the
            container will be wired to instances of the appropriate service.
            </summary>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.PropertiesAutowired(System.Boolean)">
      <summary>
            Configure the component so that any properties whose types are registered in the
            container will be wired to instances of the appropriate service.
            </summary>
      <param name="allowCircularDependencies">If set to true, the properties won't be wired until
            after the component has been activated. This allows property-property and constructor-property
            circularities in the dependency graph.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.WithMetadata(System.String,System.Object)">
      <summary>
            Associates data with the component.
            </summary>
      <param name="key">Key by which the data can be located.</param>
      <param name="value">The data value.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.WithMetadata(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
      <summary>
            Associates data with the component.
            </summary>
      <param name="properties">The extended properties to associate with the component.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.IRegistrationBuilder`3.WithMetadata``1(System.Action{Autofac.Builder.MetadataConfiguration{``0}})">
      <summary>
            Associates data with the component.
            </summary>
      <typeparam name="TMetadata">A type with properties whose names correspond to the
            property names to configure.</typeparam>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="P:Autofac.Builder.IRegistrationBuilder`3.ActivatorData">
      <summary>
            The activator data.
            </summary>
    </member>
    <member name="P:Autofac.Builder.IRegistrationBuilder`3.RegistrationStyle">
      <summary>
            The registration style.
            </summary>
    </member>
    <member name="P:Autofac.Builder.IRegistrationBuilder`3.RegistrationData">
      <summary>
            The registration data.
            </summary>
    </member>
    <member name="T:Autofac.Builder.MetadataConfiguration`1">
      <summary>
            Used with the WithMetadata configuration method to
            associate key-value pairs with an <see cref="T:Autofac.Core.IComponentRegistration" />.
            </summary>
      <typeparam name="TMetadata">Interface with properties whose names correspond to
            the property keys.</typeparam>
      <remarks>This feature was suggested by OJ Reeves (@TheColonial).</remarks>
    </member>
    <member name="M:Autofac.Builder.MetadataConfiguration`1.For``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
      <summary>
            Set one of the property values.
            </summary>
      <typeparam name="TProperty">The type of the property.</typeparam>
      <param name="propertyAccessor">An expression that accesses the property to set.</param>
      <param name="value">The property value to set.</param>
    </member>
    <member name="T:Autofac.Builder.RegistrationBuilder">
      <summary>
            Static factory methods to simplify the creation and handling of IRegistrationBuilder{L,A,R}.
            </summary>
      <example>
            To create an <see cref="T:Autofac.Core.IComponentRegistration" /> for a specific type, use:
            <code>
            var cr = RegistrationBuilder.ForType(t).CreateRegistration();
            </code>
            The full builder syntax is supported:
            <code>
            var cr = RegistrationBuilder.ForType(t).Named("foo").ExternallyOwned().CreateRegistration();
            </code></example>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder.ForDelegate``1(System.Func{Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},``0})">
      <summary>
            Creates a registration builder for the provided delegate.
            </summary>
      <typeparam name="T">Instance type returned by delegate.</typeparam>
      <param name="delegate">Delegate to register.</param>
      <returns>A registration builder.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder.ForDelegate(System.Type,System.Func{Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.Object})">
      <summary>
            Creates a registration builder for the provided delegate.
            </summary>
      <param name="delegate">Delegate to register.</param>
      <param name="limitType">Most specific type return value of delegate can be cast to.</param>
      <returns>A registration builder.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder.ForType``1">
      <summary>
            Creates a registration builder for the provided type.
            </summary>
      <typeparam name="TImplementor">Implementation type to register.</typeparam>
      <returns>A registration builder.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder.ForType(System.Type)">
      <summary>
            Creates a registration builder for the provided type.
            </summary>
      <param name="implementationType">Implementation type to register.</param>
      <returns>A registration builder.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder.CreateRegistration``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
      <summary>
            Create an <see cref="T:Autofac.Core.IComponentRegistration" /> from a <see cref="T:Autofac.Builder.RegistrationBuilder" />.
            (There is no need to call
            this method when registering components through a <see cref="T:Autofac.ContainerBuilder" />.)
            </summary>
      <remarks>
            When called on the result of one of the <see cref="T:Autofac.ContainerBuilder" /> methods,
            the returned registration will be different from the one the builder itself registers
            in the container.
            </remarks>
      <example>
        <code>
            var registration = RegistrationBuilder.ForType&lt;Foo&gt;().CreateRegistration();
            </code>
      </example>
      <typeparam name="TLimit">
      </typeparam>
      <typeparam name="TActivatorData">
      </typeparam>
      <typeparam name="TSingleRegistrationStyle">
      </typeparam>
      <param name="rb">The registration builder.</param>
      <returns>An IComponentRegistration.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder.CreateRegistration(System.Guid,Autofac.Builder.RegistrationData,Autofac.Core.IInstanceActivator,System.Collections.Generic.IEnumerable{Autofac.Core.Service})">
      <summary>
            Create an IComponentRegistration from data.
            </summary>
      <param name="id">Id of the registration.</param>
      <param name="data">Registration data.</param>
      <param name="activator">Activator.</param>
      <param name="services">Services provided by the registration.</param>
      <returns>An IComponentRegistration.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder.CreateRegistration(System.Guid,Autofac.Builder.RegistrationData,Autofac.Core.IInstanceActivator,System.Collections.Generic.IEnumerable{Autofac.Core.Service},Autofac.Core.IComponentRegistration)">
      <summary>
            Create an IComponentRegistration from data.
            </summary>
      <param name="id">Id of the registration.</param>
      <param name="data">Registration data.</param>
      <param name="activator">Activator.</param>
      <param name="services">Services provided by the registration.</param>
      <param name="target">Optional; target registration.</param>
      <returns>An IComponentRegistration.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder.RegisterSingleComponent``3(Autofac.Core.IComponentRegistry,Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
      <summary>
            Register a component in the component registry. This helper method is necessary
            in order to execute OnRegistered hooks and respect PreserveDefaults. 
            </summary>
      <remarks>Hoping to refactor this out.</remarks>
      <typeparam name="TLimit">
      </typeparam>
      <typeparam name="TActivatorData">
      </typeparam>
      <typeparam name="TSingleRegistrationStyle">
      </typeparam>
      <param name="cr">Component registry to make registration in.</param>
      <param name="rb">Registration builder with data for new registration.</param>
    </member>
    <member name="T:Autofac.Builder.RegistrationBuilderResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationBuilderResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationBuilderResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationBuilderResources.ComponentDoesNotSupportService">
      <summary>
              Looks up a localized string similar to The type '{0}' is not assignable to service '{1}'..
            </summary>
    </member>
    <member name="T:Autofac.Builder.RegistrationExtensions">
      <summary>
            Adds registration syntax for less commonly-used features.
            </summary>
      <remarks>
            These features are in this namespace because they will remain accessible to
            applications originally written against Autofac 1.4. In Autofac 2, this functionality
            is implicitly provided and thus making explicit registrations is rarely necessary.
            </remarks>
    </member>
    <member name="M:Autofac.Builder.RegistrationExtensions.RegisterGeneratedFactory(Autofac.ContainerBuilder,System.Type)">
      <summary>
            Registers a factory delegate.
            </summary>
      <param name="builder">Container builder.</param>
      <param name="delegateType">Factory type to generate.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
      <remarks>Factory delegates are provided automatically in Autofac 2,
            and this method is generally not required.</remarks>
    </member>
    <member name="M:Autofac.Builder.RegistrationExtensions.RegisterGeneratedFactory(Autofac.ContainerBuilder,System.Type,Autofac.Core.Service)">
      <summary>
            Registers a factory delegate.
            </summary>
      <param name="builder">Container builder.</param>
      <param name="delegateType">Factory type to generate.</param>
      <param name="service">The service that the delegate will return instances of.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
      <remarks>Factory delegates are provided automatically in Autofac 2, and
            this method is generally not required.</remarks>
    </member>
    <member name="M:Autofac.Builder.RegistrationExtensions.RegisterGeneratedFactory``1(Autofac.ContainerBuilder,Autofac.Core.Service)">
      <summary>
            Registers a factory delegate.
            </summary>
      <typeparam name="TDelegate">The type of the delegate.</typeparam>
      <param name="builder">Container builder.</param>
      <param name="service">The service that the delegate will return instances of.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
      <remarks>Factory delegates are provided automatically in Autofac 2,
            and this method is generally not required.</remarks>
    </member>
    <member name="M:Autofac.Builder.RegistrationExtensions.RegisterGeneratedFactory``1(Autofac.ContainerBuilder)">
      <summary>
            Registers a factory delegate.
            </summary>
      <typeparam name="TDelegate">The type of the delegate.</typeparam>
      <param name="builder">Container builder.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
      <remarks>Factory delegates are provided automatically in Autofac 2,
            and this method is generally not required.</remarks>
    </member>
    <member name="M:Autofac.Builder.RegistrationExtensions.NamedParameterMapping``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
      <summary>
            Changes the parameter mapping mode of the supplied delegate type to match
            parameters by name.
            </summary>
      <typeparam name="TDelegate">Factory delegate type</typeparam>
      <typeparam name="TGeneratedFactoryActivatorData">Activator data type</typeparam>
      <typeparam name="TSingleRegistrationStyle">Registration style</typeparam>
      <param name="registration">Registration to change parameter mapping mode of.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationExtensions.PositionalParameterMapping``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
      <summary>
            Changes the parameter mapping mode of the supplied delegate type to match
            parameters by position.
            </summary>
      <typeparam name="TDelegate">Factory delegate type</typeparam>
      <typeparam name="TGeneratedFactoryActivatorData">Activator data type</typeparam>
      <typeparam name="TSingleRegistrationStyle">Registration style</typeparam>
      <param name="registration">Registration to change parameter mapping mode of.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationExtensions.TypedParameterMapping``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
      <summary>
            Changes the parameter mapping mode of the supplied delegate type to match
            parameters by type.
            </summary>
      <typeparam name="TDelegate">Factory delegate type</typeparam>
      <typeparam name="TGeneratedFactoryActivatorData">Activator data type</typeparam>
      <typeparam name="TSingleRegistrationStyle">Registration style</typeparam>
      <param name="registration">Registration to change parameter mapping mode of.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationExtensions.RegisterCollection(Autofac.ContainerBuilder,System.String,System.Type)">
      <summary>
            Registers the type as a collection. If no services or names are specified, the
            default services will be IList&lt;T&gt;, ICollection&lt;T&gt;, and IEnumerable&lt;T&gt;        
            </summary>
      <param name="elementType">The type of the collection elements.</param>
      <param name="builder">Container builder.</param>
      <param name="collectionName">A unique name for the collection that can be passed to MemberOf().</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
      <remarks>Collections are provided automatically in Autofac 2,
            and this method is generally not required.</remarks>
    </member>
    <member name="M:Autofac.Builder.RegistrationExtensions.RegisterCollection``1(Autofac.ContainerBuilder,System.String)">
      <summary>
            Registers the type as a collection. If no services or names are specified, the
            default services will be IList&lt;T&gt;, ICollection&lt;T&gt;, and IEnumerable&lt;T&gt;        
            </summary>
      <typeparam name="T">The type of the collection elements.</typeparam>
      <param name="builder">Container builder.</param>
      <param name="collectionName">A unique name for the collection that can be passed to MemberOf().</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
      <remarks>Collections are provided automatically in Autofac 2,
            and this method is generally not required.</remarks>
    </member>
    <member name="M:Autofac.Builder.RegistrationExtensions.MemberOf``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.String)">
      <summary>
            Include the element explicitly in a collection configured using RegisterCollection.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TSingleRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to export.</param>
      <param name="collectionName">The collection name, as passed to RegisterCollection.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="T:Autofac.Core.Activators.Delegate.DelegateActivatorResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Delegate.DelegateActivatorResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Delegate.DelegateActivatorResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Delegate.DelegateActivatorResources.NullFromActivationDelegateFor">
      <summary>
              Looks up a localized string similar to A delegate registered to create instances of '{0}' returned null..
            </summary>
    </member>
    <member name="T:Autofac.Core.Activators.Reflection.ConstructorParameterBindingResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ConstructorParameterBindingResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ConstructorParameterBindingResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ConstructorParameterBindingResources.BoundConstructor">
      <summary>
              Looks up a localized string similar to Bound constructor '{0}'..
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ConstructorParameterBindingResources.NonBindableConstructor">
      <summary>
              Looks up a localized string similar to Constructor '{0}' parameter resolution failed at parameter '{1}'..
            </summary>
    </member>
    <member name="T:Autofac.Core.Parameter">
      <summary>
            Used in order to provide a value to a constructor parameter or property on an instance
            being created by the container.
            </summary>
      <remarks>
            Not all parameters can be applied to all sites.
            </remarks>
    </member>
    <member name="M:Autofac.Core.Parameter.CanSupplyValue(System.Reflection.ParameterInfo,Autofac.IComponentContext,System.Func{System.Object}@)">
      <summary>
            Returns true if the parameter is able to provide a value to a particular site.
            </summary>
      <param name="pi">Constructor, method, or property-mutator parameter.</param>
      <param name="context">The component context in which the value is being provided.</param>
      <param name="valueProvider">If the result is true, the valueProvider parameter will
            be set to a function that will lazily retrieve the parameter value. If the result is false,
            will be set to null.</param>
      <returns>True if a value can be supplied; otherwise, false.</returns>
    </member>
    <member name="T:Autofac.Core.Activators.Reflection.DefaultValueParameter">
      <summary>
            Provides parameters that have a default value, set with an optional parameter
            declaration in C# or VB.
            </summary>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.DefaultValueParameter.CanSupplyValue(System.Reflection.ParameterInfo,Autofac.IComponentContext,System.Func{System.Object}@)">
      <summary>
            Returns true if the parameter is able to provide a value to a particular site.
            </summary>
      <param name="pi">Constructor, method, or property-mutator parameter.</param>
      <param name="context">The component context in which the value is being provided.</param>
      <param name="valueProvider">If the result is true, the valueProvider parameter will
            be set to a function that will lazily retrieve the parameter value. If the result is false,
            will be set to null.</param>
      <returns>True if a value can be supplied; otherwise, false.</returns>
    </member>
    <member name="T:Autofac.Core.IActivatedEventArgs`1">
      <summary>
            Fired when the activation process for a new instance is complete.
            </summary>
    </member>
    <member name="P:Autofac.Core.IActivatedEventArgs`1.Context">
      <summary>
            The context in which the activation occurred.
            </summary>
    </member>
    <member name="P:Autofac.Core.IActivatedEventArgs`1.Component">
      <summary>
            The component providing the instance.
            </summary>
    </member>
    <member name="P:Autofac.Core.IActivatedEventArgs`1.Parameters">
      <summary>
            The paramters provided when resolved.
            </summary>
    </member>
    <member name="P:Autofac.Core.IActivatedEventArgs`1.Instance">
      <summary>
            The instance that will be used to satisfy the request.
            </summary>
    </member>
    <member name="T:Autofac.Core.IActivatingEventArgs`1">
      <summary>
            Fired after the construction of an instance but before that instance
            is shared with any other or any members are invoked on it.
            </summary>
    </member>
    <member name="M:Autofac.Core.IActivatingEventArgs`1.ReplaceInstance(System.Object)">
      <summary>
            The instance can be replaced if needed, e.g. by an interface proxy.
            </summary>
      <param name="instance">The object to use instead of the activated instance.</param>
    </member>
    <member name="P:Autofac.Core.IActivatingEventArgs`1.Context">
      <summary>
            The context in which the activation occurred.
            </summary>
    </member>
    <member name="P:Autofac.Core.IActivatingEventArgs`1.Component">
      <summary>
            The component providing the instance.
            </summary>
    </member>
    <member name="P:Autofac.Core.IActivatingEventArgs`1.Instance">
      <summary>
            The instance that will be used to satisfy the request.
            </summary>
    </member>
    <member name="P:Autofac.Core.IActivatingEventArgs`1.Parameters">
      <summary>
            The parameters supplied to the activator.
            </summary>
    </member>
    <member name="T:Autofac.Core.IServiceWithType">
      <summary>
            Interface supported by services that carry type information.
            </summary>
    </member>
    <member name="M:Autofac.Core.IServiceWithType.ChangeType(System.Type)">
      <summary>
            Return a new service of the same kind, but carrying
            <paramref name="newType" /> as the <see cref="P:Autofac.Core.IServiceWithType.ServiceType" />.
            </summary>
      <param name="newType">The new service type.</param>
      <returns>A new service with the service type.</returns>
    </member>
    <member name="P:Autofac.Core.IServiceWithType.ServiceType">
      <summary>
            Gets the type of the service.
            </summary>
      <value>The type of the service.</value>
    </member>
    <member name="T:Autofac.Core.Service">
      <summary>
            Services are the lookup keys used to locate component instances.
            </summary>
    </member>
    <member name="M:Autofac.Core.Service.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Autofac.Core.Service.op_Equality(Autofac.Core.Service,Autofac.Core.Service)">
      <summary>
            Implements the operator ==.
            </summary>
      <param name="lhs">The LHS.</param>
      <param name="rhs">The RHS.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Autofac.Core.Service.op_Inequality(Autofac.Core.Service,Autofac.Core.Service)">
      <summary>
            Implements the operator !=.
            </summary>
      <param name="lhs">The LHS.</param>
      <param name="rhs">The RHS.</param>
      <returns>The result of the operator.</returns>
    </member>
    <member name="M:Autofac.Core.Service.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception>
    </member>
    <member name="M:Autofac.Core.Service.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:Autofac.Core.Service.Description">
      <summary>
            Gets a human-readable description of the service.
            </summary>
      <value>The description.</value>
    </member>
    <member name="T:Autofac.Core.KeyedService">
      <summary>
            Identifies a service using a key in addition to its type.
            </summary>
    </member>
    <member name="M:Autofac.Core.KeyedService.#ctor(System.Object,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.KeyedService" /> class.
            </summary>
      <param name="serviceKey">Key of the service.</param>
      <param name="serviceType">Type of the service.</param>
    </member>
    <member name="M:Autofac.Core.KeyedService.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception>
    </member>
    <member name="M:Autofac.Core.KeyedService.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Autofac.Core.KeyedService.ChangeType(System.Type)">
      <summary>
            Return a new service of the same kind, but carrying
            <paramref name="newType" /> as the <see cref="P:Autofac.Core.KeyedService.ServiceType" />.
            </summary>
      <param name="newType">The new service type.</param>
      <returns>A new service with the service type.</returns>
    </member>
    <member name="P:Autofac.Core.KeyedService.ServiceKey">
      <summary>
            Gets or sets the key of the service.
            </summary>
      <value>The key of the service.</value>
    </member>
    <member name="P:Autofac.Core.KeyedService.ServiceType">
      <summary>
            Gets the type of the service.
            </summary>
      <value>The type of the service.</value>
    </member>
    <member name="P:Autofac.Core.KeyedService.Description">
      <summary>
            Gets a human-readable description of the service.
            </summary>
      <value>The description.</value>
    </member>
    <member name="T:Autofac.Util.Disposable">
      <summary>
            Base class for disposable objects.
            </summary>
    </member>
    <member name="M:Autofac.Util.Disposable.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="M:Autofac.Util.Disposable.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="T:Autofac.Core.IComponentRegistration">
      <summary>
            Describes a logical component within the container.
            </summary>
    </member>
    <member name="M:Autofac.Core.IComponentRegistration.RaisePreparing(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter}@)">
      <summary>
            Called by the container when an instance is required.
            </summary>
      <param name="context">The context in which the instance will be activated.</param>
      <param name="parameters">Parameters for activation. These may be modified by the event handler.</param>
    </member>
    <member name="M:Autofac.Core.IComponentRegistration.RaiseActivating(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.Object@)">
      <summary>
            Called by the container once an instance has been constructed.
            </summary>
      <param name="context">The context in which the instance was activated.</param>
      <param name="parameters">The parameters supplied to the activator.</param>
      <param name="instance">The instance.</param>
    </member>
    <member name="M:Autofac.Core.IComponentRegistration.RaiseActivated(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.Object)">
      <summary>
            Called by the container once an instance has been fully constructed, including
            any requested objects that depend on the instance.
            </summary>
      <param name="context">The context in which the instance was activated.</param>
      <param name="parameters">The parameters supplied to the activator.</param>
      <param name="instance">The instance.</param>
    </member>
    <member name="P:Autofac.Core.IComponentRegistration.Id">
      <summary>
            A unique identifier for this component (shared in all sub-contexts.)
            This value also appears in Services.
            </summary>
    </member>
    <member name="P:Autofac.Core.IComponentRegistration.Activator">
      <summary>
            The activator used to create instances.
            </summary>
    </member>
    <member name="P:Autofac.Core.IComponentRegistration.Lifetime">
      <summary>
            The lifetime associated with the component.
            </summary>
    </member>
    <member name="P:Autofac.Core.IComponentRegistration.Sharing">
      <summary>
            Whether the component instances are shared or not.
            </summary>
    </member>
    <member name="P:Autofac.Core.IComponentRegistration.Ownership">
      <summary>
            Whether the instances of the component should be disposed by the container.
            </summary>
    </member>
    <member name="P:Autofac.Core.IComponentRegistration.Services">
      <summary>
            The services provided by the component.
            </summary>
    </member>
    <member name="P:Autofac.Core.IComponentRegistration.Metadata">
      <summary>
            Additional data associated with the component.
            </summary>
    </member>
    <member name="P:Autofac.Core.IComponentRegistration.Target">
      <summary>
            The component registration upon which this registration is based.
            </summary>
    </member>
    <member name="E:Autofac.Core.IComponentRegistration.Preparing">
      <summary>
            Fired when a new instance is required. The instance can be
            provided in order to skip the regular activator, by setting the Instance property in
            the provided event arguments.
            </summary>
    </member>
    <member name="E:Autofac.Core.IComponentRegistration.Activating">
      <summary>
            Fired when a new instance is being activated. The instance can be
            wrapped or switched at this time by setting the Instance property in
            the provided event arguments.
            </summary>
    </member>
    <member name="E:Autofac.Core.IComponentRegistration.Activated">
      <summary>
            Fired when the activation process for a new instance is complete.
            </summary>
    </member>
    <member name="T:Autofac.Core.Registration.ComponentRegistrationLifetimeDecorator">
      <summary>
            Wraps a component registration, switching its lifetime.
            </summary>
    </member>
    <member name="T:Autofac.Core.Registration.ComponentRegistrationResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistrationResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistrationResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistrationResources.ToStringFormat">
      <summary>
              Looks up a localized string similar to Activator = {0}, Services = [{1}], Lifetime = {2}, Sharing = {3}, Ownership = {4}.
            </summary>
    </member>
    <member name="T:Autofac.Core.IRegistrationSource">
      <summary>
            Allows registrations to be made on-the-fly when unregistered
            services are requested (lazy registrations.)
            </summary>
    </member>
    <member name="M:Autofac.Core.IRegistrationSource.RegistrationsFor(Autofac.Core.Service,System.Func{Autofac.Core.Service,System.Collections.Generic.IEnumerable{Autofac.Core.IComponentRegistration}})">
      <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
      <param name="service">The service that was requested.</param>
      <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
      <returns>Registrations providing the service.</returns>
    </member>
    <member name="P:Autofac.Core.IRegistrationSource.IsAdapterForIndividualComponents">
      <summary>
            Gets whether the registrations provided by this source are 1:1 adapters on top
            of other components (I.e. like Meta, Func or Owned.)
            </summary>
    </member>
    <member name="T:Autofac.Core.Registration.ExternalRegistrySource">
      <summary>
            Pulls registrations from another component registry.
            Excludes most auto-generated registrations - currently has issues with
            collection registrations.
            </summary>
    </member>
    <member name="M:Autofac.Core.Registration.ExternalRegistrySource.#ctor(Autofac.Core.IComponentRegistry)">
      <summary>
            Create an external registry source that draws components from
            <paramref name="registry" />.
            </summary>
      <param name="registry">Component registry to pull registrations from.</param>
    </member>
    <member name="M:Autofac.Core.Registration.ExternalRegistrySource.RegistrationsFor(Autofac.Core.Service,System.Func{Autofac.Core.Service,System.Collections.Generic.IEnumerable{Autofac.Core.IComponentRegistration}})">
      <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
      <param name="service">The service that was requested.</param>
      <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
      <returns>Registrations providing the service.</returns>
    </member>
    <member name="P:Autofac.Core.Registration.ExternalRegistrySource.IsAdapterForIndividualComponents">
      <summary>
            In this case because the components that are adapted do not come from the same
            logical scope, we must return false to avoid duplicating them.
            </summary>
    </member>
    <member name="T:Autofac.Core.IComponentRegistry">
      <summary>
            Provides component registrations according to the services they provide.
            </summary>
    </member>
    <member name="M:Autofac.Core.IComponentRegistry.TryGetRegistration(Autofac.Core.Service,Autofac.Core.IComponentRegistration@)">
      <summary>
            Attempts to find a default registration for the specified service.
            </summary>
      <param name="service">The service to look up.</param>
      <param name="registration">The default registration for the service.</param>
      <returns>True if a registration exists.</returns>
    </member>
    <member name="M:Autofac.Core.IComponentRegistry.IsRegistered(Autofac.Core.Service)">
      <summary>
            Determines whether the specified service is registered.
            </summary>
      <param name="service">The service to test.</param>
      <returns>True if the service is registered.</returns>
    </member>
    <member name="M:Autofac.Core.IComponentRegistry.Register(Autofac.Core.IComponentRegistration)">
      <summary>
            Register a component.
            </summary>
      <param name="registration">The component registration.</param>
    </member>
    <member name="M:Autofac.Core.IComponentRegistry.Register(Autofac.Core.IComponentRegistration,System.Boolean)">
      <summary>
            Register a component.
            </summary>
      <param name="registration">The component registration.</param>
      <param name="preserveDefaults">If true, existing defaults for the services provided by the
            component will not be changed.</param>
    </member>
    <member name="M:Autofac.Core.IComponentRegistry.RegistrationsFor(Autofac.Core.Service)">
      <summary>
            Selects from the available registrations after ensuring that any
            dynamic registration sources that may provide <paramref name="service" />
            have been invoked.
            </summary>
      <param name="service">The service for which registrations are sought.</param>
      <returns>Registrations supporting <paramref name="service" />.</returns>
    </member>
    <member name="M:Autofac.Core.IComponentRegistry.AddRegistrationSource(Autofac.Core.IRegistrationSource)">
      <summary>
            Add a registration source that will provide registrations on-the-fly.
            </summary>
      <param name="source">The source to register.</param>
    </member>
    <member name="P:Autofac.Core.IComponentRegistry.Registrations">
      <summary>
            Enumerate the registered components.
            </summary>
    </member>
    <member name="P:Autofac.Core.IComponentRegistry.Sources">
      <summary>
            Gets the registration sources that are used by the registry.
            </summary>
    </member>
    <member name="E:Autofac.Core.IComponentRegistry.Registered">
      <summary>
            Fired whenever a component is registered - either explicitly or via a
            <see cref="T:Autofac.Core.IRegistrationSource" />.
            </summary>
    </member>
    <member name="T:Autofac.Core.Registration.ComponentRegistry">
      <summary>
            Maps services onto the components that provide them.
            </summary>
      <remarks>
            The component registry provides services directly from components,
            and also uses <see cref="T:Autofac.Core.IRegistrationSource" /> to generate components
            on-the-fly or as adapters for other components. A component registry
            is normally used through a <see cref="T:Autofac.ContainerBuilder" />, and not
            directly by application code.
            </remarks>
    </member>
    <member name="F:Autofac.Core.Registration.ComponentRegistry._synchRoot">
      <summary>
            Protects instance variables from concurrent access.
            </summary>
    </member>
    <member name="F:Autofac.Core.Registration.ComponentRegistry._dynamicRegistrationSources">
      <summary>
            External registration sources.
            </summary>
    </member>
    <member name="F:Autofac.Core.Registration.ComponentRegistry._registrations">
      <summary>
            All registrations.
            </summary>
    </member>
    <member name="F:Autofac.Core.Registration.ComponentRegistry._serviceInfo">
      <summary>
            Keeps track of the status of registered services.
            </summary>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistry.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistry.TryGetRegistration(Autofac.Core.Service,Autofac.Core.IComponentRegistration@)">
      <summary>
            Attempts to find a default registration for the specified service.
            </summary>
      <param name="service">The service to look up.</param>
      <param name="registration">The default registration for the service.</param>
      <returns>True if a registration exists.</returns>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistry.IsRegistered(Autofac.Core.Service)">
      <summary>
            Determines whether the specified service is registered.
            </summary>
      <param name="service">The service to test.</param>
      <returns>True if the service is registered.</returns>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistry.Register(Autofac.Core.IComponentRegistration)">
      <summary>
            Register a component.
            </summary>
      <param name="registration">The component registration.</param>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistry.Register(Autofac.Core.IComponentRegistration,System.Boolean)">
      <summary>
            Register a component.
            </summary>
      <param name="registration">The component registration.</param>
      <param name="preserveDefaults">If true, existing defaults for the services provided by the
            component will not be changed.</param>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistry.RegistrationsFor(Autofac.Core.Service)">
      <summary>
            Selects from the available registrations after ensuring that any
            dynamic registration sources that may provide <paramref name="service" />
            have been invoked.
            </summary>
      <param name="service">The service for which registrations are sought.</param>
      <returns>Registrations supporting <paramref name="service" />.</returns>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistry.AddRegistrationSource(Autofac.Core.IRegistrationSource)">
      <summary>
            Add a registration source that will provide registrations on-the-fly.
            </summary>
      <param name="source">The source to register.</param>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistry.Registrations">
      <summary>
            Enumerate the registered components.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistry.Sources">
      <summary>
            Gets the registration sources that are used by the registry.
            </summary>
    </member>
    <member name="E:Autofac.Core.Registration.ComponentRegistry.Registered">
      <summary>
            Fired whenever a component is registered - either explicitly or via a
            <see cref="T:Autofac.Core.IRegistrationSource" />.
            </summary>
    </member>
    <member name="T:Autofac.Core.Registration.ScopeRestrictedRegistry">
      <summary>
            Switches components with a RootScopeLifetime (singletons) with
            decorators exposing MatchingScopeLifetime targeting the specified scope.
            </summary>
    </member>
    <member name="T:Autofac.Core.Registration.ServiceRegistrationInfo">
      <summary>
            Tracks the services known to the registry.
            </summary>
    </member>
    <member name="F:Autofac.Core.Registration.ServiceRegistrationInfo._sourcesToQuery">
      <summary>
            Used for bookkeeping so that the same source is not queried twice (may be null.)
            </summary>
    </member>
    <member name="M:Autofac.Core.Registration.ServiceRegistrationInfo.#ctor(Autofac.Core.Service)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.Registration.ServiceRegistrationInfo" /> class.
            </summary>
      <param name="service">The tracked service.</param>
    </member>
    <member name="P:Autofac.Core.Registration.ServiceRegistrationInfo.IsInitialized">
      <summary>
            The first time a service is requested, initialization (e.g. reading from sources)
            happens. This value will then be set to true. Calling many methods on this type before
            initialisation is an error.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ServiceRegistrationInfo.Implementations">
      <summary>
            The known implementations.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ServiceRegistrationInfo.IsRegistered">
      <summary>
            True if any implementations are known.
            </summary>
    </member>
    <member name="T:Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData">
      <summary>
            Describes the basic requirements for generating a lightweight adapter.
            </summary>
    </member>
    <member name="M:Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData.#ctor(Autofac.Core.Service,System.Func{Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.Object,System.Object})">
      <summary>
            Create an instance of <see cref="T:Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData" />.
            </summary>
      <param name="fromService">The service that will be adapted from.</param>
      <param name="adapter">The adapter function.</param>
    </member>
    <member name="P:Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData.Adapter">
      <summary>
            The adapter function.
            </summary>
    </member>
    <member name="P:Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData.FromService">
      <summary>
            The service to be adapted from.
            </summary>
    </member>
    <member name="T:Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationSourceResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationSourceResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationSourceResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationSourceResources.FromAndToMustDiffer">
      <summary>
              Looks up a localized string similar to The service {0} cannot be both the adapter's from and to parameters - these must differ..
            </summary>
    </member>
    <member name="T:Autofac.Features.Collections.CollectionRegistrationExtensions">
      <summary>
            Internal implementation of the RegisterCollection/MemberOf-style collection feature.
            </summary>
    </member>
    <member name="T:Autofac.Builder.DynamicRegistrationStyle">
      <summary>
            Registration style for dynamic registrations.
            </summary>
    </member>
    <member name="T:Autofac.Features.GeneratedFactories.GeneratedFactoryActivatorData">
      <summary>
            Data used to create factory activators.
            </summary>
    </member>
    <member name="M:Autofac.Features.GeneratedFactories.GeneratedFactoryActivatorData.#ctor(System.Type,Autofac.Core.Service)">
      <summary>
            Create a new GeneratedFactoryActivatorData
            </summary>
      <param name="delegateType">The type of the factory.</param>
      <param name="productService">The service used to provide the products of the factory.</param>
    </member>
    <member name="P:Autofac.Features.GeneratedFactories.GeneratedFactoryActivatorData.ParameterMapping">
      <summary>
            Determines how the parameters of the delegate type are passed on
            to the generated Resolve() call as Parameter objects.
            For Func-based delegates, this defaults to ByType. Otherwise, the
            parameters will be mapped by name.
            </summary>
    </member>
    <member name="P:Autofac.Features.GeneratedFactories.GeneratedFactoryActivatorData.Activator">
      <summary>
            Activator data that can provide an IInstanceActivator instance.
            </summary>
    </member>
    <member name="T:Autofac.Builder.IHideObjectMembers">
      <summary>
            Hides standard Object members to make fluent interfaces
            easier to read.
            Based on blog post by @kzu here:
            http://www.clariusconsulting.net/blogs/kzu/archive/2008/03/10/58301.aspx
            </summary>
    </member>
    <member name="M:Autofac.Builder.IHideObjectMembers.GetType">
      <summary>
            Standard System.Object member.
            </summary>
      <returns>Standard result.</returns>
    </member>
    <member name="M:Autofac.Builder.IHideObjectMembers.GetHashCode">
      <summary>
            Standard System.Object member.
            </summary>
      <returns>Standard result.</returns>
    </member>
    <member name="M:Autofac.Builder.IHideObjectMembers.ToString">
      <summary>
            Standard System.Object member.
            </summary>
      <returns>Standard result.</returns>
    </member>
    <member name="M:Autofac.Builder.IHideObjectMembers.Equals(System.Object)">
      <summary>
            Standard System.Object member.
            </summary>
      <param name="other">The other.</param>
      <returns>Standard result.</returns>
    </member>
    <member name="T:Autofac.Features.GeneratedFactories.ParameterMapping">
      <summary>
            Determines how the parameters of the delegate type are passed on
            to the generated Resolve() call as Parameter objects.
            </summary>
    </member>
    <member name="F:Autofac.Features.GeneratedFactories.ParameterMapping.Adaptive">
      <summary>
            Chooses parameter mapping based on the factory type.
            For Func-based factories this is equivalent to ByType, for all
            others ByName will be used.
            </summary>
    </member>
    <member name="F:Autofac.Features.GeneratedFactories.ParameterMapping.ByName">
      <summary>
            Pass the parameters supplied to the delegate through to the
            underlying registration as NamedParameters based on the parameter
            names in the delegate type's formal argument list.
            </summary>
    </member>
    <member name="F:Autofac.Features.GeneratedFactories.ParameterMapping.ByType">
      <summary>
            Pass the parameters supplied to the delegate through to the
            underlying registration as TypedParameters based on the parameter
            types in the delegate type's formal argument list.
            </summary>
    </member>
    <member name="F:Autofac.Features.GeneratedFactories.ParameterMapping.ByPosition">
      <summary>
            Pass the parameters supplied to the delegate through to the
            underlying registration as PositionalParameters based on the parameter
            indices in the delegate type's formal argument list.
            </summary>
    </member>
    <member name="T:Autofac.Features.Indexed.IIndex`2">
      <summary>
            Provides components by lookup operations via an index (key) type.
            </summary>
      <typeparam name="TKey">The type of the index.</typeparam>
      <typeparam name="TValue">The service provided by the indexed components.</typeparam>
      <example>
            Retrieving a value given a key:
            <code>
            IIndex&lt;AccountType, IRenderer&gt; accountRenderers = // ...
            var renderer = accountRenderers[AccountType.User];
            </code></example>
    </member>
    <member name="M:Autofac.Features.Indexed.IIndex`2.TryGetValue(`0,`1@)">
      <summary>
            Get the value associated with <paramref name="key" /> if any is available.
            </summary>
      <param name="key">The key to look up.</param>
      <param name="value">The retrieved value.</param>
      <returns>True if a value associated with the key exists.</returns>
    </member>
    <member name="P:Autofac.Features.Indexed.IIndex`2.Item(`0)">
      <summary>
            Get the value associated with <paramref name="key" />.
            </summary>
      <param name="key">The value to retrieve.</param>
      <returns>The associated value.</returns>
    </member>
    <member name="T:Autofac.Features.Metadata.MetaRegistrationSource">
      <summary>
            Support the <see cref="T:Autofac.Features.Metadata.Meta`1" />
            types automatically whenever type T is registered with the container.
            Metadata values come from the component registration's metadata.
            </summary>
    </member>
    <member name="T:Autofac.Features.Metadata.Meta`1">
      <summary>
            Provides a value along with a dictionary of metadata describing the value.
            </summary>
      <typeparam name="T">The type of the value.</typeparam>
    </member>
    <member name="M:Autofac.Features.Metadata.Meta`1.#ctor(`0,System.Collections.Generic.IDictionary{System.String,System.Object})">
      <summary>
            Create a new instance.
            </summary>
      <param name="value">The value described by the instance.</param>
      <param name="metadata">The metadata describing the value.</param>
    </member>
    <member name="P:Autofac.Features.Metadata.Meta`1.Value">
      <summary>
            The value described by <see cref="P:Autofac.Features.Metadata.Meta`1.Metadata" />.
            </summary>
    </member>
    <member name="P:Autofac.Features.Metadata.Meta`1.Metadata">
      <summary>
            Metadata describing the value.
            </summary>
    </member>
    <member name="T:Autofac.Features.OpenGenerics.OpenGenericRegistrationExtensionsResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Features.OpenGenerics.OpenGenericRegistrationExtensionsResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Features.OpenGenerics.OpenGenericRegistrationExtensionsResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Features.OpenGenerics.OpenGenericRegistrationExtensionsResources.ImplementorMustBeOpenGenericType">
      <summary>
              Looks up a localized string similar to The type {0} is not an open generic type definition..
            </summary>
    </member>
    <member name="T:Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource">
      <summary>
            Provides registrations on-the-fly for any concrete type not already registered with
            the container.
            </summary>
    </member>
    <member name="M:Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource" /> class.
            </summary>
    </member>
    <member name="M:Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource.#ctor(System.Func{System.Type,System.Boolean})">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource" /> class.
            </summary>
      <param name="predicate">A predicate that selects types the source will register.</param>
    </member>
    <member name="M:Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource.RegistrationsFor(Autofac.Core.Service,System.Func{Autofac.Core.Service,System.Collections.Generic.IEnumerable{Autofac.Core.IComponentRegistration}})">
      <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
      <param name="service">The service that was requested.</param>
      <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
      <returns>Registrations providing the service.</returns>
    </member>
    <member name="P:Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource.IsAdapterForIndividualComponents">
      <summary>
            Gets whether the registrations provided by this source are 1:1 adapters on top
            of other components (I.e. like Meta, Func or Owned.)
            </summary>
    </member>
    <member name="T:Autofac.Features.Scanning.ScanningActivatorData">
      <summary>
            Activation data for types located by scanning assemblies.
            </summary>
    </member>
    <member name="M:Autofac.Features.Scanning.ScanningActivatorData.#ctor">
      <summary>
            Create an instance of <see cref="T:Autofac.Features.Scanning.ScanningActivatorData" />.
            </summary>
    </member>
    <member name="P:Autofac.Features.Scanning.ScanningActivatorData.Filters">
      <summary>
            The filters applied to the types from the scanned assembly.
            </summary>
    </member>
    <member name="P:Autofac.Features.Scanning.ScanningActivatorData.ConfigurationActions">
      <summary>
            Additional actions to be performed on the concrete type registrations.
            </summary>
    </member>
    <member name="P:Autofac.Features.Scanning.ScanningActivatorData.PostScanningCallbacks">
      <summary>
            Actions to be called once the scanning operation is complete.
            </summary>
    </member>
    <member name="T:Autofac.Core.ActivatedEventArgs`1">
      <summary>
            Fired when the activation process for a new instance is complete.
            </summary>
    </member>
    <member name="M:Autofac.Core.ActivatedEventArgs`1.#ctor(Autofac.IComponentContext,Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},`0)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.ActivatedEventArgs`1" /> class.
            </summary>
      <param name="context">The context.</param>
      <param name="component">The component.</param>
      <param name="parameters">The parameters.</param>
      <param name="instance">The instance.</param>
    </member>
    <member name="P:Autofac.Core.ActivatedEventArgs`1.Context">
      <summary>
            The context in which the activation occurred.
            </summary>
    </member>
    <member name="P:Autofac.Core.ActivatedEventArgs`1.Component">
      <summary>
            The component providing the instance.
            </summary>
    </member>
    <member name="P:Autofac.Core.ActivatedEventArgs`1.Parameters">
      <summary>
            The paramters provided when resolved.
            </summary>
    </member>
    <member name="P:Autofac.Core.ActivatedEventArgs`1.Instance">
      <summary>
            The instance that will be used to satisfy the request.
            </summary>
    </member>
    <member name="T:Autofac.Core.ActivatingEventArgs`1">
      <summary>
            Fired after the construction of an instance but before that instance
            is shared with any other or any members are invoked on it.
            </summary>
    </member>
    <member name="M:Autofac.Core.ActivatingEventArgs`1.#ctor(Autofac.IComponentContext,Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},`0)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.ActivatedEventArgs`1" /> class.
            </summary>
      <param name="context">The context.</param>
      <param name="component">The component.</param>
      <param name="parameters">The parameters.</param>
      <param name="instance">The instance.</param>
    </member>
    <member name="P:Autofac.Core.ActivatingEventArgs`1.Context">
      <summary>
            The context in which the activation occurred.
            </summary>
    </member>
    <member name="P:Autofac.Core.ActivatingEventArgs`1.Component">
      <summary>
            The component providing the instance.
            </summary>
    </member>
    <member name="P:Autofac.Core.ActivatingEventArgs`1.Instance">
      <summary>
            The instance that will be used to satisfy the request.
            </summary>
      <remarks>
            The instance can be replaced if needed, e.g. by an interface proxy.
            </remarks>
    </member>
    <member name="P:Autofac.Core.ActivatingEventArgs`1.Parameters">
      <summary>
            The parameters supplied to the activator.
            </summary>
    </member>
    <member name="T:Autofac.Core.Activators.InstanceActivator">
      <summary>
            Base class for instance activators.
            </summary>
    </member>
    <member name="M:Autofac.Core.Activators.InstanceActivator.#ctor(System.Type)">
      <summary>
            Create an instance activator that will return instances compatible
            with <paramref name="limitType" />.
            </summary>
      <param name="limitType">Most derived type to which instances can be cast.</param>
    </member>
    <member name="M:Autofac.Core.Activators.InstanceActivator.ToString">
      <summary>
            Gets a string representation of the activator.
            </summary>
      <returns>A string describing the activator.</returns>
    </member>
    <member name="P:Autofac.Core.Activators.InstanceActivator.LimitType">
      <summary>
            The most specific type that the component instances are known to be castable to.
            </summary>
    </member>
    <member name="T:Autofac.Core.IInstanceActivator">
      <summary>
            Activates component instances.
            </summary>
    </member>
    <member name="M:Autofac.Core.IInstanceActivator.ActivateInstance(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Activate an instance in the provided context.
            </summary>
      <param name="context">Context in which to activate instances.</param>
      <param name="parameters">Parameters to the instance.</param>
      <returns>The activated instance.</returns>
      <remarks>
            The context parameter here should probably be ILifetimeScope in order to reveal Disposer,
            but will wait until implementing a concrete use case to make the decision
            </remarks>
    </member>
    <member name="P:Autofac.Core.IInstanceActivator.LimitType">
      <summary>
            The most specific type that the component instances are known to be castable to.
            </summary>
    </member>
    <member name="T:Autofac.Core.Activators.Delegate.DelegateActivator">
      <summary>
            Activate instances using a delegate.
            </summary>
    </member>
    <member name="M:Autofac.Core.Activators.Delegate.DelegateActivator.#ctor(System.Type,System.Func{Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.Object})">
      <summary>
            Create a delegate activator.
            </summary>
      <param name="limitType">The most specific type to which activated instances can be cast.</param>
      <param name="activationFunction">Activation delegate.</param>
    </member>
    <member name="M:Autofac.Core.Activators.Delegate.DelegateActivator.ActivateInstance(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Activate an instance in the provided context.
            </summary>
      <param name="context">Context in which to activate instances.</param>
      <param name="parameters">Parameters to the instance.</param>
      <returns>The activated instance.</returns>
      <remarks>
            The context parameter here should probably be ILifetimeScope in order to reveal Disposer,
            but will wait until implementing a concrete use case to make the decision
            </remarks>
    </member>
    <member name="T:Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator">
      <summary>
            Provides a pre-constructed instance.
            </summary>
    </member>
    <member name="M:Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator.#ctor(System.Object)">
      <summary>
            Provide the specified instance.
            </summary>
      <param name="instance">The instance to provide.</param>
    </member>
    <member name="M:Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator.ActivateInstance(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Activate an instance in the provided context.
            </summary>
      <param name="context">Context in which to activate instances.</param>
      <param name="parameters">Parameters to the instance.</param>
      <returns>The activated instance.</returns>
      <remarks>
            The context parameter here should probably be ILifetimeScope in order to reveal Disposer,
            but will wait until implementing a concrete use case to make the decision
            </remarks>
    </member>
    <member name="M:Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="P:Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator.DisposeInstance">
      <summary>
            Determines whether the activator disposes the instance that it holds.
            Necessary because otherwise instances that are never resolved will never be
            disposed.
            </summary>
    </member>
    <member name="T:Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivatorResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivatorResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivatorResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivatorResources.InstanceAlreadyActivated">
      <summary>
              Looks up a localized string similar to The provided instance has already been used in an activation request. Did you combine a provided instance with non-root/single-instance lifetime/sharing?.
            </summary>
    </member>
    <member name="T:Autofac.Core.Activators.Reflection.AutowiringParameter">
      <summary>
            Supplies values based on the target parameter type.
            </summary>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.AutowiringParameter.CanSupplyValue(System.Reflection.ParameterInfo,Autofac.IComponentContext,System.Func{System.Object}@)">
      <summary>
            Returns true if the parameter is able to provide a value to a particular site.
            </summary>
      <param name="pi">Constructor, method, or property-mutator parameter.</param>
      <param name="context">The component context in which the value is being provided.</param>
      <param name="valueProvider">If the result is true, the valueProvider parameter will
            be set to a function that will lazily retrieve the parameter value. If the result is false,
            will be set to null.</param>
      <returns>True if a value can be supplied; otherwise, false.</returns>
    </member>
    <member name="T:Autofac.Core.Activators.Reflection.IConstructorFinder">
      <summary>
            Find suitable constructors from which to select.
            </summary>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.IConstructorFinder.FindConstructors(System.Type)">
      <summary>
            Finds suitable constructors on the target type.
            </summary>
      <param name="targetType">Type to search for constructors.</param>
      <returns>Suitable constructors.</returns>
    </member>
    <member name="T:Autofac.Core.Activators.Reflection.BindingFlagsConstructorFinder">
      <summary>
            Finds constructors based on their binding flags.
            </summary>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.BindingFlagsConstructorFinder.#ctor(System.Reflection.BindingFlags)">
      <summary>
            Create an instance matching constructors with the supplied binding flags.
            </summary>
      <param name="bindingFlags">Binding flags to match.</param>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.BindingFlagsConstructorFinder.FindConstructors(System.Type)">
      <summary>
            Finds suitable constructors on the target type.
            </summary>
      <param name="targetType">Type to search for constructors.</param>
      <returns>Suitable constructors.</returns>
    </member>
    <member name="T:Autofac.Core.Activators.Reflection.ConstructorParameterBinding">
      <summary>
            Binds a constructor to the parameters that will be used when it is invoked.
            </summary>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.ConstructorParameterBinding.#ctor(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},Autofac.IComponentContext)">
      <summary>
            Construct a new ConstructorParameterBinding.
            </summary>
      <param name="ci">ConstructorInfo to bind.</param>
      <param name="availableParameters">Available parameters.</param>
      <param name="context">Context in which to construct instance.</param>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate">
      <summary>
            Invoke the constructor with the parameter bindings.
            </summary>
      <returns>The constructed instance.</returns>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.ConstructorParameterBinding.ToString">
      <summary>Returns a System.String that represents the current System.Object.</summary>
      <returns>A System.String that represents the current System.Object.</returns>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ConstructorParameterBinding.TargetConstructor">
      <summary>
            The constructor on the target type. The actual constructor used
            might differ, e.g. if using a dynamic proxy.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ConstructorParameterBinding.CanInstantiate">
      <summary>
            True if the binding is valid.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Description">
      <summary>
            Describes the constructor parameter binding.
            </summary>
    </member>
    <member name="T:Autofac.Core.Activators.Reflection.IConstructorSelector">
      <summary>
            Selects the best constructor from a set of available constructors.
            </summary>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.IConstructorSelector.SelectConstructorBinding(System.Collections.Generic.IEnumerable{Autofac.Core.Activators.Reflection.ConstructorParameterBinding})">
      <summary>
            Selects the best constructor from the available constructors.
            </summary>
      <param name="constructorBindings">Available constructors.</param>
      <returns>The best constructor.</returns>
    </member>
    <member name="T:Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelector">
      <summary>
            Selects a constructor based on its signature.
            </summary>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelector.#ctor(System.Type[])">
      <summary>
            Match constructors with the provided signature.
            </summary>
      <param name="signature">Signature to match.</param>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelector.SelectConstructorBinding(System.Collections.Generic.IEnumerable{Autofac.Core.Activators.Reflection.ConstructorParameterBinding})">
      <summary>
            Selects the best constructor from the available constructors.
            </summary>
      <param name="constructorBindings">Available constructors.</param>
      <returns>The best constructor.</returns>
    </member>
    <member name="T:Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelectorResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelectorResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelectorResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelectorResources.RequiredConstructorNotAvailable">
      <summary>
              Looks up a localized string similar to The required constructor is unavailable..
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelectorResources.TooManyConstructorsMatch">
      <summary>
              Looks up a localized string similar to More than one constructor matches the selection policy..
            </summary>
    </member>
    <member name="T:Autofac.Core.Activators.Reflection.MostParametersConstructorSelector">
      <summary>
            Selects the constructor with the most parameters.
            </summary>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.MostParametersConstructorSelector.SelectConstructorBinding(System.Collections.Generic.IEnumerable{Autofac.Core.Activators.Reflection.ConstructorParameterBinding})">
      <summary>
            Selects the best constructor from the available constructors.
            </summary>
      <param name="constructorBindings">Available constructors.</param>
      <returns>The best constructor.</returns>
    </member>
    <member name="T:Autofac.Core.Activators.Reflection.ReflectionActivator">
      <summary>
            Uses reflection to activate instances of a type.
            </summary>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.ReflectionActivator.#ctor(System.Type,Autofac.Core.Activators.Reflection.IConstructorFinder,Autofac.Core.Activators.Reflection.IConstructorSelector,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Create an activator for the provided type.
            </summary>
      <param name="implementationType">Type to activate.</param>
      <param name="constructorFinder">Constructor finder.</param>
      <param name="constructorSelector">Constructor selector.</param>
      <param name="configuredParameters">Parameters configured explicitly for this instance.</param>
      <param name="configuredProperties">Properties configured explicitly for this instance.</param>
    </member>
    <member name="M:Autofac.Core.Activators.Reflection.ReflectionActivator.ActivateInstance(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Activate an instance in the provided context.
            </summary>
      <param name="context">Context in which to activate instances.</param>
      <param name="parameters">Parameters to the instance.</param>
      <returns>The activated instance.</returns>
      <remarks>
            The context parameter here should probably be ILifetimeScope in order to reveal Disposer,
            but will wait until implementing a concrete use case to make the decision
            </remarks>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ReflectionActivator.ConstructorFinder">
      <summary>
            The constructor finder.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ReflectionActivator.ConstructorSelector">
      <summary>
            The constructor selector.
            </summary>
    </member>
    <member name="T:Autofac.Core.Activators.Reflection.ReflectionActivatorResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ReflectionActivatorResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ReflectionActivatorResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ReflectionActivatorResources.NoConstructorsAvailable">
      <summary>
              Looks up a localized string similar to No constructors matching the constructor-finding policy can be found on the target type..
            </summary>
    </member>
    <member name="P:Autofac.Core.Activators.Reflection.ReflectionActivatorResources.NoConstructorsBindable">
      <summary>
              Looks up a localized string similar to None of the constructors found with policy '{0}' on type '{1}' can be invoked with the available services and parameters:{2}.
            </summary>
    </member>
    <member name="T:Autofac.Core.ConstantParameter">
      <summary>
            Base class for parameters that provide a constant value.
            </summary>
    </member>
    <member name="M:Autofac.Core.ConstantParameter.#ctor(System.Object,System.Predicate{System.Reflection.ParameterInfo})">
      <summary>
            Create a constant parameter that will apply to parameters matching
            the supplied predicate.
            </summary>
      <param name="value">
      </param>
      <param name="predicate">
      </param>
    </member>
    <member name="M:Autofac.Core.ConstantParameter.CanSupplyValue(System.Reflection.ParameterInfo,Autofac.IComponentContext,System.Func{System.Object}@)">
      <summary>
            Returns true if the parameter is able to provide a value to a particular site.
            </summary>
      <param name="pi">Constructor, method, or property-mutator parameter.</param>
      <param name="context">The component context in which the value is being provided.</param>
      <param name="valueProvider">If the result is true, the valueProvider parameter will
            be set to a function that will lazily retrieve the parameter value. If the result is false,
            will be set to null.</param>
      <returns>True if a value can be supplied; otherwise, false.</returns>
    </member>
    <member name="P:Autofac.Core.ConstantParameter.Value">
      <summary>
            The value of the parameter.
            </summary>
    </member>
    <member name="T:Autofac.IComponentContext">
      <summary>
            The context in which a service can be accessed or a component's
            dependencies resolved. Disposal of a context will dispose any owned
            components.
            </summary>
    </member>
    <member name="M:Autofac.IComponentContext.Resolve(Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Resolve an instance of the provided registration within the context.
            </summary>
      <param name="registration">The registration.</param>
      <param name="parameters">Parameters for the instance.</param>
      <returns>
            The component instance.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="P:Autofac.IComponentContext.ComponentRegistry">
      <summary>
            Associates services with the components that provide them.
            </summary>
    </member>
    <member name="T:Autofac.ILifetimeScope">
      <summary>
            An <see cref="T:Autofac.ILifetimeScope" /> tracks the instantiation of component instances.
            It defines a boundary in which instances are shared and configured.
            Disposing an <see cref="T:Autofac.ILifetimeScope" /> will dispose the components that were
            resolved through it.
            </summary>
      <example>
        <code>
            // See IContainer for definition of the container variable
            using (var requestScope = container.BeginLifetimeScope())
            {
                // Note that handler is resolved from requestScope, not
                // from the container:
                
                var handler = requestScope.Resolve&lt;IRequestHandler&gt;();
                handler.Handle(request);
                
                // When requestScope is disposed, all resources used in processing
                // the request will be released.
            }
            </code>
      </example>
      <remarks>
            All long-running applications should resolve components via an
            <see cref="T:Autofac.ILifetimeScope" />. Choosing the duration of the lifetime is application-
            specific. The standard Autofac WCF and ASP.NET/MVC integrations are already configured
            to create and release <see cref="T:Autofac.ILifetimeScope" />s as appropriate. For example, the
            ASP.NET integration will create and release an <see cref="T:Autofac.ILifetimeScope" /> per HTTP
            request.
            Most <see cref="T:Autofac.ILifetimeScope" /> functionality is provided by extension methods
            on the inherited <see cref="T:Autofac.IComponentContext" /> interface.
            </remarks>
      <seealso cref="T:Autofac.IContainer" />
      <seealso cref="T:Autofac.IComponentContext" />
      <seealso cref="M:Autofac.Builder.IRegistrationBuilder`3.InstancePerMatchingLifetimeScope(System.Object)" />
      <seealso cref="M:Autofac.Builder.IRegistrationBuilder`3.InstancePerLifetimeScope" />
      <seealso cref="T:Autofac.Core.InstanceSharing" />
      <seealso cref="T:Autofac.Core.IComponentLifetime" />
    </member>
    <member name="M:Autofac.ILifetimeScope.BeginLifetimeScope">
      <summary>
            Begin a new nested scope. Component instances created via the new scope
            will be disposed along with it.
            </summary>
      <returns>A new lifetime scope.</returns>
    </member>
    <member name="M:Autofac.ILifetimeScope.BeginLifetimeScope(System.Object)">
      <summary>
            Begin a new nested scope. Component instances created via the new scope
            will be disposed along with it.
            </summary>
      <param name="tag">The tag applied to the <see cref="T:Autofac.ILifetimeScope" />.</param>
      <returns>A new lifetime scope.</returns>
    </member>
    <member name="M:Autofac.ILifetimeScope.BeginLifetimeScope(System.Action{Autofac.ContainerBuilder})">
      <summary>
            Begin a new nested scope, with additional components available to it.
            Component instances created via the new scope
            will be disposed along with it.
            </summary>
      <remarks>
            The components registered in the sub-scope will be treated as though they were
            registered in the root scope, i.e., SingleInstance() components will live as long
            as the root scope.
            </remarks>
      <param name="configurationAction">Action on a <see cref="T:Autofac.ContainerBuilder" />
            that adds component registations visible only in the new scope.</param>
      <returns>A new lifetime scope.</returns>
    </member>
    <member name="M:Autofac.ILifetimeScope.BeginLifetimeScope(System.Object,System.Action{Autofac.ContainerBuilder})">
      <summary>
            Begin a new nested scope, with additional components available to it.
            Component instances created via the new scope
            will be disposed along with it.
            </summary>
      <remarks>
            The components registered in the sub-scope will be treated as though they were
            registered in the root scope, i.e., SingleInstance() components will live as long
            as the root scope.
            </remarks>
      <param name="tag">The tag applied to the <see cref="T:Autofac.ILifetimeScope" />.</param>
      <param name="configurationAction">Action on a <see cref="T:Autofac.ContainerBuilder" />
            that adds component registations visible only in the new scope.</param>
      <returns>A new lifetime scope.</returns>
    </member>
    <member name="P:Autofac.ILifetimeScope.Disposer">
      <summary>
            The disposer associated with this <see cref="T:Autofac.ILifetimeScope" />.
            Component instances can be associated with it manually if required.
            </summary>
      <remarks>Typical usage does not require interaction with this member- it
            is used when extending the container.</remarks>
    </member>
    <member name="P:Autofac.ILifetimeScope.Tag">
      <summary>
            The tag applied to the <see cref="T:Autofac.ILifetimeScope" />.
            </summary>
      <remarks>Tags allow a level in the lifetime hierarchy to be identified.
            In most applications, tags are not necessary.</remarks>
      <seealso cref="M:Autofac.Builder.IRegistrationBuilder`3.InstancePerMatchingLifetimeScope(System.Object)" />
    </member>
    <member name="T:Autofac.IContainer">
      <summary>
            Creates, wires dependencies and manages lifetime for a set of components.
            Most instances of <see cref="T:Autofac.IContainer" /> are created 
            by a <see cref="T:Autofac.ContainerBuilder" />.
            </summary>
      <example>
        <code>
            // See ContainerBuilder for the definition of the builder variable
            using (var container = builder.Build())
            {
                var program = container.Resolve&lt;Program&gt;();
                program.Run();
            }
            </code>
      </example>
      <remarks>
            Most <see cref="T:Autofac.IContainer" /> functionality is provided by extension methods
            on the inherited <see cref="T:Autofac.IComponentContext" /> interface.
            </remarks>
      <seealso cref="T:Autofac.ILifetimeScope" />
      <seealso cref="T:Autofac.IComponentContext" />
      <seealso cref="T:Autofac.ResolutionExtensions" />
      <seealso cref="T:Autofac.ContainerBuilder" />
    </member>
    <member name="T:Autofac.Core.Container">
      <summary>
            Standard container implementation.
            </summary>
    </member>
    <member name="F:Autofac.Core.Container.Empty">
      <summary>
            An empty container.
            </summary>
    </member>
    <member name="M:Autofac.Core.Container.#ctor">
      <summary>
            Create a new container.
            </summary>
    </member>
    <member name="M:Autofac.Core.Container.BeginLifetimeScope">
      <summary>
            Begin a new sub-scope. Instances created via the sub-scope
            will be disposed along with it.
            </summary>
      <returns>A new lifetime scope.</returns>
    </member>
    <member name="M:Autofac.Core.Container.BeginLifetimeScope(System.Object)">
      <summary>
            Begin a new sub-scope. Instances created via the sub-scope
            will be disposed along with it.
            </summary>
      <param name="tag">The tag applied to the <see cref="T:Autofac.ILifetimeScope" />.</param>
      <returns>A new lifetime scope.</returns>
    </member>
    <member name="M:Autofac.Core.Container.BeginLifetimeScope(System.Action{Autofac.ContainerBuilder})">
      <summary>
            Begin a new nested scope, with additional components available to it.
            Component instances created via the new scope
            will be disposed along with it.
            </summary>
      <param name="configurationAction">Action on a <see cref="T:Autofac.ContainerBuilder" />
            that adds component registations visible only in the new scope.</param>
      <returns>A new lifetime scope.</returns>
    </member>
    <member name="M:Autofac.Core.Container.BeginLifetimeScope(System.Object,System.Action{Autofac.ContainerBuilder})">
      <summary>
            Begin a new nested scope, with additional components available to it.
            Component instances created via the new scope
            will be disposed along with it.
            </summary>
      <param name="tag">The tag applied to the <see cref="T:Autofac.ILifetimeScope" />.</param>
      <param name="configurationAction">Action on a <see cref="T:Autofac.ContainerBuilder" />
            that adds component registations visible only in the new scope.</param>
      <returns>A new lifetime scope.</returns>
    </member>
    <member name="M:Autofac.Core.Container.Resolve(Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Resolve an instance of the provided registration within the context.
            </summary>
      <param name="registration">The registration.</param>
      <param name="parameters">Parameters for the instance.</param>
      <returns>
            The component instance.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.Core.Container.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="P:Autofac.Core.Container.Disposer">
      <summary>
            The disposer associated with this container. Instances can be associated
            with it manually if required.
            </summary>
    </member>
    <member name="P:Autofac.Core.Container.Tag">
      <summary>
            Tag applied to the lifetime scope.
            </summary>
      <remarks>The tag applied to this scope and the contexts generated when
            it resolves component dependencies.</remarks>
    </member>
    <member name="P:Autofac.Core.Container.ComponentRegistry">
      <summary>
            Associates services with the components that provide them.
            </summary>
    </member>
    <member name="T:Autofac.Core.DependencyResolutionException">
      <summary>
            Problem resolving dependencies, e.g. circular references, no callable constructor etc.
            </summary>
    </member>
    <member name="M:Autofac.Core.DependencyResolutionException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.DependencyResolutionException" /> class.
            </summary>
    </member>
    <member name="M:Autofac.Core.DependencyResolutionException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.DependencyResolutionException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Autofac.Core.DependencyResolutionException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.DependencyResolutionException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Autofac.Core.DependencyResolutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="T:Autofac.Core.DependencyResolutionExceptionResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Core.DependencyResolutionExceptionResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Core.DependencyResolutionExceptionResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Core.DependencyResolutionExceptionResources.DefaultMessage">
      <summary>
              Looks up a localized string similar to A required component could not be created..
            </summary>
    </member>
    <member name="T:Autofac.Core.IDisposer">
      <summary>
            Provided on an object that will dispose of other objects when it is
            itself disposed.
            </summary>
    </member>
    <member name="M:Autofac.Core.IDisposer.AddInstanceForDisposal(System.IDisposable)">
      <summary>
            Adds an object to the disposer. When the disposer is
            disposed, so will the object be.
            </summary>
      <param name="instance">The instance.</param>
    </member>
    <member name="T:Autofac.Core.Disposer">
      <summary>
            Maintains a set of objects to dispose, and disposes them in the reverse order
            from which they were added when the Disposer is itself disposed.
            </summary>
    </member>
    <member name="F:Autofac.Core.Disposer._items">
      <summary>
            Contents all implement IDisposable.
            </summary>
    </member>
    <member name="M:Autofac.Core.Disposer.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="M:Autofac.Core.Disposer.AddInstanceForDisposal(System.IDisposable)">
      <summary>
            Adds an object to the disposer. When the disposer is
            disposed, so will the object be.
            </summary>
      <param name="instance">The instance.</param>
    </member>
    <member name="T:Autofac.Core.IComponentLifetime">
      <summary>
            Locates the lifetime to which instances of a component should be attached.
            </summary>
    </member>
    <member name="M:Autofac.Core.IComponentLifetime.FindScope(Autofac.Core.ISharingLifetimeScope)">
      <summary>
            Given the most nested scope visible within the resolve operation, find
            the scope for the component.
            </summary>
      <param name="mostNestedVisibleScope">The most nested visible scope.</param>
      <returns>The scope for the component.</returns>
    </member>
    <member name="T:Autofac.Core.IModule">
      <summary>
            Represents a set of components and related functionality
            packaged together.
            </summary>
    </member>
    <member name="M:Autofac.Core.IModule.Configure(Autofac.Core.IComponentRegistry)">
      <summary>
            Apply the module to the component registry.
            </summary>
      <param name="componentRegistry">Component registry to apply configuration to.</param>
    </member>
    <member name="T:Autofac.Core.InstanceOwnership">
      <summary>
            Determines when instances supporting IDisposable are disposed.
            </summary>
    </member>
    <member name="F:Autofac.Core.InstanceOwnership.ExternallyOwned">
      <summary>
            The lifetime scope does not dispose the instances.
            </summary>
    </member>
    <member name="F:Autofac.Core.InstanceOwnership.OwnedByLifetimeScope">
      <summary>
            The instances are disposed when the lifetime scope is disposed.
            </summary>
    </member>
    <member name="T:Autofac.Core.InstanceSharing">
      <summary>
            Determines whether instances are shared within a lifetime scope.
            </summary>
    </member>
    <member name="F:Autofac.Core.InstanceSharing.None">
      <summary>
            Each request for an instance will return a new object.
            </summary>
    </member>
    <member name="F:Autofac.Core.InstanceSharing.Shared">
      <summary>
            Each request for an instance will return the same object.
            </summary>
    </member>
    <member name="T:Autofac.Core.ISharingLifetimeScope">
      <summary>
            Defines a nested structure of lifetimes.
            </summary>
    </member>
    <member name="M:Autofac.Core.ISharingLifetimeScope.GetOrCreateAndShare(System.Guid,System.Func{System.Object})">
      <summary>
            Try to retrieve an instance based on a GUID key. If the instance
            does not exist, invoke <paramref name="creator" /> to create it.
            </summary>
      <param name="id">Key to look up.</param>
      <param name="creator">Creation function.</param>
      <returns>An instance.</returns>
    </member>
    <member name="P:Autofac.Core.ISharingLifetimeScope.RootLifetimeScope">
      <summary>
            The root of the sharing hierarchy.
            </summary>
    </member>
    <member name="P:Autofac.Core.ISharingLifetimeScope.ParentLifetimeScope">
      <summary>
            The parent of this node of the hierarchy, or null.
            </summary>
    </member>
    <member name="T:Autofac.Core.Lifetime.CurrentScopeLifetime">
      <summary>
            Attaches the instance's lifetime to the current lifetime scope.
            </summary>
    </member>
    <member name="M:Autofac.Core.Lifetime.CurrentScopeLifetime.FindScope(Autofac.Core.ISharingLifetimeScope)">
      <summary>
            Given the most nested scope visible within the resolve operation, find
            the scope for the component.
            </summary>
      <param name="mostNestedVisibleScope">The most nested visible scope.</param>
      <returns>The scope for the component.</returns>
    </member>
    <member name="T:Autofac.Core.Lifetime.LifetimeScope">
      <summary>
            Lifetime scope implementation.
            </summary>
    </member>
    <member name="F:Autofac.Core.Lifetime.LifetimeScope._synchRoot">
      <summary>
            Protects instance variables from concurrent access.
            </summary>
    </member>
    <member name="F:Autofac.Core.Lifetime.LifetimeScope.RootTag">
      <summary>
            The tag applied to root scopes when no other tag is specified.
            </summary>
    </member>
    <member name="M:Autofac.Core.Lifetime.LifetimeScope.#ctor(Autofac.Core.IComponentRegistry,Autofac.Core.Lifetime.LifetimeScope,System.Object)">
      <summary>
            Create a lifetime scope for the provided components and nested beneath a parent.
            </summary>
      <param name="tag">The tag applied to the <see cref="T:Autofac.ILifetimeScope" />.</param>
      <param name="componentRegistry">Components used in the scope.</param>
      <param name="parent">Parent scope.</param>
    </member>
    <member name="M:Autofac.Core.Lifetime.LifetimeScope.#ctor(Autofac.Core.IComponentRegistry,System.Object)">
      <summary>
            Create a root lifetime scope for the provided components.
            </summary>
      <param name="tag">The tag applied to the <see cref="T:Autofac.ILifetimeScope" />.</param>
      <param name="componentRegistry">Components used in the scope.</param>
    </member>
    <member name="M:Autofac.Core.Lifetime.LifetimeScope.#ctor(Autofac.Core.IComponentRegistry)">
      <summary>
            Create a root lifetime scope for the provided components.
            </summary>
      <param name="componentRegistry">Components used in the scope.</param>
    </member>
    <member name="M:Autofac.Core.Lifetime.LifetimeScope.BeginLifetimeScope">
      <summary>
            Begin a new anonymous sub-scope. Instances created via the sub-scope
            will be disposed along with it.
            </summary>
      <returns>A new lifetime scope.</returns>
    </member>
    <member name="M:Autofac.Core.Lifetime.LifetimeScope.BeginLifetimeScope(System.Object)">
      <summary>
            Begin a new tagged sub-scope. Instances created via the sub-scope
            will be disposed along with it.
            </summary>
      <param name="tag">The tag applied to the <see cref="T:Autofac.ILifetimeScope" />.</param>
      <returns>A new lifetime scope.</returns>
    </member>
    <member name="M:Autofac.Core.Lifetime.LifetimeScope.BeginLifetimeScope(System.Action{Autofac.ContainerBuilder})">
      <summary>
            Begin a new anonymous sub-scope, with additional components available to it.
            Component instances created via the new scope
            will be disposed along with it.
            </summary>
      <param name="configurationAction">Action on a <see cref="T:Autofac.ContainerBuilder" />
            that adds component registations visible only in the new scope.</param>
      <returns>A new lifetime scope.</returns>
      <example>
            IContainer cr = // ...
            using (var lifetime = cr.BeginLifetimeScope(builder =&gt; {
                    builder.RegisterType&lt;Foo&gt;();
                    builder.RegisterType&lt;Bar&gt;().As&lt;IBar&gt;(); })
            {
                var foo = lifetime.Resolve&lt;Foo&gt;();
            }
            </example>
    </member>
    <member name="M:Autofac.Core.Lifetime.LifetimeScope.BeginLifetimeScope(System.Object,System.Action{Autofac.ContainerBuilder})">
      <summary>
            Begin a new tagged sub-scope, with additional components available to it.
            Component instances created via the new scope
            will be disposed along with it.
            </summary>
      <param name="tag">The tag applied to the <see cref="T:Autofac.ILifetimeScope" />.</param>
      <param name="configurationAction">Action on a <see cref="T:Autofac.ContainerBuilder" />
            that adds component registations visible only in the new scope.</param>
      <returns>A new lifetime scope.</returns>
      <example>
            IContainer cr = // ...
            using (var lifetime = cr.BeginLifetimeScope("unitOfWork", builder =&gt; {
                    builder.RegisterType&lt;Foo&gt;();
                    builder.RegisterType&lt;Bar&gt;().As&lt;IBar&gt;(); })
            {
                var foo = lifetime.Resolve&lt;Foo&gt;();
            }
            </example>
    </member>
    <member name="M:Autofac.Core.Lifetime.LifetimeScope.Resolve(Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Resolve an instance of the provided registration within the context.
            </summary>
      <param name="registration">The registration.</param>
      <param name="parameters">Parameters for the instance.</param>
      <returns>
            The component instance.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.Core.Lifetime.LifetimeScope.GetOrCreateAndShare(System.Guid,System.Func{System.Object})">
      <summary>
            Try to retrieve an instance based on a GUID key. If the instance
            does not exist, invoke <paramref name="creator" /> to create it.
            </summary>
      <param name="id">Key to look up.</param>
      <param name="creator">Creation function.</param>
      <returns>An instance.</returns>
    </member>
    <member name="M:Autofac.Core.Lifetime.LifetimeScope.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="P:Autofac.Core.Lifetime.LifetimeScope.ParentLifetimeScope">
      <summary>
            The parent of this node of the hierarchy, or null.
            </summary>
    </member>
    <member name="P:Autofac.Core.Lifetime.LifetimeScope.RootLifetimeScope">
      <summary>
            The root of the sharing hierarchy.
            </summary>
    </member>
    <member name="P:Autofac.Core.Lifetime.LifetimeScope.Disposer">
      <summary>
            The disposer associated with this container. Instances can be associated
            with it manually if required.
            </summary>
    </member>
    <member name="P:Autofac.Core.Lifetime.LifetimeScope.Tag">
      <summary>
            Tag applied to the lifetime scope.
            </summary>
      <remarks>The tag applied to this scope and the contexts generated when
            it resolves component dependencies.</remarks>
    </member>
    <member name="P:Autofac.Core.Lifetime.LifetimeScope.ComponentRegistry">
      <summary>
            Associates services with the components that provide them.
            </summary>
    </member>
    <member name="T:Autofac.Core.Lifetime.MatchingScopeLifetime">
      <summary>
            Attaches the component's lifetime to scopes matching a supplied expression.
            </summary>
    </member>
    <member name="M:Autofac.Core.Lifetime.MatchingScopeLifetime.#ctor(System.Linq.Expressions.Expression{System.Func{Autofac.ILifetimeScope,System.Boolean}})">
      <summary>
            Match scopes based on the provided expression.
            </summary>
      <param name="matchExpression">Expression describing scopes that will match.</param>
    </member>
    <member name="M:Autofac.Core.Lifetime.MatchingScopeLifetime.FindScope(Autofac.Core.ISharingLifetimeScope)">
      <summary>
            Given the most nested scope visible within the resolve operation, find
            the scope for the component.
            </summary>
      <param name="mostNestedVisibleScope">The most nested visible scope.</param>
      <returns>The scope for the component.</returns>
    </member>
    <member name="T:Autofac.Core.Lifetime.MatchingScopeLifetimeResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Core.Lifetime.MatchingScopeLifetimeResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Lifetime.MatchingScopeLifetimeResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Lifetime.MatchingScopeLifetimeResources.MatchingScopeNotFound">
      <summary>
              Looks up a localized string similar to No scope matching the expression '{0}' is visible from the scope in which the instance was requested..
            </summary>
    </member>
    <member name="T:Autofac.Core.Lifetime.RootScopeLifetime">
      <summary>
            Attaches the component's lifetime to the root scope.
            </summary>
    </member>
    <member name="M:Autofac.Core.Lifetime.RootScopeLifetime.FindScope(Autofac.Core.ISharingLifetimeScope)">
      <summary>
            Given the most nested scope visible within the resolve operation, find
            the scope for the component.
            </summary>
      <param name="mostNestedVisibleScope">The most nested visible scope.</param>
      <returns>The scope for the component.</returns>
    </member>
    <member name="T:Autofac.Core.NamedPropertyParameter">
      <summary>
            A property identified by name. When applied to a reflection-based
            component, the name will be matched against property names.
            </summary>
    </member>
    <member name="M:Autofac.Core.NamedPropertyParameter.#ctor(System.String,System.Object)">
      <summary>
            Create a <see cref="T:Autofac.Core.NamedPropertyParameter" /> with the specified constant value.
            </summary>
      <param name="name">The name of the property.</param>
      <param name="value">The property value.</param>
    </member>
    <member name="P:Autofac.Core.NamedPropertyParameter.Name">
      <summary>
            The name of the property.
            </summary>
    </member>
    <member name="T:Autofac.Core.NamedService">
      <summary>
            Identifies a service using a textual name in addition to its type.
            </summary>
    </member>
    <member name="M:Autofac.Core.NamedService.#ctor(System.String,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.NamedService" /> class.
            </summary>
      <param name="serviceName">Name of the service.</param>
      <param name="serviceType">Type of the service.</param>
    </member>
    <member name="M:Autofac.Core.NamedService.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception>
    </member>
    <member name="M:Autofac.Core.NamedService.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Autofac.Core.NamedService.ChangeType(System.Type)">
      <summary>
            Return a new service of the same kind, but carrying
            <paramref name="newType" /> as the <see cref="P:Autofac.Core.NamedService.ServiceType" />.
            </summary>
      <param name="newType">The new service type.</param>
      <returns>A new service with the service type.</returns>
    </member>
    <member name="P:Autofac.Core.NamedService.ServiceName">
      <summary>
            Gets or sets the name of the service.
            </summary>
      <value>The name of the service.</value>
    </member>
    <member name="P:Autofac.Core.NamedService.ServiceType">
      <summary>
            Gets the type of the service.
            </summary>
      <value>The type of the service.</value>
    </member>
    <member name="P:Autofac.Core.NamedService.Description">
      <summary>
            Gets a human-readable description of the service.
            </summary>
      <value>The description.</value>
    </member>
    <member name="T:Autofac.Core.PreparingEventArgs">
      <summary>
            Fired before the activation process to allow parameters to be changed or an alternative
            instance to be provided.
            </summary>
    </member>
    <member name="M:Autofac.Core.PreparingEventArgs.#ctor(Autofac.IComponentContext,Autofac.Core.IComponentRegistration,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.PreparingEventArgs" /> class.
            </summary>
      <param name="context">The context.</param>
      <param name="component">The component.</param>
      <param name="parameters">The parameters.</param>
    </member>
    <member name="P:Autofac.Core.PreparingEventArgs.Context">
      <summary>
            The context in which the activation is occurring.
            </summary>
    </member>
    <member name="P:Autofac.Core.PreparingEventArgs.Component">
      <summary>
            The component providing the instance being activated.
            </summary>
    </member>
    <member name="P:Autofac.Core.PreparingEventArgs.Parameters">
      <summary>
            The parameters supplied to the activator.
            </summary>
    </member>
    <member name="T:Autofac.Core.Registration.ComponentNotRegisteredException">
      <summary>
            A service was requested that cannot be provided
            by the container.
            </summary>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentNotRegisteredException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" /> class.
            </summary>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentNotRegisteredException.#ctor(Autofac.Core.Service)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" /> class.
            </summary>
      <param name="service">The service.</param>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentNotRegisteredException.#ctor(Autofac.Core.Service,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" /> class.
            </summary>
      <param name="service">The service.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentNotRegisteredException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="T:Autofac.Core.Registration.ComponentNotRegisteredExceptionResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentNotRegisteredExceptionResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentNotRegisteredExceptionResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentNotRegisteredExceptionResources.Message">
      <summary>
              Looks up a localized string similar to The requested service '{0}' has not been registered..
            </summary>
    </member>
    <member name="T:Autofac.Core.ComponentRegisteredEventArgs">
      <summary>
            Information about the ocurrence of a component being registered
            with a container.
            </summary>
    </member>
    <member name="M:Autofac.Core.ComponentRegisteredEventArgs.#ctor(Autofac.Core.IComponentRegistry,Autofac.Core.IComponentRegistration)">
      <summary>
            Create a new instance with a valid container and component registration.
            </summary>
      <param name="registry">The container into which the registration 
            was made.</param>
      <param name="componentRegistration">The component registration.</param>
    </member>
    <member name="P:Autofac.Core.ComponentRegisteredEventArgs.ComponentRegistry">
      <summary>
            The container into which the registration was made.
            </summary>
    </member>
    <member name="P:Autofac.Core.ComponentRegisteredEventArgs.ComponentRegistration">
      <summary>
            The component registration.
            </summary>
    </member>
    <member name="T:Autofac.Core.Registration.ComponentRegistration">
      <summary>
            Describes a logical component within the container.
            </summary>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistration.#ctor(System.Guid,Autofac.Core.IInstanceActivator,Autofac.Core.IComponentLifetime,Autofac.Core.InstanceSharing,Autofac.Core.InstanceOwnership,System.Collections.Generic.IEnumerable{Autofac.Core.Service},System.Collections.Generic.IDictionary{System.String,System.Object})">
      <summary>
            Create a new component registration.
            </summary>
      <param name="id">Unique identifier for the component.</param>
      <param name="activator">Activator used to activate instances.</param>
      <param name="lifetime">Determines how the component will be associated with its lifetime.</param>
      <param name="sharing">Whether the component is shared within its lifetime scope.</param>
      <param name="ownership">Whether the component instances are disposed at the end of their lifetimes.</param>
      <param name="services">Services the component provides.</param>
      <param name="metadata">Data associated with the component.</param>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistration.#ctor(System.Guid,Autofac.Core.IInstanceActivator,Autofac.Core.IComponentLifetime,Autofac.Core.InstanceSharing,Autofac.Core.InstanceOwnership,System.Collections.Generic.IEnumerable{Autofac.Core.Service},System.Collections.Generic.IDictionary{System.String,System.Object},Autofac.Core.IComponentRegistration)">
      <summary>
            Create a new component registration.
            </summary>
      <param name="id">Unique identifier for the component.</param>
      <param name="activator">Activator used to activate instances.</param>
      <param name="lifetime">Determines how the component will be associated with its lifetime.</param>
      <param name="sharing">Whether the component is shared within its lifetime scope.</param>
      <param name="ownership">Whether the component instances are disposed at the end of their lifetimes.</param>
      <param name="services">Services the component provides.</param>
      <param name="metadata">Data associated with the component.</param>
      <param name="target">The component registration upon which this registration is based.</param>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistration.RaisePreparing(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter}@)">
      <summary>
            Called by the container when an instance is required.
            </summary>
      <param name="context">The context in which the instance will be activated.</param>
      <param name="parameters">Parameters for activation.</param>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistration.RaiseActivating(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.Object@)">
      <summary>
            Called by the container once an instance has been constructed.
            </summary>
      <param name="context">The context in which the instance was activated.</param>
      <param name="parameters">The parameters supplied to the activator.</param>
      <param name="instance">The instance.</param>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistration.RaiseActivated(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.Object)">
      <summary>
            Called by the container once an instance has been fully constructed, including
            any requested objects that depend on the instance.
            </summary>
      <param name="context">The context in which the instance was activated.</param>
      <param name="parameters">The parameters supplied to the activator.</param>
      <param name="instance">The instance.</param>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistration.ToString">
      <summary>
            Describes the component in a human-readable form.
            </summary>
      <returns>A description of the component.</returns>
    </member>
    <member name="M:Autofac.Core.Registration.ComponentRegistration.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistration.Target">
      <summary>
            The component registration upon which this registration is based.
            If this registration was created directly by the user, returns this.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistration.Id">
      <summary>
            A unique identifier for this component (shared in all sub-contexts.)
            This value also appears in Services.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistration.Activator">
      <summary>
            The activator used to create instances.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistration.Lifetime">
      <summary>
            The lifetime associated with the component.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistration.Sharing">
      <summary>
            Whether the component instances are shared or not.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistration.Ownership">
      <summary>
            Whether the instances of the component should be disposed by the container.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistration.Services">
      <summary>
            The services provided by the component.
            </summary>
    </member>
    <member name="P:Autofac.Core.Registration.ComponentRegistration.Metadata">
      <summary>
            Additional data associated with the component.
            </summary>
    </member>
    <member name="E:Autofac.Core.Registration.ComponentRegistration.Preparing">
      <summary>
            Fired when a new instance is required. The instance can be
            provided in order to skip the regular activator, by setting the Instance property in
            the provided event arguments.
            </summary>
    </member>
    <member name="E:Autofac.Core.Registration.ComponentRegistration.Activating">
      <summary>
            Fired when a new instance is being activated. The instance can be
            wrapped or switched at this time by setting the Instance property in
            the provided event arguments.
            </summary>
    </member>
    <member name="E:Autofac.Core.Registration.ComponentRegistration.Activated">
      <summary>
            Fired when the activation process for a new instance is complete.
            </summary>
    </member>
    <member name="F:Autofac.Core.Resolving.CircularDependencyDetector.MaxResolveDepth">
      <summary>
            Catch circular dependencies that are triggered by post-resolve processing (e.g. 'OnActivated')
            </summary>
    </member>
    <member name="T:Autofac.Core.Resolving.CircularDependencyDetectorResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Core.Resolving.CircularDependencyDetectorResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Resolving.CircularDependencyDetectorResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Resolving.CircularDependencyDetectorResources.CircularDependency">
      <summary>
              Looks up a localized string similar to Circular component dependency detected: {0}..
            </summary>
    </member>
    <member name="P:Autofac.Core.Resolving.CircularDependencyDetectorResources.MaxDepthExceeded">
      <summary>
              Looks up a localized string similar to Probable circular dependency between factory-scoped components. Chain includes '{0}'.
            </summary>
    </member>
    <member name="T:Autofac.Core.Resolving.ResolveOperationResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Core.Resolving.ResolveOperationResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Resolving.ResolveOperationResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Core.Resolving.ResolveOperationResources.MaxDepthExceeded">
      <summary>
              Looks up a localized string similar to Probable circular dependency between factory-scoped components. Chain includes '{0}'.
            </summary>
    </member>
    <member name="T:Autofac.Core.TypedService">
      <summary>
            Identifies a service according to a type to which it can be assigned.
            </summary>
    </member>
    <member name="M:Autofac.Core.TypedService.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.TypedService" /> class.
            </summary>
      <param name="serviceType">Type of the service.</param>
    </member>
    <member name="M:Autofac.Core.TypedService.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception>
    </member>
    <member name="M:Autofac.Core.TypedService.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Autofac.Core.TypedService.ChangeType(System.Type)">
      <summary>
            Return a new service of the same kind, but carrying
            <paramref name="newType" /> as the <see cref="P:Autofac.Core.TypedService.ServiceType" />.
            </summary>
      <param name="newType">The new service type.</param>
      <returns>A new service with the service type.</returns>
    </member>
    <member name="P:Autofac.Core.TypedService.ServiceType">
      <summary>
            Gets the type of the service.
            </summary>
      <value>The type of the service.</value>
    </member>
    <member name="P:Autofac.Core.TypedService.Description">
      <summary>
            Gets a human-readable description of the service.
            </summary>
      <value>The description.</value>
    </member>
    <member name="T:Autofac.Core.UniqueService">
      <summary>
            A handy unique service identifier type - all instances will be regarded as unequal.
            </summary>
    </member>
    <member name="M:Autofac.Core.UniqueService.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.UniqueService" /> class.
            </summary>
    </member>
    <member name="M:Autofac.Core.UniqueService.#ctor(System.Guid)">
      <summary>
            Initializes a new instance of the <see cref="T:Autofac.Core.UniqueService" /> class.
            </summary>
      <param name="id">The id.</param>
    </member>
    <member name="M:Autofac.Core.UniqueService.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception>
    </member>
    <member name="M:Autofac.Core.UniqueService.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:Autofac.Core.UniqueService.Description">
      <summary>
            Provides a programmer-readable description of the identifying feature of the service.
            </summary>
      <value>
      </value>
    </member>
    <member name="M:Autofac.Features.Collections.CollectionRegistrationSource.RegistrationsFor(Autofac.Core.Service,System.Func{Autofac.Core.Service,System.Collections.Generic.IEnumerable{Autofac.Core.IComponentRegistration}})">
      <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
      <param name="service">The service that was requested.</param>
      <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
      <returns>Registrations providing the service.</returns>
    </member>
    <member name="M:Autofac.Features.GeneratedFactories.GeneratedFactoryRegistrationSource.RegistrationsFor(Autofac.Core.Service,System.Func{Autofac.Core.Service,System.Collections.Generic.IEnumerable{Autofac.Core.IComponentRegistration}})">
      <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
      <param name="service">The service that was requested.</param>
      <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
      <returns>Registrations providing the service.</returns>
    </member>
    <member name="T:Autofac.Features.GeneratedFactories.FactoryGenerator">
      <summary>
            Generates context-bound closures that represent factories from
            a set of heuristics based on delegate type signatures.
            </summary>
    </member>
    <member name="M:Autofac.Features.GeneratedFactories.FactoryGenerator.#ctor(System.Type,Autofac.Core.Service,Autofac.Features.GeneratedFactories.ParameterMapping)">
      <summary>
            Create a factory generator.
            </summary>
      <param name="service">The service that will be activated in
            order to create the products of the factory.</param>
      <param name="delegateType">The delegate to provide as a factory.</param>
      <param name="parameterMapping">The parameter mapping mode to use.</param>
    </member>
    <member name="M:Autofac.Features.GeneratedFactories.FactoryGenerator.#ctor(System.Type,Autofac.Core.IComponentRegistration,Autofac.Features.GeneratedFactories.ParameterMapping)">
      <summary>
            Create a factory generator.
            </summary>
      <param name="productRegistration">The component that will be activated in
            order to create the products of the factory.</param>
      <param name="delegateType">The delegate to provide as a factory.</param>
      <param name="parameterMapping">The parameter mapping mode to use.</param>
    </member>
    <member name="M:Autofac.Features.GeneratedFactories.FactoryGenerator.GenerateFactory(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Generates a factory delegate that closes over the provided context.
            </summary>
      <param name="context">The context in which the factory will be used.</param>
      <param name="parameters">Parameters provided to the resolve call for the factory itself.</param>
      <returns>A factory delegate that will work within the context.</returns>
    </member>
    <member name="M:Autofac.Features.GeneratedFactories.FactoryGenerator.GenerateFactory``1(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Generates a factory delegate that closes over the provided context.
            </summary>
      <param name="context">The context in which the factory will be used.</param>
      <param name="parameters">Parameters provided to the resolve call for the factory itself.</param>
      <returns>A factory delegate that will work within the context.</returns>
    </member>
    <member name="T:Autofac.Features.OpenGenerics.OpenGenericRegistrationSource">
      <summary>
            Generates activators for open generic types.
            </summary>
    </member>
    <member name="T:Autofac.Features.OwnedInstances.Owned`1">
      <summary>
            Represents a dependency that can be released by the dependent component.
            </summary>
      <typeparam name="T">The service provided by the dependency.</typeparam>
      <remarks>
        <para>
            Autofac automatically provides instances of <see cref="T:Autofac.Features.OwnedInstances.Owned`1" /> whenever the
            service <typeparamref name="T" /> is registered.
            </para>
        <para>
            It is not necessary for <typeparamref name="T" />, or the underlying component, to implement <see cref="T:System.IDisposable" />.
            Disposing of the <see cref="T:Autofac.Features.OwnedInstances.Owned`1" /> object is the correct way to handle cleanup of the dependency,
            as this will dispose of any other components created indirectly as well.
            </para>
        <para>
            When <see cref="T:Autofac.Features.OwnedInstances.Owned`1" /> is resolved, a new <see cref="T:Autofac.ILifetimeScope" /> is created for the
            underlying <typeparamref name="T" />, and tagged with the service matching <typeparamref name="T" />,
            generally a <see cref="T:Autofac.Core.TypedService" />. This means that shared instances can be tied to this
            scope by registering them as InstancePerMatchingLifetimeScope(new TypedService(typeof(T))).
            </para>
      </remarks>
      <example>
            The component D below is disposable and implements IService:
            <code>
            public class D : IService, IDisposable
            {
              // ...
            }
            </code>
            The dependent component C can dispose of the D instance whenever required by taking a dependency on
            <see cref="T:Autofac.Features.OwnedInstances.Owned`1" />:
            <code>
            public class C
            {
              IService _service;
              
              public C(Owned&lt;IService&gt; service)
              {
                _service = service;
              }
              
              void DoWork()
              {
                _service.Value.DoSomething();
              }
              
              void OnFinished()
              {
                _service.Dispose();
              }
            }
            </code>
            In general, rather than depending on <see cref="T:Autofac.Features.OwnedInstances.Owned`1" /> directly, components will depend on
            System.Func&lt;Owned&lt;T&gt;&gt; in order to create and dispose of other components as required.
            </example>
    </member>
    <member name="M:Autofac.Features.OwnedInstances.Owned`1.#ctor(`0,System.IDisposable)">
      <summary>
            Create an instance of <see cref="T:Autofac.Features.OwnedInstances.Owned`1" />.
            </summary>
      <param name="value">The value representing the instance.</param>
      <param name="lifetime">An IDisposable interface through which ownership can be released.</param>
    </member>
    <member name="M:Autofac.Features.OwnedInstances.Owned`1.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="P:Autofac.Features.OwnedInstances.Owned`1.Value">
      <summary>
            The owned value.
            </summary>
    </member>
    <member name="T:Autofac.Features.OwnedInstances.OwnedInstanceRegistrationSource">
      <summary>
            Generates registrations for services of type <see cref="T:Autofac.Features.OwnedInstances.Owned`1" /> whenever the service
            T is available.
            </summary>
    </member>
    <member name="M:Autofac.Features.OwnedInstances.OwnedInstanceRegistrationSource.RegistrationsFor(Autofac.Core.Service,System.Func{Autofac.Core.Service,System.Collections.Generic.IEnumerable{Autofac.Core.IComponentRegistration}})">
      <summary>
            Retrieve registrations for an unregistered service, to be used
            by the container.
            </summary>
      <param name="service">The service that was requested.</param>
      <param name="registrationAccessor">A function that will return existing registrations for a service.</param>
      <returns>Registrations providing the service.</returns>
    </member>
    <member name="M:Autofac.Features.Scanning.ScanningRegistrationExtensions.IsAssignableToClosed(System.Type,System.Type)">
      <summary>Determines whether the candidate type supports any base or interface that closes the
            provided generic service type.</summary>
      <param name="candidateType">The type that is being checked for the interface.</param>
      <param name="openGenericServiceType">The open generic type to locate.</param>
      <returns>True if an interface was found; otherwise false.</returns>
    </member>
    <member name="M:Autofac.Features.Scanning.ScanningRegistrationExtensions.GetServicesThatClose(System.Type,System.Type)">
      <summary>Returns the first concrete interface supported by the candidate type that
            closes the provided open generic service type.</summary>
      <param name="candidateType">The type that is being checked for the interface.</param>
      <param name="openGenericServiceType">The open generic type to locate.</param>
      <returns>The type of the interface.</returns>
    </member>
    <member name="M:Autofac.Features.Scanning.ScanningRegistrationExtensions.FindAssignableTypesThatClose(System.Type,System.Type)">
      <summary>
            Looks for an interface on the candidate type that closes the provided open generic interface type.
            </summary>
      <param name="candidateType">The type that is being checked for the interface.</param>
      <param name="openGenericServiceType">The open generic service type to locate.</param>
      <returns>True if a closed implementation was found; otherwise false.</returns>
    </member>
    <member name="T:Autofac.Features.Scanning.ScanningRegistrationExtensionsResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Features.Scanning.ScanningRegistrationExtensionsResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Features.Scanning.ScanningRegistrationExtensionsResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Features.Scanning.ScanningRegistrationExtensionsResources.NotOpenGenericType">
      <summary>
              Looks up a localized string similar to The type '{0}' is not an open generic class or interface type..
            </summary>
    </member>
    <member name="T:Autofac.Module">
      <summary>
            Base class for user-defined modules. Modules can add a set of releated components
            to a container (<see cref="M:Autofac.Module.Load(Autofac.ContainerBuilder)" />) or attach cross-cutting functionality
            to other components (<see cref="M:Autofac.Module.AttachToComponentRegistration(Autofac.Core.IComponentRegistry,Autofac.Core.IComponentRegistration)" />.
            Modules are given special support in the XML configuration feature - see
            http://code.google.com/p/autofac/wiki/StructuringWithModules.
            </summary>
      <remarks>Provides a user-friendly way to implement <see cref="T:Autofac.Core.IModule" />
            via <see cref="T:Autofac.ContainerBuilder" />.</remarks>
      <example>
            Defining a module:
            <code>
            public class DataAccessModule : Module
            {
                public string ConnectionString { get; set; }
                
                public override void Load(ContainerBuilder moduleBuilder)
                {
                    moduleBuilder.RegisterGeneric(typeof(MyRepository&lt;&gt;))
                        .As(typeof(IRepository&lt;&gt;))
                        .InstancePerMatchingLifetimeScope(WebLifetime.Request);
                    
                    moduleBuilder.Register(c =&gt; new MyDbConnection(ConnectionString))
                        .As&lt;IDbConnection&gt;()
                        .InstancePerMatchingLifetimeScope(WebLifetime.Request);
                }
            }
            </code>
            Using the module:
            <code>
            var builder = new ContainerBuilder();
            builder.RegisterModule(new DataAccessModule { ConnectionString = "..." });
            var container = builder.Build();
            var customers = container.Resolve&lt;IRepository&lt;Customer&gt;&gt;();
            </code></example>
    </member>
    <member name="M:Autofac.Module.Configure(Autofac.Core.IComponentRegistry)">
      <summary>
            Apply the module to the component registry.
            </summary>
      <param name="componentRegistry">Component registry to apply configuration to.</param>
    </member>
    <member name="M:Autofac.Module.Load(Autofac.ContainerBuilder)">
      <summary>
            Override to add registrations to the container.
            </summary>
      <remarks>
            Note that the ContainerBuilder parameter is unique to this module.
            </remarks>
      <param name="builder">The builder through which components can be
            registered.</param>
    </member>
    <member name="M:Autofac.Module.AttachToComponentRegistration(Autofac.Core.IComponentRegistry,Autofac.Core.IComponentRegistration)">
      <summary>
            Override to attach module-specific functionality to a
            component registration.
            </summary>
      <remarks>This method will be called for all existing <i>and future</i> component
            registrations - ordering is not important.</remarks>
      <param name="componentRegistry">The component registry.</param>
      <param name="registration">The registration to attach functionality to.</param>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.ExternallyOwned">
      <summary>
            Configure the component so that instances are never disposed by the container.
            </summary>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.OwnedByLifetimeScope">
      <summary>
            Configure the component so that instances that support IDisposable are
            disposed by the container (default.)
            </summary>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.InstancePerDependency">
      <summary>
            Configure the component so that every dependent component or call to Resolve()
            gets a new, unique instance (default.)
            </summary>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.SingleInstance">
      <summary>
            Configure the component so that every dependent component or call to Resolve()
            gets the same, shared instance.
            </summary>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.InstancePerLifetimeScope">
      <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a single ILifetimeScope gets the same, shared instance. Dependent components in
            different lifetime scopes will get different instances.
            </summary>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.InstancePerMatchingLifetimeScope(System.Object)">
      <summary>
            Configure the component so that every dependent component or call to Resolve()
            within a ILifetimeScope tagged with the provided tag value gets the same, shared instance.
            Dependent components in lifetime scopes that are children of the tagged scope will
            share the parent's instance. If no appropriately tagged scope can be found in the
            hierarchy an <see cref="T:Autofac.Core.DependencyResolutionException" /> is thrown.
            </summary>
      <param name="lifetimeScopeTag">Tag applied to matching lifetime scopes.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.As``1">
      <summary>
            Configure the services that the component will provide. The generic parameter(s) to As()
            will be exposed as TypedService instances.
            </summary>
      <typeparam name="TService">Service type.</typeparam>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.As``2">
      <summary>
            Configure the services that the component will provide. The generic parameter(s) to As()
            will be exposed as TypedService instances.
            </summary>
      <typeparam name="TService1">Service type.</typeparam>
      <typeparam name="TService2">Service type.</typeparam>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.As``3">
      <summary>
            Configure the services that the component will provide. The generic parameter(s) to As()
            will be exposed as TypedService instances.
            </summary>
      <typeparam name="TService1">Service type.</typeparam>
      <typeparam name="TService2">Service type.</typeparam>
      <typeparam name="TService3">Service type.</typeparam>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.As(System.Type[])">
      <summary>
            Configure the services that the component will provide.
            </summary>
      <param name="services">Service types to expose.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.As(Autofac.Core.Service[])">
      <summary>
            Configure the services that the component will provide.
            </summary>
      <param name="services">Services to expose.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.Named(System.String,System.Type)">
      <summary>
            Provide a textual name that can be used to retrieve the component.
            </summary>
      <param name="serviceName">Named service to associate with the component.</param>
      <param name="serviceType">The service type provided by the component.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.Named``1(System.String)">
      <summary>
            Provide a textual name that can be used to retrieve the component.
            </summary>
      <param name="serviceName">Named service to associate with the component.</param>
      <typeparam name="TService">The service type provided by the component.</typeparam>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.Keyed(System.Object,System.Type)">
      <summary>
            Provide a key that can be used to retrieve the component.
            </summary>
      <param name="serviceKey">Key to associate with the component.</param>
      <param name="serviceType">The service type provided by the component.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.Keyed``1(System.Object)">
      <summary>
            Provide a key that can be used to retrieve the component.
            </summary>
      <param name="serviceKey">Key to associate with the component.</param>
      <typeparam name="TService">The service type provided by the component.</typeparam>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.OnPreparing(System.Action{Autofac.Core.PreparingEventArgs})">
      <summary>
            Add a handler for the Preparing event. This event allows manipulating of the parameters
            that will be provided to the component.
            </summary>
      <param name="handler">The event handler.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.OnActivating(System.Action{Autofac.Core.IActivatingEventArgs{`0}})">
      <summary>
            Add a handler for the Activating event.
            </summary>
      <param name="handler">The event handler.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.OnActivated(System.Action{Autofac.Core.IActivatedEventArgs{`0}})">
      <summary>
            Add a handler for the Activated event.
            </summary>
      <param name="handler">The event handler.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.PropertiesAutowired">
      <summary>
            Configure the component so that any properties whose types are registered in the
            container will be wired to instances of the appropriate service.
            </summary>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.PropertiesAutowired(System.Boolean)">
      <summary>
            Configure the component so that any properties whose types are registered in the
            container will be wired to instances of the appropriate service.
            </summary>
      <param name="allowCircularDependencies">If set to true, the properties won't be wired until
            after the component has been activated. This allows property-property and constructor-property
            circularities in the dependency graph.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.WithMetadata(System.String,System.Object)">
      <summary>
            Associates data with the component.
            </summary>
      <param name="key">Key by which the data can be located.</param>
      <param name="value">The data value.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.WithMetadata(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
      <summary>
            Associates data with the component.
            </summary>
      <param name="properties">The extended properties to associate with the component.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.Builder.RegistrationBuilder`3.WithMetadata``1(System.Action{Autofac.Builder.MetadataConfiguration{``0}})">
      <summary>
            Associates data with the component.
            </summary>
      <typeparam name="TMetadata">A type with properties whose names correspond to the
            property names to configure.</typeparam>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="P:Autofac.Builder.RegistrationBuilder`3.ActivatorData">
      <summary>
            The activator data.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationBuilder`3.RegistrationStyle">
      <summary>
            The registration style.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationBuilder`3.RegistrationData">
      <summary>
            The registration data.
            </summary>
    </member>
    <member name="T:Autofac.Builder.RegistrationData">
      <summary>
            Data common to all registrations made in the container, both direct (IComponentRegistration)
            and dynamic (IRegistrationSource.)
            </summary>
    </member>
    <member name="M:Autofac.Builder.RegistrationData.#ctor(Autofac.Core.Service)">
      <summary>
            Construct a RegistrationData instance.
            </summary>
      <param name="defaultService">The default service that will be used if no others
            are added.</param>
    </member>
    <member name="M:Autofac.Builder.RegistrationData.AddServices(System.Collections.Generic.IEnumerable{Autofac.Core.Service})">
      <summary>
            Add multiple services for the registration, overriding the default.
            </summary>
      <param name="services">The services to add.</param>
      <remarks>If an empty collection is specified, this will still
            clear the default service.</remarks>
    </member>
    <member name="M:Autofac.Builder.RegistrationData.AddService(Autofac.Core.Service)">
      <summary>
            Add a service to the registration, overriding the default.
            </summary>
      <param name="service">The service to add.</param>
    </member>
    <member name="M:Autofac.Builder.RegistrationData.CopyFrom(Autofac.Builder.RegistrationData,System.Boolean)">
      <summary>
            Copies the contents of another RegistrationData object into this one.
            </summary>
      <param name="that">The data to copy.</param>
      <param name="includeDefaultService">When true, the default service
            will be changed to that of the other.</param>
    </member>
    <member name="M:Autofac.Builder.RegistrationData.ClearServices">
      <summary>
            Empties the configured services.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationData.Services">
      <summary>
            The services explicitly assigned to the component.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationData.Ownership">
      <summary>
            The instance ownership assigned to the component.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationData.Lifetime">
      <summary>
            The lifetime assigned to the component.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationData.Sharing">
      <summary>
            The sharing mode assigned to the component.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationData.Metadata">
      <summary>
            Extended properties assigned to the component.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationData.PreparingHandlers">
      <summary>
            Handlers for the Preparing event.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationData.ActivatingHandlers">
      <summary>
            Handlers for the Activating event.
            </summary>
    </member>
    <member name="P:Autofac.Builder.RegistrationData.ActivatedHandlers">
      <summary>
            Handlers for the Activated event.
            </summary>
    </member>
    <member name="T:Autofac.RegistrationExtensions">
      <summary>
            Adds registration syntax to the <see cref="T:Autofac.ContainerBuilder" /> type.
            </summary>
    </member>
    <member name="M:Autofac.RegistrationExtensions.RegisterModule(Autofac.ContainerBuilder,Autofac.Core.IModule)">
      <summary>
            Add a module to the container.
            </summary>
      <param name="builder">The builder to register the module with.</param>
      <param name="module">The module to add.</param>
    </member>
    <member name="M:Autofac.RegistrationExtensions.RegisterModule``1(Autofac.ContainerBuilder)">
      <summary>
            Add a module to the container.
            </summary>
      <param name="builder">The builder to register the module with.</param>
      <typeparam name="TModule">The module to add.</typeparam>
    </member>
    <member name="M:Autofac.RegistrationExtensions.RegisterComponent(Autofac.ContainerBuilder,Autofac.Core.IComponentRegistration)">
      <summary>
            Add a component to the container.
            </summary>
      <param name="builder">The builder to register the component with.</param>
      <param name="registration">The component to add.</param>
    </member>
    <member name="M:Autofac.RegistrationExtensions.RegisterSource(Autofac.ContainerBuilder,Autofac.Core.IRegistrationSource)">
      <summary>
            Add a registration source to the container.
            </summary>
      <param name="builder">The builder to register the registration source via.</param>
      <param name="registrationSource">The registration source to add.</param>
    </member>
    <member name="M:Autofac.RegistrationExtensions.RegisterInstance``1(Autofac.ContainerBuilder,``0)">
      <summary>
            Register an instance as a component.
            </summary>
      <typeparam name="T">The type of the instance.</typeparam>
      <param name="builder">Container builder.</param>
      <param name="instance">The instance to register.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
      <remarks>If no services are explicitly specified for the instance, the
            static type <typeparamref name="T" /> will be used as the default service (i.e. *not* <code>instance.GetType()</code>).</remarks>
    </member>
    <member name="M:Autofac.RegistrationExtensions.RegisterType``1(Autofac.ContainerBuilder)">
      <summary>
            Register a component to be created through reflection.
            </summary>
      <typeparam name="TImplementor">The type of the component implementation.</typeparam>
      <param name="builder">Container builder.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.RegisterType(Autofac.ContainerBuilder,System.Type)">
      <summary>
            Register a component to be created through reflection.
            </summary>
      <param name="implementationType">The type of the component implementation.</param>
      <param name="builder">Container builder.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.Register``1(Autofac.ContainerBuilder,System.Func{Autofac.IComponentContext,``0})">
      <summary>
            Register a delegate as a component.
            </summary>
      <typeparam name="T">The type of the instance.</typeparam>
      <param name="builder">Container builder.</param>
      <param name="delegate">The delegate to register.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.Register``1(Autofac.ContainerBuilder,System.Func{Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},``0})">
      <summary>
            Register a delegate as a component.
            </summary>
      <typeparam name="T">The type of the instance.</typeparam>
      <param name="builder">Container builder.</param>
      <param name="delegate">The delegate to register.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.RegisterGeneric(Autofac.ContainerBuilder,System.Type)">
      <summary>
            Register an un-parameterised generic type, e.g. Repository&lt;&gt;.
            Concrete types will be made as they are requested, e.g. with Resolve&lt;Repository&lt;int&gt;&gt;().
            </summary>
      <param name="builder">Container builder.</param>
      <param name="implementor">The open generic implementation type.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.PreserveExistingDefaults``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
      <summary>
            Specifies that the component being registered should only be made the default for services
            that have not already been registered.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TSingleRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set service mapping on.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.RegisterAssemblyTypes(Autofac.ContainerBuilder,System.Reflection.Assembly[])">
      <summary>
            Register the types in an assembly.
            </summary>
      <param name="builder">Container builder.</param>
      <param name="assemblies">The assemblies from which to register types.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.Where``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,System.Boolean})">
      <summary>
            Specifies a subset of types to register from a scanned assembly.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to filter types from.</param>
      <param name="predicate">Predicate that returns true for types to register.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.As``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,System.Collections.Generic.IEnumerable{Autofac.Core.Service}})">
      <summary>
            Specifies how a type from a scanned assembly is mapped to a service.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set service mapping on.</param>
      <param name="serviceMapping">Function mapping types to services.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.As``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,Autofac.Core.Service})">
      <summary>
            Specifies how a type from a scanned assembly is mapped to a service.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set service mapping on.</param>
      <param name="serviceMapping">Function mapping types to services.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.As``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,System.Type})">
      <summary>
            Specifies how a type from a scanned assembly is mapped to a service.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set service mapping on.</param>
      <param name="serviceMapping">Function mapping types to services.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.AsSelf``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
      <summary>
            Specifies that a type from a scanned assembly provides its own concrete type as a service.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set service mapping on.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.WithMetadata``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}}})">
      <summary>
            Specify how a type from a scanned assembly provides metadata.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set service mapping on.</param>
      <param name="metadataMapping">A function mapping the type to a list of metadata items.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.WithMetadata``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.String,System.Func{System.Type,System.Object})">
      <summary>
            Specify how a type from a scanned assembly provides metadata.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set service mapping on.</param>
      <param name="metadataKey">Key of the metadata item.</param>
      <param name="metadataValueMapping">A function retrieving the value of the item from the component type.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.Named``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Func{System.Type,System.String},System.Type)">
      <summary>
            Specifies how a type from a scanned assembly is mapped to a service.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set service mapping on.</param>
      <param name="serviceType">Service type provided by the component.</param>
      <param name="serviceNameMapping">Function mapping types to service names.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.AsImplementedInterfaces``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2})">
      <summary>
            Specifies that a type from a scanned assembly is registered as providing all of its
            implemented interfaces.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set service mapping on.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.FindConstructorsWith``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Reflection.BindingFlags)">
      <summary>
            Set the policy used to find candidate constructors on the implementation type.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
      <typeparam name="TStyle">Registration style.</typeparam>
      <param name="registration">Registration to set policy on.</param>
      <param name="bindingFlags">Binding flags used when searching for constructors.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.FindConstructorsWith``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},Autofac.Core.Activators.Reflection.IConstructorFinder)">
      <summary>
            Set the policy used to find candidate constructors on the implementation type.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
      <typeparam name="TStyle">Registration style.</typeparam>
      <param name="registration">Registration to set policy on.</param>
      <param name="constructorFinder">Policy to be used when searching for constructors.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.UsingConstructor``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Type[])">
      <summary>
            Set the policy used to select from available constructors on the implementation type.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
      <typeparam name="TStyle">Registration style.</typeparam>
      <param name="registration">Registration to set policy on.</param>
      <param name="signature">Constructor signature to match.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.UsingConstructor``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},Autofac.Core.Activators.Reflection.IConstructorSelector)">
      <summary>
            Set the policy used to select from available constructors on the implementation type.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TStyle">Registration style.</typeparam>
      <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set policy on.</param>
      <param name="constructorSelector">Policy to be used when selecting a constructor.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.WithParameter``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.String,System.Object)">
      <summary>
            Configure an explicit value for a constructor parameter.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TStyle">Registration style.</typeparam>
      <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set parameter on.</param>
      <param name="parameterName">Name of a constructor parameter on the target type.</param>
      <param name="parameterValue">Value to supply to the parameter.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.WithParameter``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},Autofac.Core.Parameter)">
      <summary>
            Configure an explicit value for a constructor parameter.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TStyle">Registration style.</typeparam>
      <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set parameter on.</param>
      <param name="parameter">The parameter to supply to the constructor.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.WithParameters``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Configure explicit values for constructor parameters.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TStyle">Registration style.</typeparam>
      <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set parameter on.</param>
      <param name="parameters">The parameters to supply to the constructor.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.WithProperty``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.String,System.Object)">
      <summary>
            Configure an explicit value for a property.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TStyle">Registration style.</typeparam>
      <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set property on.</param>
      <param name="propertyName">Name of a property on the target type.</param>
      <param name="propertyValue">Value to supply to the property.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.WithProperty``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},Autofac.Core.Parameter)">
      <summary>
            Configure an explicit value for a property.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TStyle">Registration style.</typeparam>
      <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set parameter on.</param>
      <param name="property">The property to supply.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.WithProperties``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Configure explicit values for properties.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TStyle">Registration style.</typeparam>
      <typeparam name="TReflectionActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set parameter on.</param>
      <param name="properties">The properties to supply.</param>
      <returns>A registration builder allowing further configuration of the component.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.Targeting``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},Autofac.Core.IComponentRegistration)">
      <summary>
            Sets the target of the registration (used for metadata generation.)
            </summary>
      <typeparam name="TLimit">The type of the limit.</typeparam>
      <typeparam name="TActivatorData">The type of the activator data.</typeparam>
      <typeparam name="TSingleRegistrationStyle">Registration style</typeparam>
      <param name="registration">Registration to set target for.</param>
      <param name="target">The target.</param>
      <returns>
            Registration builder allowing the registration to be configured.
            </returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.OnRegistered``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Action{Autofac.Core.ComponentRegisteredEventArgs})">
      <summary>
            Provide a handler to be called when the component is registered.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TSingleRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration add handler to.</param>
      <param name="handler">The handler.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.OnRegistered``2(Autofac.Builder.IRegistrationBuilder{``0,Autofac.Features.Scanning.ScanningActivatorData,``1},System.Action{Autofac.Core.ComponentRegisteredEventArgs})">
      <summary>
            Provide a handler to be called when the component is registred.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <param name="registration">Registration add handler to.</param>
      <param name="handler">The handler.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.AsClosedTypesOf``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Type)">
      <summary>
            Specifies that a type from a scanned assembly is registered if it implements an interface
            that closes the provided open generic interface type.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to set service mapping on.</param>
      <param name="openGenericServiceType">The open generic interface or base class type for which implementations will be found.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.AssignableTo``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.Type)">
      <summary>
            Filters the scanned types to include only those assignable to the provided
            type.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to filter types from.</param>
      <param name="type">The type or interface which all classes must be assignable from.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.AssignableTo``1(Autofac.Builder.IRegistrationBuilder{System.Object,Autofac.Features.Scanning.ScanningActivatorData,Autofac.Builder.DynamicRegistrationStyle})">
      <summary>
            Filters the scanned types to include only those assignable to the provided
            type.
            </summary>
      <param name="registration">Registration to filter types from.</param>
      <typeparam name="T">The type or interface which all classes must be assignable from.</typeparam>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.Except``1(Autofac.Builder.IRegistrationBuilder{System.Object,Autofac.Features.Scanning.ScanningActivatorData,Autofac.Builder.DynamicRegistrationStyle})">
      <summary>
            Filters the scanned types to exclude the provided type.
            </summary>
      <param name="registration">Registration to filter types from.</param>
      <typeparam name="T">The concrete type to exclude.</typeparam>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.Except``1(Autofac.Builder.IRegistrationBuilder{System.Object,Autofac.Features.Scanning.ScanningActivatorData,Autofac.Builder.DynamicRegistrationStyle},System.Action{Autofac.Builder.IRegistrationBuilder{``0,Autofac.Builder.ConcreteReflectionActivatorData,Autofac.Builder.SingleRegistrationStyle}})">
      <summary>
            Filters the scanned types to exclude the provided type, providing specific configuration for
            the excluded type.
            </summary>
      <param name="registration">Registration to filter types from.</param>
      <param name="customisedRegistration">Registration for the excepted type.</param>
      <typeparam name="T">The concrete type to exclude.</typeparam>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.InNamespaceOf``1(Autofac.Builder.IRegistrationBuilder{System.Object,Autofac.Features.Scanning.ScanningActivatorData,Autofac.Builder.DynamicRegistrationStyle})">
      <summary>
            Filters the scanned types to include only those in the namespace of the provided type
            or one of its sub-namespaces.
            </summary>
      <param name="registration">Registration to filter types from.</param>
      <typeparam name="T">A type in the target namespace.</typeparam>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.InNamespace``3(Autofac.Builder.IRegistrationBuilder{``0,``1,``2},System.String)">
      <summary>
            Filters the scanned types to include only those in the provided namespace
            or one of its sub-namespaces.
            </summary>
      <typeparam name="TLimit">Registration limit type.</typeparam>
      <typeparam name="TRegistrationStyle">Registration style.</typeparam>
      <typeparam name="TScanningActivatorData">Activator data type.</typeparam>
      <param name="registration">Registration to filter types from.</param>
      <param name="ns">The namespace from which types will be selected.</param>
      <returns>Registration builder allowing the registration to be configured.</returns>
    </member>
    <member name="M:Autofac.RegistrationExtensions.RegisterAdapter``2(Autofac.ContainerBuilder,System.Func{Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},``0,``1})">
      <summary>
            Adapt all components implementing service <typeparamref name="TFrom" />
            to provide <typeparamref name="TTo" /> using the provided <paramref name="adapter" />
            function.
            </summary>
      <typeparam name="TFrom">Service type to adapt from.</typeparam>
      <typeparam name="TTo">Service type to adapt to. Must not be the
            same as <typeparamref name="TFrom" />.</typeparam>
      <param name="builder">Container builder.</param>
      <param name="adapter">Function adapting <typeparamref name="TFrom" /> to
            service <typeparamref name="TTo" />, given the context and parameters.</param>
    </member>
    <member name="M:Autofac.RegistrationExtensions.RegisterAdapter``2(Autofac.ContainerBuilder,System.Func{Autofac.IComponentContext,``0,``1})">
      <summary>
            Adapt all components implementing service <typeparamref name="TFrom" />
            to provide <typeparamref name="TTo" /> using the provided <paramref name="adapter" />
            function.
            </summary>
      <typeparam name="TFrom">Service type to adapt from.</typeparam>
      <typeparam name="TTo">Service type to adapt to. Must not be the
            same as <typeparamref name="TFrom" />.</typeparam>
      <param name="builder">Container builder.</param>
      <param name="adapter">Function adapting <typeparamref name="TFrom" /> to
            service <typeparamref name="TTo" />, given the context.</param>
    </member>
    <member name="M:Autofac.RegistrationExtensions.RegisterAdapter``2(Autofac.ContainerBuilder,System.Func{``0,``1})">
      <summary>
            Adapt all components implementing service <typeparamref name="TFrom" />
            to provide <typeparamref name="TTo" /> using the provided <paramref name="adapter" />
            function.
            </summary>
      <typeparam name="TFrom">Service type to adapt from.</typeparam>
      <typeparam name="TTo">Service type to adapt to. Must not be the
            same as <typeparamref name="TFrom" />.</typeparam>
      <param name="builder">Container builder.</param>
      <param name="adapter">Function adapting <typeparamref name="TFrom" /> to
            service <typeparamref name="TTo" />.</param>
    </member>
    <member name="T:Autofac.RegistrationExtensionsResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.RegistrationExtensionsResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.RegistrationExtensionsResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.RegistrationExtensionsResources.InstanceRegistrationsAreSingleInstanceOnly">
      <summary>
              Looks up a localized string similar to The instance  registration '{0}' can support SingleInstance() sharing only..
            </summary>
    </member>
    <member name="P:Autofac.RegistrationExtensionsResources.NoMatchingConstructorExists">
      <summary>
              Looks up a localized string similar to No matching constructor exists on type '{0}'..
            </summary>
    </member>
    <member name="T:Autofac.Builder.SimpleActivatorData">
      <summary>
            An activator builder with no parameters.
            </summary>
    </member>
    <member name="M:Autofac.Builder.SimpleActivatorData.#ctor(Autofac.Core.IInstanceActivator)">
      <summary>
            Return the provided activator.
            </summary>
      <param name="activator">The activator to return.</param>
    </member>
    <member name="P:Autofac.Builder.SimpleActivatorData.Activator">
      <summary>
            Gets the activator.
            </summary>
    </member>
    <member name="T:Autofac.Builder.SingleRegistrationStyle">
      <summary>
            Registration style for individual components.
            </summary>
    </member>
    <member name="P:Autofac.Builder.SingleRegistrationStyle.Id">
      <summary>
            The id used for the registration.
            </summary>
    </member>
    <member name="P:Autofac.Builder.SingleRegistrationStyle.RegisteredHandlers">
      <summary>
            Handlers to notify of the component registration event.
            </summary>
    </member>
    <member name="P:Autofac.Builder.SingleRegistrationStyle.PreserveDefaults">
      <summary>
            By default, new registrations override existing registrations as defaults.
            If set to true, new registrations will not change existing defaults.
            </summary>
    </member>
    <member name="P:Autofac.Builder.SingleRegistrationStyle.Target">
      <summary>
            The component upon which this registration is based.
            </summary>
    </member>
    <member name="T:Autofac.ContainerBuilder">
      <summary>
            Used to build an <see cref="T:Autofac.IContainer" /> from component registrations.
            </summary>
      <example>
        <code>
            var builder = new ContainerBuilder();
            
            builder.RegisterType&lt;Logger&gt;()
                .As&lt;ILogger&gt;()
                .SingleInstance();
            
            builder.Register(c =&gt; new MessageHandler(c.Resolve&lt;ILogger&gt;()));
            
            var container = builder.Build();
            // resolve components from container...
            </code>
      </example>
      <remarks>Most <see cref="T:Autofac.ContainerBuilder" /> functionality is accessed
            via extension methods in <see cref="T:Autofac.RegistrationExtensions" />.</remarks>
      <seealso cref="T:Autofac.IContainer" />
      <see cref="T:Autofac.RegistrationExtensions" />
    </member>
    <member name="M:Autofac.ContainerBuilder.RegisterCallback(System.Action{Autofac.Core.IComponentRegistry})">
      <summary>
            Register a callback that will be invoked when the container is configured.
            </summary>
      <remarks>This is primarily for extending the builder syntax.</remarks>
      <param name="configurationCallback">Callback to execute.</param>
    </member>
    <member name="M:Autofac.ContainerBuilder.Build">
      <summary>
            Create a new container with the component registrations that have been made.
            </summary>
      <remarks>
            Build can only be called once per <see cref="T:Autofac.ContainerBuilder" />
            - this prevents ownership issues for provided instances.
            Build enables support for the relationship types that come with Autofac (e.g.
            Func, Owned, Meta, Lazy, IEnumerable.) To exclude support for these types,
            first create the container, then call Update() on the builder.
            </remarks>
      <returns>A new container with the configured component registrations.</returns>
    </member>
    <member name="M:Autofac.ContainerBuilder.Update(Autofac.IContainer)">
      <summary>
            Configure an existing container with the component registrations
            that have been made.
            </summary>
      <remarks>
            Update can only be called once per <see cref="T:Autofac.ContainerBuilder" />
            - this prevents ownership issues for provided instances.
            </remarks>
      <param name="container">An existing container to make the registrations in.</param>
    </member>
    <member name="M:Autofac.ContainerBuilder.Update(Autofac.Core.IComponentRegistry)">
      <summary>
            Configure an existing registry with the component registrations
            that have been made.
            </summary>
      <remarks>
            Update can only be called once per <see cref="T:Autofac.ContainerBuilder" />
            - this prevents ownership issues for provided instances.
            </remarks>
      <param name="componentRegistry">An existing registry to make the registrations in.</param>
    </member>
    <member name="T:Autofac.NamedParameter">
      <summary>
            A parameter identified by name. When applied to a reflection-based
            component, <see cref="P:Autofac.NamedParameter.Name" /> will be matched against
            the name of the component's constructor arguments. When applied to
            a delegate-based component, the parameter can be accessed using
            <see cref="M:Autofac.ParameterExtensions.Named``1(System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.String)" />.
            </summary>
      <example>
            Component with parameter:
            <code>
            public class MyComponent
            {
                public MyComponent(int amount) { ... }
            }
            </code>
            Providing the parameter:
            <code>
            var builder = new ContainerBuilder();
            builder.RegisterType&lt;MyComponent&gt;();
            var container = builder.Build();
            var myComponent = container.Resolve&lt;MyComponent&gt;(new NamedParameter("amount", 123));
            </code></example>
    </member>
    <member name="M:Autofac.NamedParameter.#ctor(System.String,System.Object)">
      <summary>
            Create a <see cref="T:Autofac.NamedParameter" /> with the specified constant value.
            </summary>
      <param name="name">The name of the parameter.</param>
      <param name="value">The parameter value.</param>
    </member>
    <member name="P:Autofac.NamedParameter.Name">
      <summary>
            The name of the parameter.
            </summary>
    </member>
    <member name="T:Autofac.ParameterExtensions">
      <summary>
            Extension methods that simplify extraction of parameter values from
            an <see cref="T:System.Collections.Generic.IEnumerable`1" /> where T is <see cref="T:Autofac.Core.Parameter" />.
            Each method returns the first matching parameter value, or throws an exception if
            none is provided.
            </summary>
      <example>
            At configuration time, delegate registrations can retrieve parameter values using
            the methods <see cref="M:Autofac.ParameterExtensions.Named``1(System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.String)" />, <see cref="M:Autofac.ParameterExtensions.Positional``1(System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.Int32)" /> and <see cref="M:Autofac.ParameterExtensions.TypedAs``1(System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})" />:
            <code>
            builder.Register((c, p) =&gt; new FtpClient(p.Named&lt;string&gt;("server")));
            </code>
            These parameters can be provided at resolution time:
            <code>
            container.Resolve&lt;FtpClient&gt;(new NamedParameter("server", "ftp.example.com"));
            </code>
            Alternatively, the parameters can be provided via a <i>Generated Factory</i> - http://code.google.com/p/autofac/wiki/DelegateFactories.
            </example>
    </member>
    <member name="M:Autofac.ParameterExtensions.Named``1(System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.String)">
      <summary>
            Retrieve a named parameter value from a <see cref="T:Autofac.NamedParameter" /> instance.
            </summary>
      <typeparam name="T">The type to which the returned value will be cast.</typeparam>
      <param name="parameters">The available parameters to choose from.</param>
      <param name="name">The name of the parameter to select.</param>
      <returns>The value of the selected parameter.</returns>
      <seealso cref="T:Autofac.NamedParameter" />
    </member>
    <member name="M:Autofac.ParameterExtensions.Positional``1(System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.Int32)">
      <summary>
            Retrieve a positional parameter value from a <see cref="T:Autofac.PositionalParameter" /> instance.
            </summary>
      <typeparam name="T">The type to which the returned value will be cast.</typeparam>
      <param name="parameters">The available parameters to choose from.</param>
      <param name="position">The zero-based position of the parameter to select.</param>
      <returns>The value of the selected parameter.</returns>
      <remarks>The position value is the one associated with the parameter when
            it was constructed, <b>not</b> its index into the <paramref name="parameters" />
            sequence.</remarks>
      <seealso cref="T:Autofac.PositionalParameter" />
    </member>
    <member name="M:Autofac.ParameterExtensions.TypedAs``1(System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Retrieve a typed parameter value from a <see cref="T:Autofac.TypedParameter" /> instance.
            </summary>
      <typeparam name="T">The type to which the returned value will be cast.</typeparam>
      <param name="parameters">The available parameters to choose from.</param>
      <returns>The value of the selected parameter.</returns>
      <seealso cref="T:Autofac.TypedParameter" />
    </member>
    <member name="T:Autofac.PositionalParameter">
      <summary>
            A parameter that is identified according to an integer representing its
            position in an argument list. When applied to a reflection-based
            component, <see cref="P:Autofac.PositionalParameter.Position" /> will be matched against
            the indices of the component's constructor arguments. When applied to
            a delegate-based component, the parameter can be accessed using
            <see cref="M:Autofac.ParameterExtensions.Positional``1(System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.Int32)" />.
            </summary>
      <example>
            Component with parameter:
            <code>
            public class MyComponent
            {
                public MyComponent(int amount) { ... }
            }
            </code>
            Providing the parameter:
            <code>
            var builder = new ContainerBuilder();
            builder.RegisterType&lt;MyComponent&gt;();
            var container = builder.Build();
            var myComponent = container.Resolve&lt;MyComponent&gt;(new PositionalParameter(0, 123));
            </code></example>
    </member>
    <member name="M:Autofac.PositionalParameter.#ctor(System.Int32,System.Object)">
      <summary>
            Construct a positional parameter with the specified constant value.
            </summary>
      <param name="position">The zero-based position of the parameter.</param>
      <param name="value">The parameter value.</param>
    </member>
    <member name="P:Autofac.PositionalParameter.Position">
      <summary>
            The zero-based position of the parameter.
            </summary>
    </member>
    <member name="T:Autofac.ResolutionExtensions">
      <summary>
            Adds syntactic convenience methods to the <see cref="T:Autofac.IComponentContext" /> interface.
            </summary>
    </member>
    <member name="M:Autofac.ResolutionExtensions.InjectProperties``1(Autofac.IComponentContext,``0)">
      <summary>
            Set any properties on <paramref name="instance" /> that can be
            resolved in the context.
            </summary>
      <typeparam name="TService">Type of instance. Used only to provide method chaining.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="instance">The instance to inject properties into.</param>
      <returns>
        <paramref name="instance" />.</returns>
    </member>
    <member name="M:Autofac.ResolutionExtensions.InjectUnsetProperties``1(Autofac.IComponentContext,``0)">
      <summary>
            Set any null-valued properties on <paramref name="instance" /> that can be
            resolved by the container.
            </summary>
      <typeparam name="TService">Type of instance. Used only to provide method chaining.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="instance">The instance to inject properties into.</param>
      <returns>
        <paramref name="instance" />.</returns>
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve``1(Autofac.IComponentContext,System.Guid)">
      <summary>
            Retrieve a service from the context.
            </summary>
      <typeparam name="TService">The type to which the result will be cast.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="registrationId">Identity of the registration providing the service.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve``1(Autofac.IComponentContext,System.Guid,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Retrieve a service from the context.
            </summary>
      <typeparam name="TService">The type to which the result will be cast.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="registrationId">Identity of the registration providing the service.</param>
      <param name="parameters">The parameters.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve``1(Autofac.IComponentContext,System.Guid,Autofac.Core.Parameter[])">
      <summary>
            Retrieve a service from the context.
            </summary>
      <typeparam name="TService">The type to which the result will be cast.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="registrationId">Identity of the registration providing the service.</param>
      <param name="parameters">The parameters.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve``1(Autofac.IComponentContext,System.String)">
      <summary>
            Retrieve a service from the context.
            </summary>
      <typeparam name="TService">The type to which the result will be cast.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceName">Name of the service.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve``1(Autofac.IComponentContext,System.String,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Retrieve a service from the context.
            </summary>
      <typeparam name="TService">The type to which the result will be cast.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceName">Name of the service.</param>
      <param name="parameters">The parameters.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve``1(Autofac.IComponentContext,System.String,Autofac.Core.Parameter[])">
      <summary>
            Retrieve a service from the context.
            </summary>
      <typeparam name="TService">The type to which the result will be cast.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceName">Name of the service.</param>
      <param name="parameters">The parameters.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve``1(Autofac.IComponentContext,System.Object)">
      <summary>
            Retrieve a service from the context.
            </summary>
      <typeparam name="TService">The type to which the result will be cast.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceKey">Key of the service.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve``1(Autofac.IComponentContext,System.Object,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Retrieve a service from the context.
            </summary>
      <typeparam name="TService">The type to which the result will be cast.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceKey">Key of the service.</param>
      <param name="parameters">The parameters.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve``1(Autofac.IComponentContext,System.Object,Autofac.Core.Parameter[])">
      <summary>
            Retrieve a service from the context.
            </summary>
      <typeparam name="TService">The type to which the result will be cast.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceKey">Key of the service.</param>
      <param name="parameters">The parameters.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve``1(Autofac.IComponentContext)">
      <summary>
            Retrieve a service from the context.
            </summary>
      <typeparam name="TService">The service to retrieve.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <returns>The component instance that provides the service.</returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve``1(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Retrieve a service from the context.
            </summary>
      <typeparam name="TService">The type to which the result will be cast.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve``1(Autofac.IComponentContext,Autofac.Core.Parameter[])">
      <summary>
            Retrieve a service from the context.
            </summary>
      <typeparam name="TService">The type to which the result will be cast.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve(Autofac.IComponentContext,System.Type)">
      <summary>
            Retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceType">The service type.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve(Autofac.IComponentContext,System.Type,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <param name="serviceType">The service type.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve(Autofac.IComponentContext,System.Type,Autofac.Core.Parameter[])">
      <summary>
            Retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <param name="serviceType">The service type.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve(Autofac.IComponentContext,System.String,System.Type)">
      <summary>
            Retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceName">The service name.</param>
      <param name="serviceType">Type of the service.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve(Autofac.IComponentContext,System.String,System.Type,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <param name="serviceName">The service name.</param>
      <param name="serviceType">Type of the service.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve(Autofac.IComponentContext,System.String,System.Type,Autofac.Core.Parameter[])">
      <summary>
            Retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <param name="serviceName">The service name.</param>
      <param name="serviceType">Type of the service.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve(Autofac.IComponentContext,Autofac.Core.Service)">
      <summary>
            Retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="service">The service to resolve.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve(Autofac.IComponentContext,Autofac.Core.Service,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <param name="service">The service to resolve.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.Resolve(Autofac.IComponentContext,Autofac.Core.Service,Autofac.Core.Parameter[])">
      <summary>
            Retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <param name="service">The service to resolve.</param>
      <returns>
            The component instance that provides the service.
            </returns>
      <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.ResolveOptional``1(Autofac.IComponentContext)">
      <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <typeparam name="TService">The service to resolve.</typeparam>
      <returns>
            The component instance that provides the service, or null.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.ResolveOptional``1(Autofac.IComponentContext,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <typeparam name="TService">The service to resolve.</typeparam>
      <returns>
            The component instance that provides the service, or null.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.ResolveOptional``1(Autofac.IComponentContext,Autofac.Core.Parameter[])">
      <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <typeparam name="TService">The service to resolve.</typeparam>
      <returns>
            The component instance that provides the service, or null.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.ResolveOptional``1(Autofac.IComponentContext,System.String)">
      <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceName">The name of the service.</param>
      <typeparam name="TService">The service to resolve.</typeparam>
      <returns>
            The component instance that provides the service, or null.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.ResolveOptional``1(Autofac.IComponentContext,System.String,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <param name="serviceName">The name of the service.</param>
      <typeparam name="TService">The service to resolve.</typeparam>
      <returns>
            The component instance that provides the service, or null.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.ResolveOptional``1(Autofac.IComponentContext,System.String,Autofac.Core.Parameter[])">
      <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <param name="serviceName">The name of the service.</param>
      <typeparam name="TService">The service to resolve.</typeparam>
      <returns>
            The component instance that provides the service, or null.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.ResolveOptional(Autofac.IComponentContext,System.Type)">
      <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceType">The type of the service.</param>
      <returns>
            The component instance that provides the service, or null.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.ResolveOptional(Autofac.IComponentContext,System.Type,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <param name="serviceType">The type of the service.</param>
      <returns>
            The component instance that provides the service, or null.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.ResolveOptional(Autofac.IComponentContext,System.Type,Autofac.Core.Parameter[])">
      <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="parameters">Parameters for the service.</param>
      <param name="serviceType">The type of the service.</param>
      <returns>
            The component instance that provides the service, or null.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.ResolveOptional(Autofac.IComponentContext,Autofac.Core.Service)">
      <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="service">The service.</param>
      <returns>
            The component instance that provides the service, or null.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.ResolveOptional(Autofac.IComponentContext,Autofac.Core.Service,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})">
      <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="service">The service.</param>
      <param name="parameters">Parameters for the service.</param>
      <returns>
            The component instance that provides the service, or null.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.ResolveOptional(Autofac.IComponentContext,Autofac.Core.Service,Autofac.Core.Parameter[])">
      <summary>
            Retrieve a service from the context, or null if the service is not
            registered.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="service">The service.</param>
      <param name="parameters">Parameters for the service.</param>
      <returns>
            The component instance that provides the service, or null.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.IsRegistered``1(Autofac.IComponentContext)">
      <summary>
            Determine whether the specified service is available in the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <typeparam name="TService">The service to test for the registration of.</typeparam>
      <returns>True if the service is registered.</returns>
    </member>
    <member name="M:Autofac.ResolutionExtensions.IsRegistered(Autofac.IComponentContext,System.Type)">
      <summary>
            Determine whether the specified service is available in the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceType">The service to test for the registration of.</param>
      <returns>True if the service is registered.</returns>
    </member>
    <member name="M:Autofac.ResolutionExtensions.IsRegistered(Autofac.IComponentContext,System.String,System.Type)">
      <summary>
            Determine whether the specified service is available in the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceName">The name of the service to test for the registration of.</param>
      <param name="serviceType">Type type of the service to test for the registration of.</param>
      <returns>True if the service is registered.</returns>
    </member>
    <member name="M:Autofac.ResolutionExtensions.IsRegistered``1(Autofac.IComponentContext,System.String)">
      <summary>
            Determine whether the specified service is available in the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceName">The name of the service to test for the registration of.</param>
      <typeparam name="TService">Type type of the service to test for the registration of.</typeparam>
      <returns>True if the service is registered.</returns>
    </member>
    <member name="M:Autofac.ResolutionExtensions.IsRegistered(Autofac.IComponentContext,Autofac.Core.Service)">
      <summary>
            Determine whether the specified service is available in the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="service">The service to test for the registration of.</param>
      <returns>True if the service is registered.</returns>
    </member>
    <member name="M:Autofac.ResolutionExtensions.TryResolve(Autofac.IComponentContext,Autofac.Core.Service,System.Collections.Generic.IEnumerable{Autofac.Core.Parameter},System.Object@)">
      <summary>
            Try to retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="service">The service to resolve.</param>
      <param name="instance">The resulting component instance providing the service, or null.</param>
      <param name="parameters">The parameters.</param>
      <returns>
            True if a component providing the service is available.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.TryResolve(Autofac.IComponentContext,Autofac.Core.Service,System.Object@)">
      <summary>
            Try to retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="service">The service to resolve.</param>
      <param name="instance">The resulting component instance providing the service, or null.</param>
      <returns>
            True if a component providing the service is available.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.TryResolve(Autofac.IComponentContext,System.Type,System.Object@)">
      <summary>
            Try to retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceType">The service type to resolve.</param>
      <param name="instance">The resulting component instance providing the service, or null.</param>
      <returns>
            True if a component providing the service is available.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.TryResolve``1(Autofac.IComponentContext,``0@)">
      <summary>
            Try to retrieve a service from the context.
            </summary>
      <typeparam name="T">The service type to resolve.</typeparam>
      <param name="context">The context from which to resolve the service.</param>
      <param name="instance">The resulting component instance providing the service, or default(T).</param>
      <returns>
            True if a component providing the service is available.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.TryResolve(Autofac.IComponentContext,System.String,System.Type,System.Object@)">
      <summary>
            Try to retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceName">The name of the service to resolve.</param>
      <param name="serviceType">The type of the service to resolve.</param>
      <param name="instance">The resulting component instance providing the service, or null.</param>
      <returns>
            True if a component providing the service is available.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="M:Autofac.ResolutionExtensions.TryResolve(Autofac.IComponentContext,System.Object,System.Type,System.Object@)">
      <summary>
            Try to retrieve a service from the context.
            </summary>
      <param name="context">The context from which to resolve the service.</param>
      <param name="serviceKey">The key of the service to resolve.</param>
      <param name="serviceType">The type of the service to resolve.</param>
      <param name="instance">The resulting component instance providing the service, or null.</param>
      <returns>
            True if a component providing the service is available.
            </returns>
      <exception cref="T:Autofac.Core.DependencyResolutionException" />
    </member>
    <member name="T:Autofac.Core.ResolvedParameter">
      <summary>
            Flexible parameter type allows arbitrary values to be retrieved
            from the resolution context.
            </summary>
    </member>
    <member name="M:Autofac.Core.ResolvedParameter.#ctor(System.Func{System.Reflection.ParameterInfo,Autofac.IComponentContext,System.Boolean},System.Func{System.Reflection.ParameterInfo,Autofac.IComponentContext,System.Object})">
      <summary>
            Create an instance of the ResolvedParameter class.
            </summary>
      <param name="predicate">A predicate that determines which parameters on a constructor will be supplied by this instance.</param>
      <param name="valueAccessor">A function that supplies the parameter value given the context.</param>
    </member>
    <member name="M:Autofac.Core.ResolvedParameter.CanSupplyValue(System.Reflection.ParameterInfo,Autofac.IComponentContext,System.Func{System.Object}@)">
      <summary>
            Returns true if the parameter is able to provide a value to a particular site.
            </summary>
      <param name="pi">Constructor, method, or property-mutator parameter.</param>
      <param name="context">The component context in which the value is being provided.</param>
      <param name="valueProvider">If the result is true, the valueProvider parameter will
            be set to a function that will lazily retrieve the parameter value. If the result is false,
            will be set to null.</param>
      <returns>True if a value can be supplied; otherwise, false.</returns>
    </member>
    <member name="T:Autofac.TypedParameter">
      <summary>
            A parameter that can supply values to sites that exactly
            match a specified type. When applied to a reflection-based
            component, <see cref="P:Autofac.TypedParameter.Type" /> will be matched against
            the types of the component's constructor arguments. When applied to
            a delegate-based component, the parameter can be accessed using
            <see cref="M:Autofac.ParameterExtensions.TypedAs``1(System.Collections.Generic.IEnumerable{Autofac.Core.Parameter})" />.
            </summary>
      <example>
            Component with parameter:
            <code>
            public class MyComponent
            {
                public MyComponent(int amount) { ... }
            }
            </code>
            Providing the parameter:
            <code>
            var builder = new ContainerBuilder();
            builder.RegisterType&lt;MyComponent&gt;();
            var container = builder.Build();
            var myComponent = container.Resolve&lt;MyComponent&gt;(new TypedParameter(typeof(int), 123));
            </code></example>
    </member>
    <member name="M:Autofac.TypedParameter.#ctor(System.Type,System.Object)">
      <summary>
            Create a typed parameter with the specified constant value.
            </summary>
      <param name="type">The exact type to match.</param>
      <param name="value">The parameter value.</param>
    </member>
    <member name="M:Autofac.TypedParameter.From``1(``0)">
      <summary>
            Shortcut for creating <see cref="T:Autofac.TypedParameter" /> 
            by using the <typeparamref name="T" /></summary>
      <typeparam name="T">type to be used for the parameter</typeparam>
      <param name="value">The parameter value.</param>
      <returns>new typed parameter</returns>
    </member>
    <member name="P:Autofac.TypedParameter.Type">
      <summary>
            The type against which targets are matched.
            </summary>
    </member>
    <member name="T:Autofac.Util.Enforce">
      <summary>
            Helper methods used throughout the codebase.
            </summary>
    </member>
    <member name="M:Autofac.Util.Enforce.ArgumentNotNull``1(``0,System.String)">
      <summary>
            Enforce that an argument is not null. Returns the
            value if valid so that it can be used inline in
            base initialiser syntax.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="value">
      </param>
      <param name="name">
      </param>
      <returns>
        <paramref name="value" />
      </returns>
    </member>
    <member name="M:Autofac.Util.Enforce.ArgumentElementNotNull``1(``0,System.String)">
      <summary>
            Enforce that sequence does not contain null. Returns the
            value if valid so that it can be used inline in
            base initialiser syntax.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="value">The value.</param>
      <param name="name">The name.</param>
      <returns>
        <paramref name="value" />
      </returns>
    </member>
    <member name="M:Autofac.Util.Enforce.NotNull``1(``0)">
      <summary>
            Enforces that the provided object is non-null.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="value">The value.</param>
      <returns>
        <paramref name="value" />
      </returns>
    </member>
    <member name="M:Autofac.Util.Enforce.ArgumentNotNullOrEmpty(System.String,System.String)">
      <summary>
            Enforce that an argument is not null or empty. Returns the
            value if valid so that it can be used inline in
            base initialiser syntax.
            </summary>
      <param name="value">The value.</param>
      <param name="description">The description.</param>
      <returns>
        <paramref name="value" />
      </returns>
    </member>
    <member name="M:Autofac.Util.Enforce.ArgumentTypeIsFunction(System.Type)">
      <summary>
            Enforce that the argument is a delegate type.
            </summary>
      <param name="delegateType">The type to test.</param>
    </member>
    <member name="T:Autofac.Util.EnforceResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Util.EnforceResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Util.EnforceResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Util.EnforceResources.CannotBeEmpty">
      <summary>
              Looks up a localized string similar to The argument '{0}' cannot be empty..
            </summary>
    </member>
    <member name="P:Autofac.Util.EnforceResources.CannotBeNull">
      <summary>
              Looks up a localized string similar to The object of type '{0}' cannot be null..
            </summary>
    </member>
    <member name="P:Autofac.Util.EnforceResources.DelegateReturnsVoid">
      <summary>
              Looks up a localized string similar to Type {0} returns void..
            </summary>
    </member>
    <member name="P:Autofac.Util.EnforceResources.ElementCannotBeNull">
      <summary>
              Looks up a localized string similar to The sequence provided as argument '{0}' cannot contain null elements..
            </summary>
    </member>
    <member name="P:Autofac.Util.EnforceResources.NotDelegate">
      <summary>
              Looks up a localized string similar to Type {0} is not a delegate type..
            </summary>
    </member>
    <member name="T:Autofac.Util.ReflectionExtensions">
      <summary>
            Extension methods for reflection-related types.
            </summary>
    </member>
    <member name="M:Autofac.Util.ReflectionExtensions.TryGetDeclaringProperty(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo@)">
      <summary>
            Maps from a property-set-value parameter to the declaring property.
            </summary>
      <param name="pi">Parameter to the property setter.</param>
      <param name="prop">The property info on which the setter is specified.</param>
      <returns>True if the parameter is a property setter.</returns>
    </member>
    <member name="M:Autofac.Util.ReflectionExtensions.GetProperty``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            Get a PropertyInfo object from an expression of the form
            x =&gt; x.P.
            </summary>
      <typeparam name="TDeclaring">Type declaring the property.</typeparam>
      <typeparam name="TProperty">The type of the property.</typeparam>
      <param name="propertyAccessor">Expression mapping an instance of the
            declaring type to the property value.</param>
      <returns>Property info.</returns>
    </member>
    <member name="T:Autofac.Util.ReflectionExtensionsResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:Autofac.Util.ReflectionExtensionsResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:Autofac.Util.ReflectionExtensionsResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:Autofac.Util.ReflectionExtensionsResources.ExpressionNotPropertyAccessor">
      <summary>
              Looks up a localized string similar to The provided expression must be of the form x =&gt;x.P, but the provided expression was {0}..
            </summary>
    </member>
    <member name="M:Autofac.Util.SequenceExtensions.JoinWith(System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Joins the strings into one single string interspersing the elements with the separator (a-la
            System.String.Join()).
            </summary>
      <param name="elements">The elements.</param>
      <param name="separator">The separator.</param>
      <returns>The joined string.</returns>
    </member>
    <member name="M:Autofac.Util.SequenceExtensions.Append``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Appends the item to the specified sequence.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="sequence">The sequence.</param>
      <param name="trailingItem">The trailing item.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Autofac.Util.SequenceExtensions.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Prepends the item to the specified sequence.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="sequence">The sequence.</param>
      <param name="leadingItem">The leading item.</param>
      <returns>
      </returns>
    </member>
  </members>
</doc>