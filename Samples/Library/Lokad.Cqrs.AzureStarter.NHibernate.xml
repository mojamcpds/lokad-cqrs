<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Lokad.Cqrs.AzureStarter.NHibernate</name>
  </assembly>
  <members>
    <member name="T:Castle.Core.LifestyleAttribute">
      <summary>
            Base for Attributes that want to express lifestyle
            chosen by the component.
            </summary>
    </member>
    <member name="M:Castle.Core.LifestyleAttribute.#ctor(Castle.Core.LifestyleType)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.LifestyleAttribute" /> class.
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="P:Castle.Core.LifestyleAttribute.Lifestyle">
      <summary>
            Gets or sets the lifestyle.
            </summary>
      <value>The lifestyle.</value>
    </member>
    <member name="T:Castle.Core.CastleComponentAttribute">
      <summary>
            This attribute is usefull only when you want to register all components
            on an assembly as a batch process. 
            By doing so, the batch register will look 
            for this attribute to distinguish components from other classes.
            </summary>
    </member>
    <member name="M:Castle.Core.CastleComponentAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CastleComponentAttribute" /> class.
            </summary>
      <param name="key">The key.</param>
    </member>
    <member name="M:Castle.Core.CastleComponentAttribute.#ctor(System.String,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CastleComponentAttribute" /> class.
            </summary>
      <param name="key">The key.</param>
      <param name="service">The service.</param>
    </member>
    <member name="M:Castle.Core.CastleComponentAttribute.#ctor(System.String,System.Type,Castle.Core.LifestyleType)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CastleComponentAttribute" /> class.
            </summary>
      <param name="key">The key.</param>
      <param name="service">The service.</param>
      <param name="lifestyle">The lifestyle.</param>
    </member>
    <member name="P:Castle.Core.CastleComponentAttribute.Service">
      <summary>
            Gets the service.
            </summary>
      <value>The service.</value>
    </member>
    <member name="P:Castle.Core.CastleComponentAttribute.Key">
      <summary>
            Gets the key.
            </summary>
      <value>The key.</value>
    </member>
    <member name="T:Castle.Core.ComponentActivatorAttribute">
      <summary>
            Associates a custom component with a component
            </summary>
    </member>
    <member name="M:Castle.Core.ComponentActivatorAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ComponentActivatorAttribute" /> class.
            </summary>
      <param name="componentActivatorType">Type of the component activator.</param>
    </member>
    <member name="P:Castle.Core.ComponentActivatorAttribute.ComponentActivatorType">
      <summary>
            Gets the type of the component activator.
            </summary>
      <value>The type of the component activator.</value>
    </member>
    <member name="T:Castle.Core.ComponentProxyBehaviorAttribute">
      <summary>
            Specifies the proxying behavior for a component.
            </summary>
    </member>
    <member name="M:Castle.Core.ComponentProxyBehaviorAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ComponentProxyBehaviorAttribute" /> class.
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.UseMarshalByRefProxy">
      <summary>
            Gets or sets a value indicating whether the generated 
            interface proxy should inherit from <see cref="T:System.MarshalByRefObject" />.
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.UseSingleInterfaceProxy">
      <summary>
            Determines if the component requires a single interface proxy.
            </summary>
      <value>
        <c>true</c> if the component requires a single interface proxy.</value>
    </member>
    <member name="P:Castle.Core.ComponentProxyBehaviorAttribute.AdditionalInterfaces">
      <summary>
             Gets or sets the additional interfaces used during proxy generation.
            </summary>
    </member>
    <member name="T:Castle.Core.DoNotWireAttribute">
      <summary>
            Marks as property to be skipped and not be wired
            by the IoC container
            </summary>
    </member>
    <member name="T:Castle.Core.InterceptorAttribute">
      <summary>
            Used to declare that a component wants interceptors acting on it.
            </summary>
    </member>
    <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.String)">
      <summary>
            Constructs the InterceptorAttribute pointing to
            a key to a interceptor
            </summary>
      <param name="componentKey">
      </param>
    </member>
    <member name="M:Castle.Core.InterceptorAttribute.#ctor(System.Type)">
      <summary>
            Constructs the InterceptorAttribute pointing to
            a service
            </summary>
      <param name="interceptorType">
      </param>
    </member>
    <member name="T:Castle.Core.SingletonAttribute">
      <summary>
            Indicates that the target components wants a
            singleton lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.SingletonAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.SingletonAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.Core.TransientAttribute">
      <summary>
            Indicates that the target components wants a
            transient lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.TransientAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.TransientAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.Core.PerThreadAttribute">
      <summary>
            Indicates that the target components wants a
            per thread lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.PerThreadAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PerThreadAttribute" /> class.
            </summary>
    </member>
    <member name="T:Castle.Core.PerWebRequestAttribute">
      <summary>
            Indicates that the target components wants a
            per web request lifestyle.
            </summary>
    </member>
    <member name="T:Castle.Core.PooledAttribute">
      <summary>
            Indicates that the target components wants a
            pooled lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.PooledAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute" /> class
            using the default initial pool size (5) and the max pool size (15).
            </summary>
    </member>
    <member name="M:Castle.Core.PooledAttribute.#ctor(System.Int32,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PooledAttribute" /> class.
            </summary>
      <param name="initialPoolSize">Initial size of the pool.</param>
      <param name="maxPoolSize">Max pool size.</param>
    </member>
    <member name="P:Castle.Core.PooledAttribute.InitialPoolSize">
      <summary>
            Gets the initial size of the pool.
            </summary>
      <value>The initial size of the pool.</value>
    </member>
    <member name="P:Castle.Core.PooledAttribute.MaxPoolSize">
      <summary>
            Gets the maximum pool size.
            </summary>
      <value>The size of the max pool.</value>
    </member>
    <member name="T:Castle.Core.CustomLifestyleAttribute">
      <summary>
            Indicates that the target components wants a
            custom lifestyle.
            </summary>
    </member>
    <member name="M:Castle.Core.CustomLifestyleAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.CustomLifestyleAttribute" /> class.
            </summary>
      <param name="lifestyleHandlerType">The lifestyle handler.</param>
    </member>
    <member name="P:Castle.Core.CustomLifestyleAttribute.LifestyleHandlerType">
      <summary>
            Gets the type of the lifestyle handler.
            </summary>
      <value>The type of the lifestyle handler.</value>
    </member>
    <member name="T:Castle.Core.Interceptor.IInterceptor">
      <summary>
            New interface that is going to be used by DynamicProxy 2
            </summary>
    </member>
    <member name="T:Castle.Core.Interceptor.IInvocation">
      <summary>
            New interface that is going to be used by DynamicProxy 2
            </summary>
    </member>
    <member name="M:Castle.Core.Interceptor.IInvocation.GetConcreteMethod">
      <summary>
            Returns the concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.Method" />, with any generic parameters bound to real types.
            </summary>
      <returns>The concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.Method" />, or <see cref="P:Castle.Core.Interceptor.IInvocation.Method" /> if not a generic method.</returns>
      <remarks>Can be slower than calling <see cref="P:Castle.Core.Interceptor.IInvocation.Method" />.</remarks>
    </member>
    <member name="M:Castle.Core.Interceptor.IInvocation.GetConcreteMethodInvocationTarget">
      <summary>
            Returns the concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget" />, with any generic parameters bound to real types.
            </summary>
      <returns>The concrete instantiation of <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget" />, or <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget" /> if not a generic method.</returns>
      <remarks>Can be slower than calling <see cref="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget" />.</remarks>
    </member>
    <member name="M:Castle.Core.Interceptor.IInvocation.Proceed">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Core.Interceptor.IInvocation.GenericArguments">
      <summary>
            The generic arguments of the method, or null if not a generic method.
            </summary>
    </member>
    <member name="P:Castle.Core.Interceptor.IInvocation.Method">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.Core.Interceptor.IInvocation.MethodInvocationTarget">
      <summary>
            For interface proxies, this will point to the
            <see cref="T:System.Reflection.MethodInfo" /> on the target class
            </summary>
    </member>
    <member name="T:Castle.Core.Interceptor.IOnBehalfAware">
      <summary>
            Interceptors might implement this to receive the
            ComponentModel on behalf of the component where the
            interceptor is acting.
            </summary>
    </member>
    <member name="M:Castle.Core.Interceptor.IProxyTargetAccessor.DynProxyGetTarget">
      <summary>
            Get the proxy target (note that null is a valid target!)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Interceptor.IProxyTargetAccessor.GetInterceptors">
      <summary>
            Gets the interceptors for the proxy
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.IVertex">
      <summary>
            Abstract representation of a vertex.
            </summary>
    </member>
    <member name="P:Castle.Core.GraphNode.Dependers">
      <summary>
            The nodes that dependes on this node
            </summary>
    </member>
    <member name="P:Castle.Core.GraphNode.Dependents">
      <summary>
            The nodes that this node depends
            </summary>
    </member>
    <member name="F:Castle.Core.Internal.VertexColor.White">
      <summary>
            The node has not been visited yet
            </summary>
    </member>
    <member name="F:Castle.Core.Internal.VertexColor.Gray">
      <summary>
            This node is in the process of being visited
            </summary>
    </member>
    <member name="F:Castle.Core.Internal.VertexColor.Black">
      <summary>
            This now was visited
            </summary>
    </member>
    <member name="T:Castle.Core.Internal.ColorsSet">
      <summary>
            Represents a collection of objects
            which are guaranted to be unique 
            and holds a color for them
            </summary>
    </member>
    <member name="T:Castle.Core.Internal.TimestampSet">
      <summary>
            Holds a timestamp (integer) 
            for a given item
            </summary>
    </member>
    <member name="M:Castle.Core.Internal.LinkedList.GetNode(System.Int32)">
      <summary>
            Returns the node at the specified index.
            </summary>
      <param name="index">The lookup index.</param>
      <returns>The node at the specified index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
            If the specified <paramref name="index" /> is greater than the
            number of objects within the list.
            </exception>
    </member>
    <member name="M:Castle.Core.Internal.LinkedList.ValidateIndex(System.Int32)">
      <summary>
            Validates the specified index.
            </summary>
      <param name="index">The lookup index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
            If the index is invalid.
            </exception>
    </member>
    <member name="T:Castle.Core.IInitializable">
      <summary>
            Lifecycle interface. If implemented by a component,
            the method Initialized will be invoked by the container
            before making the component available to the external world.
            </summary>
    </member>
    <member name="M:Castle.Core.IInitializable.Initialize">
      <summary>
            Implementors should perform any initialization logic.
            </summary>
    </member>
    <member name="T:Castle.Core.IRecyclable">
      <summary>
            Only called for components that 
            belongs to a pool when the component
            comes back to the pool.
            </summary>
    </member>
    <member name="M:Castle.Core.IRecyclable.Recycle">
      <summary>
            Implementors should perform any 
            initialization/clean up.
            </summary>
    </member>
    <member name="T:Castle.Core.IStartable">
      <summary>
            Interface for components that wish to be started by the container
            </summary>
    </member>
    <member name="M:Castle.Core.IStartable.Start">
      <summary>
            Starts this instance.
            </summary>
    </member>
    <member name="M:Castle.Core.IStartable.Stop">
      <summary>
            Stops this instance.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.ILoggerFactory">
      <summary>
            Manages the instantiation of <see cref="T:Castle.Core.Logging.ILogger" />s.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type)">
      <summary>
            Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String)">
      <summary>
            Creates a new logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ILoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new logger.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLoggerFactory">
      <summary>
            Provides a factory that can produce either <see cref="T:Castle.Core.Logging.ILogger" /> or
            <see cref="T:Castle.Core.Logging.IExtendedLogger" /> classes.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type)">
      <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String)">
      <summary>
            Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.IExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.Type)">
      <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.String)">
      <summary>
            Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.Type,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new extended logger, getting the logger name from the specified type.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new extended logger.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.Factories.AbstractExtendedLoggerFactory.GetConfigFile(System.String)">
      <summary>
            Gets the configuration file.
            </summary>
      <param name="fileName">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.AbstractLoggerFactory.GetConfigFile(System.String)">
      <summary>
            Gets the configuration file.
            </summary>
      <param name="fileName">i.e. log4net.config</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.ConsoleFactory">
      <summary>
            Summary description for ConsoleFactory.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.NullLogFactory">
      <summary>
            NullLogFactory used when logging is turned off.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String)">
      <summary>
            Creates an instance of ILogger with the specified name.
            </summary>
      <param name="name">Name.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.NullLogFactory.Create(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates an instance of ILogger with the specified name and LoggerLevel.
            </summary>
      <param name="name">Name.</param>
      <param name="level">Level.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Logging.StreamLoggerFactory">
      <summary>
            Creates <see cref="T:Castle.Core.Logging.StreamLogger" /> outputing 
            to files. The name of the file is derived from the log name
            plus the 'log' extension.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.TraceLoggerFactory">
      <summary>
            Used to create the TraceLogger implementation of ILogger interface. See <see cref="T:Castle.Core.Logging.TraceLogger" />. 
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.ILogger">
      <summary>
            Manages logging.
            </summary>
      <remarks>
            This is a facade for the different logging subsystems.
            It offers a simplified interface that follows IOC patterns
            and a simplified priority/level/severity abstraction. 
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String)">
      <summary>
            Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Exception)">
      <summary>
            Logs a debug message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Debug(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String)">
      <summary>
            Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Exception)">
      <summary>
            Logs an info message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Info(System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String)">
      <summary>
            Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Exception)">
      <summary>
            Logs a warn message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Warn(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String)">
      <summary>
            Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Exception)">
      <summary>
            Logs an error message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Error(System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String)">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Exception)">
      <summary>
            Logs a fatal message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.Fatal(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalError(System.String)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="message">The Message</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalError(System.String,System.Exception)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.FatalError(System.String,System.Object[])">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.ILogger.CreateChildLogger(System.String)">
      <summary>
            Create a new child logger.
            The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
      <param name="loggerName">The Subname of this logger.</param>
      <returns>The New ILogger instance.</returns>
      <exception cref="T:System.ArgumentException">If the name has an empty element name.</exception>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsDebugEnabled">
      <summary>
            Determines if messages of priority "debug" will be logged.
            </summary>
      <value>True if "debug" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsInfoEnabled">
      <summary>
            Determines if messages of priority "info" will be logged.
            </summary>
      <value>True if "info" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsWarnEnabled">
      <summary>
            Determines if messages of priority "warn" will be logged.
            </summary>
      <value>True if "warn" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsErrorEnabled">
      <summary>
            Determines if messages of priority "error" will be logged.
            </summary>
      <value>True if "error" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsFatalEnabled">
      <summary>
            Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>True if "fatal" messages will be logged.</value>
    </member>
    <member name="P:Castle.Core.Logging.ILogger.IsFatalErrorEnabled">
      <summary>
            Determines if messages of priority "fatalError" will be logged.
            </summary>
      <value>True if "fatalError" messages will be logged.</value>
    </member>
    <member name="T:Castle.Core.Logging.LevelFilteredLogger">
      <summary>
            The Level Filtered Logger class.  This is a base clase which
            provides a LogLevel attribute and reroutes all functions into
            one Log method.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.#ctor">
      <summary>
            Creates a new <c>LevelFilteredLogger</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InitializeLifetimeService">
      <summary>
            Keep the instance alive in a remoting scenario
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String)">
      <summary>
            Logs a debug message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Exception)">
      <summary>
            Logs a debug message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Debug(System.String,System.Object[])">
      <summary>
            Logs a debug message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String)">
      <summary>
            Logs an info message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Exception)">
      <summary>
            Logs an info message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Info(System.String,System.Object[])">
      <summary>
            Logs an info message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String)">
      <summary>
            Logs a warn message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Exception)">
      <summary>
            Logs a warn message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Warn(System.String,System.Object[])">
      <summary>
            Logs a warn message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String)">
      <summary>
            Logs an error message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Exception)">
      <summary>
            Logs an error message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Error(System.String,System.Object[])">
      <summary>
            Logs an error message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String)">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Exception)">
      <summary>
            Logs a fatal message. 
            </summary>
      <param name="exception">The exception to log</param>
      <param name="message">The message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="exception">The exception to log</param>
      <param name="formatProvider">The format provider to use</param>
      <param name="format">Format string for the message to log</param>
      <param name="args">Format arguments for the message to log</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Fatal(System.String,System.Object[])">
      <summary>
            Logs a fatal message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalError(System.String)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="message">The Message</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalError(System.String,System.Exception)">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.FatalError(System.String,System.Object[])">
      <summary>
            Logs a fatal error message.
            </summary>
      <param name="format">Message format</param>
      <param name="args">Array of objects to write using format</param>
    </member>
    <member name="M:Castle.Core.Logging.LevelFilteredLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
            Implementors output the log content by implementing this method only.
            Note that exception can be null
            </summary>
      <param name="loggerLevel">
      </param>
      <param name="loggerName">
      </param>
      <param name="message">
      </param>
      <param name="exception">
      </param>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Level">
      <value>
            The <c>LoggerLevel</c> that this logger
            will be using. Defaults to <c>LoggerLevel.Off</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.Name">
      <value>
            The name that this logger will be using. 
            Defaults to <c>String.Empty</c></value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsDebugEnabled">
      <summary>
            Determines if messages of priority "debug" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Debug" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsInfoEnabled">
      <summary>
            Determines if messages of priority "info" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Info" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsWarnEnabled">
      <summary>
            Determines if messages of priority "warn" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Warn" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsErrorEnabled">
      <summary>
            Determines if messages of priority "error" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Error" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalEnabled">
      <summary>
            Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Fatal" /> bit</value>
    </member>
    <member name="P:Castle.Core.Logging.LevelFilteredLogger.IsFatalErrorEnabled">
      <summary>
            Determines if messages of priority "fatal" will be logged.
            </summary>
      <value>
        <c>true</c> if log level flags include the <see cref="F:Castle.Core.Logging.LoggerLevel.Fatal" /> bit</value>
    </member>
    <member name="T:Castle.Core.Logging.ConsoleLogger">
      <summary>
            The Logger sending everything to the standard output streams.
            This is mainly for the cases when you have a utility that
            does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor">
      <summary>
            Creates a new ConsoleLogger with the <c>Level</c>
            set to <c>LoggerLevel.Debug</c> and the <c>Name</c>
            set to <c>String.Empty</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new ConsoleLogger with the <c>Name</c>
            set to <c>String.Empty</c>.
            </summary>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String)">
      <summary>
            Creates a new ConsoleLogger with the <c>Level</c>
            set to <c>LoggerLevel.Debug</c>.
            </summary>
      <param name="name">The logs Name.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new ConsoleLogger.
            </summary>
      <param name="name">The logs Name.</param>
      <param name="logLevel">The logs Level.</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
            A Common method to log.
            </summary>
      <param name="loggerLevel">The level of logging</param>
      <param name="loggerName">The name of the logger</param>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.ConsoleLogger.CreateChildLogger(System.String)">
      <summary>
            Returns a new <c>ConsoleLogger</c> with the name
            added after this loggers name, with a dot in between.
            </summary>
      <param name="loggerName">The added hierarchical name.</param>
      <returns>A new <c>ConsoleLogger</c>.</returns>
    </member>
    <member name="T:Castle.Core.Logging.DiagnosticsLogger">
      <summary>
            The Logger using standart Diagnostics namespace.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String)">
      <summary>
            Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String)">
      <summary>
            Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
      <param name="source">
        <see cref="P:System.Diagnostics.EventLog.Source" />
      </param>
    </member>
    <member name="M:Castle.Core.Logging.DiagnosticsLogger.#ctor(System.String,System.String,System.String)">
      <summary>
            Creates a logger based on <see cref="T:System.Diagnostics.EventLog" />.
            </summary>
      <param name="logName">
        <see cref="P:System.Diagnostics.EventLog.Log" />
      </param>
      <param name="machineName">
        <see cref="P:System.Diagnostics.EventLog.MachineName" />
      </param>
      <param name="source">
        <see cref="P:System.Diagnostics.EventLog.Source" />
      </param>
    </member>
    <member name="T:Castle.Core.Logging.IExtendedLogger">
      <summary>
            Provides an interface that supports <see cref="T:Castle.Core.Logging.ILogger" /> and
            allows the storage and retrieval of Contexts. These are supported in
            both log4net and NLog.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.GlobalProperties">
      <summary>
            Exposes the Global Context of the extended logger. 
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadProperties">
      <summary>
            Exposes the Thread Context of the extended logger.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.IExtendedLogger.ThreadStacks">
      <summary>
            Exposes the Thread Stack of the extended logger.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.NullLogger">
      <summary>
            The Null Logger class.  This is useful for implementations where you need
            to provide a logger to a utility class, but do not want any output from it.
            It also helps when you have a utility that does not have a logger to supply.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.#ctor">
      <summary>
            Creates a new <c>NullLogger</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Exception)">
      <summary>
            No-op. 
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Debug(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Exception)">
      <summary>
            No-op. 
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Info(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Exception)">
      <summary>
            No-op. 
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Warn(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Exception)">
      <summary>
            No-op. 
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Error(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Exception)">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.Fatal(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="exception">Ignored</param>
      <param name="formatProvider">Ignored</param>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalError(System.String)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalError(System.String,System.Exception)">
      <summary>
            No-op.
            </summary>
      <param name="message">Ignored</param>
      <param name="exception">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.FatalError(System.String,System.Object[])">
      <summary>
            No-op.
            </summary>
      <param name="format">Ignored</param>
      <param name="args">Ignored</param>
    </member>
    <member name="M:Castle.Core.Logging.NullLogger.CreateChildLogger(System.String)">
      <summary>
            Returns this <c>NullLogger</c>.
            </summary>
      <param name="loggerName">Ignored</param>
      <returns>This ILogger instance.</returns>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsDebugEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsInfoEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsWarnEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsErrorEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsFatalEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.IsFatalErrorEnabled">
      <summary>
            No-op.
            </summary>
      <value>false</value>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.GlobalProperties">
      <summary>
            Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadProperties">
      <summary>
            Returns empty context properties.
            </summary>
    </member>
    <member name="P:Castle.Core.Logging.NullLogger.ThreadStacks">
      <summary>
            Returns empty context stacks.
            </summary>
    </member>
    <member name="T:Castle.Core.Logging.IContextProperties">
      <summary>
            Interface for Context Properties implementations
            </summary>
      <remarks>
        <para>
            This interface defines a basic property get set accessor.
            </para>
        <para>
            Based on the ContextPropertiesBase of log4net, by Nicko Cadell.
            </para>
      </remarks>
    </member>
    <member name="P:Castle.Core.Logging.IContextProperties.Item(System.String)">
      <summary>
            Gets or sets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Gets or sets the value of a property
            </para>
      </remarks>
    </member>
    <member name="T:Castle.Core.Logging.StreamLogger">
      <summary>
            The Stream Logger class.  This class can stream log information
            to any stream, it is suitable for storing a log file to disk,
            or to a <c>MemoryStream</c> for testing your components.
            </summary>
      <remarks>
            This logger is not thread safe.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream)">
      <summary>
            Creates a new <c>StreamLogger</c> with default encoding 
            and buffer size. Initial Level is set to Debug.
            </summary>
      <param name="name">
            The name of the log.
            </param>
      <param name="stream">
            The stream that will be used for logging,
            seeking while the logger is alive 
            </param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding)">
      <summary>
            Creates a new <c>StreamLogger</c> with default buffer size.
            Initial Level is set to Debug.
            </summary>
      <param name="name">
            The name of the log.
            </param>
      <param name="stream">
            The stream that will be used for logging,
            seeking while the logger is alive 
            </param>
      <param name="encoding">
            The encoding that will be used for this stream.
            <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.Stream,System.Text.Encoding,System.Int32)">
      <summary>
            Creates a new <c>StreamLogger</c>. 
            Initial Level is set to Debug.
            </summary>
      <param name="name">
            The name of the log.
            </param>
      <param name="stream">
            The stream that will be used for logging,
            seeking while the logger is alive 
            </param>
      <param name="encoding">
            The encoding that will be used for this stream.
            <see cref="T:System.IO.StreamWriter" /></param>
      <param name="bufferSize">
            The buffer size that will be used for this stream.
            <see cref="T:System.IO.StreamWriter" /></param>
    </member>
    <member name="M:Castle.Core.Logging.StreamLogger.#ctor(System.String,System.IO.StreamWriter)">
      <summary>
            Creates a new <c>StreamLogger</c> with 
            Debug as default Level.
            </summary>
      <param name="name">The name of the log.</param>
      <param name="writer">The <c>StreamWriter</c> the log will write to.</param>
    </member>
    <member name="T:Castle.Core.Logging.TraceLogger">
      <summary>
            The TraceLogger sends all logging to the System.Diagnostics.TraceSource
            built into the .net framework. 
            </summary>
      <remarks>
            Logging can be configured in the system.diagnostics configuration 
            section. 
            
            If logger doesn't find a source name with a full match it will
            use source names which match the namespace partially. For example you can
            configure from all castle components by adding a source name with the
            name "Castle". 
            
            If no portion of the namespace matches the source named "Default" will
            be used.
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.TraceLogger.#ctor(System.String)">
      <summary>
            Build a new trace logger based on the named TraceSource
            </summary>
      <param name="name">The name used to locate the best TraceSource. In most cases comes from the using type's fullname.</param>
    </member>
    <member name="M:Castle.Core.Logging.TraceLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Build a new trace logger based on the named TraceSource
            </summary>
      <param name="name">The name used to locate the best TraceSource. In most cases comes from the using type's fullname.</param>
      <param name="level">The default logging level at which this source should write messages. In almost all cases this
            default value will be overridden in the config file. </param>
    </member>
    <member name="M:Castle.Core.Logging.TraceLogger.CreateChildLogger(System.String)">
      <summary>
            Create a new child logger.
            The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
      <param name="loggerName">The Subname of this logger.</param>
      <returns>The New ILogger instance.</returns>
    </member>
    <member name="T:Castle.Core.Logging.WebLogger">
      <summary>
            The WebLogger sends everything to the HttpContext.Trace 
            </summary>
      <remarks>
            Trace must be enabled on the Asp.Net configuration file (web.config or machine.config)
            </remarks>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.#ctor">
      <summary>
            Creates a new WebLogger with the priority set to DEBUG.
            </summary>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.#ctor(Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new WebLogger.
            </summary>
      <param name="logLevel">The Log level typecode.</param>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.#ctor(System.String)">
      <summary>
            Creates a new WebLogger.
            </summary>
      <param name="name">The Log name.</param>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.#ctor(System.String,Castle.Core.Logging.LoggerLevel)">
      <summary>
            Creates a new WebLogger.
            </summary>
      <param name="name">The Log name.</param>
      <param name="loggerLevel">The Log level typecode.</param>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.Log(Castle.Core.Logging.LoggerLevel,System.String,System.String,System.Exception)">
      <summary>
            A Common method to log.
            </summary>
      <param name="loggerLevel">The level of logging</param>
      <param name="loggerName">The Log name.</param>
      <param name="message">The Message</param>
      <param name="exception">The Exception</param>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.CreateChildLogger(System.String)">
      <summary>
            Just returns this logger (<c>WebLogger</c> is not hierarchical).
            </summary>
      <param name="loggerName">Ignored</param>
      <returns>This ILogger instance.</returns>
    </member>
    <member name="M:Castle.Core.Logging.WebLogger.TryToGetTraceContext">
      <summary>
            Tries to get the current http context's trace context.
            </summary>
      <returns>The current http context's trace context or null if none is 
            available</returns>
    </member>
    <member name="T:Castle.Core.Logging.LoggerLevel">
      <summary>
            Supporting Logger levels.
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Off">
      <summary>
            Logging will be off
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Fatal">
      <summary>
            Fatal logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Error">
      <summary>
            Error logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Warn">
      <summary>
            Warn logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Info">
      <summary>
            Info logging level
            </summary>
    </member>
    <member name="F:Castle.Core.Logging.LoggerLevel.Debug">
      <summary>
            Debug logging level
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.Xml.XmlConfigurationDeserializer">
      <summary>
            Pendent
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.Xml.XmlConfigurationDeserializer.Deserialize(System.Xml.XmlNode)">
      <summary>
            Deserializes the specified node into an abstract representation of configuration.
            </summary>
      <param name="node">The node.</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Configuration.Xml.XmlConfigurationDeserializer.GetConfigValue(System.String)">
      <summary>
            If a config value is an empty string we return null, this is to keep
            backward compability with old code
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.IConfiguration">
      <summary>
        <see cref="T:Castle.Core.Configuration.IConfiguration" /> is a interface encapsulating a configuration node
            used to retrieve configuration values.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.IConfiguration.GetValue(System.Type,System.Object)">
      <summary>
            Gets the value of the node and converts it 
            into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
            The Default value returned if the convertion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Name">
      <summary>
            Gets the name of the node.
            </summary>
      <value>
            The Name of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Value">
      <summary>
            Gets the value of the node.
            </summary>
      <value>
            The Value of the node.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Children">
      <summary>
            Gets an <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of <see cref="T:Castle.Core.Configuration.IConfiguration" />
            elements containing all node children.
            </summary>
      <value>The Collection of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.IConfiguration.Attributes">
      <summary>
            Gets an <see cref="T:System.Collections.IDictionary" /> of the configuration attributes.
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.AbstractConfiguration">
      <summary>
            This is an abstract <see cref="T:Castle.Core.Configuration.IConfiguration" /> implementation
            that deals with methods that can be abstracted away
            from underlying implementations.
            </summary>
      <remarks>
        <para>
          <b>AbstractConfiguration</b> makes easier to implementers 
            to create a new version of <see cref="T:Castle.Core.Configuration.IConfiguration" /></para>
      </remarks>
    </member>
    <member name="M:Castle.Core.Configuration.AbstractConfiguration.GetValue(System.Type,System.Object)">
      <summary>
            Gets the value of the node and converts it
            into specified <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /></param>
      <param name="defaultValue">
            The Default value returned if the convertion fails.
            </param>
      <returns>The Value converted into the specified type.</returns>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Name">
      <summary>
            Gets the name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
            The Name of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Value">
      <summary>
            Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
            The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Children">
      <summary>
            Gets all child nodes.
            </summary>
      <value>The <see cref="T:Castle.Core.Configuration.ConfigurationCollection" /> of child nodes.</value>
    </member>
    <member name="P:Castle.Core.Configuration.AbstractConfiguration.Attributes">
      <summary>
            Gets node attributes.
            </summary>
      <value>
            All attributes of the node.
            </value>
    </member>
    <member name="T:Castle.Core.Configuration.ConfigurationCollection">
      <summary>
            A collection of <see cref="T:Castle.Core.Configuration.IConfiguration" /> objects.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.ConfigurationCollection.#ctor(System.Collections.Generic.IEnumerable{Castle.Core.Configuration.IConfiguration})">
      <summary>
            Creates a new instance of <c>ConfigurationCollection</c>.
            </summary>
    </member>
    <member name="T:Castle.Core.Configuration.MutableConfiguration">
      <summary>
            Summary description for MutableConfiguration.
            </summary>
    </member>
    <member name="M:Castle.Core.Configuration.MutableConfiguration.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.Configuration.MutableConfiguration" /> class.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="P:Castle.Core.Configuration.MutableConfiguration.Value">
      <summary>
            Gets the value of <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </summary>
      <value>
            The Value of the <see cref="T:Castle.Core.Configuration.IConfiguration" />.
            </value>
    </member>
    <member name="T:Castle.Core.LifestyleType">
      <summary>
            Enumeration used to mark the component's lifestyle.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Undefined">
      <summary>
            No lifestyle specified.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Singleton">
      <summary>
            Singleton components are instantiated once, and shared
            between all clients.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Thread">
      <summary>
            Thread components have a unique instance per thread.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Transient">
      <summary>
            Transient components are created on demand.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Pooled">
      <summary>
            Optimization of transient components that keeps
            instance in a pool instead of always creating them.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.Custom">
      <summary>
            Any other logic to create/release components.
            </summary>
    </member>
    <member name="F:Castle.Core.LifestyleType.PerWebRequest">
      <summary>
            PerWebRequest components are created once per Http Request
            </summary>
    </member>
    <member name="T:Castle.Core.PropertiesInspectionBehavior">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.ComponentModel">
      <summary>
            Represents the collection of information and
            meta information collected about a component.
            </summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.name">
      <summary>Name (key) of the component</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.service">
      <summary>Service exposed</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.implementation">
      <summary>Implementation for the service</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.extended">
      <summary>Extended properties</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.lifestyleType">
      <summary>Lifestyle for the component</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.customLifestyle">
      <summary>Custom lifestyle, if any</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.customComponentActivator">
      <summary>Custom activator, if any</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.dependencies">
      <summary>Dependencies the kernel must resolve</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.constructors">
      <summary>All available constructors</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.properties">
      <summary>All potential properties that can be setted by the kernel</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.lifecycleSteps">
      <summary>Steps of lifecycle</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.parameters">
      <summary>External parameters</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.configuration">
      <summary>Configuration node associated</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.interceptors">
      <summary>Interceptors associated</summary>
    </member>
    <member name="F:Castle.Core.ComponentModel.customDependencies">
      <summary>/// Custom dependencies/// </summary>
    </member>
    <member name="M:Castle.Core.ComponentModel.#ctor(System.String,System.Type,System.Type)">
      <summary>
            Constructs a ComponentModel
            </summary>
    </member>
    <member name="M:Castle.Core.ComponentModel.Requires(System.Predicate{Castle.Core.PropertySet}[])">
      <summary>
            Requires the selected property dependencies.
            </summary>
      <param name="selectors">The property selector.</param>
    </member>
    <member name="M:Castle.Core.ComponentModel.Requires``1">
      <summary>
            Requires the property dependencies of type <typeparamref name="D" />.
            </summary>
      <typeparam name="D">The dependency type.</typeparam>
    </member>
    <member name="P:Castle.Core.ComponentModel.Name">
      <summary>
            Sets or returns the component key
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentModel.Service">
      <summary>
            Gets or sets the service exposed.
            </summary>
      <value>The service.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Implementation">
      <summary>
            Gets or sets the component implementation.
            </summary>
      <value>The implementation.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.RequiresGenericArguments">
      <summary>
            Gets or sets a value indicating whether the component requires generic arguments.
            </summary>
      <value>
        <c>true</c> if generic arguments are required; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.ComponentModel.ExtendedProperties">
      <summary>
            Gets or sets the extended properties.
            </summary>
      <value>The extended properties.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Constructors">
      <summary>
            Gets the constructors candidates.
            </summary>
      <value>The constructors.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Properties">
      <summary>
            Gets the properties set.
            </summary>
      <value>The properties.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Configuration">
      <summary>
            Gets or sets the configuration.
            </summary>
      <value>The configuration.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.LifecycleSteps">
      <summary>
            Gets the lifecycle steps.
            </summary>
      <value>The lifecycle steps.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.LifestyleType">
      <summary>
            Gets or sets the lifestyle type.
            </summary>
      <value>The type of the lifestyle.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.InspectionBehavior">
      <summary>
            Gets or sets the strategy for
            inspecting public properties 
            on the components
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentModel.CustomLifestyle">
      <summary>
            Gets or sets the custom lifestyle.
            </summary>
      <value>The custom lifestyle.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.CustomComponentActivator">
      <summary>
            Gets or sets the custom component activator.
            </summary>
      <value>The custom component activator.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Interceptors">
      <summary>
            Gets the interceptors.
            </summary>
      <value>The interceptors.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Parameters">
      <summary>
            Gets the parameter collection.
            </summary>
      <value>The parameters.</value>
    </member>
    <member name="P:Castle.Core.ComponentModel.Dependencies">
      <summary>
            Dependencies are kept within constructors and
            properties. Others dependencies must be 
            registered here, so the kernel (as a matter 
            of fact the handler) can check them
            </summary>
    </member>
    <member name="P:Castle.Core.ComponentModel.CustomDependencies">
      <summary>
            Gets the custom dependencies.
            </summary>
      <value>The custom dependencies.</value>
    </member>
    <member name="T:Castle.Core.ConstructorCandidate">
      <summary>
            Represents a constructor of the component 
            that the container can use to initialize it properly.
            </summary>
    </member>
    <member name="M:Castle.Core.ConstructorCandidate.#ctor(System.Reflection.ConstructorInfo,Castle.Core.DependencyModel[])">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ConstructorCandidate" /> class.
            </summary>
      <param name="constructorInfo">The constructor info.</param>
      <param name="dependencies">The dependencies.</param>
    </member>
    <member name="P:Castle.Core.ConstructorCandidate.Constructor">
      <summary>
            Gets the ConstructorInfo (from reflection).
            </summary>
      <value>The constructor.</value>
    </member>
    <member name="P:Castle.Core.ConstructorCandidate.Dependencies">
      <summary>
            Gets the dependencies this constructor candidate exposes.
            </summary>
      <value>The dependencies.</value>
    </member>
    <member name="T:Castle.Core.ConstructorCandidateCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.ConstructorCandidate" /></summary>
    </member>
    <member name="P:Castle.Core.ConstructorCandidateCollection.FewerArgumentsCandidate">
      <summary>
            Gets the fewer arguments candidate.
            </summary>
      <value>The fewer arguments candidate.</value>
    </member>
    <member name="T:Castle.Core.DependencyModel">
      <summary>
            Represents a dependency (other component or a 
            fixed value available through external configuration).
            </summary>
    </member>
    <member name="M:Castle.Core.DependencyModel.#ctor(Castle.Core.DependencyType,System.String,System.Type,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModel" /> class.
            </summary>
      <param name="type">The type.</param>
      <param name="dependencyKey">The dependency key.</param>
      <param name="targetType">Type of the target.</param>
      <param name="isOptional">if set to <c>true</c> [is optional].</param>
    </member>
    <member name="M:Castle.Core.DependencyModel.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Castle.Core.DependencyModel.GetHashCode">
      <summary>
            Serves as a hash function for a particular type, suitable
            for use in hashing algorithms and data structures like a hash table.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Castle.Core.DependencyModel.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
        <see langword="true" /> if the specified <see cref="T:System.Object" /> is equal to the
            current <see cref="T:System.Object" />; otherwise, <see langword="false" />.
            </returns>
    </member>
    <member name="P:Castle.Core.DependencyModel.DependencyType">
      <summary>
            Gets or sets the type of the dependency.
            </summary>
      <value>The type of the dependency.</value>
    </member>
    <member name="P:Castle.Core.DependencyModel.DependencyKey">
      <summary>
            Gets or sets the dependency key.
            </summary>
      <value>The dependency key.</value>
    </member>
    <member name="P:Castle.Core.DependencyModel.TargetType">
      <summary>
            Gets the type of the target.
            </summary>
      <value>The type of the target.</value>
    </member>
    <member name="P:Castle.Core.DependencyModel.IsOptional">
      <summary>
            Gets or sets whether this dependency is optional.
            </summary>
      <value>
        <c>true</c> if this dependency is optional; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.Core.DependencyModelCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.DependencyModel" />.
            </summary>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModelCollection" /> class.
            </summary>
    </member>
    <member name="M:Castle.Core.DependencyModelCollection.#ctor(System.Collections.Generic.IEnumerable{Castle.Core.DependencyModel})">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.DependencyModelCollection" /> class.
            </summary>
      <param name="dependencies">The dependencies.</param>
    </member>
    <member name="T:Castle.Core.InterceptorReference">
      <summary>
            Represents an reference to a Interceptor component.
            </summary>
    </member>
    <member name="M:Castle.Core.InterceptorReference.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference" /> class.
            </summary>
      <param name="componentKey">The component key.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReference.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.InterceptorReference" /> class.
            </summary>
      <param name="serviceType">Type of the service.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReference.ForKey(System.String)">
      <summary>
            Gets an <see cref="T:Castle.Core.InterceptorReference" /> for the component key.
            </summary>
      <param name="key">The component key.</param>
      <returns>The <see cref="T:Castle.Core.InterceptorReference" /></returns>
    </member>
    <member name="M:Castle.Core.InterceptorReference.ForType(System.Type)">
      <summary>
            Gets an <see cref="T:Castle.Core.InterceptorReference" /> for the service.
            </summary>
      <param name="service">The service.</param>
      <returns>The <see cref="T:Castle.Core.InterceptorReference" /></returns>
    </member>
    <member name="M:Castle.Core.InterceptorReference.ForType``1">
      <summary>
            Gets an <see cref="T:Castle.Core.InterceptorReference" /> for the service.
            </summary>
      <typeparam name="T">The service type.</typeparam>
      <returns>The <see cref="T:Castle.Core.InterceptorReference" /></returns>
    </member>
    <member name="P:Castle.Core.InterceptorReference.ServiceType">
      <summary>
            Gets the type of the service.
            </summary>
      <value>The type of the service.</value>
    </member>
    <member name="P:Castle.Core.InterceptorReference.ComponentKey">
      <summary>
            Gets the interceptor component key.
            </summary>
      <value>The component key.</value>
    </member>
    <member name="P:Castle.Core.InterceptorReference.ReferenceType">
      <summary>
            Gets the type of the reference.
            </summary>
      <value>The type of the reference.</value>
    </member>
    <member name="T:Castle.Core.InterceptorReferenceCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.InterceptorReference" /></summary>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.Add(Castle.Core.InterceptorReference)">
      <summary>
            Adds the specified item.
            </summary>
      <param name="item">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.AddFirst(Castle.Core.InterceptorReference)">
      <summary>
            Adds the specified interceptor as the first.
            </summary>
      <param name="item">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.AddLast(Castle.Core.InterceptorReference)">
      <summary>
            Adds the specified interceptor as the last.
            </summary>
      <param name="item">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.Insert(System.Int32,Castle.Core.InterceptorReference)">
      <summary>
            Inserts the specified interceptor at the specified index.
            </summary>
      <param name="index">The index.</param>
      <param name="item">The interceptor.</param>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.CopyTo(System.Array,System.Int32)">
      <summary>
            When implemented by a class, copies the elements of
            the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero.</exception>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="array" /> is multidimensional.</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than the length of <paramref name="array" />.</para>
        <para>-or-</para>
        <para>The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</para>
      </exception>
      <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ICollection" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" />
            that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Castle.Core.InterceptorReferenceCollection.AddIfNotInCollection(Castle.Core.InterceptorReference)">
      <summary>
            Adds the interceptor to the end of the interceptors list if it does not exist already.
            </summary>
      <param name="interceptorReference">The interceptor reference.</param>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.HasInterceptors">
      <summary>
            Gets a value indicating whether this instance has interceptors.
            </summary>
      <value>
        <c>true</c> if this instance has interceptors; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.Count">
      <summary>
            Gets the number of
            elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.SyncRoot">
      <summary>
            Gets an object that
            can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.InterceptorReferenceCollection.IsSynchronized">
      <summary>
            Gets a value
            indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized
            (thread-safe).
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.Core.LifecycleStepCollection">
      <summary>
            Represents a collection of ordered lifecycle steps.
            </summary>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.LifecycleStepCollection" /> class.
            </summary>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.GetCommissionSteps">
      <summary>
            Returns all steps for the commission phase
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.GetDecommissionSteps">
      <summary>
            Returns all steps for the decommission phase
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.Add(Castle.Core.LifecycleStepType,System.Object)">
      <summary>
            Adds a step to the commission or decomission phases.
            </summary>
      <param name="type">
      </param>
      <param name="stepImplementation">
      </param>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.AddFirst(Castle.Core.LifecycleStepType,System.Object)">
      <summary>
            Adds a step as the first step to execute for the commission or decomission phase.
            </summary>
      <param name="type">
      </param>
      <param name="stepImplementation">
      </param>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of
            the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero.</exception>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="array" /> is multidimensional.</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than the length of <paramref name="array" />.</para>
        <para>-or-</para>
        <para>The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</para>
      </exception>
      <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ICollection" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
    </member>
    <member name="M:Castle.Core.LifecycleStepCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" />
            that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.HasCommissionSteps">
      <summary>
            Gets a value indicating whether this instance has commission steps.
            </summary>
      <value>
        <c>true</c> if this instance has commission steps; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.HasDecommissionSteps">
      <summary>
            Gets a value indicating whether this instance has decommission steps.
            </summary>
      <value>
        <c>true</c> if this instance has decommission steps; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.Count">
      <summary>
            Gets the number of
            elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.SyncRoot">
      <summary>
            Gets an object that
            can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.LifecycleStepCollection.IsSynchronized">
      <summary>
            Gets a value
            indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized
            (thread-safe).
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Castle.Core.MethodMetaModel">
      <summary>
            Represents meta information associated with a method
            (not yet defined)
            </summary>
    </member>
    <member name="M:Castle.Core.MethodMetaModel.#ctor(Castle.Core.Configuration.IConfiguration)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.MethodMetaModel" /> class.
            </summary>
      <param name="configNode">The config node.</param>
    </member>
    <member name="P:Castle.Core.MethodMetaModel.ConfigNode">
      <summary>
            Gets the config node.
            </summary>
      <value>The config node.</value>
    </member>
    <member name="T:Castle.Core.MethodMetaModelCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.MethodMetaModel" /></summary>
    </member>
    <member name="P:Castle.Core.MethodMetaModelCollection.MethodInfo2Model">
      <summary>
            Gets the method info2 model.
            </summary>
      <value>The method info2 model.</value>
    </member>
    <member name="T:Castle.Core.ParameterModel">
      <summary>
            Represents a parameter. Usually the parameter
            comes from the external world, ie, an external configuration.
            </summary>
    </member>
    <member name="M:Castle.Core.ParameterModel.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.Core.ParameterModel.#ctor(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModel" /> class.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="P:Castle.Core.ParameterModel.Name">
      <summary>
            Gets the name.
            </summary>
      <value>The name.</value>
    </member>
    <member name="P:Castle.Core.ParameterModel.Value">
      <summary>
            Gets the value.
            </summary>
      <value>The value.</value>
    </member>
    <member name="P:Castle.Core.ParameterModel.ConfigValue">
      <summary>
            Gets the config value.
            </summary>
      <value>The config value.</value>
    </member>
    <member name="T:Castle.Core.ParameterModelCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.ParameterModel" /></summary>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ParameterModelCollection" /> class.
            </summary>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,System.String)">
      <summary>
            Adds the specified name.
            </summary>
      <param name="name">The name.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Add(System.String,Castle.Core.Configuration.IConfiguration)">
      <summary>
            Adds the specified name.
            </summary>
      <param name="name">The name.</param>
      <param name="configNode">The config node.</param>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Contains(System.Object)">
      <summary>
            Determines whether this collection contains the specified key.
            </summary>
      <param name="key">The key.</param>
      <returns>
        <c>true</c> if yes; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Add(System.Object,System.Object)">
      <summary>
            Adds the specified key.
            </summary>
      <remarks>
            Not implemented
            </remarks>
      <param name="key">The key.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Clear">
      <summary>
            Clears this instance.
            </summary>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.Remove(System.Object)">
      <summary>
            Removes the specified key.
            </summary>
      <param name="key">The key.</param>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.CopyTo(System.Array,System.Int32)">
      <summary>
            Copy the content to the specified array
            </summary>
      <param name="array">target array</param>
      <param name="index">target index</param>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="M:Castle.Core.ParameterModelCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" />
            that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Keys">
      <summary>
            Gets the keys.
            </summary>
      <value>The keys.</value>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Values">
      <summary>
            Gets the values.
            </summary>
      <value>The values.</value>
      <remarks>
            Not implemented
            </remarks>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.IsReadOnly">
      <summary>
            Gets a value indicating whether this instance is read only.
            </summary>
      <value>
        <c>true</c> if this instance is read only; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.IsFixedSize">
      <summary>
            Gets a value indicating whether this instance is fixed size.
            </summary>
      <value>
        <c>true</c> if this instance is fixed size; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Castle.Core.ParameterModel" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.Count">
      <summary>
            Gets the count.
            </summary>
      <value>The count.</value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.SyncRoot">
      <summary>
            Gets the sync root.
            </summary>
      <value>The sync root.</value>
    </member>
    <member name="P:Castle.Core.ParameterModelCollection.IsSynchronized">
      <summary>
            Gets a value indicating whether this instance is synchronized.
            </summary>
      <value>
        <c>true</c> if this instance is synchronized; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Castle.Core.PropertySet">
      <summary>
            Represents a property and the respective dependency.
            </summary>
    </member>
    <member name="M:Castle.Core.PropertySet.#ctor(System.Reflection.PropertyInfo,Castle.Core.DependencyModel)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.PropertySet" /> class.
            </summary>
      <param name="propertyInfo">The property info.</param>
      <param name="dependency">The dependency.</param>
    </member>
    <member name="P:Castle.Core.PropertySet.Property">
      <summary>
            Gets the property.
            </summary>
      <value>The property.</value>
    </member>
    <member name="P:Castle.Core.PropertySet.Dependency">
      <summary>
            Gets the dependency.
            </summary>
      <value>The dependency.</value>
    </member>
    <member name="T:Castle.Core.PropertySetCollection">
      <summary>
            Collection of <see cref="T:Castle.Core.PropertySet" /></summary>
    </member>
    <member name="M:Castle.Core.PropertySetCollection.FindByPropertyInfo(System.Reflection.PropertyInfo)">
      <summary>
            Finds a PropertySet the by PropertyInfo.
            </summary>
      <param name="info">The info.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Resource.IResource">
      <summary>
            Represents a 'streamable' resource. Can
            be a file, a resource in an assembly.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.GetStreamReader(System.Text.Encoding)">
      <summary>
            Returns a reader for the stream
            </summary>
      <remarks>
            It's up to the caller to dispose the reader.
            </remarks>
      <param name="encoding">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResource.CreateRelative(System.String)">
      <summary>
            Returns an instance of <see cref="T:Castle.Core.Resource.IResource" />
            created according to the <c>relativePath</c>
            using itself as the root.
            </summary>
      <param name="relativePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.Core.Resource.IResource.FileBasePath">
      <summary>
      </summary>
      <remarks>
            Only valid for resources that
            can be obtained through relative paths
            </remarks>
    </member>
    <member name="T:Castle.Core.Resource.AbstractStreamResource">
      <summary>
      </summary>
    </member>
    <member name="F:Castle.Core.Resource.AbstractStreamResource.createStream">
      <summary>
            This returns a new stream instance each time it is called.
            It is the responsability of the caller to dispose of this stream
            </summary>
    </member>
    <member name="T:Castle.Core.Resource.IResourceFactory">
      <summary>
            Depicts the contract for resource factories.
            </summary>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Accept(Castle.Core.Resource.CustomUri)">
      <summary>
            Used to check whether the resource factory
            is able to deal with the given resource
            identifier.
            </summary>
      <remarks>
            Implementors should return <c>true</c>
            only if the given identificator is supported
            by the resource factory
            </remarks>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.Core.Resource.IResourceFactory.Create(Castle.Core.Resource.CustomUri,System.String)">
      <summary>
            Creates an <see cref="T:Castle.Core.Resource.IResource" /> instance
            for the given resource identifier
            </summary>
      <param name="uri">
      </param>
      <param name="basePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:Castle.Core.Resource.AssemblyResourceFactory">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.FileResource">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.FileResourceFactory">
      <summary>
      </summary>
    </member>
    <member name="T:Castle.Core.Resource.StaticContentResource">
      <summary>
            Adapts a static string content as an <see cref="T:Castle.Core.Resource.IResource" /></summary>
    </member>
    <member name="T:Castle.Core.Resource.UncResource">
      <summary>
            Enable access to files on network shares
            </summary>
    </member>
    <member name="T:Castle.Core.IServiceEnabledComponent">
      <summary>
            Defines that the implementation wants a 
            <see cref="T:System.IServiceProvider" /> in order to 
            access other components. The creator must be aware
            that the component might (or might not) implement 
            the interface.
            </summary>
      <remarks>
            Used by Castle Project components to, for example, 
            gather logging factories
            </remarks>
    </member>
    <member name="T:Castle.Core.IServiceProviderEx">
      <summary>
            Increments <c>IServiceProvider</c> with a generic service resolution operation.
            </summary>
    </member>
    <member name="T:Castle.Core.IServiceProviderExAccessor">
      <summary>
            This interface should be implemented by classes
            that are available in a bigger context, exposing
            the container to different areas in the same application.
            <para>
            For example, in Web application, the (global) HttpApplication
            subclasses should implement this interface to expose 
            the configured container
            </para></summary>
    </member>
    <member name="T:Castle.Core.Pair`2">
      <summary>
            General purpose class to represent a standard pair of values. 
            </summary>
      <typeparam name="TFirst">Type of the first value</typeparam>
      <typeparam name="TSecond">Type of the second value</typeparam>
    </member>
    <member name="M:Castle.Core.Pair`2.#ctor(`0,`1)">
      <summary>
            Constructs a pair with its values
            </summary>
      <param name="first">
      </param>
      <param name="second">
      </param>
    </member>
    <member name="T:Castle.Core.ProxyServices">
      <summary>
            List of utility methods related to dynamic proxy operations
            </summary>
    </member>
    <member name="M:Castle.Core.ProxyServices.IsDynamicProxy(System.Type)">
      <summary>
            Determines whether the specified type is a proxy generated by
            DynamicProxy (1 or 2).
            </summary>
      <param name="type">The type.</param>
      <returns>
        <c>true</c> if it is a proxy; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Castle.Core.ReflectionBasedDictionaryAdapter">
      <summary>
            Pendent
            </summary>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.Core.ReflectionBasedDictionaryAdapter" /> class.
            </summary>
      <param name="target">The target.</param>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Contains(System.Object)">
      <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary" /> object contains an element with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary" /> object.</param>
      <returns>
            true if the <see cref="T:System.Collections.IDictionary" /> contains an element with the key; otherwise, false.
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Add(System.Object,System.Object)">
      <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <param name="key">The <see cref="T:System.Object" /> to use as the key of the element to add.</param>
      <param name="value">The <see cref="T:System.Object" /> to use as the value of the element to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
      <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary" /> object. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> is read-only.-or- The <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Clear">
      <summary>
            Removes all elements from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> object is read-only. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.Remove(System.Object)">
      <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null. </exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary" /> object is read-only.-or- The <see cref="T:System.Collections.IDictionary" /> has a fixed size. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is null. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero. </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" /> is multidimensional.-or- <paramref name="index" /> is equal to or greater than the length of <paramref name="array" />.-or- The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />. </exception>
      <exception cref="T:System.ArgumentException">The type of the source <see cref="T:System.Collections.ICollection" /> cannot be cast automatically to the type of the destination <paramref name="array" />. </exception>
    </member>
    <member name="M:Castle.Core.ReflectionBasedDictionaryAdapter.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Item(System.Object)">
      <summary>
            Gets or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Keys">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> object containing the keys of the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection" /> object containing the keys of the <see cref="T:System.Collections.IDictionary" /> object.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Values">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> object containing the values in the <see cref="T:System.Collections.IDictionary" /> object.
            </summary>
      <value>
      </value>
      <returns>An <see cref="T:System.Collections.ICollection" /> object containing the values in the <see cref="T:System.Collections.IDictionary" /> object.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary" /> object is read-only.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary" /> object is read-only; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsFixedSize">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary" /> object has a fixed size.
            </summary>
      <value>
      </value>
      <returns>true if the <see cref="T:System.Collections.IDictionary" /> object has a fixed size; otherwise, false.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
      <returns>The number of elements contained in the <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
      </value>
      <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
    </member>
    <member name="P:Castle.Core.ReflectionBasedDictionaryAdapter.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).
            </summary>
      <value>
      </value>
      <returns>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, false.</returns>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.IndirectReference">
      <summary>
            Wraps a reference that is passed 
            ByRef and provides indirect load/store support.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.NewArrayExpression">
      <summary>
            Summary description for NewArrayExpression.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.SimpleAST.ReferencesToObjectArrayExpression">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.CustomAttributeUtil.InitializeConstructorArgs(System.Type,System.Attribute,System.Object[],System.Reflection.ParameterInfo[])">
      <summary>
            Here we try to match a constructor argument to its value.
            Since we can't get the values from the assembly, we use some heuristics to get it.
            a/ we first try to match all the properties on the attributes by name (case insensitive) to the argument
            b/ if we fail we try to match them by property type, with some smarts about convertions (i,e: can use Guid for string).
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.CustomAttributeUtil.ReplaceIfBetterMatch(System.Reflection.ParameterInfo,System.Reflection.PropertyInfo,System.Reflection.PropertyInfo)">
      <summary>
            We have the following rules here.
            Try to find a matching type, failing that, if the parameter is string, get the first property (under the assumption that
            we can convert it.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.CustomAttributeUtil.ConvertValue(System.Object,System.Type)">
      <summary>
            Attributes can only accept simple types, so we return null for null,
            if the value is passed as string we call to string (should help with converting), 
            otherwise, we use the value as is (enums, integer, etc).
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdcOpCodesDictionary">
      <summary>s
            Provides appropriate Ldc.X opcode for the type of primitive value to be loaded.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.LdindOpCodesDictionary">
      <summary>
            Provides appropriate Ldind.X opcode for 
            the type of primitive value to be loaded indirectly.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.MethodEmitter.CopyParametersAndReturnTypeFrom(System.Reflection.MethodInfo,Castle.DynamicProxy.Generators.Emitters.AbstractTypeEmitter)">
      <summary>
            Inspect the base method for generic definitions
            and set the return type and the parameters
            accordingly
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForConstantValue(System.Reflection.Emit.ILGenerator,System.Object)">
      <summary>
            Emits a load opcode of the appropriate kind for a constant string or
            primitive value.
            </summary>
      <param name="gen">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadOpCodeForDefaultValueOfType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
            Emits a load opcode of the appropriate kind for the constant default value of a
            type, such as 0 for value types and null for reference types.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitLoadIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
            Emits a load indirect opcode of the appropriate type for a value or object reference.
            Pops a pointer off the evaluation stack, dereferences it and loads
            a value of the specified type.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.Emitters.OpCodeUtil.EmitStoreIndirectOpCodeForType(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
            Emits a store indirectopcode of the appropriate type for a value or object reference.
            Pops a value of the specified type and a pointer off the evaluation stack, and
            stores the value.
            </summary>
      <param name="gen">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.PropertiesCollection">
      <summary>
            Summary description for PropertiesCollection.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.Emitters.StindOpCodesDictionary">
      <summary>
            Provides appropriate Stind.X opcode 
            for the type of primitive value to be stored indirectly.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.BaseProxyGenerator">
      <summary>
            Base class that exposes the common functionalities
            to proxy generation.
            </summary>
      <remarks>
            TODO: 
            - Add tests and fixes for 'leaking this' problem
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GetProxyTargetReference">
      <summary>
            Used by dinamically implement <see cref="T:Castle.Core.Interceptor.IProxyTargetAccessor" /></summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.GenerateParameterlessConstructor(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference)">
      <summary>
            Generates a parameters constructor that initializes the proxy
            state with <see cref="T:Castle.Core.Interceptor.StandardInterceptor" /> just to make it non-null.
            <para>
            This constructor is important to allow proxies to be XML serializable
            </para></summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.BuildInvocationNestedType(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo,Castle.DynamicProxy.Generators.ConstructorVersion)">
      <summary>
            If callbackMethod is null the InvokeOnTarget implementation 
            is just the code to throw an exception
            </summary>
      <param name="emitter">
      </param>
      <param name="targetType">
      </param>
      <param name="targetForInvocation">
      </param>
      <param name="methodInfo">
      </param>
      <param name="callbackMethod">
      </param>
      <param name="version">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.BuildInvocationNestedType(Castle.DynamicProxy.Generators.Emitters.ClassEmitter,System.Type,System.Type,System.Reflection.MethodInfo,System.Reflection.MethodInfo,Castle.DynamicProxy.Generators.ConstructorVersion,System.Boolean)">
      <summary>
            If callbackMethod is null the InvokeOnTarget implementation
            is just the code to throw an exception
            </summary>
      <param name="emitter">
      </param>
      <param name="targetType">
      </param>
      <param name="targetForInvocation">
      </param>
      <param name="methodInfo">
      </param>
      <param name="callbackMethod">
      </param>
      <param name="version">
      </param>
      <param name="allowChangeTarget">If true the invocation will implement the IChangeProxyTarget interface</param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.CreateIInvocationConstructor(System.Type,Castle.DynamicProxy.Generators.Emitters.NestedClassEmitter,Castle.DynamicProxy.Generators.Emitters.SimpleAST.FieldReference,Castle.DynamicProxy.Generators.ConstructorVersion)">
      <summary>
            Generates the constructor for the nested class that extends
            <see cref="T:Castle.DynamicProxy.AbstractInvocation" /></summary>
      <param name="targetFieldType">
      </param>
      <param name="nested">
      </param>
      <param name="targetField">
      </param>
      <param name="version">
      </param>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.CreateInitializeCacheMethodBody(System.Type,System.Reflection.MethodInfo[],Castle.DynamicProxy.Generators.Emitters.ClassEmitter,Castle.DynamicProxy.Generators.Emitters.ConstructorEmitter)">
      <summary>
            Improvement: this cache should be static. We should generate a
            type constructor instead
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.AcceptMethod(System.Reflection.MethodInfo,System.Boolean)">
      <summary>
            Performs some basic screening and invokes the <see cref="T:Castle.DynamicProxy.IProxyGenerationHook" />
            to select methods.
            </summary>
      <param name="method">
      </param>
      <param name="onlyVirtuals">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.IsAccessible(System.Reflection.MethodInfo)">
      <summary>
            Checks if the method is public or protected.
            </summary>
      <param name="method">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.ShouldSkipAttributeReplication(System.Attribute)">
      <summary>
            Attributes should be replicated if they are non-inheritable,
            but there are some special cases where the attributes means
            something to the CLR, where they should be skipped.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.BaseProxyGenerator.ShouldCreateNewSlot(System.Reflection.MethodInfo)">
      <summary>
            Checks if the method has the same signature as a method that was marked as
            one that should generate a new vtable slot.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.CacheKey.#ctor(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.CacheKey" /> class.
            </summary>
      <param name="targetType">Type of the target.</param>
      <param name="interfaces">The interfaces.</param>
      <param name="options">The options.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.ClassProxyGenerator">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.EventToGenerate.#ctor(Castle.DynamicProxy.Generators.Emitters.EventEmitter,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.EventAttributes)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.Generators.EventToGenerate" /> class.
            </summary>
      <param name="emitter">The emitter.</param>
      <param name="addMethod">The add method.</param>
      <param name="removeMethod">The remove method.</param>
      <param name="attributes">The attributes.</param>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator">
      <summary>
      </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator.FindMethodOnTargetType(System.Reflection.MethodInfo,System.Type,System.Boolean)">
      <summary>
            Finds the type of the method on target.
            </summary>
      <param name="methodOnInterface">The method on interface.</param>
      <param name="proxyTargetType">Type of the proxy target.</param>
            /// <param name="checkMixins">if set to <c>true</c> will check implementation on mixins.</param><returns></returns></member>
    <member name="M:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator.IsTypeEquivalent(System.Type,System.Type)">
      <summary>
            Checks whether the given types are the same. This is 
            more complicated than it looks.
            </summary>
      <param name="sourceType">
      </param>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator.IsMethodEquivalent(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
      <summary>
            Checks whether the given methods are the same.
            </summary>
      <param name="methodInfo">
      </param>
      <param name="methodOnInterface">
      </param>
      <returns>True if the methods are the same.</returns>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.InterfaceGeneratorType">
      <summary>
            This is used by the ProxyObjectReference class durin de-serialiation, to know
            which generator it should use
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Generators.MethodFinder">
      <summary>
            Returns the methods implemented by a type. Use this instead of Type.GetMethods() to work around a CLR issue
            where duplicate MethodInfos are returned by Type.GetMethods() after a token of a generic type's method was loaded.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.Serialization.ProxyObjectReference">
      <summary>
            Handles the deserialization of proxies.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope">
      <summary>
            Resets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization to a new scope.
            </summary>
      <remarks>This is useful for test cases.</remarks>
    </member>
    <member name="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.SetScope(Castle.DynamicProxy.ModuleScope)">
      <summary>
            Resets the <see cref="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope" /> used for deserialization to a given <paramref name="scope" />.
            </summary>
      <param name="scope">The scope to be used for deserialization.</param>
      <remarks>By default, the deserialization process uses a different scope than the rest of the application, which can lead to multiple proxies
            being generated for the same type. By explicitly setting the deserialization scope to the application's scope, this can be avoided.</remarks>
    </member>
    <member name="P:Castle.DynamicProxy.Serialization.ProxyObjectReference.ModuleScope">
      <summary>
            Gets the <see cref="T:Castle.DynamicProxy.ModuleScope" /> used for deserialization.
            </summary>
      <value>As <see cref="T:Castle.DynamicProxy.Serialization.ProxyObjectReference" /> has no way of automatically determining the scope used by the application (and the application
            might use more than one scope at the same time), <see cref="T:Castle.DynamicProxy.Serialization.ProxyObjectReference" /> uses a dedicated scope instance for deserializing proxy
            types. This instance can be reset and set to a specific value via <see cref="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.ResetScope" /> and <see cref="M:Castle.DynamicProxy.Serialization.ProxyObjectReference.SetScope(Castle.DynamicProxy.ModuleScope)" />.</value>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyGenerationHook">
      <summary>
            Used during the target type inspection process. Implementors have a chance to customize the
            proxy generation process.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.ShouldInterceptMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>
            Invoked by the generation process to determine if the specified method should be proxied.
            </summary>
      <param name="type">The type which declares the given method.</param>
      <param name="methodInfo">The method to inspect.</param>
      <returns>True if the given method should be proxied; false otherwise.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.NonVirtualMemberNotification(System.Type,System.Reflection.MemberInfo)">
      <summary>
            Invoked by the generation process to notify that a member was not marked as virtual.
            </summary>
      <param name="type">The type which declares the non-virtual member.</param>
      <param name="memberInfo">The non-virtual member.</param>
      <remarks>
            Non-virtual members cannot be proxied. This method gives an opportunity to inspect
            any non-virtual member of a type that has been requested to be proxied, and if
            appropriate - throw an exception to notify the caller.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyGenerationHook.MethodsInspected">
      <summary>
            Invoked by the generation process to notify that the whole process has completed.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.CacheMappingsAttribute">
      <summary>
            Applied to the assemblies saved by <see cref="T:Castle.DynamicProxy.ModuleScope" /> in order to persist the cache data included in the persisted assembly.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.IProxyBuilder">
      <summary>
            Abstracts the implementation of proxy type construction.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Creates a proxy type for given <paramref name="classToProxy" />, using <paramref name="options" /> provided.
            </summary>
      <param name="classToProxy">The class type to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy" /> is not public.
            Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
            pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.ClassProxyGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Creates a proxy type for given <paramref name="classToProxy" />, implementing <paramref name="additionalInterfacesToProxy" />, using <paramref name="options" /> provided.
            </summary>
      <param name="classToProxy">The class type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
            Implementers should return a proxy type for the specified class and interfaces.
            Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
            Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
            pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.ClassProxyGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Creates a proxy type that proxies calls to <paramref name="interfaceToProxy" /> members on <paramref name="targetType" />, implementing <paramref name="additionalInterfacesToProxy" />, using <paramref name="options" /> provided.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="targetType">Type implementing <paramref name="interfaceToProxy" /> on which calls to the interface members should be intercepted.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
            Implementers should return a proxy type for the specified interface that 'proceeds' executions to the specified target.
            Additional interfaces should be only 'mark' interfaces, that is, they should work like interface proxy without target. (See <see cref="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)" /> method.)
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
            Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
            pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Creates a proxy type for given <paramref name="interfaceToProxy" /> that delegates all calls to the provided interceptors.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
            Implementers should return a proxy type for the specified interface and additional interfaces that delegate all executions to the specified interceptors.
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
            Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
            pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithoutTargetGenerator" />
    </member>
    <member name="M:Castle.DynamicProxy.IProxyBuilder.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Creates a proxy type for given <paramref name="interfaceToProxy" /> and <parmaref name="additionalInterfacesToProxy" /> that delegates all calls to the provided interceptors and allows interceptors to switch the actual target of invocation.
            </summary>
      <param name="interfaceToProxy">The interface type to proxy.</param>
      <param name="additionalInterfacesToProxy">Additional interface types to proxy.</param>
      <param name="options">The proxy generation options.</param>
      <returns>The generated proxy type.</returns>
      <remarks>
            Implementers should return a proxy type for the specified interface(s) that delegate all executions to the specified interceptors
            and uses an instance of the interface as their targets (i.e. <see cref="P:Castle.Core.Interceptor.IInvocation.InvocationTarget" />), rather than a class. All <see cref="T:Castle.Core.Interceptor.IInvocation" /> classes should then implement <see cref="T:Castle.Core.Interceptor.IChangeProxyTarget" /> interface,
            to allow interceptors to switch invocation target with instance of another type implementing called interface.
            </remarks>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:Castle.DynamicProxy.Generators.GeneratorException">Thrown when <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is not public.
            Note that to avoid this exception, you can mark offending type internal, and define <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute" /> 
            pointing to Castle Dynamic Proxy assembly, in assembly containing that type, if this is appropriate.</exception>
      <seealso cref="T:Castle.DynamicProxy.Generators.InterfaceProxyWithTargetInterfaceGenerator" />
    </member>
    <member name="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope">
      <summary>
            Gets the <see cref="P:Castle.DynamicProxy.IProxyBuilder.ModuleScope" /> associated with this builder.
            </summary>
      <value>The module scope associated with this builder.</value>
    </member>
    <member name="T:Castle.DynamicProxy.DefaultProxyBuilder">
      <summary>
            Default implementation of <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> interface producing in-memory proxy assemblies.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.DefaultProxyBuilder" /> class with new <see cref="T:Castle.DynamicProxy.ModuleScope" />.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.DefaultProxyBuilder.#ctor(Castle.DynamicProxy.ModuleScope)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.DefaultProxyBuilder" /> class.
            </summary>
      <param name="scope">The module scope for generated proxy types.</param>
    </member>
    <member name="T:Castle.DynamicProxy.IInterceptorSelector">
      <summary>
            Provides an extension point that allows proxies to choose specific interceptors on
            a per method basis.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.IInterceptorSelector.SelectInterceptors(System.Type,System.Reflection.MethodInfo,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Selects the interceptors that should intercept calls to the given <paramref name="method" />.
            </summary>
      <param name="type">The type declaring the method to intercept.</param>
      <param name="method">The method that will be intercepted.</param>
      <param name="interceptors">All interceptors registered with the proxy.</param>
      <returns>An array of interceptors to invoke upon calling the <paramref name="method" />.</returns>
      <remarks>
            This method is called only once per proxy instance, upon the first call to the
            <paramref name="method" />. Either an empty array or null are valid return values to indicate
            that no interceptor should intercept calls to the method. Although it is not advised, it is
            legal to return other <see cref="T:Castle.Core.Interceptor.IInterceptor" /> implementations than these provided in
            <paramref name="interceptors" />. A better way to do this, is by passing all the required
            interceptors to the appropriate method of <see cref="T:Castle.DynamicProxy.ProxyGenerator" />. You can use this
            method to influence the order in which interceptors will be called, by reordering the array.
            Returning an array containing null references (Nothing in Visual Basic) is not legal,
            and will result in a runtime exception.
            </remarks>
      <seealso cref="T:Castle.DynamicProxy.ProxyGenerationOptions" />
    </member>
    <member name="M:Castle.DynamicProxy.InternalsHelper.IsInternalToDynamicProxy(System.Reflection.Assembly)">
      <summary>
            Determines whether this assembly has internals visible to dynamic proxy.
            </summary>
      <param name="asm">The assembly to inspect.</param>
    </member>
    <member name="M:Castle.DynamicProxy.InternalsHelper.IsInternal(System.Reflection.MethodInfo)">
      <summary>
            Determines whether the specified method is internal.
            </summary>
      <param name="method">The method.</param>
      <returns>
        <c>true</c> if the specified method is internal; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Castle.DynamicProxy.MixinData.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
            Because we need to cache the types based on the mixed in mixins, we do the following here:
             - Get all the mixin interfaces
             - Sort them by full name
             - Return them by position
            
            The idea is to have reproducable behavior for the case that mixins are registered in different orders.
            This method is here because it is required 
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.ModuleScope">
      <summary>
            Summary description for ModuleScope.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME">
      <summary>
            The default file name used when the assembly is saved using <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" />.
            </summary>
    </member>
    <member name="F:Castle.DynamicProxy.ModuleScope.DEFAULT_ASSEMBLY_NAME">
      <summary>
            The default assembly (simple) name used for the assemblies generated by a <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class; assemblies created by this instance will not be saved.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
            should be saved.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.#ctor(System.Boolean,System.String,System.String,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ModuleScope" /> class, allowing to specify whether the assemblies generated by this instance
            should be saved and what simple names are to be assigned to them.
            </summary>
      <param name="savePhysicalAssembly">If set to <c>true</c> saves the generated module.</param>
      <param name="strongAssemblyName">The simple name of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="strongModulePath">The path and file name of the manifest module of the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakAssemblyName">The simple name of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
      <param name="weakModulePath">The path and file name of the manifest module of the weak-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.GetFromCache(Castle.DynamicProxy.Generators.CacheKey)">
      <summary>
            Returns a type from this scope's type cache, or null if the key cannot be found.
            </summary>
      <param name="key">The key to be looked up in the cache.</param>
      <returns>The type from this scope's type cache matching the key, or null if the key cannot be found</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.RegisterInCache(Castle.DynamicProxy.Generators.CacheKey,System.Type)">
      <summary>
            Registers a type in this scope's type cache.
            </summary>
      <param name="key">The key to be associated with the type.</param>
      <param name="type">The type to be stored in the cache.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.GetKeyPair">
      <summary>
            Gets the key pair used to sign the strong-named assembly generated by this <see cref="T:Castle.DynamicProxy.ModuleScope" />.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModule(System.Boolean)">
      <summary>
            Gets the specified module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <param name="isStrongNamed">If set to true, a strong-named module is returned; otherwise, a weak-named module is returned.</param>
      <returns>A strong-named or weak-named module generated by this scope, as specified by the <paramref name="isStrongNamed" /> parameter.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithStrongName">
      <summary>
            Gets the strong-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <returns>A strong-named module generated by this scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.ObtainDynamicModuleWithWeakName">
      <summary>
            Gets the weak-named module generated by this scope, creating a new one if none has yet been generated.
            </summary>
      <returns>A weak-named module generated by this scope.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly">
      <summary>
            Saves the generated assembly with the name and directory information given when this <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance was created (or with
            the <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" /> and current directory if none was given).
            </summary>
      <remarks>
        <para>
            This method stores the generated assembly in the directory passed as part of the module information specified when this instance was
            constructed (if any, else the current directory is used). If both a strong-named and a weak-named assembly
            have been generated, it will throw an exception; in this case, use the <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)" /> overload.
            </para>
        <para>
            If this <see cref="T:Castle.DynamicProxy.ModuleScope" /> was created without indicating that the assembly should be saved, this method does nothing.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">Both a strong-named and a weak-named assembly have been generated.</exception>
      <returns>The path of the generated assembly file, or null if no file has been generated.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)">
      <summary>
            Saves the specified generated assembly with the name and directory information given when this <see cref="T:Castle.DynamicProxy.ModuleScope" /> instance was created
            (or with the <see cref="F:Castle.DynamicProxy.ModuleScope.DEFAULT_FILE_NAME" /> and current directory if none was given).
            </summary>
      <param name="strongNamed">True if the generated assembly with a strong name should be saved (see <see cref="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule" />);
              false if the generated assembly without a strong name should be saved (see <see cref="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule" />.</param>
      <remarks>
        <para>
            This method stores the specified generated assembly in the directory passed as part of the module information specified when this instance was
            constructed (if any, else the current directory is used).
            </para>
        <para>
            If this <see cref="T:Castle.DynamicProxy.ModuleScope" /> was created without indicating that the assembly should be saved, this method does nothing.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">No assembly has been generated that matches the <paramref name="strongNamed" /> parameter.
            </exception>
      <returns>The path of the generated assembly file, or null if no file has been generated.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ModuleScope.LoadAssemblyIntoCache(System.Reflection.Assembly)">
      <summary>
            Loads the generated types from the given assembly into this <see cref="T:Castle.DynamicProxy.ModuleScope" />'s cache.
            </summary>
      <param name="assembly">The assembly to load types from. This assembly must have been saved via <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly(System.Boolean)" /> or
            <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" />, or it must have the <see cref="T:Castle.DynamicProxy.CacheMappingsAttribute" /> manually applied.</param>
      <remarks>
            This method can be used to load previously generated and persisted proxy types from disk into this scope's type cache, eg. in order
            to avoid the performance hit associated with proxy generation.
            </remarks>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.RWLock">
      <summary>
            Users of this <see cref="T:Castle.DynamicProxy.ModuleScope" /> should use this lock when accessing the cache.
            </summary>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModule">
      <summary>
            Gets the strong-named module generated by this scope, or <see langword="null" /> if none has yet been generated.
            </summary>
      <value>The strong-named module generated by this scope, or <see langword="null" /> if none has yet been generated.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleName">
      <summary>
            Gets the file name of the strongly named module generated by this scope.
            </summary>
      <value>The file name of the strongly named module generated by this scope.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.StrongNamedModuleDirectory">
      <summary>
            Gets the directory where the strongly named module generated by this scope will be saved, or <see langword="null" /> if the current directory
            is used.
            </summary>
      <value>The directory where the strongly named module generated by this scope will be saved when <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" /> is called
            (if this scope was created to save modules).</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModule">
      <summary>
            Gets the weak-named module generated by this scope, or <see langword="null" /> if none has yet been generated.
            </summary>
      <value>The weak-named module generated by this scope, or <see langword="null" /> if none has yet been generated.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleName">
      <summary>
            Gets the file name of the weakly named module generated by this scope.
            </summary>
      <value>The file name of the weakly named module generated by this scope.</value>
    </member>
    <member name="P:Castle.DynamicProxy.ModuleScope.WeakNamedModuleDirectory">
      <summary>
            Gets the directory where the weakly named module generated by this scope will be saved, or <see langword="null" /> if the current directory
            is used.
            </summary>
      <value>The directory where the weakly named module generated by this scope will be saved when <see cref="M:Castle.DynamicProxy.ModuleScope.SaveAssembly" /> is called
            (if this scope was created to save modules).</value>
    </member>
    <member name="T:Castle.DynamicProxy.PersistentProxyBuilder">
      <summary>
            ProxyBuilder that persists the generated type.
            </summary>
      <remarks>
            The saved assembly contains just the last generated type.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.PersistentProxyBuilder" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.PersistentProxyBuilder.SaveAssembly">
      <summary>
            Saves the generated assembly to a physical file. Note that this renders the <see cref="T:Castle.DynamicProxy.PersistentProxyBuilder" /> unusable.
            </summary>
      <returns>The path of the generated assembly file, or null if no assembly has been generated.</returns>
      <remarks>This method does not support saving multiple files. If both a signed and an unsigned module have been generated, use the 
            respective methods of the <see cref="T:Castle.DynamicProxy.ModuleScope" />.</remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor(Castle.DynamicProxy.IProxyGenerationHook)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
      <param name="hook">The hook.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerationOptions.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerationOptions" /> class.
            </summary>
    </member>
    <member name="T:Castle.DynamicProxy.ProxyGenerator">
      <summary>
            Provides proxy objects for classes and interfaces.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor(Castle.DynamicProxy.IProxyBuilder)">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
      <param name="builder">Proxy types builder.</param>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Castle.DynamicProxy.ProxyGenerator" /> class.
            </summary>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(``0,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>Object proxying calls to members of <typeparamref name="TInterface" /> on <paramref name="target" /> object.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" />is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget``1(System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface implemented by <paramref name="target" /> which will be proxied.</typeparam>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <typeparamref name="TInterface" /> on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" />is not an interface type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types  on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTarget(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            Interceptors can use <see cref="T:Castle.Core.Interceptor.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            Interceptors can use <see cref="T:Castle.Core.Interceptor.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy" /> type on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithTargetInterface(System.Type,System.Type[],System.Object,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on <paramref name="target" /> object with given <paramref name="interceptors" />.
            Interceptors can use <see cref="T:Castle.Core.Interceptor.IChangeProxyTarget" /> interface to provide other target for method invocation than default <paramref name="target" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface implemented by <paramref name="target" /> which will be proxied.</param>
      <param name="target">The target object, calls to which will be intercepted.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on <paramref name="target" /> object or alternative implementation swapped at runtime by an interceptor.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="target" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="target" /> does not implement <paramref name="interfaceToProxy" /> interface.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on actual type of <paramref name="target" /> object.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of actual type of <paramref name="target" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.Core.Interceptor.IInterceptor)">
      <summary>
            Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptor" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="interceptor">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptor" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
            Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor" /> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget``1(Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <typeparamref name="TInterface" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TInterface">Type of the interface which will be proxied.</typeparam>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <typeparamref name="TInterface" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TInterface" /> is not an interface type.</exception>
      <remarks>
            Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor" /> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
            As a result of that also at least one <see cref="T:Castle.Core.Interceptor.IInterceptor" /> implementation must be provided.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.Core.Interceptor.IInterceptor)">
      <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptor" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="interceptor">The interceptor called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy" /> type on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptor" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
            Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor" /> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy" /> type on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
            Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor" /> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
            Since this method uses an empty-shell implementation of interfaces to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor" /> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to members of interface <paramref name="interfaceToProxy" /> on target object generated at runtime with given <paramref name="interceptors" />.
            </summary>
      <param name="interfaceToProxy">Type of the interface which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            Object proxying calls to members of <paramref name="interfaceToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types on generated target object.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interfaceToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="interceptors" /> array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="interfaceToProxy" /> is not an interface type.</exception>
      <remarks>
            Since this method uses an empty-shell implementation of <paramref name="additionalInterfacesToProxy" /> to proxy generated at runtime, the actual implementation of proxied methods must be provided by given <see cref="T:Castle.Core.Interceptor.IInterceptor" /> implementations.
            They are responsible for setting return value (and out parameters) on proxied methods. It is also illegal for an interceptor to call <see cref="M:Castle.Core.Interceptor.IInvocation.Proceed" />, since there's no actual implementation to proceed with.
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy``1(Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to virtual members of type <typeparamref name="TClass" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <typeparam name="TClass">Type of class which will be proxied.</typeparam>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            New object of type <typeparamref name="TClass" /> proxying calls to virtual members of <typeparamref name="TClass" /> type.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when given <typeparamref name="TClass" /> is not a class type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on type <typeparamref name="TClass" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <typeparamref name="TClass" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.Core.Interceptor.IInterceptor[],System.Object[])">
      <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> type.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no default constructor exists on type <paramref name="classToProxy" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when default constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxy(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions,System.Object[],Castle.Core.Interceptor.IInterceptor[])">
      <summary>
            Creates proxy object intercepting calls to virtual members of type <paramref name="classToProxy" /> on newly created instance of that type with given <paramref name="interceptors" />.
            </summary>
      <param name="classToProxy">Type of class which will be proxied.</param>
      <param name="additionalInterfacesToProxy">Additional interface types. Calls to their members will be proxied as well.</param>
      <param name="options">The proxy generation options used to influence generated proxy type and object.</param>
      <param name="constructorArguments">Arguments of constructor of type <paramref name="classToProxy" /> which should be used to create a new instance of that type.</param>
      <param name="interceptors">The interceptors called during the invocation of proxied methods.</param>
      <returns>
            New object of type <paramref name="classToProxy" /> proxying calls to virtual members of <paramref name="classToProxy" /> and <paramref name="additionalInterfacesToProxy" /> types.
            </returns>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="classToProxy" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when given <paramref name="options" /> object is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> or any of <paramref name="additionalInterfacesToProxy" /> is a generic type definition.</exception>
      <exception cref="T:System.ArgumentException">Thrown when given <paramref name="classToProxy" /> is not a class type.</exception>
      <exception cref="T:System.MissingMethodException">Thrown when no constructor exists on type <paramref name="classToProxy" /> with parameters matching <paramref name="constructorArguments" />.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">Thrown when constructor of type <paramref name="classToProxy" /> throws an exception.</exception>
      <remarks>
            This method uses <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation to generate a proxy type.
            As such caller should expect any type of exception that given <see cref="T:Castle.DynamicProxy.IProxyBuilder" /> implementation may throw.
            </remarks>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateClassProxyType(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Creates the proxy type for class proxy with given <paramref name="classToProxy" /> class, implementing given <paramref name="additionalInterfacesToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="classToProxy">The base class for proxy type.</param>
      <param name="additionalInterfacesToProxy">The interfaces that proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTarget(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Creates the proxy type for interface proxy with target for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> on given <paramref name="targetType" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="targetType">Actual type that the proxy type will encompass.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithTargetInterface(System.Type,System.Type[],System.Type,Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Creates the proxy type for interface proxy with target interface for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> on given <paramref name="targetType" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="targetType">Actual type that the proxy type will encompass.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="M:Castle.DynamicProxy.ProxyGenerator.CreateInterfaceProxyTypeWithoutTarget(System.Type,System.Type[],Castle.DynamicProxy.ProxyGenerationOptions)">
      <summary>
            Creates the proxy type for interface proxy without target for given <paramref name="interfaceToProxy" /> interface, implementing given <paramref name="additionalInterfacesToProxy" /> and using provided <paramref name="options" />.
            </summary>
      <param name="interfaceToProxy">The interface proxy type should implement.</param>
      <param name="additionalInterfacesToProxy">The additional interfaces proxy type should implement.</param>
      <param name="options">The options for proxy generation process.</param>
      <returns>
        <see cref="T:System.Type" /> of proxy.</returns>
    </member>
    <member name="P:Castle.DynamicProxy.ProxyGenerator.ProxyBuilder">
      <summary>
            Gets the proxy builder instance used to generate proxy types.
            </summary>
      <value>The proxy builder.</value>
    </member>
    <member name="M:Castle.DynamicProxy.RemotableInvocation.Proceed">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:Castle.DynamicProxy.RemotableInvocation.Method">
      <summary>
      </summary>
    </member>
    <member name="P:Castle.DynamicProxy.RemotableInvocation.MethodInvocationTarget">
      <summary>
            For interface proxies, this will point to the
            <see cref="T:System.Reflection.MethodInfo" /> on the target class
            </summary>
    </member>
    <member name="F:FluentNHibernate.AutoMappingExpressions.FindIdentity">
      <summary>
            Determines whether a property is the identity of an entity.
            </summary>
    </member>
    <member name="F:FluentNHibernate.AutoMappingExpressions.AbstractClassIsLayerSupertype">
      <summary>
            Determines whether an abstract class is a layer supertype or part of a mapped inheritance hierarchy.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Automapping.Alterations.IAutoMappingAlteration">
      <summary>
            Provides a mechanism for altering an AutoPersistenceModel prior to
            the generation of mappings.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Automapping.Alterations.IAutoMappingAlteration.Alter(FluentNHibernate.Automapping.AutoPersistenceModel)">
      <summary>
            Alter the model
            </summary>
      <param name="model">AutoPersistenceModel instance to alter</param>
    </member>
    <member name="T:FluentNHibernate.Automapping.Alterations.AutoMappingOverrideAlteration">
      <summary>
            Built-in alteration for altering an AutoPersistenceModel with instance of IAutoMappingOverride&lt;T&gt;.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Automapping.Alterations.AutoMappingOverrideAlteration.#ctor(System.Reflection.Assembly)">
      <summary>
            Constructor for AutoMappingOverrideAlteration.
            </summary>
      <param name="overrideAssembly">Assembly to load overrides from.</param>
    </member>
    <member name="M:FluentNHibernate.Automapping.Alterations.AutoMappingOverrideAlteration.Alter(FluentNHibernate.Automapping.AutoPersistenceModel)">
      <summary>
            Alter the model
            </summary>
      <remarks>
            Finds all types in the assembly (passed in the constructor) that implement IAutoMappingOverride&lt;T&gt;, then
            creates an AutoMapping&lt;T&gt; and applies the override to it.
            </remarks>
      <param name="model">AutoPersistenceModel instance to alter</param>
    </member>
    <member name="T:FluentNHibernate.Automapping.Alterations.IAutoMappingOverride`1">
      <summary>
            A mapping override for an auto mapped entity.
            </summary>
      <typeparam name="T">Entity who's auto-mapping you're overriding</typeparam>
    </member>
    <member name="M:FluentNHibernate.Automapping.Alterations.IAutoMappingOverride`1.Override(FluentNHibernate.Automapping.AutoMapping{`0})">
      <summary>
            Alter the automapping for this type
            </summary>
      <param name="mapping">Automapping</param>
    </member>
    <member name="T:FluentNHibernate.Automapping.ITypeSource">
      <summary>
            A source for Type instances, used for locating types that should be
            automapped.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.KeyProperty(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
      <summary>
            Defines a property to be used as a key for this composite-id.
            </summary>
      <param name="expression">A member access lambda expression for the property</param>
      <returns>The composite identity part fluent interface</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.KeyProperty(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
      <summary>
            Defines a property to be used as a key for this composite-id with an explicit column name.
            </summary>
      <param name="expression">A member access lambda expression for the property</param>
      <param name="columnName">The column name in the database to use for this key, or null to use the property name</param>
      <returns>The composite identity part fluent interface</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.KeyReference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
      <summary>
            Defines a reference to be used as a many-to-one key for this composite-id with an explicit column name.
            </summary>
      <param name="expression">A member access lambda expression for the property</param>
      <returns>The composite identity part fluent interface</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.CompositeIdentityPart`1.KeyReference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String)">
      <summary>
            Defines a reference to be used as a many-to-one key for this composite-id with an explicit column name.
            </summary>
      <param name="expression">A member access lambda expression for the property</param>
      <param name="columnName">The column name in the database to use for this key, or null to use the property name</param>
      <returns>The composite identity part fluent interface</returns>
    </member>
    <member name="P:FluentNHibernate.Mapping.CompositeIdentityPart`1.Access">
      <summary>
            Set the access and naming strategy for this identity.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.Component``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Action{FluentNHibernate.Mapping.ComponentPart{``0}})">
      <summary>
            Maps a component
            </summary>
      <typeparam name="TComponent">Type of component</typeparam>
      <param name="expression">Component property</param>
      <param name="action">Component mapping</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.Component``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Action{FluentNHibernate.Mapping.ComponentPart{``0}})">
      <summary>
            Maps a component
            </summary>
      <typeparam name="TComponent">Type of component</typeparam>
      <param name="expression">Component property</param>
      <param name="action">Component mapping</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.MapHasMany``2(System.Linq.Expressions.Expression{System.Func{`0,``1}})">
      <summary>
            CreateProperties a one-to-many relationship
            </summary>
      <typeparam name="TChild">Child object type</typeparam>
      <typeparam name="TReturn">Property return type</typeparam>
      <param name="expression">Expression to get property from</param>
      <returns>one-to-many part</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
      <summary>
            CreateProperties a one-to-many relationship
            </summary>
      <typeparam name="TChild">Child object type</typeparam>
      <param name="expression">Expression to get property from</param>
      <returns>one-to-many part</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasMany``2(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IDictionary{``0,``1}}})">
      <summary>
            CreateProperties a one-to-many relationship with a IDictionary
            </summary>
      <typeparam name="TKey">Dictionary key type</typeparam>
      <typeparam name="TChild">Child object type / Dictionary value type</typeparam>
      <param name="expression">Expression to get property from</param>
      <returns>one-to-many part</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
      <summary>
            CreateProperties a one-to-many relationship
            </summary>
      <typeparam name="TChild">Child object type</typeparam>
      <param name="expression">Expression to get property from</param>
      <returns>one-to-many part</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.MapHasManyToMany``2(System.Linq.Expressions.Expression{System.Func{`0,``1}})">
      <summary>
            CreateProperties a many-to-many relationship
            </summary>
      <typeparam name="TChild">Child object type</typeparam>
      <typeparam name="TReturn">Property return type</typeparam>
      <param name="expression">Expression to get property from</param>
      <returns>many-to-many part</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
      <summary>
            CreateProperties a many-to-many relationship
            </summary>
      <typeparam name="TChild">Child object type</typeparam>
      <param name="expression">Expression to get property from</param>
      <returns>many-to-many part</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClasslikeMapBase`1.HasManyToMany``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
      <summary>
            CreateProperties a many-to-many relationship
            </summary>
      <typeparam name="TChild">Child object type</typeparam>
      <param name="expression">Expression to get property from</param>
      <returns>many-to-many part</returns>
    </member>
    <member name="P:FluentNHibernate.Mapping.JoinedSubClassPart`1.Not">
      <summary>
            Inverts the next boolean
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClassMap`1.Schema(System.String)">
      <summary>
            Sets the hibernate-mapping schema for this class.
            </summary>
      <param name="schema">Schema name</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClassMap`1.Table(System.String)">
      <summary>
            Sets the table for the class.
            </summary>
      <param name="tableName">Table name</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClassMap`1.LazyLoad">
      <summary>
            Sets this entity to be lazy-loaded (overrides the default lazy load configuration).
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClassMap`1.Join(System.String,System.Action{FluentNHibernate.Mapping.JoinPart{`0}})">
      <summary>
            Sets additional tables for the class via the NH 2.0 Join element.
            </summary>
      <param name="tableName">Joined table name</param>
      <param name="action">Joined table mapping</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClassMap`1.ImportType``1">
      <summary>
            Imports an existing type for use in the mapping.
            </summary>
      <typeparam name="TImport">Type to import.</typeparam>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClassMap`1.ReadOnly">
      <summary>
            Set the mutability of this class, sets the mutable attribute.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClassMap`1.DynamicUpdate">
      <summary>
            Sets this entity to be dynamic update
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClassMap`1.DynamicInsert">
      <summary>
            Sets this entity to be dynamic insert
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClassMap`1.Where(System.String)">
      <summary>
            Defines a SQL 'where' clause used when retrieving objects of this type.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ClassMap`1.Subselect(System.String)">
      <summary>
            Sets the SQL statement used in subselect fetching.
            </summary>
      <param name="subselectSql">Subselect SQL Query</param>
    </member>
    <member name="P:FluentNHibernate.Mapping.ClassMap`1.Cache">
      <summary>
            Specify caching for this entity.
            </summary>
    </member>
    <member name="P:FluentNHibernate.Mapping.ClassMap`1.Not">
      <summary>
            Inverse next boolean
            </summary>
    </member>
    <member name="P:FluentNHibernate.Mapping.ClassMap`1.OptimisticLock">
      <summary>
            Sets the optimistic locking strategy
            </summary>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoMapper.FlagAsMapped(System.Type)">
      <summary>
            Flags a type as already mapped, stop it from being auto-mapped.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoMappingAlterationCollection.Add(System.Type)">
      <summary>
            Creates an instance of an IAutoMappingAlteration from a type instance, then adds it to the alterations collection.
            </summary>
      <param name="type">Type of an IAutoMappingAlteration</param>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoMappingAlterationCollection.Add``1">
      <summary>
            Creates an instance of an IAutoMappingAlteration from a generic type parameter, then adds it to the alterations collection.
            </summary>
      <typeparam name="T">Type of an IAutoMappingAlteration</typeparam>
      <returns>Container</returns>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoMappingAlterationCollection.Add(FluentNHibernate.Automapping.Alterations.IAutoMappingAlteration)">
      <summary>
            Adds an alteration
            </summary>
      <param name="alteration">Alteration to add</param>
      <returns>Container</returns>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoMappingAlterationCollection.AddFromAssembly(System.Reflection.Assembly)">
      <summary>
            Adds all alterations from an assembly
            </summary>
      <param name="assembly">Assembly to search</param>
      <returns>Container</returns>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoMappingAlterationCollection.AddFromAssemblyOf``1">
      <summary>
            Adds all alterations from an assembly that contains T.
            </summary>
      <typeparam name="T">Type who's assembly to search</typeparam>
      <returns>Container</returns>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoMappingAlterationCollection.Apply(FluentNHibernate.Automapping.AutoPersistenceModel)">
      <summary>
            Apply alterations to an AutoPersisteceModel
            </summary>
      <param name="model">AutoPersistenceModel instance to apply alterations to</param>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.Alterations(System.Action{FluentNHibernate.Automapping.AutoMappingAlterationCollection})">
      <summary>
            Specify alterations to be used with this AutoPersisteceModel
            </summary>
      <param name="alterationDelegate">Lambda to declare alterations</param>
      <returns>AutoPersistenceModel</returns>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.UseOverridesFromAssemblyOf``1">
      <summary>
            Use auto mapping overrides defined in the assembly of T.
            </summary>
      <typeparam name="T">Type to get assembly from</typeparam>
      <returns>AutoPersistenceModel</returns>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.Setup(System.Action{FluentNHibernate.AutoMappingExpressions})">
      <summary>
            Alter some of the configuration options that control how the automapper works
            </summary>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.AddEntityAssembly(System.Reflection.Assembly)">
      <summary>
            Adds all entities from a specific assembly.
            </summary>
      <param name="assembly">Assembly to load from</param>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.AddTypeSource(FluentNHibernate.Automapping.ITypeSource)">
      <summary>
            Adds all entities from the <see cref="T:FluentNHibernate.Automapping.ITypeSource" />.
            </summary>
      <param name="source">
        <see cref="T:FluentNHibernate.Automapping.ITypeSource" /> to load from</param>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.Override``1(System.Action{FluentNHibernate.Automapping.AutoMapping{``0}})">
      <summary>
            Override the mapping of a specific entity.
            </summary>
      <remarks>This may affect subclasses, depending on the alterations you do.</remarks>
      <typeparam name="T">Entity who's mapping to override</typeparam>
      <param name="populateMap">Lambda performing alterations</param>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.OverrideAll(System.Action{FluentNHibernate.Automapping.IPropertyIgnorer})">
      <summary>
            Override all mappings.
            </summary>
      <remarks>Currently only supports ignoring properties on all entities.</remarks>
      <param name="alteration">Lambda performing alterations</param>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.IgnoreBase``1">
      <summary>
            Ignore a base type. This removes it from any mapped inheritance hierarchies, good for non-abstract layer
            supertypes.
            </summary>
      <typeparam name="T">Type to ignore</typeparam>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.IgnoreBase(System.Type)">
      <summary>
            Ignore a base type. This removes it from any mapped inheritance hierarchies, good for non-abstract layer
            supertypes.
            </summary>
      <param name="baseType">Type to ignore</param>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.IncludeBase``1">
      <summary>
            Explicitly includes a type to be used as part of a mapped inheritance hierarchy.
            </summary>
      <remarks>
            Abstract classes are probably what you'll be using this method with. Fluent NHibernate considers abstract
            classes to be layer supertypes, so doesn't automatically map them as part of an inheritance hierarchy. You
            can use this method to override that behavior for a specific type; otherwise you should consider using the
            <see cref="F:FluentNHibernate.AutoMappingExpressions.AbstractClassIsLayerSupertype" /> setting.
            </remarks>
      <typeparam name="T">Type to include</typeparam>
    </member>
    <member name="M:FluentNHibernate.Automapping.AutoPersistenceModel.IncludeBase(System.Type)">
      <summary>
            Explicitly includes a type to be used as part of a mapped inheritance hierarchy.
            </summary>
      <remarks>
            Abstract classes are probably what you'll be using this method with. Fluent NHibernate considers abstract
            classes to be layer supertypes, so doesn't automatically map them as part of an inheritance hierarchy. You
            can use this method to override that behavior for a specific type; otherwise you should consider using the
            <see cref="F:FluentNHibernate.AutoMappingExpressions.AbstractClassIsLayerSupertype" /> setting.
            </remarks>
      <param name="baseType">Type to include</param>
    </member>
    <member name="P:FluentNHibernate.Automapping.AutoPersistenceModel.Conventions">
      <summary>
            Alter convention discovery
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.SubClassPart`1.LazyLoad">
      <summary>
            Sets whether this subclass is lazy loaded
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:FluentNHibernate.Mapping.SubClassPart`1.Not">
      <summary>
            Inverts the next boolean
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IConvention">
      <summary>
            Ignore - this is used for generic restrictions only
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IConvention`2">
      <summary>
            Basic convention interface. Don't use directly.
            </summary>
      <typeparam name="TInspector">Inspector instance for use in retrieving values and setting expectations</typeparam>
      <typeparam name="TInstance">Apply instance</typeparam>
    </member>
    <member name="M:FluentNHibernate.Conventions.IConvention`2.Apply(`1)">
      <summary>
            Apply changes to the target
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IHibernateMappingConvention">
      <summary>
            Convention for the hibernate-mapping container for a class, this can be used to
            set some class-wide settings such as lazy-load and access strategies.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IReferenceConvention">
      <summary>
            Reference convention, implement this interface to apply changes to Reference/many-to-one
            relationships.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IJoinedSubclassConvention">
      <summary>
            Joined subclass convention, implement this interface to alter joined-subclass mappings.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IJoinConvention">
      <summary>
            Join convention, implement this interface to alter join mappings.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.ISubclassConvention">
      <summary>
            Subclass convention, implement this interface to alter subclass mappings.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IHasOneConvention">
      <summary>
            HasOne convention, used for applying changes to one-to-one relationships.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IVersionConvention">
      <summary>
            Version convention, implement this interface to apply changes to vesion mappings.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IComponentConvention">
      <summary>
            Convention for a component mapping. Implement this interface to
            apply changes to components.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IDynamicComponentConvention">
      <summary>
            Convention for dynamic components. Implement this member to apply changes
            to dynamic components.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Conventions.IConventionAcceptance`1.Accept(FluentNHibernate.Conventions.AcceptanceCriteria.IAcceptanceCriteria{`0})">
      <summary>
            Whether this convention will be applied to the target.
            </summary>
      <param name="criteria">Instace that could be supplied</param>
      <returns>Apply on this target?</returns>
    </member>
    <member name="P:FluentNHibernate.Conventions.Inspections.IInspector.StringIdentifierForModel">
      <summary>
            Represents a string identifier for the model instance, used in conventions for a lazy
            shortcut.
            
            e.g. for a ColumnMapping the StringIdentifierForModel would be the Name attribute,
            this allows the user to find any columns with the matching name.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Conventions.Inspections.CollectionInspector.IsSet(System.Reflection.PropertyInfo)">
      <summary>
            Represents a string identifier for the model instance, used in conventions for a lazy
            shortcut.
            
            e.g. for a ColumnMapping the StringIdentifierForModel would be the Name attribute,
            this allows the user to find any columns with the matching name.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Conventions.Inspections.ColumnBasedInspector.GetValueFromColumns``1(System.Func{FluentNHibernate.MappingModel.ColumnMapping,System.Object})">
      <summary>
            Gets the requested value off the first column, as all columns are (currently) created equal
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Increment">
      <summary>
            generates identifiers of any integral type that are unique only when no other 
            process is inserting data into the same table. Do not use in a cluster.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Increment(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            generates identifiers of any integral type that are unique only when no other 
            process is inserting data into the same table. Do not use in a cluster.
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Identity">
      <summary>
            supports identity columns in DB2, MySQL, MS SQL Server and Sybase.
            The identifier returned by the database is converted to the property type using 
            Convert.ChangeType. Any integral property type is thus supported.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Identity(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            supports identity columns in DB2, MySQL, MS SQL Server and Sybase.
            The identifier returned by the database is converted to the property type using 
            Convert.ChangeType. Any integral property type is thus supported.
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Sequence(System.String)">
      <summary>
            uses a sequence in DB2, PostgreSQL, Oracle or a generator in Firebird.
            The identifier returned by the database is converted to the property type 
            using Convert.ChangeType. Any integral property type is thus supported.
            </summary>
      <param name="sequenceName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Sequence(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a sequence in DB2, PostgreSQL, Oracle or a generator in Firebird.
            The identifier returned by the database is converted to the property type 
            using Convert.ChangeType. Any integral property type is thus supported.
            </summary>
      <param name="sequenceName">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.HiLo(System.String,System.String,System.String)">
      <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
      <param name="table">
      </param>
      <param name="column">
      </param>
      <param name="maxLo">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.HiLo(System.String,System.String,System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
      <param name="table">
      </param>
      <param name="column">
      </param>
      <param name="maxLo">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.HiLo(System.String)">
      <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
      <param name="maxLo">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.HiLo(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
      <param name="maxLo">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.SeqHiLo(System.String,System.String)">
      <summary>
            uses an Oracle-style sequence (where supported)
            </summary>
      <param name="sequence">
      </param>
      <param name="maxLo">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.SeqHiLo(System.String,System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses an Oracle-style sequence (where supported)
            </summary>
      <param name="sequence">
      </param>
      <param name="maxLo">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.UuidHex(System.String)">
      <summary>
            uses System.Guid and its ToString(string format) method to generate identifiers
            of type string. The length of the string returned depends on the configured format. 
            </summary>
      <param name="format">http://msdn.microsoft.com/en-us/library/97af8hh4.aspx</param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.UuidHex(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses System.Guid and its ToString(string format) method to generate identifiers
            of type string. The length of the string returned depends on the configured format. 
            </summary>
      <param name="format">http://msdn.microsoft.com/en-us/library/97af8hh4.aspx</param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.UuidString">
      <summary>
            uses a new System.Guid to create a byte[] that is converted to a string.  
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.UuidString(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a new System.Guid to create a byte[] that is converted to a string.  
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Guid">
      <summary>
            uses a new System.Guid as the identifier. 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Guid(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a new System.Guid as the identifier. 
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.GuidComb">
      <summary>
            Recommended for Guid identifiers!
            uses the algorithm to generate a new System.Guid described by Jimmy Nilsson 
            in the article http://www.informit.com/articles/article.asp?p=25862. 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.GuidComb(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            Recommended for Guid identifiers!
            uses the algorithm to generate a new System.Guid described by Jimmy Nilsson 
            in the article http://www.informit.com/articles/article.asp?p=25862. 
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Assigned">
      <summary>
            lets the application to assign an identifier to the object before Save() is called. 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Assigned(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            lets the application to assign an identifier to the object before Save() is called. 
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Native">
      <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Native(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Native(System.String)">
      <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Native(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Foreign(System.String)">
      <summary>
            uses the identifier of another associated object. Usually used in conjunction with a one-to-one primary key association. 
            </summary>
      <param name="property">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.GeneratorInstance.Foreign(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses the identifier of another associated object. Usually used in conjunction with a one-to-one primary key association. 
            </summary>
      <param name="property">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.IndexInstance.Column(System.String)">
      <summary>
            Adds a column to the index if columns have not yet been specified
            </summary>
      <param name="columnName">The column name to add</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.Instances.IndexManyToManyInstance.Column(System.String)">
      <summary>
            Adds a column to the index if columns have not yet been specified
            </summary>
      <param name="columnName">The column name to add</param>
    </member>
    <member name="T:FluentNHibernate.Conventions.IClassConvention">
      <summary>
            Convention for a single class mapping. Implement this interface to apply
            changes to class mappings.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IIdConvention">
      <summary>
            Convention for identities, implement this interface to apply changes to
            identity mappings.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IPropertyConvention">
      <summary>
            Property convention, implement this interface to apply changes to
            property mappings.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Conventions.EnumerableExtensionsForConventions.Contains``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            Checks whether a collection contains an inspector identified by the string value.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="collection">
      </param>
      <param name="expected">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.EnumerableExtensionsForConventions.Contains``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Checks whether a collection contains an inspector identified by a predicate.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="collection">
      </param>
      <param name="prediate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:FluentNHibernate.Conventions.ManyToManyTableNameConvention">
      <summary>
            Base convention for specifying your own many-to-many table naming style. Implement
            the abstract members defined by this class to control how your join tables are named
            for uni and bi-directional many-to-many's.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Conventions.ManyToManyTableNameConvention.GetBiDirectionalTableName(FluentNHibernate.Conventions.Inspections.IManyToManyCollectionInspector,FluentNHibernate.Conventions.Inspections.IManyToManyCollectionInspector)">
      <summary>
            Gets the name used for bi-directional many-to-many tables. Implement this member to control how
            your join table is named for bi-directional relationships.
            </summary>
      <remarks>
            This method will be called once per bi-directional relationship; once one side of the relationship
            has been saved, then the other side will assume that name aswell.
            </remarks>
      <param name="collection">Main collection</param>
      <param name="otherSide">Inverse collection</param>
      <returns>Many-to-many table name</returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.ManyToManyTableNameConvention.GetUniDirectionalTableName(FluentNHibernate.Conventions.Inspections.IManyToManyCollectionInspector)">
      <summary>
            Gets the name used for uni-directional many-to-many tables. Implement this member to control how
            your join table is named for uni-directional relationships.
            </summary>
      <param name="collection">Main collection</param>
      <returns>Many-to-many table name</returns>
    </member>
    <member name="M:FluentNHibernate.SeparateSubclassVisitor.SortByDistanceFrom(System.Type,System.Collections.Generic.IEnumerable{FluentNHibernate.Mapping.Providers.IIndeterminateSubclassMappingProvider})">
      <summary>
            Takes a type that represents the level in the class/subclass-hiearchy that we're starting from, the parent,
            this can be a class or subclass; also takes a list of subclass providers. The providers are then iterated
            and added to a dictionary key'd by the types "distance" from the parentType; distance being the number of levels
            between parentType and the subclass-type.
            </summary>
      <param name="parentType">Starting point, parent type.</param>
      <param name="providers">List of subclasses</param>
      <returns>Dictionary key'd by the distance from the parentType.</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.Identity">
      <summary>
            supports identity columns in DB2, MySQL, MS SQL Server and Sybase.
            The identifier returned by the database is converted to the property type using 
            Convert.ChangeType. Any integral property type is thus supported.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.Identity(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            supports identity columns in DB2, MySQL, MS SQL Server and Sybase.
            The identifier returned by the database is converted to the property type using 
            Convert.ChangeType. Any integral property type is thus supported.
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.Sequence(System.String)">
      <summary>
            uses a sequence in DB2, PostgreSQL, Oracle or a generator in Firebird.
            The identifier returned by the database is converted to the property type 
            using Convert.ChangeType. Any integral property type is thus supported.
            </summary>
      <param name="sequenceName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.Sequence(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a sequence in DB2, PostgreSQL, Oracle or a generator in Firebird.
            The identifier returned by the database is converted to the property type 
            using Convert.ChangeType. Any integral property type is thus supported.
            </summary>
      <param name="sequenceName">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.HiLo(System.String,System.String,System.String)">
      <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
      <param name="table">
      </param>
      <param name="column">
      </param>
      <param name="maxLo">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.HiLo(System.String,System.String,System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
      <param name="table">
      </param>
      <param name="column">
      </param>
      <param name="maxLo">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.HiLo(System.String)">
      <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
      <param name="maxLo">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.HiLo(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
      <param name="maxLo">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.SeqHiLo(System.String,System.String)">
      <summary>
            uses an Oracle-style sequence (where supported)
            </summary>
      <param name="sequence">
      </param>
      <param name="maxLo">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.SeqHiLo(System.String,System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses an Oracle-style sequence (where supported)
            </summary>
      <param name="sequence">
      </param>
      <param name="maxLo">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.UuidHex(System.String)">
      <summary>
            uses System.Guid and its ToString(string format) method to generate identifiers
            of type string. The length of the string returned depends on the configured format. 
            </summary>
      <param name="format">http://msdn.microsoft.com/en-us/library/97af8hh4.aspx</param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.UuidHex(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses System.Guid and its ToString(string format) method to generate identifiers
            of type string. The length of the string returned depends on the configured format. 
            </summary>
      <param name="format">http://msdn.microsoft.com/en-us/library/97af8hh4.aspx</param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.UuidString">
      <summary>
            uses a new System.Guid to create a byte[] that is converted to a string.  
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.UuidString(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a new System.Guid to create a byte[] that is converted to a string.  
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.GeneratorBuilder.Guid">
      <summary>
            uses a new System.Guid as the identifier. 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.SubclassMap`1.Join(System.String,System.Action{FluentNHibernate.Mapping.JoinPart{`0}})">
      <summary>
            Sets additional tables for the class via the NH 2.0 Join element, this only works if
            the hierarchy you're mapping has a discriminator.
            </summary>
      <param name="tableName">Joined table name</param>
      <param name="action">Joined table mapping</param>
    </member>
    <member name="T:FluentNHibernate.Cfg.AutoMappingsContainer">
      <summary>
            Container for automatic mappings
            </summary>
    </member>
    <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.Add(System.Func{FluentNHibernate.Automapping.AutoPersistenceModel})">
      <summary>
            Add automatic mappings
            </summary>
      <param name="model">Lambda returning an auto mapping setup</param>
      <returns>Auto mappings configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.Add(FluentNHibernate.Automapping.AutoPersistenceModel)">
      <summary>
            Add automatic mappings
            </summary>
      <param name="model">Auto mapping setup</param>
      <returns>Auto mappings configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.ExportTo(System.String)">
      <summary>
            Sets the export location for generated mappings
            </summary>
      <param name="path">Path to folder for mappings</param>
      <returns>Auto mappings configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.AutoMappingsContainer.Apply(NHibernate.Cfg.Configuration)">
      <summary>
            Applies any added mappings to the NHibernate Configuration
            </summary>
      <param name="cfg">NHibernate Configuration instance</param>
    </member>
    <member name="P:FluentNHibernate.Cfg.AutoMappingsContainer.WasUsed">
      <summary>
            Gets whether any mappings were added
            </summary>
    </member>
    <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.ProxyFactoryFactory(System.String)">
      <summary>
            Sets the proxyfactory.factory_class property.
            NOTE: NHibernate 2.1 only
            </summary>
      <param name="proxyFactoryFactoryClass">factory class</param>
      <returns>Configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.AdoNetBatchSize(System.Int32)">
      <summary>
            Sets the adonet.batch_size property.
            </summary>
      <param name="size">Batch size</param>
      <returns>Configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.CurrentSessionContext(System.String)">
      <summary>
            Sets the current_session_context_class property.
            </summary>
      <param name="currentSessionContextClass">current session context class</param>
      <returns>Configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.Db.PersistenceConfiguration`2.CurrentSessionContext``1">
      <summary>
            Sets the current_session_context_class property.
            </summary>
      <typeparam name="TSessionContext">Implementation of ICurrentSessionContext to use</typeparam>
      <returns>Configuration</returns>
    </member>
    <member name="P:FluentNHibernate.Cfg.Db.OracleClientConfiguration.Oracle9">
      <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleClientConfiguration" /> class using the
            MS Oracle Client (System.Data.OracleClient) library specifying the Oracle 9i dialect.
            </summary>
    </member>
    <member name="P:FluentNHibernate.Cfg.Db.OracleClientConfiguration.Oracle10">
      <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleClientConfiguration" /> class using the
            MS Oracle Client (System.Data.OracleClient) library specifying the Oracle 10g dialect.
            This allows for ANSI join syntax.
            </summary>
    </member>
    <member name="P:FluentNHibernate.Cfg.Db.OracleConfiguration.Oracle9">
      <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleConfiguration" /> class using the
            Oracle Data Provider (Oracle.DataAccess) library specifying the Oracle 9i dialect.
            The Oracle.DataAccess library must be available to the calling application/library.
            </summary>
    </member>
    <member name="P:FluentNHibernate.Cfg.Db.OracleConfiguration.Oracle10">
      <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleConfiguration" /> class using the
            Oracle Data Provider (Oracle.DataAccess) library specifying the Oracle 10g dialect.
            The Oracle.DataAccess library must be available to the calling application/library.
            This allows for ANSI join syntax.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Server(System.String)">
      <summary>
            Specifies the server to connect. This can be either the DNS name of the
            server or the IP (as a string).
            </summary>
      <param name="server">The server.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Instance(System.String)">
      <summary>
            Specifies the instance (database name) to use.  This can be the short name or the
            fully qualified name (Oracle service name).
            </summary>
      <param name="instance">The instance.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Username(System.String)">
      <summary>
            Specifies the name of the user account accessing the database.
            </summary>
      <param name="username">The username.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Password(System.String)">
      <summary>
            Specifies the password of the user account accessing the database.
            </summary>
      <param name="password">The password.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Port(System.Int32)">
      <summary>
            Optional. Ports the specified port the oracle database is running on.  This defaults to 1521.
            </summary>
      <param name="port">The port.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.Pooling(System.Boolean)">
      <summary>
            Enable or disable pooling connections for this data configuration.
            </summary>
      <param name="pooling">if set to <c>true</c> enable pooling.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.StatementCacheSize(System.Int32)">
      <summary>
            Specifies the SQL statement cache size to use for this connection.
            </summary>
      <param name="cacheSize">Size of the cache.</param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.Db.OracleConnectionStringBuilder.OtherOptions(System.String)">
      <summary>
            Specifies, as a string, other Oracle options to pass to the connection.
            </summary>
      <param name="otherOptions">The other options.</param>
      <returns>
      </returns>
    </member>
    <member name="P:FluentNHibernate.Cfg.Db.OracleDataClientConfiguration.Oracle9">
      <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleDataClientConfiguration" /> class using the
            Oracle Data Provider (Oracle.DataAccess) library specifying the Oracle 9i dialect. 
            The Oracle.DataAccess library must be available to the calling application/library. 
            </summary>
    </member>
    <member name="P:FluentNHibernate.Cfg.Db.OracleDataClientConfiguration.Oracle10">
      <summary>
            Initializes a new instance of the <see cref="T:FluentNHibernate.Cfg.Db.OracleDataClientConfiguration" /> class using the
            Oracle Data Provider (Oracle.DataAccess) library specifying the Oracle 10g dialect. 
            The Oracle.DataAccess library must be available to the calling application/library. 
            </summary>
    </member>
    <member name="T:FluentNHibernate.Cfg.FluentConfiguration">
      <summary>
            Fluent configuration API for NHibernate
            </summary>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentConfiguration.Database(System.Func{FluentNHibernate.Cfg.Db.IPersistenceConfigurer})">
      <summary>
            Apply database settings
            </summary>
      <param name="config">Lambda returning database configuration</param>
      <returns>Fluent configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentConfiguration.Database(FluentNHibernate.Cfg.Db.IPersistenceConfigurer)">
      <summary>
            Apply database settings
            </summary>
      <param name="config">Database configuration instance</param>
      <returns>Fluent configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentConfiguration.Mappings(System.Action{FluentNHibernate.Cfg.MappingConfiguration})">
      <summary>
            Apply mappings to NHibernate
            </summary>
      <param name="mappings">Lambda used to apply mappings</param>
      <returns>Fluent configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentConfiguration.ExposeConfiguration(System.Action{NHibernate.Cfg.Configuration})">
      <summary>
            Allows altering of the raw NHibernate Configuration object before creation
            </summary>
      <param name="config">Lambda used to alter Configuration</param>
      <returns>Fluent configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentConfiguration.BuildSessionFactory">
      <summary>
            Verify's the configuration and instructs NHibernate to build a SessionFactory.
            </summary>
      <returns>ISessionFactory from supplied settings.</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentConfiguration.BuildConfiguration">
      <summary>
            Verifies the configuration and populates the NHibernate Configuration instance.
            </summary>
      <returns>NHibernate Configuration instance</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentConfiguration.CreateConfigurationException(System.Exception)">
      <summary>
            Creates an exception based on the current state of the configuration.
            </summary>
      <param name="innerException">Inner exception</param>
      <returns>FluentConfigurationException with state</returns>
    </member>
    <member name="T:FluentNHibernate.Cfg.Fluently">
      <summary>
            Fluently configure NHibernate
            </summary>
    </member>
    <member name="M:FluentNHibernate.Cfg.Fluently.Configure">
      <summary>
            Begin fluently configuring NHibernate
            </summary>
      <returns>Fluent Configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.Fluently.Configure(NHibernate.Cfg.Configuration)">
      <summary>
            Begin fluently configuring NHibernate
            </summary>
      <param name="cfg">Instance of an NHibernate Configuration</param>
      <returns>Fluent Configuration</returns>
    </member>
    <member name="T:FluentNHibernate.Cfg.FluentMappingsContainer">
      <summary>
            Container for fluent mappings
            </summary>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.AddFromAssemblyOf``1">
      <summary>
            Add all fluent mappings in the assembly that contains T.
            </summary>
      <typeparam name="T">Type from the assembly</typeparam>
      <returns>Fluent mappings configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.AddFromAssembly(System.Reflection.Assembly)">
      <summary>
            Add all fluent mappings in the assembly
            </summary>
      <param name="assembly">Assembly to add mappings from</param>
      <returns>Fluent mappings configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.Add``1">
      <summary>
            Adds a single <see cref="!:IClassMap" /> represented by the specified type.
            </summary>
      <returns>Fluent mappings configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.Add(System.Type)">
      <summary>
            Adds a single <see cref="!:IClassMap" /> represented by the specified type.
            </summary>
      <param name="type">The type.</param>
      <returns>Fluent mappings configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.ExportTo(System.String)">
      <summary>
            Sets the export location for generated mappings
            </summary>
      <param name="path">Path to folder for mappings</param>
      <returns>Fluent mappings configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.FluentMappingsContainer.Apply(NHibernate.Cfg.Configuration)">
      <summary>
            Applies any added mappings to the NHibernate Configuration
            </summary>
      <param name="cfg">NHibernate Configuration instance</param>
    </member>
    <member name="P:FluentNHibernate.Cfg.FluentMappingsContainer.Conventions">
      <summary>
            Alter convention discovery
            </summary>
    </member>
    <member name="P:FluentNHibernate.Cfg.FluentMappingsContainer.WasUsed">
      <summary>
            Gets whether any mappings were added
            </summary>
    </member>
    <member name="T:FluentNHibernate.Cfg.HbmMappingsContainer">
      <summary>
            Container for Hbm mappings
            </summary>
    </member>
    <member name="M:FluentNHibernate.Cfg.HbmMappingsContainer.AddClasses(System.Type[])">
      <summary>
            Add explicit classes with Hbm mappings
            </summary>
      <param name="types">List of types to map</param>
      <returns>Hbm mappings configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.HbmMappingsContainer.AddFromAssemblyOf``1">
      <summary>
            Add all Hbm mappings in the assembly that contains T.
            </summary>
      <typeparam name="T">Type from the assembly</typeparam>
      <returns>Hbm mappings configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.HbmMappingsContainer.AddFromAssembly(System.Reflection.Assembly)">
      <summary>
            Add all Hbm mappings in the assembly
            </summary>
      <param name="assembly">Assembly to add mappings from</param>
      <returns>Hbm mappings configuration</returns>
    </member>
    <member name="M:FluentNHibernate.Cfg.HbmMappingsContainer.Apply(NHibernate.Cfg.Configuration)">
      <summary>
            Applies any added mappings to the NHibernate Configuration
            </summary>
      <param name="cfg">NHibernate Configuration instance</param>
    </member>
    <member name="P:FluentNHibernate.Cfg.HbmMappingsContainer.WasUsed">
      <summary>
            Gets whether any mappings were added
            </summary>
    </member>
    <member name="T:FluentNHibernate.Cfg.MappingConfiguration">
      <summary>
            Fluent mapping configuration
            </summary>
    </member>
    <member name="M:FluentNHibernate.Cfg.MappingConfiguration.Apply(NHibernate.Cfg.Configuration)">
      <summary>
            Applies any mappings to the NHibernate Configuration
            </summary>
      <param name="cfg">NHibernate Configuration instance</param>
    </member>
    <member name="P:FluentNHibernate.Cfg.MappingConfiguration.FluentMappings">
      <summary>
            Fluent mappings
            </summary>
    </member>
    <member name="P:FluentNHibernate.Cfg.MappingConfiguration.AutoMappings">
      <summary>
            Automatic mapping configurations
            </summary>
    </member>
    <member name="P:FluentNHibernate.Cfg.MappingConfiguration.HbmMappings">
      <summary>
            Hbm mappings
            </summary>
    </member>
    <member name="P:FluentNHibernate.Cfg.MappingConfiguration.WasUsed">
      <summary>
            Get whether any mappings of any kind were added
            </summary>
    </member>
    <member name="T:FluentNHibernate.Conventions.IConventionFinder">
      <summary>
            Convention finder - used to search through assemblies for types that implement a specific convention interface.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Conventions.IConventionFinder.AddAssembly(System.Reflection.Assembly)">
      <summary>
            Add an assembly to be queried.
            </summary>
      <remarks>
            All convention types must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder" />.
            </remarks>
      <param name="assembly">Assembly instance to query</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.IConventionFinder.AddFromAssemblyOf``1">
      <summary>
            Adds all conventions found in the assembly that contains <typeparam name="T" />.
            </summary>
      <remarks>
            All convention types must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder" />.
            </remarks>
    </member>
    <member name="M:FluentNHibernate.Conventions.IConventionFinder.Add``1">
      <summary>
            Add a single convention by type.
            </summary>
      <remarks>
            Type must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder" />.
            </remarks>
      <typeparam name="T">Convention type</typeparam>
    </member>
    <member name="M:FluentNHibernate.Conventions.IConventionFinder.Add(System.Type)">
      <summary>
            Add a single convention by type.
            </summary>
      <remarks>
            Types must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder" />.
            </remarks>
      <param name="type">Type of convention</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.IConventionFinder.Add``1(``0)">
      <summary>
            Add an instance of a convention.
            </summary>
      <remarks>
            Useful for supplying conventions that require extra constructor parameters.
            </remarks>
      <typeparam name="T">Convention type</typeparam>
      <param name="instance">Instance of convention</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.IConventionFinder.Find``1">
      <summary>
            Find any conventions implementing T.
            </summary>
      <typeparam name="T">Convention interface type</typeparam>
      <returns>IEnumerable of T</returns>
    </member>
    <member name="T:FluentNHibernate.Conventions.DefaultConventionFinder">
      <summary>
            Default convention finder - doesn't do anything special.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.Find``1">
      <summary>
            Find any conventions implementing T.
            </summary>
      <typeparam name="T">Convention interface type</typeparam>
      <returns>IEnumerable of T</returns>
    </member>
    <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.AddAssembly(System.Reflection.Assembly)">
      <summary>
            Add an assembly to be queried.
            </summary>
      <remarks>
            All convention types must have a parameterless constructor, or a single parameter of IConventionFinder.
            </remarks>
      <param name="assembly">Assembly instance to query</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.AddFromAssemblyOf``1">
      <summary>
            Adds all conventions found in the assembly that contains T.
            </summary>
      <remarks>
            All convention types must have a parameterless constructor, or a single parameter of IConventionFinder.
            </remarks>
    </member>
    <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.Add``1">
      <summary>
            Add a single convention by type.
            </summary>
      <remarks>
            Type must have a parameterless constructor, or a single parameter of IConventionFinder.
            </remarks>
      <typeparam name="T">Convention type</typeparam>
    </member>
    <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.Add(System.Type)">
      <summary>
            Add a single convention by type.
            </summary>
      <remarks>
            Types must have a parameterless constructor, or a single parameter of <see cref="T:FluentNHibernate.Conventions.IConventionFinder" />.
            </remarks>
      <param name="type">Type of convention</param>
    </member>
    <member name="M:FluentNHibernate.Conventions.DefaultConventionFinder.Add``1(``0)">
      <summary>
            Add an instance of a convention.
            </summary>
      <remarks>
            Useful for supplying conventions that require extra constructor parameters.
            </remarks>
      <typeparam name="T">Convention type</typeparam>
      <param name="instance">Instance of convention</param>
    </member>
    <member name="M:FluentNHibernate.Data.Entity.Equals(FluentNHibernate.Data.Entity)">
      <summary>
            Indicates whether the current <see cref="T:FluentNHibernate.Data.Entity" /> is equal to another <see cref="T:FluentNHibernate.Data.Entity" />.
            </summary>
      <returns>
            true if the current object is equal to the <paramref name="obj" /> parameter; otherwise, false.
            </returns>
      <param name="obj">An Entity to compare with this object.</param>
    </member>
    <member name="M:FluentNHibernate.Data.Entity.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:FluentNHibernate.Data.Entity" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            true if the specified <see cref="T:FluentNHibernate.Data.Entity" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />. </param>
      <exception cref="T:System.NullReferenceException">The <paramref name="obj" /> parameter is null.</exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:FluentNHibernate.Data.Entity.GetHashCode">
      <summary>
            Serves as a hash function for a Entity. 
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:FluentNHibernate.Mapping.AnyPart`1">
      <summary>
            Represents the "Any" mapping in NHibernate. It is impossible to specify a foreign key constraint for this kind of association. For more information
            please reference chapter 5.2.4 in the NHibernate online documentation
            </summary>
    </member>
    <member name="P:FluentNHibernate.Mapping.AnyPart`1.Access">
      <summary>
            Defines how NHibernate will access the object for persisting/hydrating (Defaults to Property)
            </summary>
    </member>
    <member name="P:FluentNHibernate.Mapping.AnyPart`1.Cascade">
      <summary>
            Cascade style (Defaults to none)
            </summary>
    </member>
    <member name="T:FluentNHibernate.Mapping.AccessStrategyBuilder">
      <summary>
            Access strategy mapping builder.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.#ctor(System.Action{System.String})">
      <summary>
            Access strategy mapping builder.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.Property">
      <summary>
            Sets the access-strategy to property.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.Field">
      <summary>
            Sets the access-strategy to field.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.BackingField">
      <summary>
            Sets the access-strategy to use the backing-field of an auto-property.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.CamelCaseField">
      <summary>
            Sets the access-strategy to field and the naming-strategy to camelcase (field.camelcase).
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.CamelCaseField(FluentNHibernate.Mapping.Prefix)">
      <summary>
            Sets the access-strategy to field and the naming-strategy to camelcase, with the specified prefix.
            </summary>
      <param name="prefix">Naming-strategy prefix</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.LowerCaseField">
      <summary>
            Sets the access-strategy to field and the naming-strategy to lowercase.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.LowerCaseField(FluentNHibernate.Mapping.Prefix)">
      <summary>
            Sets the access-strategy to field and the naming-strategy to lowercase, with the specified prefix.
            </summary>
      <param name="prefix">Naming-strategy prefix</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.PascalCaseField(FluentNHibernate.Mapping.Prefix)">
      <summary>
            Sets the access-strategy to field and the naming-strategy to pascalcase, with the specified prefix.
            </summary>
      <param name="prefix">Naming-strategy prefix</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.ReadOnlyPropertyThroughCamelCaseField">
      <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to camelcase.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.ReadOnlyPropertyThroughCamelCaseField(FluentNHibernate.Mapping.Prefix)">
      <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to camelcase, with the specified prefix.
            </summary>
      <param name="prefix">Naming-strategy prefix</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.ReadOnlyPropertyThroughLowerCaseField">
      <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to lowercase.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.ReadOnlyPropertyThroughLowerCaseField(FluentNHibernate.Mapping.Prefix)">
      <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to lowercase.
            </summary>
      <param name="prefix">Naming-strategy prefix</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.ReadOnlyPropertyThroughPascalCaseField(FluentNHibernate.Mapping.Prefix)">
      <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to pascalcase, with the specified prefix.
            </summary>
      <param name="prefix">Naming-strategy prefix</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.Using(System.String)">
      <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
      <param name="propertyAccessorAssemblyQualifiedClassName">Assembly qualified name of the type to use as the access-strategy</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.Using(System.Type)">
      <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
      <param name="propertyAccessorClassType">Type to use as the access-strategy</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder.Using``1">
      <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
      <typeparam name="TPropertyAccessorClass">Type to use as the access-strategy</typeparam>
    </member>
    <member name="P:FluentNHibernate.Mapping.ComponentPartBase`1.Access">
      <summary>
            Set the access and naming strategy for this component.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.AlwaysSelectWithValue">
      <summary>
            Force NHibernate to always select using the discriminator value, even when selecting all subclasses. This
            can be useful when your table contains more discriminator values than you have classes (legacy).
            </summary>
      <remarks>Sets the "force" attribute.</remarks>
    </member>
    <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.ReadOnly">
      <summary>
            Set this discriminator as read-only. Call this if your discriminator column is also part of a mapped composite identifier.
            </summary>
      <returns>Sets the "insert" attribute.</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.DiscriminatorPart.Formula(System.String)">
      <summary>
            An arbitrary SQL expression that is executed when a type has to be evaluated. Allows content-based discrimination.
            </summary>
      <param name="sql">SQL expression</param>
    </member>
    <member name="T:FluentNHibernate.Conventions.UserTypeConvention`1">
      <summary>
            Base class for user type conventions. Create a subclass of this to automatically
            map all properties that the user type can be used against. Override Accept or
            Apply to alter the behavior.
            </summary>
      <typeparam name="TUserType">IUserType implementation</typeparam>
    </member>
    <member name="T:FluentNHibernate.Conventions.AttributePropertyConvention`1">
      <summary>
            Base class for attribute based conventions. Create a subclass of this to supply your own
            attribute based conventions.
            </summary>
      <typeparam name="T">Attribute identifier</typeparam>
    </member>
    <member name="M:FluentNHibernate.Conventions.AttributePropertyConvention`1.Apply(`0,FluentNHibernate.Conventions.Instances.IPropertyInstance)">
      <summary>
            Apply changes to a property with an attribute matching T.
            </summary>
      <param name="attribute">Instance of attribute found on property.</param>
      <param name="instance">Property with attribute</param>
    </member>
    <member name="P:FluentNHibernate.Mapping.DynamicComponentPart`1.Access">
      <summary>
            Set the access and naming strategy for this component.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Mapping.InvalidPrefixException">
      <summary>
            Thrown when a prefix is specified for an access-strategy that isn't supported.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Mapping.Prefix">
      <summary>
            Naming strategy prefix.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Testing.PersistenceSpecification`1.CheckComponentList``1(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.Collections.Generic.IList{``0})">
      <summary>
            Checks a list of components for validity.
            </summary>
      <typeparam name="TList">Type of list element</typeparam>
      <param name="expression">Property</param>
      <param name="propertyValue">Value to save</param>
    </member>
    <member name="T:FluentNHibernate.Utils.ExpressionToSql">
      <summary>
            Converts an expression to a best guess SQL string
            </summary>
    </member>
    <member name="M:FluentNHibernate.Utils.ExpressionToSql.Convert``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
      <summary>
            Converts a Func expression to a best guess SQL string
            </summary>
    </member>
    <member name="M:FluentNHibernate.Utils.ExpressionToSql.Convert``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>
            Converts a boolean Func expression to a best guess SQL string
            </summary>
    </member>
    <member name="M:FluentNHibernate.Utils.ExpressionToSql.Convert(System.Linq.Expressions.MethodCallExpression)">
      <summary>
            Gets the value of a method call.
            </summary>
      <param name="body">Method call expression</param>
    </member>
    <member name="T:FluentNHibernate.Mapping.JoinPart`1">
      <summary>
            Maps to the Join element in NH 2.0
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:FluentNHibernate.Mapping.NotFoundExpression`1.Ignore">
      <summary>
            Used to set the Not-Found attribute to ignore.  This tells NHibernate to 
            return a null object rather then throw an exception when the join fails
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.NotFoundExpression`1.Exception">
      <summary>
            Used to set the Not-Found attribute to exception (Nhibernate default).  This 
            tells NHibernate to throw an exception when the join fails
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder`1.None">
      <summary>
            Use no locking strategy
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder`1.Version">
      <summary>
            Use version locking
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder`1.Dirty">
      <summary>
            Use dirty locking
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.OptimisticLockBuilder`1.All">
      <summary>
            Use all locking
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ToManyBase`3.Component(System.Action{FluentNHibernate.Mapping.CompositeElementPart{`1}})">
      <summary>
            Maps this collection as a collection of components.
            </summary>
      <param name="action">Component mapping</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.ToManyBase`3.Table(System.String)">
      <summary>
            Sets the table name for this one-to-many.
            </summary>
      <param name="name">Table name</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.ToManyBase`3.Where(System.Linq.Expressions.Expression{System.Func{`1,System.Boolean}})">
      <summary>
            Sets the where clause for this one-to-many relationship.
            Note: This only supports simple cases, use the string overload for more complex clauses.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ToManyBase`3.Where(System.String)">
      <summary>
            Sets the where clause for this one-to-many relationship.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ToManyBase`3.CollectionType``1">
      <summary>
            Sets a custom collection type
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ToManyBase`3.CollectionType(System.Type)">
      <summary>
            Sets a custom collection type
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ToManyBase`3.CollectionType(System.String)">
      <summary>
            Sets a custom collection type
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ToManyBase`3.CollectionType(FluentNHibernate.MappingModel.TypeReference)">
      <summary>
            Sets a custom collection type
            </summary>
    </member>
    <member name="P:FluentNHibernate.Mapping.ToManyBase`3.Cache">
      <summary>
            Specify caching for this entity.
            </summary>
    </member>
    <member name="P:FluentNHibernate.Mapping.ToManyBase`3.Access">
      <summary>
            Set the access and naming strategy for this one-to-many.
            </summary>
    </member>
    <member name="P:FluentNHibernate.Mapping.ToManyBase`3.Not">
      <summary>
            Inverts the next boolean
            </summary>
    </member>
    <member name="T:FluentNHibernate.Mapping.AccessStrategyBuilder`1">
      <summary>
            Access strategy mapping builder.
            </summary>
      <typeparam name="T">Mapping part to be applied to</typeparam>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.#ctor(`0,System.Action{System.String})">
      <summary>
            Access strategy mapping builder.
            </summary>
      <param name="parent">Instance of the parent mapping part.</param>
      <param name="setter">Setter for altering the model</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Property">
      <summary>
            Sets the access-strategy to property.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Field">
      <summary>
            Sets the access-strategy to field.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.BackingField">
      <summary>
            Sets the access-strategy to use the backing-field of an auto-property.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.CamelCaseField">
      <summary>
            Sets the access-strategy to field and the naming-strategy to camelcase (field.camelcase).
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.CamelCaseField(FluentNHibernate.Mapping.Prefix)">
      <summary>
            Sets the access-strategy to field and the naming-strategy to camelcase, with the specified prefix.
            </summary>
      <param name="prefix">Naming-strategy prefix</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.LowerCaseField">
      <summary>
            Sets the access-strategy to field and the naming-strategy to lowercase.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.LowerCaseField(FluentNHibernate.Mapping.Prefix)">
      <summary>
            Sets the access-strategy to field and the naming-strategy to lowercase, with the specified prefix.
            </summary>
      <param name="prefix">Naming-strategy prefix</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.PascalCaseField(FluentNHibernate.Mapping.Prefix)">
      <summary>
            Sets the access-strategy to field and the naming-strategy to pascalcase, with the specified prefix.
            </summary>
      <param name="prefix">Naming-strategy prefix</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.ReadOnlyPropertyThroughCamelCaseField">
      <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to camelcase.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.ReadOnlyPropertyThroughCamelCaseField(FluentNHibernate.Mapping.Prefix)">
      <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to camelcase, with the specified prefix.
            </summary>
      <param name="prefix">Naming-strategy prefix</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.ReadOnlyPropertyThroughLowerCaseField">
      <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to lowercase.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.ReadOnlyPropertyThroughLowerCaseField(FluentNHibernate.Mapping.Prefix)">
      <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to lowercase.
            </summary>
      <param name="prefix">Naming-strategy prefix</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.ReadOnlyPropertyThroughPascalCaseField(FluentNHibernate.Mapping.Prefix)">
      <summary>
            Sets the access-strategy to read-only property (nosetter) and the naming-strategy to pascalcase, with the specified prefix.
            </summary>
      <param name="prefix">Naming-strategy prefix</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Using(System.String)">
      <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
      <param name="propertyAccessorAssemblyQualifiedClassName">Assembly qualified name of the type to use as the access-strategy</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Using(System.Type)">
      <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
      <param name="propertyAccessorClassType">Type to use as the access-strategy</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.AccessStrategyBuilder`1.Using``1">
      <summary>
            Sets the access-strategy to use the type referenced.
            </summary>
      <typeparam name="TPropertyAccessorClass">Type to use as the access-strategy</typeparam>
    </member>
    <member name="P:FluentNHibernate.Mapping.ComponentPart`1.Access">
      <summary>
            Set the access and naming strategy for this component.
            </summary>
    </member>
    <member name="T:FluentNHibernate.Mapping.CompositeElementPart`1">
      <summary>
            Component-element for component HasMany's.
            </summary>
      <typeparam name="T">Component type</typeparam>
    </member>
    <member name="M:FluentNHibernate.Mapping.CompositeElementPart`1.ParentReference(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
      <summary>
            Maps a property of the component class as a reference back to the containing entity
            </summary>
      <param name="exp">Parent reference property</param>
      <returns>Component being mapped</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Increment">
      <summary>
            generates identifiers of any integral type that are unique only when no other 
            process is inserting data into the same table. Do not use in a cluster.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Increment(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            generates identifiers of any integral type that are unique only when no other 
            process is inserting data into the same table. Do not use in a cluster.
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Identity">
      <summary>
            supports identity columns in DB2, MySQL, MS SQL Server and Sybase.
            The identifier returned by the database is converted to the property type using 
            Convert.ChangeType. Any integral property type is thus supported.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Identity(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            supports identity columns in DB2, MySQL, MS SQL Server and Sybase.
            The identifier returned by the database is converted to the property type using 
            Convert.ChangeType. Any integral property type is thus supported.
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Sequence(System.String)">
      <summary>
            uses a sequence in DB2, PostgreSQL, Oracle or a generator in Firebird.
            The identifier returned by the database is converted to the property type 
            using Convert.ChangeType. Any integral property type is thus supported.
            </summary>
      <param name="sequenceName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Sequence(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a sequence in DB2, PostgreSQL, Oracle or a generator in Firebird.
            The identifier returned by the database is converted to the property type 
            using Convert.ChangeType. Any integral property type is thus supported.
            </summary>
      <param name="sequenceName">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.HiLo(System.String,System.String,System.String)">
      <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
      <param name="table">
      </param>
      <param name="column">
      </param>
      <param name="maxLo">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.HiLo(System.String,System.String,System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
      <param name="table">
      </param>
      <param name="column">
      </param>
      <param name="maxLo">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.HiLo(System.String)">
      <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
      <param name="maxLo">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.HiLo(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a hi/lo algorithm to efficiently generate identifiers of any integral type, 
            given a table and column (by default hibernate_unique_key and next_hi respectively) 
            as a source of hi values. The hi/lo algorithm generates identifiers that are unique 
            only for a particular database. Do not use this generator with a user-supplied connection.
            requires a "special" database table to hold the next available "hi" value
            </summary>
      <param name="maxLo">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.SeqHiLo(System.String,System.String)">
      <summary>
            uses an Oracle-style sequence (where supported)
            </summary>
      <param name="sequence">
      </param>
      <param name="maxLo">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.SeqHiLo(System.String,System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses an Oracle-style sequence (where supported)
            </summary>
      <param name="sequence">
      </param>
      <param name="maxLo">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.UuidHex(System.String)">
      <summary>
            uses System.Guid and its ToString(string format) method to generate identifiers
            of type string. The length of the string returned depends on the configured format. 
            </summary>
      <param name="format">http://msdn.microsoft.com/en-us/library/97af8hh4.aspx</param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.UuidHex(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses System.Guid and its ToString(string format) method to generate identifiers
            of type string. The length of the string returned depends on the configured format. 
            </summary>
      <param name="format">http://msdn.microsoft.com/en-us/library/97af8hh4.aspx</param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.UuidString">
      <summary>
            uses a new System.Guid to create a byte[] that is converted to a string.  
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.UuidString(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a new System.Guid to create a byte[] that is converted to a string.  
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Guid">
      <summary>
            uses a new System.Guid as the identifier. 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Guid(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses a new System.Guid as the identifier. 
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.GuidComb">
      <summary>
            Recommended for Guid identifiers!
            uses the algorithm to generate a new System.Guid described by Jimmy Nilsson 
            in the article http://www.informit.com/articles/article.asp?p=25862. 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.GuidComb(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            Recommended for Guid identifiers!
            uses the algorithm to generate a new System.Guid described by Jimmy Nilsson 
            in the article http://www.informit.com/articles/article.asp?p=25862. 
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Assigned">
      <summary>
            lets the application to assign an identifier to the object before Save() is called. 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Assigned(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            lets the application to assign an identifier to the object before Save() is called. 
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Native">
      <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Native(System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Native(System.String)">
      <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Native(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            picks identity, sequence or hilo depending upon the capabilities of the underlying database. 
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Foreign(System.String)">
      <summary>
            uses the identifier of another associated object. Usually used in conjunction with a one-to-one primary key association. 
            </summary>
      <param name="property">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityGenerationStrategyBuilder`1.Foreign(System.String,System.Action{FluentNHibernate.Mapping.ParamBuilder})">
      <summary>
            uses the identifier of another associated object. Usually used in conjunction with a one-to-one primary key association. 
            </summary>
      <param name="property">
      </param>
      <param name="paramValues">Params configuration</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityPart.UnsavedValue(System.Object)">
      <summary>
            Sets the unsaved-value of the identity.
            </summary>
      <param name="unsavedValue">Value that represents an unsaved value.</param>
    </member>
    <member name="M:FluentNHibernate.Mapping.IdentityPart.Column(System.String)">
      <summary>
            Sets the column name for the identity field.
            </summary>
      <param name="columnName">Column name</param>
    </member>
    <member name="P:FluentNHibernate.Mapping.IdentityPart.Access">
      <summary>
            Set the access and naming strategy for this identity.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ManyToManyPart`1.OrderBy(System.String)">
      <summary>
            Sets the order-by clause for this one-to-many relationship.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.ManyToOnePart`1.UniqueKey(System.String)">
      <summary>
            Specifies the name of a multi-column unique constraint.
            </summary>
      <param name="keyName">Name of constraint</param>
    </member>
    <member name="P:FluentNHibernate.Mapping.ManyToOnePart`1.Not">
      <summary>
            Inverts the next boolean
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.OneToManyPart`1.OrderBy(System.String)">
      <summary>
            Sets the order-by clause for this one-to-many relationship.
            </summary>
    </member>
    <member name="M:FluentNHibernate.Mapping.PropertyPart.CustomType``1">
      <summary>
            Specifies that a custom type (an implementation of <see cref="T:NHibernate.UserTypes.IUserType" />) should be used for this property for mapping it to/from one or more database columns whose format or type doesn't match this .NET property.
            </summary>
      <typeparam name="TCustomtype">A type which implements <see cref="T:NHibernate.UserTypes.IUserType" />.</typeparam>
      <returns>This property mapping to continue the method chain</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.PropertyPart.CustomType(System.Type)">
      <summary>
            Specifies that a custom type (an implementation of <see cref="T:NHibernate.UserTypes.IUserType" />) should be used for this property for mapping it to/from one or more database columns whose format or type doesn't match this .NET property.
            </summary>
      <param name="type">A type which implements <see cref="T:NHibernate.UserTypes.IUserType" />.</param>
      <returns>This property mapping to continue the method chain</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.PropertyPart.CustomType(System.String)">
      <summary>
            Specifies that a custom type (an implementation of <see cref="T:NHibernate.UserTypes.IUserType" />) should be used for this property for mapping it to/from one or more database columns whose format or type doesn't match this .NET property.
            </summary>
      <param name="type">A type which implements <see cref="T:NHibernate.UserTypes.IUserType" />.</param>
      <returns>This property mapping to continue the method chain</returns>
    </member>
    <member name="M:FluentNHibernate.Mapping.PropertyPart.UniqueKey(System.String)">
      <summary>
            Specifies the name of a multi-column unique constraint.
            </summary>
      <param name="keyName">Name of constraint</param>
    </member>
    <member name="P:FluentNHibernate.Mapping.PropertyPart.Access">
      <summary>
            Set the access and naming strategy for this property.
            </summary>
    </member>
    <member name="P:FluentNHibernate.Mapping.PropertyPart.Not">
      <summary>
            Inverts the next boolean
            </summary>
    </member>
    <member name="M:FluentNHibernate.MappingModel.AttributeStore`1.IsSpecified``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Returns whether the user has set a value for a property.
            </summary>
    </member>
    <member name="M:FluentNHibernate.MappingModel.AttributeStore`1.IsSpecified(System.String)">
      <summary>
            Returns whether the user has set a value for a property.
            </summary>
    </member>
    <member name="M:FluentNHibernate.MappingModel.AttributeStore`1.HasValue``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
      <summary>
            Returns whether a property has any value, default or user specified.
            </summary>
      <typeparam name="TResult">
      </typeparam>
      <param name="exp">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:FluentNHibernate.Reveal.Property``1(System.String)">
      <summary>
            Reveals a hidden property for use instead of expressions.
            </summary>
      <typeparam name="TEntity">Entity type</typeparam>
      <param name="propertyName">Name of property</param>
      <returns>Expression for the hidden property</returns>
    </member>
    <member name="M:FluentNHibernate.Reveal.Property``2(System.String)">
      <summary>
            Reveals a hidden property with a specific return type for use instead of expressions.
            </summary>
      <typeparam name="TEntity">Entity type</typeparam>
      <typeparam name="TReturn">Property return type</typeparam>
      <param name="propertyName">Name of property</param>
      <returns>Expression for the hidden property</returns>
    </member>
    <member name="T:Iesi.Collections.Generic.ISet`1">
      <summary>
        <p>A collection that contains no duplicate elements.  This interface models the mathematical
            <c>Set</c> abstraction.    
            The order of elements in a set is dependant on (a)the data-structure implementation, and 
            (b)the implementation of the various <c>Set</c> methods, and thus is not guaranteed.</p>
        <p>None of the <c>Set</c> implementations in this library are guranteed to be thread-safe
            in any way unless wrapped in a <c>SynchronizedSet</c>.</p>
        <p>The following table summarizes the binary operators that are supported by the <c>Set</c> class.</p>
        <list type="table">
          <listheader>
            <term>Operation</term>
            <term>Description</term>
            <term>Method</term>
          </listheader>
          <item>
            <term>Union (OR)</term>
            <term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            <term>
              <c>Union()</c>
            </term>
          </item>
          <item>
            <term>Intersection (AND)</term>
            <term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            <term>
              <c>InterSect()</c>
            </term>
          </item>
          <item>
            <term>Exclusive Or (XOR)</term>
            <term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            <term>
              <c>ExclusiveOr()</c>
            </term>
          </item>
          <item>
            <term>Minus (n/a)</term>
            <term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            		them.  Note that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            <term>
              <c>Minus()</c>
            </term>
          </item>
        </list>
      </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.ISet`1.Union(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
      <param name="a">A collection of elements.</param>
      <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ISet`1.Intersect(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>The intersection of this set with <c>a</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ISet`1.Minus(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ISet`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>A set containing the result of <c>a ^ b</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ISet`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Returns <see langword="true" /> if the set contains all the elements in the specified collection.
            </summary>
      <param name="c">A collection of objects.</param>
      <returns>
        <see langword="true" /> if the set contains all the elements in the specified collection, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ISet`1.Add(`0)">
      <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
      <param name="o">The object to add to the set.</param>
      <returns>
        <see langword="true" /> is the object was added, <see langword="false" /> if it was already present.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ISet`1.AddAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
      <param name="c">A collection of objects to add to the set.</param>
      <returns>
        <see langword="true" /> is the set changed as a result of this operation, <see langword="false" /> if not.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ISet`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
      <param name="c">A collection of elements to remove.</param>
      <returns>
        <see langword="true" /> if the set was modified as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ISet`1.RetainAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
      <param name="c">Collection that defines the set of elements to be retained.</param>
      <returns>
        <see langword="true" /> if this set changed as a result of this operation.</returns>
    </member>
    <member name="P:Iesi.Collections.Generic.ISet`1.IsEmpty">
      <summary>
            Returns <see langword="true" /> if this set contains no elements.
            </summary>
    </member>
    <member name="T:Iesi.Collections.ISet">
      <summary>
        <p>A collection that contains no duplicate elements.  This interface models the mathematical
            <c>Set</c> abstraction.    
            The order of elements in a set is dependant on (a)the data-structure implementation, and 
            (b)the implementation of the various <c>Set</c> methods, and thus is not guaranteed.</p>
        <p>None of the <c>Set</c> implementations in this library are guranteed to be thread-safe
            in any way unless wrapped in a <c>SynchronizedSet</c>.</p>
        <p>The following table summarizes the binary operators that are supported by the <c>Set</c> class.</p>
        <list type="table">
          <listheader>
            <term>Operation</term>
            <term>Description</term>
            <term>Method</term>
          </listheader>
          <item>
            <term>Union (OR)</term>
            <term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            <term>
              <c>Union()</c>
            </term>
          </item>
          <item>
            <term>Intersection (AND)</term>
            <term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            <term>
              <c>InterSect()</c>
            </term>
          </item>
          <item>
            <term>Exclusive Or (XOR)</term>
            <term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            <term>
              <c>ExclusiveOr()</c>
            </term>
          </item>
          <item>
            <term>Minus (n/a)</term>
            <term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            		them.  Note that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            <term>
              <c>Minus()</c>
            </term>
          </item>
        </list>
      </summary>
    </member>
    <member name="M:Iesi.Collections.ISet.Union(Iesi.Collections.ISet)">
      <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
      <param name="a">A collection of elements.</param>
      <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
    </member>
    <member name="M:Iesi.Collections.ISet.Intersect(Iesi.Collections.ISet)">
      <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>The intersection of this set with <c>a</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.ISet.Minus(Iesi.Collections.ISet)">
      <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
    </member>
    <member name="M:Iesi.Collections.ISet.ExclusiveOr(Iesi.Collections.ISet)">
      <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>A set containing the result of <c>a ^ b</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.ISet.Contains(System.Object)">
      <summary>
            Returns <see langword="true" /> if this set contains the specified element.
            </summary>
      <param name="o">The element to look for.</param>
      <returns>
        <see langword="true" /> if this set contains the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.ISet.ContainsAll(System.Collections.ICollection)">
      <summary>
            Returns <see langword="true" /> if the set contains all the elements in the specified collection.
            </summary>
      <param name="c">A collection of objects.</param>
      <returns>
        <see langword="true" /> if the set contains all the elements in the specified collection, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.ISet.Add(System.Object)">
      <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
      <param name="o">The object to add to the set.</param>
      <returns>
        <see langword="true" /> is the object was added, <see langword="false" /> if it was already present.</returns>
    </member>
    <member name="M:Iesi.Collections.ISet.AddAll(System.Collections.ICollection)">
      <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
      <param name="c">A collection of objects to add to the set.</param>
      <returns>
        <see langword="true" /> is the set changed as a result of this operation, <see langword="false" /> if not.</returns>
    </member>
    <member name="M:Iesi.Collections.ISet.Remove(System.Object)">
      <summary>
            Removes the specified element from the set.
            </summary>
      <param name="o">The element to be removed.</param>
      <returns>
        <see langword="true" /> if the set contained the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.ISet.RemoveAll(System.Collections.ICollection)">
      <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
      <param name="c">A collection of elements to remove.</param>
      <returns>
        <see langword="true" /> if the set was modified as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.ISet.RetainAll(System.Collections.ICollection)">
      <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
      <param name="c">Collection that defines the set of elements to be retained.</param>
      <returns>
        <see langword="true" /> if this set changed as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.ISet.Clear">
      <summary>
            Removes all objects from the set.
            </summary>
    </member>
    <member name="P:Iesi.Collections.ISet.IsEmpty">
      <summary>
            Returns <see langword="true" /> if this set contains no elements.
            </summary>
    </member>
    <member name="T:Iesi.Collections.Generic.Set`1">
      <summary>
        <p>A collection that contains no duplicate elements.  This class models the mathematical
            <c>Set</c> abstraction, and is the base class for all other <c>Set</c> implementations.  
            The order of elements in a set is dependant on (a)the data-structure implementation, and 
            (b)the implementation of the various <c>Set</c> methods, and thus is not guaranteed.</p>
        <p>None of the <c>Set</c> implementations in this library are guranteed to be thread-safe
            in any way unless wrapped in a <c>SynchronizedSet</c>.</p>
        <p>The following table summarizes the binary operators that are supported by the <c>Set</c> class.</p>
        <list type="table">
          <listheader>
            <term>Operation</term>
            <term>Description</term>
            <term>Method</term>
            <term>Operator</term>
          </listheader>
          <item>
            <term>Union (OR)</term>
            <term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            <term>
              <c>Union()</c>
            </term>
            <term>
              <c>|</c>
            </term>
          </item>
          <item>
            <term>Intersection (AND)</term>
            <term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            <term>
              <c>InterSect()</c>
            </term>
            <term>
              <c>&amp;</c>
            </term>
          </item>
          <item>
            <term>Exclusive Or (XOR)</term>
            <term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            <term>
              <c>ExclusiveOr()</c>
            </term>
            <term>
              <c>^</c>
            </term>
          </item>
          <item>
            <term>Minus (n/a)</term>
            <term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            		them.  Note that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            <term>
              <c>Minus()</c>
            </term>
            <term>
              <c>-</c>
            </term>
          </item>
        </list>
      </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.Union(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
      <param name="a">A collection of elements.</param>
      <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.Union(Iesi.Collections.Generic.ISet{`0},Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs a "union" of two sets, where all the elements
            in both are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            The return value is a <c>Clone()</c> of one of the sets (<c>a</c> if it is not <see langword="null" />) with elements of the other set
            added in.  Neither of the input sets is modified by the operation.
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>A set containing the union of the input sets.  <see langword="null" /> if both sets are <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.op_BitwiseOr(Iesi.Collections.Generic.Set{`0},Iesi.Collections.Generic.Set{`0})">
      <summary>
            Performs a "union" of two sets, where all the elements
            in both are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            The return value is a <c>Clone()</c> of one of the sets (<c>a</c> if it is not <see langword="null" />) with elements of the other set
            added in.  Neither of the input sets is modified by the operation.
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>A set containing the union of the input sets.  <see langword="null" /> if both sets are <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.Intersect(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>The intersection of this set with <c>a</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.Intersect(Iesi.Collections.Generic.ISet{`0},Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <c>a</c> and <c>b</c>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<c>a</c> if it is not <see langword="null" />) containing the
            elements from the intersect operation. 
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>The intersection of the two input sets.  <see langword="null" /> if both sets are <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.op_BitwiseAnd(Iesi.Collections.Generic.Set{`0},Iesi.Collections.Generic.Set{`0})">
      <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <c>a</c> and <c>b</c>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<c>a</c> if it is not <see langword="null" />) containing the
            elements from the intersect operation. 
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>The intersection of the two input sets.  <see langword="null" /> if both sets are <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.Minus(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.Minus(Iesi.Collections.Generic.ISet{`0},Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <c>a</c> containing the elements from the operation. 
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>A set containing <c>A - B</c> elements.  <see langword="null" /> if <c>a</c> is <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.op_Subtraction(Iesi.Collections.Generic.Set{`0},Iesi.Collections.Generic.Set{`0})">
      <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <c>a</c> containing the elements from the operation. 
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>A set containing <c>A - B</c> elements.  <see langword="null" /> if <c>a</c> is <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>A set containing the result of <c>a ^ b</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0},Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of one of the sets
            (<c>a</c> if it is not <see langword="null" />) containing
            the elements from the exclusive-or operation.
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>A set containing the result of <c>a ^ b</c>.  <see langword="null" /> if both sets are <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.op_ExclusiveOr(Iesi.Collections.Generic.Set{`0},Iesi.Collections.Generic.Set{`0})">
      <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of one of the sets
            (<c>a</c> if it is not <see langword="null" />) containing
            the elements from the exclusive-or operation.
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>A set containing the result of <c>a ^ b</c>.  <see langword="null" /> if both sets are <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.Add(`0)">
      <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
      <param name="o">The object to add to the set.</param>
      <returns>
        <see langword="true" /> is the object was added, <see langword="false" /> if it was already present.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.AddAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
      <param name="c">A collection of objects to add to the set.</param>
      <returns>
        <see langword="true" /> is the set changed as a result of this operation, <see langword="false" /> if not.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.Clear">
      <summary>
            Removes all objects from the set.
            </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.Contains(`0)">
      <summary>
            Returns <see langword="true" /> if this set contains the specified element.
            </summary>
      <param name="o">The element to look for.</param>
      <returns>
        <see langword="true" /> if this set contains the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Returns <see langword="true" /> if the set contains all the elements in the specified collection.
            </summary>
      <param name="c">A collection of objects.</param>
      <returns>
        <see langword="true" /> if the set contains all the elements in the specified collection, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.Remove(`0)">
      <summary>
            Removes the specified element from the set.
            </summary>
      <param name="o">The element to be removed.</param>
      <returns>
        <see langword="true" /> if the set contained the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
      <param name="c">A collection of elements to remove.</param>
      <returns>
        <see langword="true" /> if the set was modified as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.RetainAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
      <param name="c">Collection that defines the set of elements to be retained.</param>
      <returns>
        <see langword="true" /> if this set changed as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.Clone">
      <summary>
            Returns a clone of the <c>Set</c> instance.  This will work for derived <c>Set</c>
            classes if the derived class implements a constructor that takes no arguments.
            </summary>
      <returns>A clone of this object.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
      <param name="array">An array that will be the target of the copy operation.</param>
      <param name="index">The zero-based index where copying will start.</param>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.GetEnumerator">
      <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
      <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.NonGenericCopyTo(System.Array,System.Int32)">
      <summary>
            Performs CopyTo when called trhough non-generic ISet (ICollection) interface
            </summary>
      <param name="array">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.NonGenericUnion(Iesi.Collections.ISet)">
      <summary>
            Performs Union when called trhough non-generic ISet interface
            </summary>
      <param name="a">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.NonGenericMinus(Iesi.Collections.ISet)">
      <summary>
            Performs Minus when called trhough non-generic ISet interface
            </summary>
      <param name="a">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.NonGenericIntersect(Iesi.Collections.ISet)">
      <summary>
            Performs Intersect when called trhough non-generic ISet interface
            </summary>
      <param name="a">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Iesi.Collections.Generic.Set`1.NonGenericExclusiveOr(Iesi.Collections.ISet)">
      <summary>
            Performs ExclusiveOr when called trhough non-generic ISet interface
            </summary>
      <param name="a">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Iesi.Collections.Generic.Set`1.IsEmpty">
      <summary>
            Returns <see langword="true" /> if this set contains no elements.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.Set`1.Count">
      <summary>
            The number of elements currently contained in this collection.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.Set`1.IsSynchronized">
      <summary>
            Returns <see langword="true" /> if the <c>Set</c> is synchronized across threads.  Note that
            enumeration is inherently not thread-safe.  Use the <c>SyncRoot</c> to lock the
            object during enumeration.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.Set`1.SyncRoot">
      <summary>
            An object that can be used to synchronize this collection to make it thread-safe.
            When implementing this, if your object uses a base object, like an <c>IDictionary</c>,
            or anything that has a <c>SyncRoot</c>, return that object instead of "<c>this</c>".
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.Set`1.IsReadOnly">
      <summary>
            Indicates whether the given instance is read-only or not
            </summary>
      <value>
        <see langword="true" /> if the ISet is read-only; otherwise, <see langword="false" />. 
            In the default implementation of Set, this property always returns false. 
            </value>
    </member>
    <member name="T:Iesi.Collections.Generic.DictionarySet`1">
      <summary>
        <p>
          <c>DictionarySet</c> is an abstract class that supports the creation of new <c>Set</c>
             types where the underlying data store is an <c>IDictionary</c> instance.</p>
        <p>You can use any object that implements the <c>IDictionary</c> interface to hold set data.
             You can define your own, or you can use one of the objects provided in the Framework.   
             The type of <c>IDictionary</c> you choose will affect both the performance and the behavior
             of the <c>Set</c> using it. </p>
        <p>To make a <c>Set</c> typed based on your own <c>IDictionary</c>, simply derive a
             new class with a constructor that takes no parameters.  Some <c>Set</c> implmentations
             cannot be defined with a default constructor.  If this is the case for your class, 
             you will need to override <c>Clone()</c> as well.</p>
        <p>It is also standard practice that at least one of your constructors takes an <c>ICollection</c> or 
             an <c>ISet</c> as an argument.</p>
      </summary>
    </member>
    <member name="F:Iesi.Collections.Generic.DictionarySet`1.InternalDictionary">
      <summary>
            Provides the storage for elements in the <c>Set</c>, stored as the key-set
            of the <c>IDictionary</c> object.  Set this object in the constructor
            if you create your own <c>Set</c> class.  
            </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.DictionarySet`1.Add(`0)">
      <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
      <param name="o">The <typeparamref name="T" /> to add to the set.</param>
      <returns>
        <see langword="true" /> is the object was added, <see langword="false" /> if it was already present.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.DictionarySet`1.AddAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
      <param name="c">A collection of objects to add to the set.</param>
      <returns>
        <see langword="true" /> is the set changed as a result of this operation, <see langword="false" /> if not.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.DictionarySet`1.Clear">
      <summary>
            Removes all objects from the set.
            </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.DictionarySet`1.Contains(`0)">
      <summary>
            Returns <see langword="true" /> if this set contains the specified element.
            </summary>
      <param name="o">The element to look for.</param>
      <returns>
        <see langword="true" /> if this set contains the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.DictionarySet`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Returns <see langword="true" /> if the set contains all the elements in the specified collection.
            </summary>
      <param name="c">A collection of objects.</param>
      <returns>
        <see langword="true" /> if the set contains all the elements in the specified collection, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.DictionarySet`1.Remove(`0)">
      <summary>
            Removes the specified element from the set.
            </summary>
      <param name="o">The element to be removed.</param>
      <returns>
        <see langword="true" /> if the set contained the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.DictionarySet`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
      <param name="c">A collection of elements to remove.</param>
      <returns>
        <see langword="true" /> if the set was modified as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.DictionarySet`1.RetainAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
      <param name="c">Collection that defines the set of elements to be retained.</param>
      <returns>
        <see langword="true" /> if this set changed as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.DictionarySet`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the elements in the <c>Set</c> to an array of T.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
      <param name="array">An array that will be the target of the copy operation.</param>
      <param name="index">The zero-based index where copying will start.</param>
    </member>
    <member name="M:Iesi.Collections.Generic.DictionarySet`1.GetEnumerator">
      <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
      <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.DictionarySet`1.NonGenericCopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously. Needed for 
            non-generic ISet methods implementation
            </summary>
      <param name="array">An array that will be the target of the copy operation.</param>
      <param name="index">The zero-based index where copying will start.</param>
    </member>
    <member name="P:Iesi.Collections.Generic.DictionarySet`1.Placeholder">
      <summary>
            The placeholder object used as the value for the <c>IDictionary</c> instance.
            </summary>
      <remarks>
            There is a single instance of this object globally, used for all <c>Sets</c>.
            </remarks>
    </member>
    <member name="P:Iesi.Collections.Generic.DictionarySet`1.IsEmpty">
      <summary>
            Returns <see langword="true" /> if this set contains no elements.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.DictionarySet`1.Count">
      <summary>
            The number of elements contained in this collection.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.DictionarySet`1.IsSynchronized">
      <summary>
            None of the objects based on <c>DictionarySet</c> are synchronized.  Use the
            <c>SyncRoot</c> property instead.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.DictionarySet`1.SyncRoot">
      <summary>
            Returns an object that can be used to synchronize the <c>Set</c> between threads.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.DictionarySet`1.IsReadOnly">
      <summary>
            Indicates wether the <c>Set</c> is read-only or not
            </summary>
    </member>
    <member name="T:Iesi.Collections.Generic.HashedSet`1">
      <summary>
            Implements a <c>Set</c> based on a Dictionary (which is equivalent of 
            non-genric <c>HashTable</c>) This will give the best lookup, add, and remove
            performance for very large data-sets, but iteration will occur in no particular order.
            </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.HashedSet`1.#ctor">
      <summary>
            Creates a new set instance based on a Dictinary.
            </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.HashedSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
      <summary>
            Creates a new set instance based on a Dictinary and
            initializes it based on a collection of elements.
            </summary>
      <param name="initialValues">A collection of elements that defines the initial set contents.</param>
    </member>
    <member name="T:Iesi.Collections.Generic.ImmutableSet`1">
      <summary>
        <p>Implements an immutable (read-only) <c>Set</c> wrapper.</p>
        <p>Although this is advertised as immutable, it really isn't.  Anyone with access to the
            <c>basisSet</c> can still change the data-set.  So <c>GetHashCode()</c> is not implemented
            for this <c>Set</c>, as is the case for all <c>Set</c> implementations in this library.
            This design decision was based on the efficiency of not having to <c>Clone()</c> the 
            <c>basisSet</c> every time you wrap a mutable <c>Set</c>.</p>
      </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.#ctor(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Constructs an immutable (read-only) <c>Set</c> wrapper.
            </summary>
      <param name="basisSet">The <c>Set</c> that is wrapped.</param>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Add(`0)">
      <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
      <param name="o">The object to add to the set.</param>
      <returns>nothing</returns>
      <exception cref="T:System.NotSupportedException"> is always thrown</exception>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.AddAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
      <param name="c">A collection of objects to add to the set.</param>
      <returns>nothing</returns>
      <exception cref="T:System.NotSupportedException"> is always thrown</exception>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Clear">
      <summary>
            Removes all objects from the set.
            </summary>
      <exception cref="T:System.NotSupportedException"> is always thrown</exception>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Contains(`0)">
      <summary>
            Returns <see langword="true" /> if this set contains the specified element.
            </summary>
      <param name="o">The element to look for.</param>
      <returns>
        <see langword="true" /> if this set contains the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Returns <see langword="true" /> if the set contains all the elements in the specified collection.
            </summary>
      <param name="c">A collection of objects.</param>
      <returns>
        <see langword="true" /> if the set contains all the elements in the specified collection, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Remove(`0)">
      <summary>
            Removes the specified element from the set.
            </summary>
      <param name="o">The element to be removed.</param>
      <returns>nothing</returns>
      <exception cref="T:System.NotSupportedException"> is always thrown</exception>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
      <param name="c">A collection of elements to remove.</param>
      <returns>nothing</returns>
      <exception cref="T:System.NotSupportedException"> is always thrown</exception>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.RetainAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
      <param name="c">Collection that defines the set of elements to be retained.</param>
      <returns>nothing</returns>
      <exception cref="T:System.NotSupportedException"> is always thrown</exception>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the elements in the <c>Set</c> to an array of T. The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
      <param name="array">An array that will be the target of the copy operation.</param>
      <param name="index">The zero-based index where copying will start.</param>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.GetEnumerator">
      <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
      <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Clone">
      <summary>
            Returns a clone of the <c>Set</c> instance.  
            </summary>
      <returns>A clone of this object.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Union(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
      <param name="a">A collection of elements.</param>
      <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Intersect(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>The intersection of this set with <c>a</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.Minus(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.ExclusiveOr(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>A set containing the result of <c>a ^ b</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.NonGenericCopyTo(System.Array,System.Int32)">
      <summary>
            Performs CopyTo when called trhough non-generic ISet (ICollection) interface
            </summary>
      <param name="array">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.NonGenericUnion(Iesi.Collections.ISet)">
      <summary>
            Performs Union when called trhough non-generic ISet interface
            </summary>
      <param name="a">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.NonGenericMinus(Iesi.Collections.ISet)">
      <summary>
            Performs Minus when called trhough non-generic ISet interface
            </summary>
      <param name="a">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.NonGenericIntersect(Iesi.Collections.ISet)">
      <summary>
            Performs Intersect when called trhough non-generic ISet interface
            </summary>
      <param name="a">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Iesi.Collections.Generic.ImmutableSet`1.NonGenericExclusiveOr(Iesi.Collections.ISet)">
      <summary>
            Performs ExclusiveOr when called trhough non-generic ISet interface
            </summary>
      <param name="a">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:Iesi.Collections.Generic.ImmutableSet`1.IsEmpty">
      <summary>
            Returns <see langword="true" /> if this set contains no elements.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.ImmutableSet`1.Count">
      <summary>
            The number of elements contained in this collection.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.ImmutableSet`1.IsSynchronized">
      <summary>
            Returns an object that can be used to synchronize use of the <c>Set</c> across threads.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.ImmutableSet`1.SyncRoot">
      <summary>
            Returns an object that can be used to synchronize the <c>Set</c> between threads.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.ImmutableSet`1.IsReadOnly">
      <summary>
            Indicates that the given instance is read-only
            </summary>
    </member>
    <member name="T:Iesi.Collections.Generic.OrderedSet`1">
      <summary>
            Implements an ordered <c>Set</c> based on a dictionary.
            </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.OrderedSet`1.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Iesi.Collections.Generic.OrderedSet`1" /> class.
            </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.OrderedSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:Iesi.Collections.Generic.OrderedSet`1" /> class.
            </summary>
      <param name="initialValues">A collection of elements that defines the initial set contents.</param>
    </member>
    <member name="T:Iesi.Collections.Generic.SortedSet`1">
      <summary>
            Implements a <c>Set</c> based on a sorted tree.  This gives good performance for operations on very
            large data-sets, though not as good - asymptotically - as a <c>HashedSet</c>.  However, iteration
            occurs in order.  Elements that you put into this type of collection must implement <c>IComparable</c>,
            and they must actually be comparable.  You can't mix <c>string</c> and <c>int</c> values, for example.
            </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor">
      <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> to use for sorting.</param>
    </member>
    <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.ICollection{`0})">
      <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
      <param name="initialValues">A collection of elements that defines the initial set contents.</param>
    </member>
    <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor(System.Collections.ICollection)">
      <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
      <param name="initialValues">A collection of elements that defines the initial set contents.</param>
    </member>
    <member name="M:Iesi.Collections.Generic.SortedSet`1.#ctor(System.Collections.Generic.ICollection{`0},System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
      <param name="initialValues">A collection of elements that defines the initial set contents.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> to use for sorting.</param>
    </member>
    <member name="T:Iesi.Collections.Generic.SynchronizedSet`1">
      <summary>
        <p>Implements a thread-safe <c>Set</c> wrapper.  The implementation is extremely conservative, 
            serializing critical sections to prevent possible deadlocks, and locking on everything.
            The one exception is for enumeration, which is inherently not thread-safe.  For this, you
            have to <c>lock</c> the <c>SyncRoot</c> object for the duration of the enumeration.</p>
      </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.#ctor(Iesi.Collections.Generic.ISet{`0})">
      <summary>
            Constructs a thread-safe <c>Set</c> wrapper.
            </summary>
      <param name="basisSet">The <c>Set</c> object that this object will wrap.</param>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.Add(`0)">
      <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
      <param name="o">The object to add to the set.</param>
      <returns>
        <see langword="true" /> is the object was added, <see langword="false" /> if it was already present.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.AddAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
      <param name="c">A collection of objects to add to the set.</param>
      <returns>
        <see langword="true" /> is the set changed as a result of this operation, <see langword="false" /> if not.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.Clear">
      <summary>
            Removes all objects from the set.
            </summary>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.Contains(`0)">
      <summary>
            Returns <see langword="true" /> if this set contains the specified element.
            </summary>
      <param name="o">The element to look for.</param>
      <returns>
        <see langword="true" /> if this set contains the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.ContainsAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Returns <see langword="true" /> if the set contains all the elements in the specified collection.
            </summary>
      <param name="c">A collection of objects.</param>
      <returns>
        <see langword="true" /> if the set contains all the elements in the specified collection, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.Remove(`0)">
      <summary>
            Removes the specified element from the set.
            </summary>
      <param name="o">The element to be removed.</param>
      <returns>
        <see langword="true" /> if the set contained the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.RemoveAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
      <param name="c">A collection of elements to remove.</param>
      <returns>
        <see langword="true" /> if the set was modified as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.RetainAll(System.Collections.Generic.ICollection{`0})">
      <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
      <param name="c">Collection that defines the set of elements to be retained.</param>
      <returns>
        <see langword="true" /> if this set changed as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
      <param name="array">An array that will be the target of the copy operation.</param>
      <param name="index">The zero-based index where copying will start.</param>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.GetEnumerator">
      <summary>
            Enumeration is, by definition, not thread-safe.  Use a <c>lock</c> on the <c>SyncRoot</c> 
            to synchronize the entire enumeration process.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.Clone">
      <summary>
            Returns a clone of the <c>Set</c> instance.  
            </summary>
      <returns>A clone of this object.</returns>
    </member>
    <member name="M:Iesi.Collections.Generic.SynchronizedSet`1.NonGenericCopyTo(System.Array,System.Int32)">
      <summary>
            Performs CopyTo when called trhough non-generic ISet (ICollection) interface
            </summary>
      <param name="array">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="P:Iesi.Collections.Generic.SynchronizedSet`1.IsEmpty">
      <summary>
            Returns <see langword="true" /> if this set contains no elements.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.SynchronizedSet`1.Count">
      <summary>
            The number of elements contained in this collection.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.SynchronizedSet`1.IsSynchronized">
      <summary>
            Returns <see langword="true" />, indicating that this object is thread-safe.  The exception to this
            is enumeration, which is inherently not thread-safe.  Use the <c>SyncRoot</c> object to
            lock this object for the entire duration of the enumeration.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.SynchronizedSet`1.SyncRoot">
      <summary>
            Returns an object that can be used to synchronize the <c>Set</c> between threads.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Generic.SynchronizedSet`1.IsReadOnly">
      <summary>
            Indicates whether given instace is read-only or not
            </summary>
    </member>
    <member name="T:Iesi.Collections.Set">
      <summary>A collection that contains no duplicate elements.</summary>
      <remarks>
        <para>
            This class models the mathematical set abstraction, and is the base class for all
            other set implementations. The order of elements in a set is dependant on
            (a) the data-structure implementation, and (b) the implementation of the various
            methods, and thus is not guaranteed.
            </para>
        <para>
            None of the <see cref="T:Iesi.Collections.ISet" /> implementations in this library are guranteed to be thread-safe
            in any way unless wrapped in a <see cref="T:Iesi.Collections.SynchronizedSet" />.
            </para>
        <para>
            The following table summarizes the binary operators that are supported by the <see cref="T:Iesi.Collections.ISet" />
            type.
            </para>
        <list type="table">
          <listheader>
            <term>Operation</term>
            <term>Description</term>
            <term>Method</term>
            <term>Operator</term>
          </listheader>
          <item>
            <term>Union (OR)</term>
            <term>Element included in result if it exists in either <c>A</c> OR <c>B</c>.</term>
            <term>
              <c>Union()</c>
            </term>
            <term>
              <c>|</c>
            </term>
          </item>
          <item>
            <term>Intersection (AND)</term>
            <term>Element included in result if it exists in both <c>A</c> AND <c>B</c>.</term>
            <term>
              <c>InterSect()</c>
            </term>
            <term>
              <c>&amp;</c>
            </term>
          </item>
          <item>
            <term>Exclusive Or (XOR)</term>
            <term>Element included in result if it exists in one, but not both, of <c>A</c> and <c>B</c>.</term>
            <term>
              <c>ExclusiveOr()</c>
            </term>
            <term>
              <c>^</c>
            </term>
          </item>
          <item>
            <term>Minus (n/a)</term>
            <term>Take all the elements in <c>A</c>.  Now, if any of them exist in <c>B</c>, remove
            		them.  Note that unlike the other operators, <c>A - B</c> is not the same as <c>B - A</c>.</term>
            <term>
              <c>Minus()</c>
            </term>
            <term>
              <c>-</c>
            </term>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:Iesi.Collections.Set.Union(Iesi.Collections.ISet)">
      <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a clone of this set with the extra elements added in.
            </summary>
      <param name="a">A collection of elements.</param>
      <returns>A new <see cref="T:Iesi.Collections.ISet" /> instance containing the union of this instance with the specified collection.
            Neither of the input objects is modified by the union.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.Union(Iesi.Collections.ISet,Iesi.Collections.ISet)">
      <summary>
            Performs a "union" of two sets, where all the elements
            in both are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            The return value is a clone of one of the sets (<c>a</c> if it is not <see langword="null" />) with elements of the other set
            added in.  Neither of the input sets is modified by the operation.
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>A set containing the union of the input sets.  <see langword="null" /> if both sets are <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.op_BitwiseOr(Iesi.Collections.Set,Iesi.Collections.Set)">
      <summary>
            Performs a "union" of two sets, where all the elements
            in both are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            The return value is a clone of one of the sets (<c>a</c> if it is not <see langword="null" />) with elements of the other set
            added in.  Neither of the input sets is modified by the operation.
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>A set containing the union of the input sets.  <see langword="null" /> if both sets are <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.Intersect(Iesi.Collections.ISet)">
      <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>The intersection of this set with <c>a</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.Intersect(Iesi.Collections.ISet,Iesi.Collections.ISet)">
      <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <c>a</c> and <c>b</c>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<c>a</c> if it is not <see langword="null" />) containing the
            elements from the intersect operation. 
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>The intersection of the two input sets.  <see langword="null" /> if both sets are <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.op_BitwiseAnd(Iesi.Collections.Set,Iesi.Collections.Set)">
      <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included only if it exists in
            both <c>a</c> and <c>b</c>.  Neither input object is modified by the operation.
            The result object is a <c>Clone()</c> of one of the input objects (<c>a</c> if it is not <see langword="null" />) containing the
            elements from the intersect operation. 
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>The intersection of the two input sets.  <see langword="null" /> if both sets are <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.Minus(Iesi.Collections.ISet)">
      <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.Minus(Iesi.Collections.ISet,Iesi.Collections.ISet)">
      <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <c>a</c> containing the elements from the operation. 
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>A set containing <c>A - B</c> elements.  <see langword="null" /> if <c>a</c> is <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.op_Subtraction(Iesi.Collections.Set,Iesi.Collections.Set)">
      <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of set <c>a</c> containing the elements from the operation. 
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>A set containing <c>A - B</c> elements.  <see langword="null" /> if <c>a</c> is <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.ExclusiveOr(Iesi.Collections.ISet)">
      <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a clone of this set containing
            the elements from the exclusive-or operation.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>A set containing the result of <c>a ^ b</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.ExclusiveOr(Iesi.Collections.ISet,Iesi.Collections.ISet)">
      <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a clone of one of the sets
            (<c>a</c> if it is not <see langword="null" />) containing
            the elements from the exclusive-or operation.
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>A set containing the result of <c>a ^ b</c>.  <see langword="null" /> if both sets are <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.op_ExclusiveOr(Iesi.Collections.Set,Iesi.Collections.Set)">
      <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a clone of one of the sets
            (<c>a</c> if it is not <see langword="null" />) containing
            the elements from the exclusive-or operation.
            </summary>
      <param name="a">A set of elements.</param>
      <param name="b">A set of elements.</param>
      <returns>A set containing the result of <c>a ^ b</c>.  <see langword="null" /> if both sets are <see langword="null" />.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.Add(System.Object)">
      <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
      <param name="o">The object to add to the set.</param>
      <returns>
        <see langword="true" /> is the object was added, <see langword="false" /> if it was already present.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.AddAll(System.Collections.ICollection)">
      <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
      <param name="c">A collection of objects to add to the set.</param>
      <returns>
        <see langword="true" /> is the set changed as a result of this operation, <see langword="false" /> if not.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.Clear">
      <summary>
            Removes all objects from the set.
            </summary>
    </member>
    <member name="M:Iesi.Collections.Set.Contains(System.Object)">
      <summary>
            Returns <see langword="true" /> if this set contains the specified element.
            </summary>
      <param name="o">The element to look for.</param>
      <returns>
        <see langword="true" /> if this set contains the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.ContainsAll(System.Collections.ICollection)">
      <summary>
            Returns <see langword="true" /> if the set contains all the elements in the specified collection.
            </summary>
      <param name="c">A collection of objects.</param>
      <returns>
        <see langword="true" /> if the set contains all the elements in the specified collection, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.Remove(System.Object)">
      <summary>
            Removes the specified element from the set.
            </summary>
      <param name="o">The element to be removed.</param>
      <returns>
        <see langword="true" /> if the set contained the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.RemoveAll(System.Collections.ICollection)">
      <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
      <param name="c">A collection of elements to remove.</param>
      <returns>
        <see langword="true" /> if the set was modified as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.RetainAll(System.Collections.ICollection)">
      <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
      <param name="c">Collection that defines the set of elements to be retained.</param>
      <returns>
        <see langword="true" /> if this set changed as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.Clone">
      <summary>
            Returns a clone of the set instance.  This will work for derived set
            classes if the derived class implements a constructor that takes no arguments.
            </summary>
      <returns>A clone of this object.</returns>
    </member>
    <member name="M:Iesi.Collections.Set.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements in the set to an array.  The type of array needs
            to be compatible with the objects in the set, obviously.
            </summary>
      <param name="array">An array that will be the target of the copy operation.</param>
      <param name="index">The zero-based index where copying will start.</param>
    </member>
    <member name="M:Iesi.Collections.Set.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the set.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the set.
            </returns>
    </member>
    <member name="P:Iesi.Collections.Set.IsEmpty">
      <summary>
            Returns <see langword="true" /> if this set contains no elements.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Set.Count">
      <summary>
            The number of elements currently contained in this collection.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Set.IsSynchronized">
      <summary>
            Returns <see langword="true" /> if the set is synchronized across threads.  Note that
            enumeration is inherently not thread-safe.  Use the <see cref="P:Iesi.Collections.Set.SyncRoot" /> to lock the
            object during enumeration.
            </summary>
    </member>
    <member name="P:Iesi.Collections.Set.SyncRoot">
      <summary>
            An object that can be used to synchronize this collection to make it thread-safe.
            When implementing this, if your object uses a base object, like an <see cref="T:System.Collections.IDictionary" />,
            or anything that has a <see cref="P:Iesi.Collections.Set.SyncRoot" />, return that object instead
            of <see langword="this" />.
            </summary>
    </member>
    <member name="T:Iesi.Collections.DictionarySet">
      <summary>
        <p>
          <c>DictionarySet</c> is an abstract class that supports the creation of new <c>Set</c>
             types where the underlying data store is an <c>IDictionary</c> instance.</p>
        <p>You can use any object that implements the <c>IDictionary</c> interface to hold set data.
             You can define your own, or you can use one of the objects provided in the Framework.   
             The type of <c>IDictionary</c> you choose will affect both the performance and the behavior
             of the <c>Set</c> using it. </p>
        <p>To make a <c>Set</c> typed based on your own <c>IDictionary</c>, simply derive a
             new class with a constructor that takes no parameters.  Some <c>Set</c> implmentations
             cannot be defined with a default constructor.  If this is the case for your class, 
             you will need to override <c>Clone()</c> as well.</p>
        <p>It is also standard practice that at least one of your constructors takes an <c>ICollection</c> or 
             an <c>ISet</c> as an argument.</p>
      </summary>
    </member>
    <member name="F:Iesi.Collections.DictionarySet.InternalDictionary">
      <summary>
            Provides the storage for elements in the <c>Set</c>, stored as the key-set
            of the <c>IDictionary</c> object.  Set this object in the constructor
            if you create your own <c>Set</c> class.  
            </summary>
    </member>
    <member name="M:Iesi.Collections.DictionarySet.Add(System.Object)">
      <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
      <param name="o">The object to add to the set.</param>
      <returns>
        <see langword="true" /> is the object was added, <see langword="false" /> if it was already present.</returns>
    </member>
    <member name="M:Iesi.Collections.DictionarySet.AddAll(System.Collections.ICollection)">
      <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
      <param name="c">A collection of objects to add to the set.</param>
      <returns>
        <see langword="true" /> is the set changed as a result of this operation, <see langword="false" /> if not.</returns>
    </member>
    <member name="M:Iesi.Collections.DictionarySet.Clear">
      <summary>
            Removes all objects from the set.
            </summary>
    </member>
    <member name="M:Iesi.Collections.DictionarySet.Contains(System.Object)">
      <summary>
            Returns <see langword="true" /> if this set contains the specified element.
            </summary>
      <param name="o">The element to look for.</param>
      <returns>
        <see langword="true" /> if this set contains the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.DictionarySet.ContainsAll(System.Collections.ICollection)">
      <summary>
            Returns <see langword="true" /> if the set contains all the elements in the specified collection.
            </summary>
      <param name="c">A collection of objects.</param>
      <returns>
        <see langword="true" /> if the set contains all the elements in the specified collection, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.DictionarySet.Remove(System.Object)">
      <summary>
            Removes the specified element from the set.
            </summary>
      <param name="o">The element to be removed.</param>
      <returns>
        <see langword="true" /> if the set contained the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.DictionarySet.RemoveAll(System.Collections.ICollection)">
      <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
      <param name="c">A collection of elements to remove.</param>
      <returns>
        <see langword="true" /> if the set was modified as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.DictionarySet.RetainAll(System.Collections.ICollection)">
      <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
      <param name="c">Collection that defines the set of elements to be retained.</param>
      <returns>
        <see langword="true" /> if this set changed as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.DictionarySet.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
      <param name="array">An array that will be the target of the copy operation.</param>
      <param name="index">The zero-based index where copying will start.</param>
    </member>
    <member name="M:Iesi.Collections.DictionarySet.GetEnumerator">
      <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
      <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
    </member>
    <member name="P:Iesi.Collections.DictionarySet.Placeholder">
      <summary>
            The placeholder object used as the value for the <c>IDictionary</c> instance.
            </summary>
      <remarks>
            There is a single instance of this object globally, used for all <c>Sets</c>.
            </remarks>
    </member>
    <member name="P:Iesi.Collections.DictionarySet.IsEmpty">
      <summary>
            Returns <see langword="true" /> if this set contains no elements.
            </summary>
    </member>
    <member name="P:Iesi.Collections.DictionarySet.Count">
      <summary>
            The number of elements contained in this collection.
            </summary>
    </member>
    <member name="P:Iesi.Collections.DictionarySet.IsSynchronized">
      <summary>
            None of the objects based on <c>DictionarySet</c> are synchronized.  Use the
            <c>SyncRoot</c> property instead.
            </summary>
    </member>
    <member name="P:Iesi.Collections.DictionarySet.SyncRoot">
      <summary>
            Returns an object that can be used to synchronize the <c>Set</c> between threads.
            </summary>
    </member>
    <member name="T:Iesi.Collections.HashedSet">
      <summary>
            Implements a <c>Set</c> based on a hash table.  This will give the best lookup, add, and remove
            performance for very large data-sets, but iteration will occur in no particular order.
            </summary>
    </member>
    <member name="M:Iesi.Collections.HashedSet.#ctor">
      <summary>
            Creates a new set instance based on a hash table.
            </summary>
    </member>
    <member name="M:Iesi.Collections.HashedSet.#ctor(System.Collections.ICollection)">
      <summary>
            Creates a new set instance based on a hash table and
            initializes it based on a collection of elements.
            </summary>
      <param name="initialValues">A collection of elements that defines the initial set contents.</param>
    </member>
    <member name="T:Iesi.Collections.HybridSet">
      <summary>
            Implements a <c>Set</c> that automatically changes from a list to a hash table
            when the size reaches a certain threshold.  This is good if you are unsure about
            whether you data-set will be tiny or huge.  Because this uses a dual implementation,
            iteration order is not guaranteed!
            </summary>
    </member>
    <member name="M:Iesi.Collections.HybridSet.#ctor">
      <summary>
            Creates a new set instance based on either a list or a hash table, depending on which 
            will be more efficient based on the data-set size.
            </summary>
    </member>
    <member name="M:Iesi.Collections.HybridSet.#ctor(System.Collections.ICollection)">
      <summary>
            Creates a new set instance based on either a list or a hash table, depending on which 
            will be more efficient based on the data-set size, and
            initializes it based on a collection of elements.
            </summary>
      <param name="initialValues">A collection of elements that defines the initial set contents.</param>
    </member>
    <member name="T:Iesi.Collections.ImmutableSet">
      <summary>
        <p>Implements an immutable (read-only) <c>Set</c> wrapper.</p>
        <p>Although this is advertised as immutable, it really isn't.  Anyone with access to the
            <c>basisSet</c> can still change the data-set.  So <c>GetHashCode()</c> is not implemented
            for this <c>Set</c>, as is the case for all <c>Set</c> implementations in this library.
            This design decision was based on the efficiency of not having to <c>Clone()</c> the 
            <c>basisSet</c> every time you wrap a mutable <c>Set</c>.</p>
      </summary>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.#ctor(Iesi.Collections.ISet)">
      <summary>
            Constructs an immutable (read-only) <c>Set</c> wrapper.
            </summary>
      <param name="basisSet">The <c>Set</c> that is wrapped.</param>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.Add(System.Object)">
      <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
      <param name="o">The object to add to the set.</param>
      <returns>
        <see langword="true" /> is the object was added, <see langword="false" /> if it was already present.</returns>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.AddAll(System.Collections.ICollection)">
      <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
      <param name="c">A collection of objects to add to the set.</param>
      <returns>
        <see langword="true" /> is the set changed as a result of this operation, <see langword="false" /> if not.</returns>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.Clear">
      <summary>
            Removes all objects from the set.
            </summary>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.Contains(System.Object)">
      <summary>
            Returns <see langword="true" /> if this set contains the specified element.
            </summary>
      <param name="o">The element to look for.</param>
      <returns>
        <see langword="true" /> if this set contains the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.ContainsAll(System.Collections.ICollection)">
      <summary>
            Returns <see langword="true" /> if the set contains all the elements in the specified collection.
            </summary>
      <param name="c">A collection of objects.</param>
      <returns>
        <see langword="true" /> if the set contains all the elements in the specified collection, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.Remove(System.Object)">
      <summary>
            Removes the specified element from the set.
            </summary>
      <param name="o">The element to be removed.</param>
      <returns>
        <see langword="true" /> if the set contained the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.RemoveAll(System.Collections.ICollection)">
      <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
      <param name="c">A collection of elements to remove.</param>
      <returns>
        <see langword="true" /> if the set was modified as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.RetainAll(System.Collections.ICollection)">
      <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
      <param name="c">Collection that defines the set of elements to be retained.</param>
      <returns>
        <see langword="true" /> if this set changed as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements in the <c>Set</c> to an array.  The type of array needs
            to be compatible with the objects in the <c>Set</c>, obviously.
            </summary>
      <param name="array">An array that will be the target of the copy operation.</param>
      <param name="index">The zero-based index where copying will start.</param>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.GetEnumerator">
      <summary>
            Gets an enumerator for the elements in the <c>Set</c>.
            </summary>
      <returns>An <c>IEnumerator</c> over the elements in the <c>Set</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.Clone">
      <summary>
            Returns a clone of the <c>Set</c> instance.  
            </summary>
      <returns>A clone of this object.</returns>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.Union(Iesi.Collections.ISet)">
      <summary>
            Performs a "union" of the two sets, where all the elements
            in both sets are present.  That is, the element is included if it is in either <c>a</c> or <c>b</c>.
            Neither this set nor the input set are modified during the operation.  The return value
            is a <c>Clone()</c> of this set with the extra elements added in.
            </summary>
      <param name="a">A collection of elements.</param>
      <returns>A new <c>Set</c> containing the union of this <c>Set</c> with the specified collection.
            Neither of the input objects is modified by the union.</returns>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.Intersect(Iesi.Collections.ISet)">
      <summary>
            Performs an "intersection" of the two sets, where only the elements
            that are present in both sets remain.  That is, the element is included if it exists in
            both sets.  The <c>Intersect()</c> operation does not modify the input sets.  It returns
            a <c>Clone()</c> of this set with the appropriate elements removed.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>The intersection of this set with <c>a</c>.</returns>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.Minus(Iesi.Collections.ISet)">
      <summary>
            Performs a "minus" of set <c>b</c> from set <c>a</c>.  This returns a set of all
            the elements in set <c>a</c>, removing the elements that are also in set <c>b</c>.
            The original sets are not modified during this operation.  The result set is a <c>Clone()</c>
            of this <c>Set</c> containing the elements from the operation.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>A set containing the elements from this set with the elements in <c>a</c> removed.</returns>
    </member>
    <member name="M:Iesi.Collections.ImmutableSet.ExclusiveOr(Iesi.Collections.ISet)">
      <summary>
            Performs an "exclusive-or" of the two sets, keeping only the elements that
            are in one of the sets, but not in both.  The original sets are not modified
            during this operation.  The result set is a <c>Clone()</c> of this set containing
            the elements from the exclusive-or operation.
            </summary>
      <param name="a">A set of elements.</param>
      <returns>A set containing the result of <c>a ^ b</c>.</returns>
    </member>
    <member name="P:Iesi.Collections.ImmutableSet.IsEmpty">
      <summary>
            Returns <see langword="true" /> if this set contains no elements.
            </summary>
    </member>
    <member name="P:Iesi.Collections.ImmutableSet.Count">
      <summary>
            The number of elements contained in this collection.
            </summary>
    </member>
    <member name="P:Iesi.Collections.ImmutableSet.IsSynchronized">
      <summary>
            Returns an object that can be used to synchronize use of the <c>Set</c> across threads.
            </summary>
    </member>
    <member name="P:Iesi.Collections.ImmutableSet.SyncRoot">
      <summary>
            Returns an object that can be used to synchronize the <c>Set</c> between threads.
            </summary>
    </member>
    <member name="T:Iesi.Collections.ListSet">
      <summary>
            Implements a <c>Set</c> based on a list.  Performance is much better for very small lists 
            than either <c>HashedSet</c> or <c>SortedSet</c>.  However, performance degrades rapidly as 
            the data-set gets bigger.  Use a <c>HybridSet</c> instead if you are not sure your data-set
            will always remain very small.  Iteration produces elements in the order they were added.
            However, element order is not guaranteed to be maintained by the various <c>Set</c>
            mathematical operators.  
            </summary>
    </member>
    <member name="M:Iesi.Collections.ListSet.#ctor">
      <summary>
            Creates a new set instance based on a list.
            </summary>
    </member>
    <member name="M:Iesi.Collections.ListSet.#ctor(System.Collections.ICollection)">
      <summary>
            Creates a new set instance based on a list and
            initializes it based on a collection of elements.
            </summary>
      <param name="initialValues">A collection of elements that defines the initial set contents.</param>
    </member>
    <member name="T:Iesi.Collections.SortedSet">
      <summary>
            Implements a set based on a sorted tree.  This gives good performance for operations on very
            large data-sets, though not as good - asymptotically - as a <see cref="T:Iesi.Collections.HashedSet" />.
            However, iteration occurs in order.  Elements that you put into this type of collection must
            implement <see cref="T:System.IComparable" />, and they must actually be comparable.  You can't mix
            <see cref="T:System.String" /> and <see cref="T:System.Int32" /> values, for example.
            </summary>
    </member>
    <member name="M:Iesi.Collections.SortedSet.#ctor">
      <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
    </member>
    <member name="M:Iesi.Collections.SortedSet.#ctor(System.Collections.IComparer)">
      <summary>
            Creates a new set instance based on a sorted tree.
            </summary>
      <param name="comparer">The <see cref="T:System.Collections.IComparer" /> to use for sorting.</param>
    </member>
    <member name="M:Iesi.Collections.SortedSet.#ctor(System.Collections.ICollection)">
      <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
      <param name="initialValues">A collection of elements that defines the initial set contents.</param>
    </member>
    <member name="M:Iesi.Collections.SortedSet.#ctor(System.Collections.ICollection,System.Collections.IComparer)">
      <summary>
            Creates a new set instance based on a sorted tree and
            initializes it based on a collection of elements.
            </summary>
      <param name="initialValues">A collection of elements that defines the initial set contents.</param>
      <param name="comparer">The <see cref="T:System.Collections.IComparer" /> to use for sorting.</param>
    </member>
    <member name="T:Iesi.Collections.SynchronizedSet">
      <summary>
            Implements a thread-safe <see cref="T:Iesi.Collections.ISet" /> wrapper.
            </summary>
      <remarks>
            The implementation is extremely conservative, serializing critical sections
            to prevent possible deadlocks, and locking on everything. The one exception
            is for enumeration, which is inherently not thread-safe.  For this, you have
            to <see langword="lock" /> the <see cref="P:Iesi.Collections.SynchronizedSet.SyncRoot" /> object for the duration
            of the enumeration.
            </remarks>
    </member>
    <member name="M:Iesi.Collections.SynchronizedSet.#ctor(Iesi.Collections.ISet)">
      <summary>
            Constructs a thread-safe <see cref="T:Iesi.Collections.ISet" /> wrapper.
            </summary>
      <param name="basisSet">The <see cref="T:Iesi.Collections.ISet" /> object that this object will wrap.</param>
    </member>
    <member name="M:Iesi.Collections.SynchronizedSet.Add(System.Object)">
      <summary>
            Adds the specified element to this set if it is not already present.
            </summary>
      <param name="o">The object to add to the set.</param>
      <returns>
        <see langword="true" /> is the object was added, <see langword="false" /> if it was already present.</returns>
    </member>
    <member name="M:Iesi.Collections.SynchronizedSet.AddAll(System.Collections.ICollection)">
      <summary>
            Adds all the elements in the specified collection to the set if they are not already present.
            </summary>
      <param name="c">A collection of objects to add to the set.</param>
      <returns>
        <see langword="true" /> is the set changed as a result of this operation, <see langword="false" /> if not.</returns>
    </member>
    <member name="M:Iesi.Collections.SynchronizedSet.Clear">
      <summary>
            Removes all objects from the set.
            </summary>
    </member>
    <member name="M:Iesi.Collections.SynchronizedSet.Contains(System.Object)">
      <summary>
            Returns <see langword="true" /> if this set contains the specified element.
            </summary>
      <param name="o">The element to look for.</param>
      <returns>
        <see langword="true" /> if this set contains the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.SynchronizedSet.ContainsAll(System.Collections.ICollection)">
      <summary>
            Returns <see langword="true" /> if the set contains all the elements in the specified collection.
            </summary>
      <param name="c">A collection of objects.</param>
      <returns>
        <see langword="true" /> if the set contains all the elements in the specified collection, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.SynchronizedSet.Remove(System.Object)">
      <summary>
            Removes the specified element from the set.
            </summary>
      <param name="o">The element to be removed.</param>
      <returns>
        <see langword="true" /> if the set contained the specified element, <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:Iesi.Collections.SynchronizedSet.RemoveAll(System.Collections.ICollection)">
      <summary>
            Remove all the specified elements from this set, if they exist in this set.
            </summary>
      <param name="c">A collection of elements to remove.</param>
      <returns>
        <see langword="true" /> if the set was modified as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.SynchronizedSet.RetainAll(System.Collections.ICollection)">
      <summary>
            Retains only the elements in this set that are contained in the specified collection.
            </summary>
      <param name="c">Collection that defines the set of elements to be retained.</param>
      <returns>
        <see langword="true" /> if this set changed as a result of this operation.</returns>
    </member>
    <member name="M:Iesi.Collections.SynchronizedSet.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements in the set to an array.  The type of array needs
            to be compatible with the objects in the set, obviously.
            </summary>
      <param name="array">An array that will be the target of the copy operation.</param>
      <param name="index">The zero-based index where copying will start.</param>
    </member>
    <member name="M:Iesi.Collections.SynchronizedSet.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the set.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the set.
            </returns>
      <remarks>
            Enumeration is, by definition, not thread-safe.  Use a <see langword="lock" /> on the <see cref="P:Iesi.Collections.SynchronizedSet.SyncRoot" /> 
            to synchronize the entire enumeration process.
            </remarks>
    </member>
    <member name="M:Iesi.Collections.SynchronizedSet.Clone">
      <summary>
            Returns a clone of this instance.  
            </summary>
      <returns>A clone of this object.</returns>
    </member>
    <member name="P:Iesi.Collections.SynchronizedSet.IsEmpty">
      <summary>
            Returns <see langword="true" /> if this set contains no elements.
            </summary>
    </member>
    <member name="P:Iesi.Collections.SynchronizedSet.Count">
      <summary>
            The number of elements contained in this collection.
            </summary>
    </member>
    <member name="P:Iesi.Collections.SynchronizedSet.IsSynchronized">
      <summary>
            Returns <see langword="true" />, indicating that this object is thread-safe.  The exception to this
            is enumeration, which is inherently not thread-safe.  Use the <see cref="P:Iesi.Collections.SynchronizedSet.SyncRoot" /> object to
            lock this object for the entire duration of the enumeration.
            </summary>
    </member>
    <member name="P:Iesi.Collections.SynchronizedSet.SyncRoot">
      <summary>
            Returns an object that can be used to synchronize the set between threads.
            </summary>
    </member>
    <member name="T:log4net.Appender.IAppender">
      <summary>
            Implement this interface for your own strategies for printing log statements.
            </summary>
      <remarks>
        <para>
            Implementors should consider extending the <see cref="T:log4net.Appender.AppenderSkeleton" />
            class which provides a default implementation of this interface.
            </para>
        <para>
            Appenders can also implement the <see cref="T:log4net.Core.IOptionHandler" /> interface. Therefore
            they would require that the <see cref="M:log4net.Core.IOptionHandler.ActivateOptions" /> method
            be called after the appenders properties have been configured.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Appender.IAppender.Close">
      <summary>
            Closes the appender and releases resources.
            </summary>
      <remarks>
        <para>
            Releases any resources allocated within the appender such as file handles, 
            network connections, etc.
            </para>
        <para>
            It is a programming error to append to a closed appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.IAppender.DoAppend(log4net.Core.LoggingEvent)">
      <summary>
            Log the logging event in Appender specific way.
            </summary>
      <param name="loggingEvent">The event to log</param>
      <remarks>
        <para>
            This method is called to log a message into this appender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.IAppender.Name">
      <summary>
            Gets or sets the name of this appender.
            </summary>
      <value>The name of the appender.</value>
      <remarks>
        <para>The name uniquely identifies the appender.</para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.IBulkAppender">
      <summary>
            Interface for appenders that support bulk logging.
            </summary>
      <remarks>
        <para>
            This interface extends the <see cref="T:log4net.Appender.IAppender" /> interface to
            support bulk logging of <see cref="T:log4net.Core.LoggingEvent" /> objects. Appenders
            should only implement this interface if they can bulk log efficiently.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Appender.IBulkAppender.DoAppend(log4net.Core.LoggingEvent[])">
      <summary>
            Log the array of logging events in Appender specific way.
            </summary>
      <param name="loggingEvents">The events to log</param>
      <remarks>
        <para>
            This method is called to log an array of events into this appender.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.IOptionHandler">
      <summary>
            Interface used to delay activate a configured object.
            </summary>
      <remarks>
        <para>
            This allows an object to defer activation of its options until all
            options have been set. This is required for components which have
            related options that remain ambiguous until all are set.
            </para>
        <para>
            If a component implements this interface then the <see cref="M:log4net.Core.IOptionHandler.ActivateOptions" /> method 
            must be called by the container after its all the configured properties have been set 
            and before the component can be used.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Core.IOptionHandler.ActivateOptions">
      <summary>
            Activate the options that were previously set with calls to properties.
            </summary>
      <remarks>
        <para>
            This allows an object to defer activation of its options until all
            options have been set. This is required for components which have
            related options that remain ambiguous until all are set.
            </para>
        <para>
            If a component implements this interface then this method must be called
            after its properties have been set before the component can be used.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.AppenderSkeleton">
      <summary>
            Abstract base class implementation of <see cref="T:log4net.Appender.IAppender" />. 
            </summary>
      <remarks>
        <para>
            This class provides the code for common functionality, such 
            as support for threshold filtering and support for general filters.
            </para>
        <para>
            Appenders can also implement the <see cref="T:log4net.Core.IOptionHandler" /> interface. Therefore
            they would require that the <see cref="M:log4net.Core.IOptionHandler.ActivateOptions" /> method
            be called after the appenders properties have been configured.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.c_renderBufferSize">
      <summary>
            Initial buffer size
            </summary>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.c_renderBufferMaxCapacity">
      <summary>
            Maximum buffer size before it is recycled
            </summary>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_layout">
      <summary>
            The layout of this appender.
            </summary>
      <remarks>
            See <see cref="P:log4net.Appender.AppenderSkeleton.Layout" /> for more information.
            </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_name">
      <summary>
            The name of this appender.
            </summary>
      <remarks>
            See <see cref="P:log4net.Appender.AppenderSkeleton.Name" /> for more information.
            </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_threshold">
      <summary>
            The level threshold of this appender.
            </summary>
      <remarks>
        <para>
            There is no level threshold filtering by default.
            </para>
        <para>
            See <see cref="P:log4net.Appender.AppenderSkeleton.Threshold" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_errorHandler">
      <summary>
            It is assumed and enforced that errorHandler is never null.
            </summary>
      <remarks>
        <para>
            It is assumed and enforced that errorHandler is never null.
            </para>
        <para>
            See <see cref="P:log4net.Appender.AppenderSkeleton.ErrorHandler" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_headFilter">
      <summary>
            The first filter in the filter chain.
            </summary>
      <remarks>
        <para>
            Set to <c>null</c> initially.
            </para>
        <para>
            See <see cref="T:log4net.Filter.IFilter" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_tailFilter">
      <summary>
            The last filter in the filter chain.
            </summary>
      <remarks>
            See <see cref="T:log4net.Filter.IFilter" /> for more information.
            </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_closed">
      <summary>
            Flag indicating if this appender is closed.
            </summary>
      <remarks>
            See <see cref="M:log4net.Appender.AppenderSkeleton.Close" /> for more information.
            </remarks>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_recursiveGuard">
      <summary>
            The guard prevents an appender from repeatedly calling its own DoAppend method
            </summary>
    </member>
    <member name="F:log4net.Appender.AppenderSkeleton.m_renderWriter">
      <summary>
            StringWriter used to render events
            </summary>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>Empty default constructor</para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.Finalize">
      <summary>
            Finalizes this appender by calling the implementation's 
            <see cref="M:log4net.Appender.AppenderSkeleton.Close" /> method.
            </summary>
      <remarks>
        <para>
            If this appender has not been closed then the <c>Finalize</c> method
            will call <see cref="M:log4net.Appender.AppenderSkeleton.Close" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.ActivateOptions">
      <summary>
            Initialize the appender based on the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.AppenderSkeleton.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.AppenderSkeleton.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.AppenderSkeleton.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.Close">
      <summary>
            Closes the appender and release resources.
            </summary>
      <remarks>
        <para>
            Release any resources allocated within the appender such as file handles, 
            network connections, etc.
            </para>
        <para>
            It is a programming error to append to a closed appender.
            </para>
        <para>
            This method cannot be overridden by subclasses. This method 
            delegates the closing of the appender to the <see cref="M:log4net.Appender.AppenderSkeleton.OnClose" />
            method which must be overridden in the subclass.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)">
      <summary>
            Performs threshold checks and invokes filters before 
            delegating actual logging to the subclasses specific 
            <see cref="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            This method cannot be overridden by derived classes. A
            derived class should override the <see cref="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent)" /> method
            which is called by this method.
            </para>
        <para>
            The implementation of this method is as follows:
            </para>
        <para>
          <list type="bullet">
            <item>
              <description>
            		Checks that the severity of the <paramref name="loggingEvent" />
            		is greater than or equal to the <see cref="P:log4net.Appender.AppenderSkeleton.Threshold" /> of this
            		appender.</description>
            </item>
            <item>
              <description>
            		Checks that the <see cref="T:log4net.Filter.IFilter" /> chain accepts the 
            		<paramref name="loggingEvent" />.
            		</description>
            </item>
            <item>
              <description>
            		Calls <see cref="M:log4net.Appender.AppenderSkeleton.PreAppendCheck" /> and checks that 
            		it returns <c>true</c>.</description>
            </item>
          </list>
        </para>
        <para>
            If all of the above steps succeed then the <paramref name="loggingEvent" />
            will be passed to the abstract <see cref="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent)" /> method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent[])">
      <summary>
            Performs threshold checks and invokes filters before 
            delegating actual logging to the subclasses specific 
            <see cref="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent[])" /> method.
            </summary>
      <param name="loggingEvents">The array of events to log.</param>
      <remarks>
        <para>
            This method cannot be overridden by derived classes. A
            derived class should override the <see cref="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent[])" /> method
            which is called by this method.
            </para>
        <para>
            The implementation of this method is as follows:
            </para>
        <para>
          <list type="bullet">
            <item>
              <description>
            		Checks that the severity of the <paramref name="loggingEvent" />
            		is greater than or equal to the <see cref="P:log4net.Appender.AppenderSkeleton.Threshold" /> of this
            		appender.</description>
            </item>
            <item>
              <description>
            		Checks that the <see cref="T:log4net.Filter.IFilter" /> chain accepts the 
            		<paramref name="loggingEvent" />.
            		</description>
            </item>
            <item>
              <description>
            		Calls <see cref="M:log4net.Appender.AppenderSkeleton.PreAppendCheck" /> and checks that 
            		it returns <c>true</c>.</description>
            </item>
          </list>
        </para>
        <para>
            If all of the above steps succeed then the <paramref name="loggingEvents" />
            will be passed to the <see cref="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent[])" /> method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.FilterEvent(log4net.Core.LoggingEvent)">
      <summary>
            Test if the logging event should we output by this appender
            </summary>
      <param name="loggingEvent">the event to test</param>
      <returns>
        <c>true</c> if the event should be output, <c>false</c> if the event should be ignored</returns>
      <remarks>
        <para>
            This method checks the logging event against the threshold level set
            on this appender and also against the filters specified on this
            appender.
            </para>
        <para>
            The implementation of this method is as follows:
            </para>
        <para>
          <list type="bullet">
            <item>
              <description>
            		Checks that the severity of the <paramref name="loggingEvent" />
            		is greater than or equal to the <see cref="P:log4net.Appender.AppenderSkeleton.Threshold" /> of this
            		appender.</description>
            </item>
            <item>
              <description>
            		Checks that the <see cref="T:log4net.Filter.IFilter" /> chain accepts the 
            		<paramref name="loggingEvent" />.
            		</description>
            </item>
          </list>
        </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.AddFilter(log4net.Filter.IFilter)">
      <summary>
            Adds a filter to the end of the filter chain.
            </summary>
      <param name="filter">the filter to add to this appender</param>
      <remarks>
        <para>
            The Filters are organized in a linked list.
            </para>
        <para>
            Setting this property causes the new filter to be pushed onto the 
            back of the filter chain.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.ClearFilters">
      <summary>
            Clears the filter list for this appender.
            </summary>
      <remarks>
        <para>
            Clears the filter list for this appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.IsAsSevereAsThreshold(log4net.Core.Level)">
      <summary>
            Checks if the message level is below this appender's threshold.
            </summary>
      <param name="level">
        <see cref="T:log4net.Core.Level" /> to test against.</param>
      <remarks>
        <para>
            If there is no threshold set, then the return value is always <c>true</c>.
            </para>
      </remarks>
      <returns>
        <c>true</c> if the <paramref name="level" /> meets the <see cref="P:log4net.Appender.AppenderSkeleton.Threshold" /> 
            requirements of this appender.
            </returns>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.OnClose">
      <summary>
            Is called when the appender is closed. Derived classes should override 
            this method if resources need to be released.
            </summary>
      <remarks>
        <para>
            Releases any resources allocated within the appender such as file handles, 
            network connections, etc.
            </para>
        <para>
            It is a programming error to append to a closed appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent)">
      <summary>
            Subclasses of <see cref="T:log4net.Appender.AppenderSkeleton" /> should implement this method 
            to perform actual logging.
            </summary>
      <param name="loggingEvent">The event to append.</param>
      <remarks>
        <para>
            A subclass must implement this method to perform
            logging of the <paramref name="loggingEvent" />.
            </para>
        <para>This method will be called by <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" />
            if all the conditions listed for that method are met.
            </para>
        <para>
            To restrict the logging of events in the appender
            override the <see cref="M:log4net.Appender.AppenderSkeleton.PreAppendCheck" /> method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent[])">
      <summary>
            Append a bulk array of logging events.
            </summary>
      <param name="loggingEvents">the array of logging events</param>
      <remarks>
        <para>
            This base class implementation calls the <see cref="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent)" />
            method for each element in the bulk array.
            </para>
        <para>
            A sub class that can better process a bulk array of events should
            override this method in addition to <see cref="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent)" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.PreAppendCheck">
      <summary>
            Called before <see cref="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent)" /> as a precondition.
            </summary>
      <remarks>
        <para>
            This method is called by <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" />
            before the call to the abstract <see cref="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent)" /> method.
            </para>
        <para>
            This method can be overridden in a subclass to extend the checks 
            made before the event is passed to the <see cref="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent)" /> method.
            </para>
        <para>
            A subclass should ensure that they delegate this call to
            this base class if it is overridden.
            </para>
      </remarks>
      <returns>
        <c>true</c> if the call to <see cref="M:log4net.Appender.AppenderSkeleton.Append(log4net.Core.LoggingEvent)" /> should proceed.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.RenderLoggingEvent(log4net.Core.LoggingEvent)">
      <summary>
            Renders the <see cref="T:log4net.Core.LoggingEvent" /> to a string.
            </summary>
      <param name="loggingEvent">The event to render.</param>
      <returns>The event rendered as a string.</returns>
      <remarks>
        <para>
            Helper method to render a <see cref="T:log4net.Core.LoggingEvent" /> to 
            a string. This appender must have a <see cref="P:log4net.Appender.AppenderSkeleton.Layout" />
            set to render the <paramref name="loggingEvent" /> to 
            a string.
            </para>
        <para>If there is exception data in the logging event and 
            the layout does not process the exception, this method 
            will append the exception text to the rendered string.
            </para>
        <para>
            Where possible use the alternative version of this method
            <see cref="M:log4net.Appender.AppenderSkeleton.RenderLoggingEvent(System.IO.TextWriter,log4net.Core.LoggingEvent)" />.
            That method streams the rendering onto an existing Writer
            which can give better performance if the caller already has
            a <see cref="T:System.IO.TextWriter" /> open and ready for writing.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AppenderSkeleton.RenderLoggingEvent(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Renders the <see cref="T:log4net.Core.LoggingEvent" /> to a string.
            </summary>
      <param name="loggingEvent">The event to render.</param>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <remarks>
        <para>
            Helper method to render a <see cref="T:log4net.Core.LoggingEvent" /> to 
            a string. This appender must have a <see cref="P:log4net.Appender.AppenderSkeleton.Layout" />
            set to render the <paramref name="loggingEvent" /> to 
            a string.
            </para>
        <para>If there is exception data in the logging event and 
            the layout does not process the exception, this method 
            will append the exception text to the rendered string.
            </para>
        <para>
            Use this method in preference to <see cref="M:log4net.Appender.AppenderSkeleton.RenderLoggingEvent(log4net.Core.LoggingEvent)" />
            where possible. If, however, the caller needs to render the event
            to a string then <see cref="M:log4net.Appender.AppenderSkeleton.RenderLoggingEvent(log4net.Core.LoggingEvent)" /> does
            provide an efficient mechanism for doing so.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AppenderSkeleton.Threshold">
      <summary>
            Gets or sets the threshold <see cref="T:log4net.Core.Level" /> of this appender.
            </summary>
      <value>
            The threshold <see cref="T:log4net.Core.Level" /> of the appender. 
            </value>
      <remarks>
        <para>
            All log events with lower level than the threshold level are ignored 
            by the appender.
            </para>
        <para>
            In configuration files this option is specified by setting the
            value of the <see cref="P:log4net.Appender.AppenderSkeleton.Threshold" /> option to a level
            string, such as "DEBUG", "INFO" and so on.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AppenderSkeleton.ErrorHandler">
      <summary>
            Gets or sets the <see cref="T:log4net.Core.IErrorHandler" /> for this appender.
            </summary>
      <value>The <see cref="T:log4net.Core.IErrorHandler" /> of the appender</value>
      <remarks>
        <para>
            The <see cref="T:log4net.Appender.AppenderSkeleton" /> provides a default 
            implementation for the <see cref="P:log4net.Appender.AppenderSkeleton.ErrorHandler" /> property. 
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AppenderSkeleton.FilterHead">
      <summary>
            The filter chain.
            </summary>
      <value>The head of the filter chain filter chain.</value>
      <remarks>
        <para>
            Returns the head Filter. The Filters are organized in a linked list
            and so all Filters on this Appender are available through the result.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AppenderSkeleton.Layout">
      <summary>
            Gets or sets the <see cref="T:log4net.Layout.ILayout" /> for this appender.
            </summary>
      <value>The layout of the appender.</value>
      <remarks>
        <para>
            See <see cref="P:log4net.Appender.AppenderSkeleton.RequiresLayout" /> for more information.
            </para>
      </remarks>
      <seealso cref="P:log4net.Appender.AppenderSkeleton.RequiresLayout" />
    </member>
    <member name="P:log4net.Appender.AppenderSkeleton.Name">
      <summary>
            Gets or sets the name of this appender.
            </summary>
      <value>The name of the appender.</value>
      <remarks>
        <para>
            The name uniquely identifies the appender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AppenderSkeleton.RequiresLayout">
      <summary>
            Tests if this appender requires a <see cref="P:log4net.Appender.AppenderSkeleton.Layout" /> to be set.
            </summary>
      <remarks>
        <para>
            In the rather exceptional case, where the appender 
            implementation admits a layout but can also work without it, 
            then the appender should return <c>true</c>.
            </para>
        <para>
            This default implementation always returns <c>true</c>.
            </para>
      </remarks>
      <returns>
        <c>true</c> if the appender requires a layout object, otherwise <c>false</c>.
            </returns>
    </member>
    <member name="T:log4net.Appender.BufferingAppenderSkeleton">
      <summary>
            Abstract base class implementation of <see cref="T:log4net.Appender.IAppender" /> that 
            buffers events in a fixed size buffer.
            </summary>
      <remarks>
        <para>
            This base class should be used by appenders that need to buffer a 
            number of events before logging them. For example the <see cref="T:log4net.Appender.AdoNetAppender" /> 
            buffers events and then submits the entire contents of the buffer to 
            the underlying database in one go.
            </para>
        <para>
            Subclasses should override the <see cref="M:log4net.Appender.BufferingAppenderSkeleton.SendBuffer(log4net.Core.LoggingEvent[])" />
            method to deliver the buffered events.
            </para>
        <para>The BufferingAppenderSkeleton maintains a fixed size cyclic 
            buffer of events. The size of the buffer is set using 
            the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> property.
            </para>
        <para>A <see cref="T:log4net.Core.ITriggeringEventEvaluator" /> is used to inspect 
            each event as it arrives in the appender. If the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> 
            triggers, then the current buffer is sent immediately 
            (see <see cref="M:log4net.Appender.BufferingAppenderSkeleton.SendBuffer(log4net.Core.LoggingEvent[])" />). Otherwise the event 
            is stored in the buffer. For example, an evaluator can be used to 
            deliver the events immediately when an ERROR event arrives.
            </para>
        <para>
            The buffering appender can be configured in a <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> mode. 
            By default the appender is NOT lossy. When the buffer is full all 
            the buffered events are sent with <see cref="M:log4net.Appender.BufferingAppenderSkeleton.SendBuffer(log4net.Core.LoggingEvent[])" />.
            If the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> property is set to <c>true</c> then the 
            buffer will not be sent when it is full, and new events arriving 
            in the appender will overwrite the oldest event in the buffer. 
            In lossy mode the buffer will only be sent when the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" />
            triggers. This can be useful behavior when you need to know about 
            ERROR events but not about events with a lower level, configure an 
            evaluator that will trigger when an ERROR event arrives, the whole 
            buffer will be sent which gives a history of events leading up to
            the ERROR event.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.DEFAULT_BUFFER_SIZE">
      <summary>
            The default buffer size.
            </summary>
      <remarks>
            The default size of the cyclic buffer used to store events.
            This is set to 512 by default.
            </remarks>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_bufferSize">
      <summary>
            The size of the cyclic buffer used to hold the logging events.
            </summary>
      <remarks>
            Set to <see cref="F:log4net.Appender.BufferingAppenderSkeleton.DEFAULT_BUFFER_SIZE" /> by default.
            </remarks>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_cb">
      <summary>
            The cyclic buffer used to store the logging events.
            </summary>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_evaluator">
      <summary>
            The triggering event evaluator that causes the buffer to be sent immediately.
            </summary>
      <remarks>
            The object that is used to determine if an event causes the entire
            buffer to be sent immediately. This field can be <c>null</c>, which 
            indicates that event triggering is not to be done. The evaluator
            can be set using the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> property. If this appender
            has the <see cref="F:log4net.Appender.BufferingAppenderSkeleton.m_lossy" /> (<see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> property) set to 
            <c>true</c> then an <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> must be set.
            </remarks>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_lossy">
      <summary>
            Indicates if the appender should overwrite events in the cyclic buffer 
            when it becomes full, or if the buffer should be flushed when the 
            buffer is full.
            </summary>
      <remarks>
            If this field is set to <c>true</c> then an <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> must 
            be set.
            </remarks>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_lossyEvaluator">
      <summary>
            The triggering event evaluator filters discarded events.
            </summary>
      <remarks>
            The object that is used to determine if an event that is discarded should
            really be discarded or if it should be sent to the appenders. 
            This field can be <c>null</c>, which indicates that all discarded events will
            be discarded. 
            </remarks>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_fixFlags">
      <summary>
            Value indicating which fields in the event should be fixed
            </summary>
      <remarks>
            By default all fields are fixed
            </remarks>
    </member>
    <member name="F:log4net.Appender.BufferingAppenderSkeleton.m_eventMustBeFixed">
      <summary>
            The events delivered to the subclass must be fixed.
            </summary>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.BufferingAppenderSkeleton" /> class.
            </summary>
      <remarks>
        <para>
            Protected default constructor to allow subclassing.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.BufferingAppenderSkeleton" /> class.
            </summary>
      <param name="eventMustBeFixed">the events passed through this appender must be
            fixed by the time that they arrive in the derived class' <c>SendBuffer</c> method.</param>
      <remarks>
        <para>
            Protected constructor to allow subclassing.
            </para>
        <para>
            The <paramref name="eventMustBeFixed" /> should be set if the subclass
            expects the events delivered to be fixed even if the 
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> is set to zero, i.e. when no buffering occurs.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.Flush">
      <summary>
            Flush the currently buffered events
            </summary>
      <remarks>
        <para>
            Flushes any events that have been buffered.
            </para>
        <para>
            If the appender is buffering in <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> mode then the contents
            of the buffer will NOT be flushed to the appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.Flush(System.Boolean)">
      <summary>
            Flush the currently buffered events
            </summary>
      <param name="flushLossyBuffer">set to <c>true</c> to flush the buffer of lossy events</param>
      <remarks>
        <para>
            Flushes events that have been buffered. If <paramref name="flushLossyBuffer" /> is
            <c>false</c> then events will only be flushed if this buffer is non-lossy mode.
            </para>
        <para>
            If the appender is buffering in <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> mode then the contents
            of the buffer will only be flushed if <paramref name="flushLossyBuffer" /> is <c>true</c>.
            In this case the contents of the buffer will be tested against the 
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.LossyEvaluator" /> and if triggering will be output. All other buffered
            events will be discarded.
            </para>
        <para>
            If <paramref name="flushLossyBuffer" /> is <c>true</c> then the buffer will always
            be emptied by calling this method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.ActivateOptions">
      <summary>
            Initialize the appender based on the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.BufferingAppenderSkeleton.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.BufferingAppenderSkeleton.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.BufferingAppenderSkeleton.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.OnClose">
      <summary>
            Close this appender instance.
            </summary>
      <remarks>
        <para>
            Close this appender instance. If this appender is marked
            as not <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> then the remaining events in 
            the buffer must be sent when the appender is closed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" /> method. 
            </summary>
      <param name="loggingEvent">the event to log</param>
      <remarks>
        <para>
            Stores the <paramref name="loggingEvent" /> in the cyclic buffer.
            </para>
        <para>
            The buffer will be sent (i.e. passed to the <see cref="M:log4net.Appender.BufferingAppenderSkeleton.SendBuffer(log4net.Core.LoggingEvent[])" /> 
            method) if one of the following conditions is met:
            </para>
        <list type="bullet">
          <item>
            <description>The cyclic buffer is full and this appender is
            		marked as not lossy (see <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" />)</description>
          </item>
          <item>
            <description>An <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> is set and
            		it is triggered for the <paramref name="loggingEvent" />
            		specified.</description>
          </item>
        </list>
        <para>
            Before the event is stored in the buffer it is fixed
            (see <see cref="M:log4net.Core.LoggingEvent.FixVolatileData(log4net.Core.FixFlags)" />) to ensure that
            any data referenced by the event will be valid when the buffer
            is processed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.SendFromBuffer(log4net.Core.LoggingEvent,log4net.Util.CyclicBuffer)">
      <summary>
            Sends the contents of the buffer.
            </summary>
      <param name="firstLoggingEvent">The first logging event.</param>
      <param name="buffer">The buffer containing the events that need to be send.</param>
      <remarks>
        <para>
            The subclass must override <see cref="M:log4net.Appender.BufferingAppenderSkeleton.SendBuffer(log4net.Core.LoggingEvent[])" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingAppenderSkeleton.SendBuffer(log4net.Core.LoggingEvent[])">
      <summary>
            Sends the events.
            </summary>
      <param name="events">The events that need to be send.</param>
      <remarks>
        <para>
            The subclass must override this method to process the buffered events.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingAppenderSkeleton.Lossy">
      <summary>
            Gets or sets a value that indicates whether the appender is lossy.
            </summary>
      <value>
        <c>true</c> if the appender is lossy, otherwise <c>false</c>. The default is <c>false</c>.
            </value>
      <remarks>
        <para>
            This appender uses a buffer to store logging events before 
            delivering them. A triggering event causes the whole buffer
            to be send to the remote sink. If the buffer overruns before
            a triggering event then logging events could be lost. Set
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> to <c>false</c> to prevent logging events 
            from being lost.
            </para>
        <para>If <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> is set to <c>true</c> then an
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> must be specified.</para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize">
      <summary>
            Gets or sets the size of the cyclic buffer used to hold the 
            logging events.
            </summary>
      <value>
            The size of the cyclic buffer used to hold the logging events.
            </value>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> option takes a positive integer
            representing the maximum number of logging events to collect in 
            a cyclic buffer. When the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> is reached,
            oldest events are deleted as new events are added to the
            buffer. By default the size of the cyclic buffer is 512 events.
            </para>
        <para>
            If the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> is set to a value less than
            or equal to 1 then no buffering will occur. The logging event
            will be delivered synchronously (depending on the <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" />
            and <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> properties). Otherwise the event will
            be buffered.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator">
      <summary>
            Gets or sets the <see cref="T:log4net.Core.ITriggeringEventEvaluator" /> that causes the 
            buffer to be sent immediately.
            </summary>
      <value>
            The <see cref="T:log4net.Core.ITriggeringEventEvaluator" /> that causes the buffer to be
            sent immediately.
            </value>
      <remarks>
        <para>
            The evaluator will be called for each event that is appended to this 
            appender. If the evaluator triggers then the current buffer will 
            immediately be sent (see <see cref="M:log4net.Appender.BufferingAppenderSkeleton.SendBuffer(log4net.Core.LoggingEvent[])" />).
            </para>
        <para>If <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Lossy" /> is set to <c>true</c> then an
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.Evaluator" /> must be specified.</para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingAppenderSkeleton.LossyEvaluator">
      <summary>
            Gets or sets the value of the <see cref="T:log4net.Core.ITriggeringEventEvaluator" /> to use.
            </summary>
      <value>
            The value of the <see cref="T:log4net.Core.ITriggeringEventEvaluator" /> to use.
            </value>
      <remarks>
        <para>
            The evaluator will be called for each event that is discarded from this 
            appender. If the evaluator triggers then the current buffer will immediately 
            be sent (see <see cref="M:log4net.Appender.BufferingAppenderSkeleton.SendBuffer(log4net.Core.LoggingEvent[])" />).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingAppenderSkeleton.OnlyFixPartialEventData">
      <summary>
            Gets or sets a value indicating if only part of the logging event data
            should be fixed.
            </summary>
      <value>
        <c>true</c> if the appender should only fix part of the logging event 
            data, otherwise <c>false</c>. The default is <c>false</c>.
            </value>
      <remarks>
        <para>
            Setting this property to <c>true</c> will cause only part of the
            event data to be fixed and serialized. This will improve performance.
            </para>
        <para>
            See <see cref="M:log4net.Core.LoggingEvent.FixVolatileData(log4net.Core.FixFlags)" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingAppenderSkeleton.Fix">
      <summary>
            Gets or sets a the fields that will be fixed in the event
            </summary>
      <value>
            The event fields that will be fixed before the event is buffered
            </value>
      <remarks>
        <para>
            The logging event needs to have certain thread specific values 
            captured before it can be buffered. See <see cref="P:log4net.Core.LoggingEvent.Fix" />
            for details.
            </para>
      </remarks>
      <seealso cref="P:log4net.Core.LoggingEvent.Fix" />
    </member>
    <member name="T:log4net.Appender.AdoNetAppender">
      <summary>
            Appender that logs to a database.
            </summary>
      <remarks>
        <para>
          <see cref="T:log4net.Appender.AdoNetAppender" /> appends logging events to a table within a
            database. The appender can be configured to specify the connection 
            string by setting the <see cref="P:log4net.Appender.AdoNetAppender.ConnectionString" /> property. 
            The connection type (provider) can be specified by setting the <see cref="P:log4net.Appender.AdoNetAppender.ConnectionType" />
            property. For more information on database connection strings for
            your specific database see <a href="http://www.connectionstrings.com/">http://www.connectionstrings.com/</a>.
            </para>
        <para>
            Records are written into the database either using a prepared
            statement or a stored procedure. The <see cref="P:log4net.Appender.AdoNetAppender.CommandType" /> property
            is set to <see cref="F:System.Data.CommandType.Text" /> (<c>System.Data.CommandType.Text</c>) to specify a prepared statement
            or to <see cref="F:System.Data.CommandType.StoredProcedure" /> (<c>System.Data.CommandType.StoredProcedure</c>) to specify a stored
            procedure.
            </para>
        <para>
            The prepared statement text or the name of the stored procedure
            must be set in the <see cref="P:log4net.Appender.AdoNetAppender.CommandText" /> property.
            </para>
        <para>
            The prepared statement or stored procedure can take a number
            of parameters. Parameters are added using the <see cref="M:log4net.Appender.AdoNetAppender.AddParameter(log4net.Appender.AdoNetAppenderParameter)" />
            method. This adds a single <see cref="T:log4net.Appender.AdoNetAppenderParameter" /> to the
            ordered list of parameters. The <see cref="T:log4net.Appender.AdoNetAppenderParameter" />
            type may be subclassed if required to provide database specific
            functionality. The <see cref="T:log4net.Appender.AdoNetAppenderParameter" /> specifies
            the parameter name, database type, size, and how the value should
            be generated using a <see cref="T:log4net.Layout.ILayout" />.
            </para>
      </remarks>
      <example>
            An example of a SQL Server table that could be logged to:
            <code lang="SQL">
            CREATE TABLE [dbo].[Log] ( 
              [ID] [int] IDENTITY (1, 1) NOT NULL ,
              [Date] [datetime] NOT NULL ,
              [Thread] [varchar] (255) NOT NULL ,
              [Level] [varchar] (20) NOT NULL ,
              [Logger] [varchar] (255) NOT NULL ,
              [Message] [varchar] (4000) NOT NULL 
            ) ON [PRIMARY]
            </code></example>
      <example>
            An example configuration to log to the above table:
            <code lang="XML" escaped="true"><appender name="AdoNetAppender_SqlServer" type="log4net.Appender.AdoNetAppender"><connectionType value="System.Data.SqlClient.SqlConnection, System.Data, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" /><connectionString value="data source=SQLSVR;initial catalog=test_log4net;integrated security=false;persist security info=True;User ID=sa;Password=sa" /><commandText value="INSERT INTO Log ([Date],[Thread],[Level],[Logger],[Message]) VALUES (@log_date, @thread, @log_level, @logger, @message)" /><parameter><parameterName value="@log_date" /><dbType value="DateTime" /><layout type="log4net.Layout.PatternLayout" value="%date{yyyy'-'MM'-'dd HH':'mm':'ss'.'fff}" /></parameter><parameter><parameterName value="@thread" /><dbType value="String" /><size value="255" /><layout type="log4net.Layout.PatternLayout" value="%thread" /></parameter><parameter><parameterName value="@log_level" /><dbType value="String" /><size value="50" /><layout type="log4net.Layout.PatternLayout" value="%level" /></parameter><parameter><parameterName value="@logger" /><dbType value="String" /><size value="255" /><layout type="log4net.Layout.PatternLayout" value="%logger" /></parameter><parameter><parameterName value="@message" /><dbType value="String" /><size value="4000" /><layout type="log4net.Layout.PatternLayout" value="%message" /></parameter></appender></code></example>
      <author>Julian Biddle</author>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Lance Nehring</author>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_usePreparedCommand">
      <summary>
            Flag to indicate if we are using a command object
            </summary>
      <remarks>
        <para>
            Set to <c>true</c> when the appender is to use a prepared
            statement or stored procedure to insert into the database.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_parameters">
      <summary>
            The list of <see cref="T:log4net.Appender.AdoNetAppenderParameter" /> objects.
            </summary>
      <remarks>
        <para>
            The list of <see cref="T:log4net.Appender.AdoNetAppenderParameter" /> objects.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_securityContext">
      <summary>
            The security context to use for privileged calls
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_dbConnection">
      <summary>
            The <see cref="T:System.Data.IDbConnection" /> that will be used
            to insert logging events into a database.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_dbCommand">
      <summary>
            The database command.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_connectionString">
      <summary>
            Database connection string.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_connectionType">
      <summary>
            String type name of the <see cref="T:System.Data.IDbConnection" /> type name.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_commandText">
      <summary>
            The text of the command.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_commandType">
      <summary>
            The command type.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_useTransactions">
      <summary>
            Indicates whether to use transactions when writing to the database.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppender.m_reconnectOnError">
      <summary>
            Indicates whether to use transactions when writing to the database.
            </summary>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.#ctor">
      <summary> 
            Initializes a new instance of the <see cref="T:log4net.Appender.AdoNetAppender" /> class.
            </summary>
      <remarks>
            Public default constructor to initialize a new instance of this class.
            </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.AdoNetAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.AdoNetAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.AdoNetAppender.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.OnClose">
      <summary>
            Override the parent method to close the database
            </summary>
      <remarks>
        <para>
            Closes the database command and database connection.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.SendBuffer(log4net.Core.LoggingEvent[])">
      <summary>
            Inserts the events into the database.
            </summary>
      <param name="events">The events to insert into the database.</param>
      <remarks>
        <para>
            Insert all the events specified in the <paramref name="events" />
            array into the database.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.AddParameter(log4net.Appender.AdoNetAppenderParameter)">
      <summary>
            Adds a parameter to the command.
            </summary>
      <param name="parameter">The parameter to add to the command.</param>
      <remarks>
        <para>
            Adds a parameter to the ordered list of command parameters.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.SendBuffer(System.Data.IDbTransaction,log4net.Core.LoggingEvent[])">
      <summary>
            Writes the events to the database using the transaction specified.
            </summary>
      <param name="dbTran">The transaction that the events will be executed under.</param>
      <param name="events">The array of events to insert into the database.</param>
      <remarks>
        <para>
            The transaction argument can be <c>null</c> if the appender has been
            configured not to use transactions. See <see cref="P:log4net.Appender.AdoNetAppender.UseTransactions" />
            property for more information.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.GetLogStatement(log4net.Core.LoggingEvent)">
      <summary>
            Formats the log message into database statement text.
            </summary>
      <param name="logEvent">The event being logged.</param>
      <remarks>
            This method can be overridden by subclasses to provide 
            more control over the format of the database statement.
            </remarks>
      <returns>
            Text that can be passed to a <see cref="T:System.Data.IDbCommand" />.
            </returns>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.InitializeDatabaseConnection">
      <summary>
            Connects to the database.
            </summary>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.ResolveConnectionType">
      <summary>
            Retrieves the class type of the ADO.NET provider.
            </summary>
      <remarks>
        <para>
            Gets the Type of the ADO.NET provider to use to connect to the
            database. This method resolves the type specified in the 
            <see cref="P:log4net.Appender.AdoNetAppender.ConnectionType" /> property.
            </para>
        <para>
            Subclasses can override this method to return a different type
            if necessary.
            </para>
      </remarks>
      <returns>The <see cref="T:System.Type" /> of the ADO.NET provider</returns>
    </member>
    <member name="M:log4net.Appender.AdoNetAppender.InitializeDatabaseCommand">
      <summary>
            Prepares the database command and initialize the parameters.
            </summary>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.ConnectionString">
      <summary>
            Gets or sets the database connection string that is used to connect to 
            the database.
            </summary>
      <value>
            The database connection string used to connect to the database.
            </value>
      <remarks>
        <para>
            The connections string is specific to the connection type.
            See <see cref="P:log4net.Appender.AdoNetAppender.ConnectionType" /> for more information.
            </para>
      </remarks>
      <example>Connection string for MS Access via ODBC:
            <code>"DSN=MS Access Database;UID=admin;PWD=;SystemDB=C:\data\System.mdw;SafeTransactions = 0;FIL=MS Access;DriverID = 25;DBQ=C:\data\train33.mdb"</code></example>
      <example>Another connection string for MS Access via ODBC:
            <code>"Driver={Microsoft Access Driver (*.mdb)};DBQ=C:\Work\cvs_root\log4net-1.2\access.mdb;UID=;PWD=;"</code></example>
      <example>Connection string for MS Access via OLE DB:
            <code>"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=C:\Work\cvs_root\log4net-1.2\access.mdb;User Id=;Password=;"</code></example>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.ConnectionType">
      <summary>
            Gets or sets the type name of the <see cref="T:System.Data.IDbConnection" /> connection
            that should be created.
            </summary>
      <value>
            The type name of the <see cref="T:System.Data.IDbConnection" /> connection.
            </value>
      <remarks>
        <para>
            The type name of the ADO.NET provider to use.
            </para>
        <para>
            The default is to use the OLE DB provider.
            </para>
      </remarks>
      <example>Use the OLE DB Provider. This is the default value.
            <code>System.Data.OleDb.OleDbConnection, System.Data, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</code></example>
      <example>Use the MS SQL Server Provider. 
            <code>System.Data.SqlClient.SqlConnection, System.Data, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</code></example>
      <example>Use the ODBC Provider. 
            <code>Microsoft.Data.Odbc.OdbcConnection,Microsoft.Data.Odbc,version=1.0.3300.0,publicKeyToken=b77a5c561934e089,culture=neutral</code>
            This is an optional package that you can download from 
            <a href="http://msdn.microsoft.com/downloads">http://msdn.microsoft.com/downloads</a> 
            search for <b>ODBC .NET Data Provider</b>.
            </example>
      <example>Use the Oracle Provider. 
            <code>System.Data.OracleClient.OracleConnection, System.Data.OracleClient, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</code>
            This is an optional package that you can download from 
            <a href="http://msdn.microsoft.com/downloads">http://msdn.microsoft.com/downloads</a> 
            search for <b>.NET Managed Provider for Oracle</b>.
            </example>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.CommandText">
      <summary>
            Gets or sets the command text that is used to insert logging events
            into the database.
            </summary>
      <value>
            The command text used to insert logging events into the database.
            </value>
      <remarks>
        <para>
            Either the text of the prepared statement or the
            name of the stored procedure to execute to write into
            the database.
            </para>
        <para>
            The <see cref="P:log4net.Appender.AdoNetAppender.CommandType" /> property determines if
            this text is a prepared statement or a stored procedure.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.CommandType">
      <summary>
            Gets or sets the command type to execute.
            </summary>
      <value>
            The command type to execute.
            </value>
      <remarks>
        <para>
            This value may be either <see cref="F:System.Data.CommandType.Text" /> (<c>System.Data.CommandType.Text</c>) to specify
            that the <see cref="P:log4net.Appender.AdoNetAppender.CommandText" /> is a prepared statement to execute, 
            or <see cref="F:System.Data.CommandType.StoredProcedure" /> (<c>System.Data.CommandType.StoredProcedure</c>) to specify that the
            <see cref="P:log4net.Appender.AdoNetAppender.CommandText" /> property is the name of a stored procedure
            to execute.
            </para>
        <para>
            The default value is <see cref="F:System.Data.CommandType.Text" /> (<c>System.Data.CommandType.Text</c>).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.UseTransactions">
      <summary>
            Should transactions be used to insert logging events in the database.
            </summary>
      <value>
        <c>true</c> if transactions should be used to insert logging events in
            the database, otherwise <c>false</c>. The default value is <c>true</c>.
            </value>
      <remarks>
        <para>
            Gets or sets a value that indicates whether transactions should be used
            to insert logging events in the database.
            </para>
        <para>
            When set a single transaction will be used to insert the buffered events
            into the database. Otherwise each event will be inserted without using
            an explicit transaction.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.SecurityContext">
      <summary>
            Gets or sets the <see cref="P:log4net.Appender.AdoNetAppender.SecurityContext" /> used to call the NetSend method.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.AdoNetAppender.SecurityContext" /> used to call the NetSend method.
            </value>
      <remarks>
        <para>
            Unless a <see cref="P:log4net.Appender.AdoNetAppender.SecurityContext" /> specified here for this appender
            the <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> is queried for the
            security context to use. The default behavior is to use the security context
            of the current thread.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.ReconnectOnError">
      <summary>
            Should this appender try to reconnect to the database on error.
            </summary>
      <value>
        <c>true</c> if the appender should try to reconnect to the database after an
            error has occurred, otherwise <c>false</c>. The default value is <c>false</c>, 
            i.e. not to try to reconnect.
            </value>
      <remarks>
        <para>
            The default behaviour is for the appender not to try to reconnect to the
            database if an error occurs. Subsequent logging events are discarded.
            </para>
        <para>
            To force the appender to attempt to reconnect to the database set this
            property to <c>true</c>.
            </para>
        <note>
            When the appender attempts to connect to the database there may be a
            delay of up to the connection timeout specified in the connection string.
            This delay will block the calling application's thread. 
            Until the connection can be reestablished this potential delay may occur multiple times.
            </note>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppender.Connection">
      <summary>
            Gets or sets the underlying <see cref="T:System.Data.IDbConnection" />.
            </summary>
      <value>
            The underlying <see cref="T:System.Data.IDbConnection" />.
            </value>
      <remarks>
        <see cref="T:log4net.Appender.AdoNetAppender" /> creates a <see cref="T:System.Data.IDbConnection" /> to insert 
            logging events into a database.  Classes deriving from <see cref="T:log4net.Appender.AdoNetAppender" /> 
            can use this property to get or set this <see cref="T:System.Data.IDbConnection" />.  Use the 
            underlying <see cref="T:System.Data.IDbConnection" /> returned from <see cref="P:log4net.Appender.AdoNetAppender.Connection" /> if 
            you require access beyond that which <see cref="T:log4net.Appender.AdoNetAppender" /> provides.
            </remarks>
    </member>
    <member name="T:log4net.Appender.AdoNetAppenderParameter">
      <summary>
            Parameter type used by the <see cref="T:log4net.Appender.AdoNetAppender" />.
            </summary>
      <remarks>
        <para>
            This class provides the basic database parameter properties
            as defined by the <see cref="T:System.Data.IDbDataParameter" /> interface.
            </para>
        <para>This type can be subclassed to provide database specific
            functionality. The two methods that are called externally are
            <see cref="M:log4net.Appender.AdoNetAppenderParameter.Prepare(System.Data.IDbCommand)" /> and <see cref="M:log4net.Appender.AdoNetAppenderParameter.FormatValue(System.Data.IDbCommand,log4net.Core.LoggingEvent)" />.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_parameterName">
      <summary>
            The name of this parameter.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_dbType">
      <summary>
            The database type for this parameter.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_inferType">
      <summary>
            Flag to infer type rather than use the DbType
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_precision">
      <summary>
            The precision for this parameter.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_scale">
      <summary>
            The scale for this parameter.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_size">
      <summary>
            The size for this parameter.
            </summary>
    </member>
    <member name="F:log4net.Appender.AdoNetAppenderParameter.m_layout">
      <summary>
            The <see cref="T:log4net.Layout.IRawLayout" /> to use to render the
            logging event into an object for this parameter.
            </summary>
    </member>
    <member name="M:log4net.Appender.AdoNetAppenderParameter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.AdoNetAppenderParameter" /> class.
            </summary>
      <remarks>
            Default constructor for the AdoNetAppenderParameter class.
            </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppenderParameter.Prepare(System.Data.IDbCommand)">
      <summary>
            Prepare the specified database command object.
            </summary>
      <param name="command">The command to prepare.</param>
      <remarks>
        <para>
            Prepares the database command object by adding
            this parameter to its collection of parameters.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AdoNetAppenderParameter.FormatValue(System.Data.IDbCommand,log4net.Core.LoggingEvent)">
      <summary>
            Renders the logging event and set the parameter value in the command.
            </summary>
      <param name="command">The command containing the parameter.</param>
      <param name="loggingEvent">The event to be rendered.</param>
      <remarks>
        <para>
            Renders the logging event using this parameters layout
            object. Sets the value of the parameter on the command object.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppenderParameter.ParameterName">
      <summary>
            Gets or sets the name of this parameter.
            </summary>
      <value>
            The name of this parameter.
            </value>
      <remarks>
        <para>
            The name of this parameter. The parameter name
            must match up to a named parameter to the SQL stored procedure
            or prepared statement.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AdoNetAppenderParameter.DbType">
      <summary>
            Gets or sets the database type for this parameter.
            </summary>
      <value>
            The database type for this parameter.
            </value>
      <remarks>
        <para>
            The database type for this parameter. This property should
            be set to the database type from the <see cref="P:log4net.Appender.AdoNetAppenderParameter.DbType" />
            enumeration. See <see cref="P:System.Data.IDataParameter.DbType" />.
            </para>
        <para>
            This property is optional. If not specified the ADO.NET provider 
            will attempt to infer the type from the value.
            </para>
      </remarks>
      <seealso cref="P:System.Data.IDataParameter.DbType" />
    </member>
    <member name="P:log4net.Appender.AdoNetAppenderParameter.Precision">
      <summary>
            Gets or sets the precision for this parameter.
            </summary>
      <value>
            The precision for this parameter.
            </value>
      <remarks>
        <para>
            The maximum number of digits used to represent the Value.
            </para>
        <para>
            This property is optional. If not specified the ADO.NET provider 
            will attempt to infer the precision from the value.
            </para>
      </remarks>
      <seealso cref="P:System.Data.IDbDataParameter.Precision" />
    </member>
    <member name="P:log4net.Appender.AdoNetAppenderParameter.Scale">
      <summary>
            Gets or sets the scale for this parameter.
            </summary>
      <value>
            The scale for this parameter.
            </value>
      <remarks>
        <para>
            The number of decimal places to which Value is resolved.
            </para>
        <para>
            This property is optional. If not specified the ADO.NET provider 
            will attempt to infer the scale from the value.
            </para>
      </remarks>
      <seealso cref="P:System.Data.IDbDataParameter.Scale" />
    </member>
    <member name="P:log4net.Appender.AdoNetAppenderParameter.Size">
      <summary>
            Gets or sets the size for this parameter.
            </summary>
      <value>
            The size for this parameter.
            </value>
      <remarks>
        <para>
            The maximum size, in bytes, of the data within the column.
            </para>
        <para>
            This property is optional. If not specified the ADO.NET provider 
            will attempt to infer the size from the value.
            </para>
      </remarks>
      <seealso cref="P:System.Data.IDbDataParameter.Size" />
    </member>
    <member name="P:log4net.Appender.AdoNetAppenderParameter.Layout">
      <summary>
            Gets or sets the <see cref="T:log4net.Layout.IRawLayout" /> to use to 
            render the logging event into an object for this 
            parameter.
            </summary>
      <value>
            The <see cref="T:log4net.Layout.IRawLayout" /> used to render the
            logging event into an object for this parameter.
            </value>
      <remarks>
        <para>
            The <see cref="T:log4net.Layout.IRawLayout" /> that renders the value for this
            parameter.
            </para>
        <para>
            The <see cref="T:log4net.Layout.RawLayoutConverter" /> can be used to adapt
            any <see cref="T:log4net.Layout.ILayout" /> into a <see cref="T:log4net.Layout.IRawLayout" />
            for use in the property.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.AnsiColorTerminalAppender">
      <summary>
            Appends logging events to the terminal using ANSI color escape sequences.
            </summary>
      <remarks>
        <para>
            AnsiColorTerminalAppender appends log events to the standard output stream
            or the error output stream using a layout specified by the 
            user. It also allows the color of a specific level of message to be set.
            </para>
        <note>
            This appender expects the terminal to understand the VT100 control set 
            in order to interpret the color codes. If the terminal or console does not
            understand the control codes the behavior is not defined.
            </note>
        <para>
            By default, all output is written to the console's standard output stream.
            The <see cref="P:log4net.Appender.AnsiColorTerminalAppender.Target" /> property can be set to direct the output to the
            error stream.
            </para>
        <para>
            NOTE: This appender writes each message to the <c>System.Console.Out</c> or 
            <c>System.Console.Error</c> that is set at the time the event is appended.
            Therefore it is possible to programmatically redirect the output of this appender 
            (for example NUnit does this to capture program output). While this is the desired
            behavior of this appender it may have security implications in your application. 
            </para>
        <para>
            When configuring the ANSI colored terminal appender, a mapping should be
            specified to map a logging level to a color. For example:
            </para>
        <code lang="XML" escaped="true">
          <mapping>
            <level value="ERROR" />
            <foreColor value="White" />
            <backColor value="Red" />
            <attributes value="Bright,Underscore" />
          </mapping>
          <mapping>
            <level value="DEBUG" />
            <backColor value="Green" />
          </mapping>
        </code>
        <para>
            The Level is the standard log4net logging level and ForeColor and BackColor can be any
            of the following values:
            <list type="bullet"><item><term>Blue</term><description></description></item><item><term>Green</term><description></description></item><item><term>Red</term><description></description></item><item><term>White</term><description></description></item><item><term>Yellow</term><description></description></item><item><term>Purple</term><description></description></item><item><term>Cyan</term><description></description></item></list>
            These color values cannot be combined together to make new colors.
            </para>
        <para>
            The attributes can be any combination of the following:
            <list type="bullet"><item><term>Bright</term><description>foreground is brighter</description></item><item><term>Dim</term><description>foreground is dimmer</description></item><item><term>Underscore</term><description>message is underlined</description></item><item><term>Blink</term><description>foreground is blinking (does not work on all terminals)</description></item><item><term>Reverse</term><description>foreground and background are reversed</description></item><item><term>Hidden</term><description>output is hidden</description></item><item><term>Strikethrough</term><description>message has a line through it</description></item></list>
            While any of these attributes may be combined together not all combinations
            work well together, for example setting both <i>Bright</i> and <i>Dim</i> attributes makes
            no sense.
            </para>
      </remarks>
      <author>Patrick Wagstrom</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Appender.AnsiColorTerminalAppender.AnsiAttributes">
      <summary>
            The enum of possible display attributes
            </summary>
      <remarks>
        <para>
            The following flags can be combined together to
            form the ANSI color attributes.
            </para>
      </remarks>
      <seealso cref="T:log4net.Appender.AnsiColorTerminalAppender" />
    </member>
    <member name="T:log4net.Appender.AnsiColorTerminalAppender.AnsiColor">
      <summary>
            The enum of possible foreground or background color values for 
            use with the color mapping method
            </summary>
      <remarks>
        <para>
            The output can be in one for the following ANSI colors.
            </para>
      </remarks>
      <seealso cref="T:log4net.Appender.AnsiColorTerminalAppender" />
    </member>
    <member name="T:log4net.Appender.AnsiColorTerminalAppender.LevelColors">
      <summary>
            A class to act as a mapping between the level that a logging call is made at and
            the color it should be displayed as.
            </summary>
      <remarks>
        <para>
            Defines the mapping between a level and the color it should be displayed in.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AnsiColorTerminalAppender.LevelColors.ActivateOptions">
      <summary>
            Initialize the options for the object
            </summary>
      <remarks>
        <para>
            Combine the <see cref="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.ForeColor" /> and <see cref="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.BackColor" /> together
            and append the attributes.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.ForeColor">
      <summary>
            The mapped foreground color for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped foreground color for the specified level
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.BackColor">
      <summary>
            The mapped background color for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped background color for the specified level
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.Attributes">
      <summary>
            The color attributes for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The color attributes for the specified level
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.CombinedColor">
      <summary>
            The combined <see cref="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.ForeColor" />, <see cref="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.BackColor" /> and
            <see cref="P:log4net.Appender.AnsiColorTerminalAppender.LevelColors.Attributes" /> suitable for setting the ansi terminal color.
            </summary>
    </member>
    <member name="F:log4net.Appender.AnsiColorTerminalAppender.ConsoleOut">
      <summary>
            The <see cref="P:log4net.Appender.AnsiColorTerminalAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.AnsiColorTerminalAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AnsiColorTerminalAppender.ConsoleError">
      <summary>
            The <see cref="P:log4net.Appender.AnsiColorTerminalAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.AnsiColorTerminalAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.AnsiColorTerminalAppender.PostEventCodes">
      <summary>
            Ansi code to reset terminal
            </summary>
    </member>
    <member name="F:log4net.Appender.AnsiColorTerminalAppender.m_writeToErrorStream">
      <summary>
            Flag to write output to the error stream rather than the standard output stream
            </summary>
    </member>
    <member name="F:log4net.Appender.AnsiColorTerminalAppender.m_levelMapping">
      <summary>
            Mapping from level object to color value
            </summary>
    </member>
    <member name="M:log4net.Appender.AnsiColorTerminalAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.AnsiColorTerminalAppender" /> class.
            </summary>
      <remarks>
            The instance of the <see cref="T:log4net.Appender.AnsiColorTerminalAppender" /> class is set up to write 
            to the standard output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.AnsiColorTerminalAppender.AddMapping(log4net.Appender.AnsiColorTerminalAppender.LevelColors)">
      <summary>
            Add a mapping of level to color
            </summary>
      <param name="mapping">The mapping to add</param>
      <remarks>
        <para>
            Add a <see cref="T:log4net.Appender.AnsiColorTerminalAppender.LevelColors" /> mapping to this appender.
            Each mapping defines the foreground and background colours
            for a level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AnsiColorTerminalAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the event to the console.
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AnsiColorTerminalAppender.ActivateOptions">
      <summary>
            Initialize the options for this appender
            </summary>
      <remarks>
        <para>
            Initialize the level to color mappings set on this appender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AnsiColorTerminalAppender.Target">
      <summary>
            Target is the value of the console output stream.
            </summary>
      <value>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </value>
      <remarks>
        <para>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AnsiColorTerminalAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.LevelMappingEntry">
      <summary>
            An entry in the <see cref="T:log4net.Util.LevelMapping" /></summary>
      <remarks>
        <para>
            This is an abstract base class for types that are stored in the
            <see cref="T:log4net.Util.LevelMapping" /> object.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.LevelMappingEntry.#ctor">
      <summary>
            Default protected constructor
            </summary>
      <remarks>
        <para>
            Default protected constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LevelMappingEntry.ActivateOptions">
      <summary>
            Initialize any options defined on this entry
            </summary>
      <remarks>
        <para>
            Should be overridden by any classes that need to initialise based on their options
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.LevelMappingEntry.Level">
      <summary>
            The level that is the key for this mapping 
            </summary>
      <value>
            The <see cref="P:log4net.Util.LevelMappingEntry.Level" /> that is the key for this mapping 
            </value>
      <remarks>
        <para>
            Get or set the <see cref="P:log4net.Util.LevelMappingEntry.Level" /> that is the key for this
            mapping subclass.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.AppenderCollection">
      <summary>
            A strongly-typed collection of <see cref="T:log4net.Appender.IAppender" /> objects.
            </summary>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Appender.AppenderCollection.IAppenderCollectionEnumerator">
      <summary>
            Supports type-safe iteration over a <see cref="T:log4net.Appender.AppenderCollection" />.
            </summary>
      <exclude />
    </member>
    <member name="M:log4net.Appender.AppenderCollection.IAppenderCollectionEnumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element in the collection.
            </summary>
      <returns>
        <c>true</c> if the enumerator was successfully advanced to the next element; 
            <c>false</c> if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.IAppenderCollectionEnumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.IAppenderCollectionEnumerator.Current">
      <summary>
            Gets the current element in the collection.
            </summary>
    </member>
    <member name="T:log4net.Appender.AppenderCollection.Tag">
      <summary>
            Type visible only to our subclasses
            Used to access protected constructor
            </summary>
      <exclude />
    </member>
    <member name="T:log4net.Appender.AppenderCollection.Enumerator">
      <summary>
            Supports simple iteration over a <see cref="T:log4net.Appender.AppenderCollection" />.
            </summary>
      <exclude />
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Enumerator.#ctor(log4net.Appender.AppenderCollection)">
      <summary>
            Initializes a new instance of the <c>Enumerator</c> class.
            </summary>
      <param name="tc">
      </param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Enumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element in the collection.
            </summary>
      <returns>
        <c>true</c> if the enumerator was successfully advanced to the next element; 
            <c>false</c> if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Enumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.Enumerator.Current">
      <summary>
            Gets the current element in the collection.
            </summary>
    </member>
    <member name="T:log4net.Appender.AppenderCollection.ReadOnlyAppenderCollection">
      <exclude />
    </member>
    <member name="F:log4net.Appender.AppenderCollection.EmptyCollection">
      <summary>
            An empty readonly static AppenderCollection
            </summary>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.ReadOnly(log4net.Appender.AppenderCollection)">
      <summary>
            Creates a read-only wrapper for a <c>AppenderCollection</c> instance.
            </summary>
      <param name="list">list to create a readonly wrapper arround</param>
      <returns>
            An <c>AppenderCollection</c> wrapper that is read-only.
            </returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.#ctor">
      <summary>
            Initializes a new instance of the <c>AppenderCollection</c> class
            that is empty and has the default initial capacity.
            </summary>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <c>AppenderCollection</c> class
            that has the specified initial capacity.
            </summary>
      <param name="capacity">
            The number of elements that the new <c>AppenderCollection</c> is initially capable of storing.
            </param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.#ctor(log4net.Appender.AppenderCollection)">
      <summary>
            Initializes a new instance of the <c>AppenderCollection</c> class
            that contains elements copied from the specified <c>AppenderCollection</c>.
            </summary>
      <param name="c">The <c>AppenderCollection</c> whose elements are copied to the new collection.</param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.#ctor(log4net.Appender.IAppender[])">
      <summary>
            Initializes a new instance of the <c>AppenderCollection</c> class
            that contains elements copied from the specified <see cref="T:log4net.Appender.IAppender" /> array.
            </summary>
      <param name="a">The <see cref="T:log4net.Appender.IAppender" /> array whose elements are copied to the new list.</param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.#ctor(System.Collections.ICollection)">
      <summary>
            Initializes a new instance of the <c>AppenderCollection</c> class
            that contains elements copied from the specified <see cref="T:log4net.Appender.IAppender" /> collection.
            </summary>
      <param name="col">The <see cref="T:log4net.Appender.IAppender" /> collection whose elements are copied to the new list.</param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.#ctor(log4net.Appender.AppenderCollection.Tag)">
      <summary>
            Allow subclasses to avoid our default constructors
            </summary>
      <param name="tag">
      </param>
      <exclude />
    </member>
    <member name="M:log4net.Appender.AppenderCollection.CopyTo(log4net.Appender.IAppender[])">
      <summary>
            Copies the entire <c>AppenderCollection</c> to a one-dimensional
            <see cref="T:log4net.Appender.IAppender" /> array.
            </summary>
      <param name="array">The one-dimensional <see cref="T:log4net.Appender.IAppender" /> array to copy to.</param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.CopyTo(log4net.Appender.IAppender[],System.Int32)">
      <summary>
            Copies the entire <c>AppenderCollection</c> to a one-dimensional
            <see cref="T:log4net.Appender.IAppender" /> array, starting at the specified index of the target array.
            </summary>
      <param name="array">The one-dimensional <see cref="T:log4net.Appender.IAppender" /> array to copy to.</param>
      <param name="start">The zero-based index in <paramref name="array" /> at which copying begins.</param>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Add(log4net.Appender.IAppender)">
      <summary>
            Adds a <see cref="T:log4net.Appender.IAppender" /> to the end of the <c>AppenderCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Appender.IAppender" /> to be added to the end of the <c>AppenderCollection</c>.</param>
      <returns>The index at which the value has been added.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Clear">
      <summary>
            Removes all elements from the <c>AppenderCollection</c>.
            </summary>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Clone">
      <summary>
            Creates a shallow copy of the <see cref="T:log4net.Appender.AppenderCollection" />.
            </summary>
      <returns>A new <see cref="T:log4net.Appender.AppenderCollection" /> with a shallow copy of the collection data.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Contains(log4net.Appender.IAppender)">
      <summary>
            Determines whether a given <see cref="T:log4net.Appender.IAppender" /> is in the <c>AppenderCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Appender.IAppender" /> to check for.</param>
      <returns>
        <c>true</c> if <paramref name="item" /> is found in the <c>AppenderCollection</c>; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.IndexOf(log4net.Appender.IAppender)">
      <summary>
            Returns the zero-based index of the first occurrence of a <see cref="T:log4net.Appender.IAppender" />
            in the <c>AppenderCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Appender.IAppender" /> to locate in the <c>AppenderCollection</c>.</param>
      <returns>
            The zero-based index of the first occurrence of <paramref name="item" /> 
            in the entire <c>AppenderCollection</c>, if found; otherwise, -1.
            </returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Insert(System.Int32,log4net.Appender.IAppender)">
      <summary>
            Inserts an element into the <c>AppenderCollection</c> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
      <param name="item">The <see cref="T:log4net.Appender.IAppender" /> to insert.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Appender.AppenderCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.Remove(log4net.Appender.IAppender)">
      <summary>
            Removes the first occurrence of a specific <see cref="T:log4net.Appender.IAppender" /> from the <c>AppenderCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Appender.IAppender" /> to remove from the <c>AppenderCollection</c>.</param>
      <exception cref="T:System.ArgumentException">
            The specified <see cref="T:log4net.Appender.IAppender" /> was not found in the <c>AppenderCollection</c>.
            </exception>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.RemoveAt(System.Int32)">
      <summary>
            Removes the element at the specified index of the <c>AppenderCollection</c>.
            </summary>
      <param name="index">The zero-based index of the element to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Appender.AppenderCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through the <c>AppenderCollection</c>.
            </summary>
      <returns>An <see cref="T:log4net.Appender.AppenderCollection.Enumerator" /> for the entire <c>AppenderCollection</c>.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.AddRange(log4net.Appender.AppenderCollection)">
      <summary>
            Adds the elements of another <c>AppenderCollection</c> to the current <c>AppenderCollection</c>.
            </summary>
      <param name="x">The <c>AppenderCollection</c> whose elements should be added to the end of the current <c>AppenderCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Appender.AppenderCollection.Count" /> of the <c>AppenderCollection</c>.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.AddRange(log4net.Appender.IAppender[])">
      <summary>
            Adds the elements of a <see cref="T:log4net.Appender.IAppender" /> array to the current <c>AppenderCollection</c>.
            </summary>
      <param name="x">The <see cref="T:log4net.Appender.IAppender" /> array whose elements should be added to the end of the <c>AppenderCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Appender.AppenderCollection.Count" /> of the <c>AppenderCollection</c>.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.AddRange(System.Collections.ICollection)">
      <summary>
            Adds the elements of a <see cref="T:log4net.Appender.IAppender" /> collection to the current <c>AppenderCollection</c>.
            </summary>
      <param name="col">The <see cref="T:log4net.Appender.IAppender" /> collection whose elements should be added to the end of the <c>AppenderCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Appender.AppenderCollection.Count" /> of the <c>AppenderCollection</c>.</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.TrimToSize">
      <summary>
            Sets the capacity to the actual number of elements.
            </summary>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.ToArray">
      <summary>
            Return the collection elements as an array
            </summary>
      <returns>the array</returns>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.ValidateIndex(System.Int32)">
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Appender.AppenderCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Appender.AppenderCollection.ValidateIndex(System.Int32,System.Boolean)">
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Appender.AppenderCollection.Count" />.</para>
      </exception>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.Count">
      <summary>
            Gets the number of elements actually contained in the <c>AppenderCollection</c>.
            </summary>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the collection is synchronized (thread-safe).
            </summary>
      <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the collection.
            </summary>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="T:log4net.Appender.IAppender" /> at the specified index.
            </summary>
      <param name="index">The zero-based index of the element to get or set.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Appender.AppenderCollection.Count" />.</para>
      </exception>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.IsFixedSize">
      <summary>
            Gets a value indicating whether the collection has a fixed size.
            </summary>
      <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.IsReadOnly">
      <summary>
            Gets a value indicating whether the IList is read-only.
            </summary>
      <value>true if the collection is read-only; otherwise, false. The default is false</value>
    </member>
    <member name="P:log4net.Appender.AppenderCollection.Capacity">
      <summary>
            Gets or sets the number of elements the <c>AppenderCollection</c> can contain.
            </summary>
    </member>
    <member name="T:log4net.Appender.AspNetTraceAppender">
      <summary>
        <para>
            Appends log events to the ASP.NET <see cref="T:System.Web.TraceContext" /> system.
            </para>
      </summary>
      <remarks>
        <para>
            Diagnostic information and tracing messages that you specify are appended to the output 
            of the page that is sent to the requesting browser. Optionally, you can view this information
            from a separate trace viewer (Trace.axd) that displays trace information for every page in a 
            given application.
            </para>
        <para>
            Trace statements are processed and displayed only when tracing is enabled. You can control 
            whether tracing is displayed to a page, to the trace viewer, or both.
            </para>
        <para>
            The logging event is passed to the <see cref="M:System.Web.TraceContext.Write(System.String)" /> or 
            <see cref="M:System.Web.TraceContext.Warn(System.String)" /> method depending on the level of the logging event.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Appender.AspNetTraceAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.AspNetTraceAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.AspNetTraceAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Write the logging event to the ASP.NET trace
            </summary>
      <param name="loggingEvent">the event to log</param>
      <remarks>
        <para>
            Write the logging event to the ASP.NET trace
            <c>HttpContext.Current.Trace</c> 
            (<see cref="T:System.Web.TraceContext" />).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.AspNetTraceAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.IAppenderAttachable">
      <summary>
            Interface for attaching appenders to objects.
            </summary>
      <remarks>
        <para>
            Interface for attaching, removing and retrieving appenders.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Core.IAppenderAttachable.AddAppender(log4net.Appender.IAppender)">
      <summary>
            Attaches an appender.
            </summary>
      <param name="appender">The appender to add.</param>
      <remarks>
        <para>
            Add the specified appender. The implementation may
            choose to allow or deny duplicate appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IAppenderAttachable.GetAppender(System.String)">
      <summary>
            Gets an attached appender with the specified name.
            </summary>
      <param name="name">The name of the appender to get.</param>
      <returns>
            The appender with the name specified, or <c>null</c> if no appender with the
            specified name is found.
            </returns>
      <remarks>
        <para>
            Returns an attached appender with the <paramref name="name" /> specified.
            If no appender with the specified name is found <c>null</c> will be
            returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IAppenderAttachable.RemoveAllAppenders">
      <summary>
            Removes all attached appenders.
            </summary>
      <remarks>
        <para>
            Removes and closes all attached appenders
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IAppenderAttachable.RemoveAppender(log4net.Appender.IAppender)">
      <summary>
            Removes the specified appender from the list of attached appenders.
            </summary>
      <param name="appender">The appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
        <para>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IAppenderAttachable.RemoveAppender(System.String)">
      <summary>
            Removes the appender with the specified name from the list of appenders.
            </summary>
      <param name="name">The name of the appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
        <para>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.IAppenderAttachable.Appenders">
      <summary>
            Gets all attached appenders.
            </summary>
      <value>
            A collection of attached appenders.
            </value>
      <remarks>
        <para>
            Gets a collection of attached appenders.
            If there are no attached appenders the
            implementation should return an empty 
            collection rather than <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.BufferingForwardingAppender">
      <summary>
            Buffers events and then forwards them to attached appenders.
            </summary>
      <remarks>
        <para>
            The events are buffered in this appender until conditions are
            met to allow the appender to deliver the events to the attached 
            appenders. See <see cref="T:log4net.Appender.BufferingAppenderSkeleton" /> for the
            conditions that cause the buffer to be sent.
            </para>
        <para>The forwarding appender can be used to specify different 
            thresholds and filters for the same appender at different locations 
            within the hierarchy.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.BufferingForwardingAppender.m_appenderAttachedImpl">
      <summary>
            Implementation of the <see cref="T:log4net.Core.IAppenderAttachable" /> interface
            </summary>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.BufferingForwardingAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.OnClose">
      <summary>
            Closes the appender and releases resources.
            </summary>
      <remarks>
        <para>
            Releases any resources allocated within the appender such as file handles, 
            network connections, etc.
            </para>
        <para>
            It is a programming error to append to a closed appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.SendBuffer(log4net.Core.LoggingEvent[])">
      <summary>
            Send the events.
            </summary>
      <param name="events">The events that need to be send.</param>
      <remarks>
        <para>
            Forwards the events to the attached appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.AddAppender(log4net.Appender.IAppender)">
      <summary>
            Adds an <see cref="T:log4net.Appender.IAppender" /> to the list of appenders of this
            instance.
            </summary>
      <param name="newAppender">The <see cref="T:log4net.Appender.IAppender" /> to add to this appender.</param>
      <remarks>
        <para>
            If the specified <see cref="T:log4net.Appender.IAppender" /> is already in the list of
            appenders, then it won't be added again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.GetAppender(System.String)">
      <summary>
            Looks for the appender with the specified name.
            </summary>
      <param name="name">The name of the appender to lookup.</param>
      <returns>
            The appender with the specified name, or <c>null</c>.
            </returns>
      <remarks>
        <para>
            Get the named appender attached to this buffering appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.RemoveAllAppenders">
      <summary>
            Removes all previously added appenders from this appender.
            </summary>
      <remarks>
        <para>
            This is useful when re-reading configuration information.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.RemoveAppender(log4net.Appender.IAppender)">
      <summary>
            Removes the specified appender from the list of appenders.
            </summary>
      <param name="appender">The appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </remarks>
    </member>
    <member name="M:log4net.Appender.BufferingForwardingAppender.RemoveAppender(System.String)">
      <summary>
            Removes the appender with the specified name from the list of appenders.
            </summary>
      <param name="name">The name of the appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </remarks>
    </member>
    <member name="P:log4net.Appender.BufferingForwardingAppender.Appenders">
      <summary>
            Gets the appenders contained in this appender as an 
            <see cref="T:System.Collections.ICollection" />.
            </summary>
      <remarks>
            If no appenders can be found, then an <see cref="T:log4net.Util.EmptyCollection" /> 
            is returned.
            </remarks>
      <returns>
            A collection of the appenders in this appender.
            </returns>
    </member>
    <member name="T:log4net.Appender.ColoredConsoleAppender">
      <summary>
            Appends logging events to the console.
            </summary>
      <remarks>
        <para>
            ColoredConsoleAppender appends log events to the standard output stream
            or the error output stream using a layout specified by the 
            user. It also allows the color of a specific type of message to be set.
            </para>
        <para>
            By default, all output is written to the console's standard output stream.
            The <see cref="P:log4net.Appender.ColoredConsoleAppender.Target" /> property can be set to direct the output to the
            error stream.
            </para>
        <para>
            NOTE: This appender writes directly to the application's attached console
            not to the <c>System.Console.Out</c> or <c>System.Console.Error</c><c>TextWriter</c>.
            The <c>System.Console.Out</c> and <c>System.Console.Error</c> streams can be
            programmatically redirected (for example NUnit does this to capture program output).
            This appender will ignore these redirections because it needs to use Win32
            API calls to colorize the output. To respect these redirections the <see cref="T:log4net.Appender.ConsoleAppender" />
            must be used.
            </para>
        <para>
            When configuring the colored console appender, mapping should be
            specified to map a logging level to a color. For example:
            </para>
        <code lang="XML" escaped="true">
          <mapping>
            <level value="ERROR" />
            <foreColor value="White" />
            <backColor value="Red, HighIntensity" />
          </mapping>
          <mapping>
            <level value="DEBUG" />
            <backColor value="Green" />
          </mapping>
        </code>
        <para>
            The Level is the standard log4net logging level and ForeColor and BackColor can be any
            combination of the following values:
            <list type="bullet"><item><term>Blue</term><description></description></item><item><term>Green</term><description></description></item><item><term>Red</term><description></description></item><item><term>White</term><description></description></item><item><term>Yellow</term><description></description></item><item><term>Purple</term><description></description></item><item><term>Cyan</term><description></description></item><item><term>HighIntensity</term><description></description></item></list></para>
      </remarks>
      <author>Rick Hobbs</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Appender.ColoredConsoleAppender.Colors">
      <summary>
            The enum of possible color values for use with the color mapping method
            </summary>
      <remarks>
        <para>
            The following flags can be combined together to
            form the colors.
            </para>
      </remarks>
      <seealso cref="T:log4net.Appender.ColoredConsoleAppender" />
    </member>
    <member name="T:log4net.Appender.ColoredConsoleAppender.LevelColors">
      <summary>
            A class to act as a mapping between the level that a logging call is made at and
            the color it should be displayed as.
            </summary>
      <remarks>
        <para>
            Defines the mapping between a level and the color it should be displayed in.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.LevelColors.ActivateOptions">
      <summary>
            Initialize the options for the object
            </summary>
      <remarks>
        <para>
            Combine the <see cref="P:log4net.Appender.ColoredConsoleAppender.LevelColors.ForeColor" /> and <see cref="P:log4net.Appender.ColoredConsoleAppender.LevelColors.BackColor" /> together.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ColoredConsoleAppender.LevelColors.ForeColor">
      <summary>
            The mapped foreground color for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped foreground color for the specified level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ColoredConsoleAppender.LevelColors.BackColor">
      <summary>
            The mapped background color for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped background color for the specified level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ColoredConsoleAppender.LevelColors.CombinedColor">
      <summary>
            The combined <see cref="P:log4net.Appender.ColoredConsoleAppender.LevelColors.ForeColor" /> and <see cref="P:log4net.Appender.ColoredConsoleAppender.LevelColors.BackColor" /> suitable for 
            setting the console color.
            </summary>
    </member>
    <member name="F:log4net.Appender.ColoredConsoleAppender.ConsoleOut">
      <summary>
            The <see cref="P:log4net.Appender.ColoredConsoleAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.ColoredConsoleAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.ColoredConsoleAppender.ConsoleError">
      <summary>
            The <see cref="P:log4net.Appender.ColoredConsoleAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.ColoredConsoleAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.ColoredConsoleAppender.m_writeToErrorStream">
      <summary>
            Flag to write output to the error stream rather than the standard output stream
            </summary>
    </member>
    <member name="F:log4net.Appender.ColoredConsoleAppender.m_levelMapping">
      <summary>
            Mapping from level object to color value
            </summary>
    </member>
    <member name="F:log4net.Appender.ColoredConsoleAppender.m_consoleOutputWriter">
      <summary>
            The console output stream writer to write to
            </summary>
      <remarks>
        <para>
            This writer is not thread safe.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ColoredConsoleAppender" /> class.
            </summary>
      <remarks>
            The instance of the <see cref="T:log4net.Appender.ColoredConsoleAppender" /> class is set up to write 
            to the standard output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.#ctor(log4net.Layout.ILayout)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ColoredConsoleAppender" /> class
            with the specified layout.
            </summary>
      <param name="layout">the layout to use for this appender</param>
      <remarks>
            The instance of the <see cref="T:log4net.Appender.ColoredConsoleAppender" /> class is set up to write 
            to the standard output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.#ctor(log4net.Layout.ILayout,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ColoredConsoleAppender" /> class
            with the specified layout.
            </summary>
      <param name="layout">the layout to use for this appender</param>
      <param name="writeToErrorStream">flag set to <c>true</c> to write to the console error stream</param>
      <remarks>
            When <paramref name="writeToErrorStream" /> is set to <c>true</c>, output is written to
            the standard error output stream.  Otherwise, output is written to the standard
            output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.AddMapping(log4net.Appender.ColoredConsoleAppender.LevelColors)">
      <summary>
            Add a mapping of level to color - done by the config file
            </summary>
      <param name="mapping">The mapping to add</param>
      <remarks>
        <para>
            Add a <see cref="T:log4net.Appender.ColoredConsoleAppender.LevelColors" /> mapping to this appender.
            Each mapping defines the foreground and background colors
            for a level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the event to the console.
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ColoredConsoleAppender.ActivateOptions">
      <summary>
            Initialize the options for this appender
            </summary>
      <remarks>
        <para>
            Initialize the level to color mappings set on this appender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ColoredConsoleAppender.Target">
      <summary>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </summary>
      <value>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </value>
      <remarks>
        <para>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ColoredConsoleAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.ConsoleAppender">
      <summary>
            Appends logging events to the console.
            </summary>
      <remarks>
        <para>
            ConsoleAppender appends log events to the standard output stream
            or the error output stream using a layout specified by the 
            user.
            </para>
        <para>
            By default, all output is written to the console's standard output stream.
            The <see cref="P:log4net.Appender.ConsoleAppender.Target" /> property can be set to direct the output to the
            error stream.
            </para>
        <para>
            NOTE: This appender writes each message to the <c>System.Console.Out</c> or 
            <c>System.Console.Error</c> that is set at the time the event is appended.
            Therefore it is possible to programmatically redirect the output of this appender 
            (for example NUnit does this to capture program output). While this is the desired
            behavior of this appender it may have security implications in your application. 
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.ConsoleAppender.ConsoleOut">
      <summary>
            The <see cref="P:log4net.Appender.ConsoleAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.ConsoleAppender.Target" /> to use when writing to the Console 
            standard output stream.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.ConsoleAppender.ConsoleError">
      <summary>
            The <see cref="P:log4net.Appender.ConsoleAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.ConsoleAppender.Target" /> to use when writing to the Console 
            standard error output stream.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ConsoleAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ConsoleAppender" /> class.
            </summary>
      <remarks>
            The instance of the <see cref="T:log4net.Appender.ConsoleAppender" /> class is set up to write 
            to the standard output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ConsoleAppender.#ctor(log4net.Layout.ILayout)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ConsoleAppender" /> class
            with the specified layout.
            </summary>
      <param name="layout">the layout to use for this appender</param>
      <remarks>
            The instance of the <see cref="T:log4net.Appender.ConsoleAppender" /> class is set up to write 
            to the standard output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ConsoleAppender.#ctor(log4net.Layout.ILayout,System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ConsoleAppender" /> class
            with the specified layout.
            </summary>
      <param name="layout">the layout to use for this appender</param>
      <param name="writeToErrorStream">flag set to <c>true</c> to write to the console error stream</param>
      <remarks>
            When <paramref name="writeToErrorStream" /> is set to <c>true</c>, output is written to
            the standard error output stream.  Otherwise, output is written to the standard
            output stream.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ConsoleAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the event to the console.
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ConsoleAppender.Target">
      <summary>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </summary>
      <value>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </value>
      <remarks>
        <para>
            Target is the value of the console output stream.
            This is either <c>"Console.Out"</c> or <c>"Console.Error"</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.ConsoleAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.DebugAppender">
      <summary>
            Appends log events to the <see cref="T:System.Diagnostics.Debug" /> system.
            </summary>
      <remarks>
        <para>
            The application configuration file can be used to control what listeners 
            are actually used. See the MSDN documentation for the 
            <see cref="T:System.Diagnostics.Debug" /> class for details on configuring the
            debug system.
            </para>
        <para>
            Events are written using the <see cref="M:System.Diagnostics.Debug.Write(System.String,System.String)" />
            method. The event's logger name is passed as the value for the category name to the Write method.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Appender.DebugAppender.m_immediateFlush">
      <summary>
            Immediate flush means that the underlying writer or output stream
            will be flushed at the end of each append operation.
            </summary>
      <remarks>
        <para>
            Immediate flush is slower but ensures that each append request is 
            actually written. If <see cref="P:log4net.Appender.DebugAppender.ImmediateFlush" /> is set to
            <c>false</c>, then there is a good chance that the last few
            logs events are not actually written to persistent media if and
            when the application crashes.
            </para>
        <para>
            The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.DebugAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.DebugAppender" />.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.DebugAppender.#ctor(log4net.Layout.ILayout)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.DebugAppender" /> 
            with a specified layout.
            </summary>
      <param name="layout">The layout to use with this appender.</param>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.DebugAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Writes the logging event to the <see cref="T:System.Diagnostics.Debug" /> system.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the logging event to the <see cref="T:System.Diagnostics.Debug" /> system.
            If <see cref="P:log4net.Appender.DebugAppender.ImmediateFlush" /> is <c>true</c> then the <see cref="M:System.Diagnostics.Debug.Flush" />
            is called.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.DebugAppender.ImmediateFlush">
      <summary>
            Gets or sets a value that indicates whether the appender will 
            flush at the end of each write.
            </summary>
      <remarks>
        <para>The default behavior is to flush at the end of each 
            write. If the option is set to<c>false</c>, then the underlying 
            stream can defer writing to physical medium to a later time. 
            </para>
        <para>
            Avoiding the flush operation at the end of each append results 
            in a performance gain of 10 to 20 percent. However, there is safety
            trade-off involved in skipping flushing. Indeed, when flushing is
            skipped, then it is likely that the last few log events will not
            be recorded on disk when the application exits. This is a high
            price to pay even for a 20% performance gain.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.DebugAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.EventLogAppender">
      <summary>
            Writes events to the system event log.
            </summary>
      <remarks>
        <para>
            The <c>EventID</c> of the event log entry can be
            set using the <c>EventLogEventID</c> property (<see cref="P:log4net.Core.LoggingEvent.Properties" />)
            on the <see cref="T:log4net.Core.LoggingEvent" />.
            </para>
        <para>
            There is a limit of 32K characters for an event log message
            </para>
        <para>
            When configuring the EventLogAppender a mapping can be
            specified to map a logging level to an event log entry type. For example:
            </para>
        <code lang="XML">
            &lt;mapping&gt;
            	&lt;level value="ERROR" /&gt;
            	&lt;eventLogEntryType value="Error" /&gt;
            &lt;/mapping&gt;
            &lt;mapping&gt;
            	&lt;level value="DEBUG" /&gt;
            	&lt;eventLogEntryType value="Information" /&gt;
            &lt;/mapping&gt;
            </code>
        <para>
            The Level is the standard log4net logging level and eventLogEntryType can be any value
            from the <see cref="T:System.Diagnostics.EventLogEntryType" /> enum, i.e.:
            <list type="bullet"><item><term>Error</term><description>an error event</description></item><item><term>Warning</term><description>a warning event</description></item><item><term>Information</term><description>an informational event</description></item></list></para>
      </remarks>
      <author>Aspi Havewala</author>
      <author>Douglas de la Torre</author>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Thomas Voss</author>
    </member>
    <member name="T:log4net.Appender.EventLogAppender.Level2EventLogEntryType">
      <summary>
            A class to act as a mapping between the level that a logging call is made at and
            the color it should be displayed as.
            </summary>
      <remarks>
        <para>
            Defines the mapping between a level and its event log entry type.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.Level2EventLogEntryType.EventLogEntryType">
      <summary>
            The <see cref="P:log4net.Appender.EventLogAppender.Level2EventLogEntryType.EventLogEntryType" /> for this entry
            </summary>
      <remarks>
        <para>
            Required property.
            The <see cref="P:log4net.Appender.EventLogAppender.Level2EventLogEntryType.EventLogEntryType" /> for this entry
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.m_logName">
      <summary>
            The log name is the section in the event logs where the messages
            are stored.
            </summary>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.m_applicationName">
      <summary>
            Name of the application to use when logging.  This appears in the
            application column of the event log named by <see cref="F:log4net.Appender.EventLogAppender.m_logName" />.
            </summary>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.m_machineName">
      <summary>
            The name of the machine which holds the event log. This is
            currently only allowed to be '.' i.e. the current machine.
            </summary>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.m_levelMapping">
      <summary>
            Mapping from level object to EventLogEntryType
            </summary>
    </member>
    <member name="F:log4net.Appender.EventLogAppender.m_securityContext">
      <summary>
            The security context to use for privileged calls
            </summary>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.EventLogAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.#ctor(log4net.Layout.ILayout)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.EventLogAppender" /> class
            with the specified <see cref="T:log4net.Layout.ILayout" />.
            </summary>
      <param name="layout">The <see cref="T:log4net.Layout.ILayout" /> to use with this appender.</param>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.AddMapping(log4net.Appender.EventLogAppender.Level2EventLogEntryType)">
      <summary>
            Add a mapping of level to <see cref="T:System.Diagnostics.EventLogEntryType" /> - done by the config file
            </summary>
      <param name="mapping">The mapping to add</param>
      <remarks>
        <para>
            Add a <see cref="T:log4net.Appender.EventLogAppender.Level2EventLogEntryType" /> mapping to this appender.
            Each mapping defines the event log entry type for a level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.EventLogAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.EventLogAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.EventLogAppender.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.CreateEventSource(System.String,System.String,System.String)">
      <summary>
            Create an event log source
            </summary>
      <remarks>
            Uses different API calls under NET_2_0
            </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" />
            method. 
            </summary>
      <param name="loggingEvent">the event to log</param>
      <remarks>
        <para>Writes the event to the system event log using the 
            <see cref="P:log4net.Appender.EventLogAppender.ApplicationName" />.</para>
        <para>If the event has an <c>EventID</c> property (see <see cref="P:log4net.Core.LoggingEvent.Properties" />)
            set then this integer will be used as the event log event id.</para>
        <para>
            There is a limit of 32K characters for an event log message
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.EventLogAppender.GetEntryType(log4net.Core.Level)">
      <summary>
            Get the equivalent <see cref="T:System.Diagnostics.EventLogEntryType" /> for a <see cref="T:log4net.Core.Level" /><paramref name="p" /></summary>
      <param name="level">the Level to convert to an EventLogEntryType</param>
      <returns>The equivalent <see cref="T:System.Diagnostics.EventLogEntryType" /> for a <see cref="T:log4net.Core.Level" /><paramref name="p" /></returns>
      <remarks>
            Because there are fewer applicable <see cref="T:System.Diagnostics.EventLogEntryType" />
            values to use in logging levels than there are in the 
            <see cref="T:log4net.Core.Level" /> this is a one way mapping. There is
            a loss of information during the conversion.
            </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.LogName">
      <summary>
            The name of the log where messages will be stored.
            </summary>
      <value>
            The string name of the log where messages will be stored.
            </value>
      <remarks>
        <para>This is the name of the log as it appears in the Event Viewer
            tree. The default value is to log into the <c>Application</c>
            log, this is where most applications write their events. However
            if you need a separate log for your application (or applications)
            then you should set the <see cref="P:log4net.Appender.EventLogAppender.LogName" /> appropriately.</para>
        <para>This should not be used to distinguish your event log messages
            from those of other applications, the <see cref="P:log4net.Appender.EventLogAppender.ApplicationName" />
            property should be used to distinguish events. This property should be 
            used to group together events into a single log.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.ApplicationName">
      <summary>
            Property used to set the Application name.  This appears in the
            event logs when logging.
            </summary>
      <value>
            The string used to distinguish events from different sources.
            </value>
      <remarks>
            Sets the event log source property.
            </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.MachineName">
      <summary>
            This property is used to return the name of the computer to use
            when accessing the event logs.  Currently, this is the current
            computer, denoted by a dot "."
            </summary>
      <value>
            The string name of the machine holding the event log that 
            will be logged into.
            </value>
      <remarks>
            This property cannot be changed. It is currently set to '.'
            i.e. the local machine. This may be changed in future.
            </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.SecurityContext">
      <summary>
            Gets or sets the <see cref="P:log4net.Appender.EventLogAppender.SecurityContext" /> used to write to the EventLog.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.EventLogAppender.SecurityContext" /> used to write to the EventLog.
            </value>
      <remarks>
        <para>
            The system security context used to write to the EventLog.
            </para>
        <para>
            Unless a <see cref="P:log4net.Appender.EventLogAppender.SecurityContext" /> specified here for this appender
            the <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> is queried for the
            security context to use. The default behavior is to use the security context
            of the current thread.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.EventLogAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.TextWriterAppender">
      <summary>
            Sends logging events to a <see cref="T:System.IO.TextWriter" />.
            </summary>
      <remarks>
        <para>
            An Appender that writes to a <see cref="T:System.IO.TextWriter" />.
            </para>
        <para>
            This appender may be used stand alone if initialized with an appropriate
            writer, however it is typically used as a base class for an appender that
            can open a <see cref="T:System.IO.TextWriter" /> to write to.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Douglas de la Torre</author>
    </member>
    <member name="F:log4net.Appender.TextWriterAppender.m_qtw">
      <summary>
            This is the <see cref="T:log4net.Util.QuietTextWriter" /> where logging events
            will be written to. 
            </summary>
    </member>
    <member name="F:log4net.Appender.TextWriterAppender.m_immediateFlush">
      <summary>
            Immediate flush means that the underlying <see cref="T:System.IO.TextWriter" /> 
            or output stream will be flushed at the end of each append operation.
            </summary>
      <remarks>
        <para>
            Immediate flush is slower but ensures that each append request is 
            actually written. If <see cref="P:log4net.Appender.TextWriterAppender.ImmediateFlush" /> is set to
            <c>false</c>, then there is a good chance that the last few
            logging events are not actually persisted if and when the application 
            crashes.
            </para>
        <para>
            The default value is <c>true</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.TextWriterAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.#ctor(log4net.Layout.ILayout,System.IO.Stream)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.TextWriterAppender" /> class and
            sets the output destination to a new <see cref="T:System.IO.StreamWriter" /> initialized 
            with the specified <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="layout">The layout to use with this appender.</param>
      <param name="os">The <see cref="T:System.IO.Stream" /> to output to.</param>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.#ctor(log4net.Layout.ILayout,System.IO.TextWriter)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.TextWriterAppender" /> class and sets
            the output destination to the specified <see cref="T:System.IO.StreamWriter" />.
            </summary>
      <param name="layout">The layout to use with this appender</param>
      <param name="writer">The <see cref="T:System.IO.TextWriter" /> to output to</param>
      <remarks>
            The <see cref="T:System.IO.TextWriter" /> must have been previously opened.
            </remarks>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.PreAppendCheck">
      <summary>
            This method determines if there is a sense in attempting to append.
            </summary>
      <remarks>
        <para>
            This method checked if an output target has been set and if a
            layout has been set. 
            </para>
      </remarks>
      <returns>
        <c>false</c> if any of the preconditions fail.</returns>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" />
            method. 
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes a log statement to the output stream if the output stream exists 
            and is writable.  
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.Append(log4net.Core.LoggingEvent[])">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent[])" />
            method. 
            </summary>
      <param name="loggingEvents">The array of events to log.</param>
      <remarks>
        <para>
            This method writes all the bulk logged events to the output writer
            before flushing the stream.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.OnClose">
      <summary>
            Close this appender instance. The underlying stream or writer is also closed.
            </summary>
      <remarks>
            Closed appenders cannot be reused.
            </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.WriteFooterAndCloseWriter">
      <summary>
            Writes the footer and closes the underlying <see cref="T:System.IO.TextWriter" />.
            </summary>
      <remarks>
        <para>
            Writes the footer and closes the underlying <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.CloseWriter">
      <summary>
            Closes the underlying <see cref="T:System.IO.TextWriter" />.
            </summary>
      <remarks>
        <para>
            Closes the underlying <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.Reset">
      <summary>
            Clears internal references to the underlying <see cref="T:System.IO.TextWriter" /> 
            and other variables.
            </summary>
      <remarks>
        <para>
            Subclasses can override this method for an alternate closing behavior.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.WriteFooter">
      <summary>
            Writes a footer as produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Footer" /> property.
            </summary>
      <remarks>
        <para>
            Writes a footer as produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Footer" /> property.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.WriteHeader">
      <summary>
            Writes a header produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Header" /> property.
            </summary>
      <remarks>
        <para>
            Writes a header produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Header" /> property.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TextWriterAppender.PrepareWriter">
      <summary>
            Called to allow a subclass to lazily initialize the writer
            </summary>
      <remarks>
        <para>
            This method is called when an event is logged and the <see cref="P:log4net.Appender.TextWriterAppender.Writer" /> or
            <see cref="P:log4net.Appender.TextWriterAppender.QuietWriter" /> have not been set. This allows a subclass to
            attempt to initialize the writer multiple times.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TextWriterAppender.ImmediateFlush">
      <summary>
            Gets or set whether the appender will flush at the end 
            of each append operation.
            </summary>
      <value>
        <para>
            The default behavior is to flush at the end of each 
            append operation.
            </para>
        <para>
            If this option is set to <c>false</c>, then the underlying 
            stream can defer persisting the logging event to a later 
            time.
            </para>
      </value>
      <remarks>
            Avoiding the flush operation at the end of each append results in
            a performance gain of 10 to 20 percent. However, there is safety
            trade-off involved in skipping flushing. Indeed, when flushing is
            skipped, then it is likely that the last few log events will not
            be recorded on disk when the application exits. This is a high
            price to pay even for a 20% performance gain.
            </remarks>
    </member>
    <member name="P:log4net.Appender.TextWriterAppender.Writer">
      <summary>
            Sets the <see cref="T:System.IO.TextWriter" /> where the log output will go.
            </summary>
      <remarks>
        <para>
            The specified <see cref="T:System.IO.TextWriter" /> must be open and writable.
            </para>
        <para>
            The <see cref="T:System.IO.TextWriter" /> will be closed when the appender 
            instance is closed.
            </para>
        <para>
          <b>Note:</b> Logging to an unopened <see cref="T:System.IO.TextWriter" /> will fail.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TextWriterAppender.ErrorHandler">
      <summary>
            Gets or set the <see cref="T:log4net.Core.IErrorHandler" /> and the underlying 
            <see cref="T:log4net.Util.QuietTextWriter" />, if any, for this appender. 
            </summary>
      <value>
            The <see cref="T:log4net.Core.IErrorHandler" /> for this appender.
            </value>
    </member>
    <member name="P:log4net.Appender.TextWriterAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TextWriterAppender.QuietWriter">
      <summary>
            Gets or sets the <see cref="T:log4net.Util.QuietTextWriter" /> where logging events
            will be written to. 
            </summary>
      <value>
            The <see cref="T:log4net.Util.QuietTextWriter" /> where logging events are written.
            </value>
      <remarks>
        <para>
            This is the <see cref="T:log4net.Util.QuietTextWriter" /> where logging events
            will be written to. 
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.FileAppender">
      <summary>
            Appends logging events to a file.
            </summary>
      <remarks>
        <para>
            Logging events are sent to the file specified by
            the <see cref="P:log4net.Appender.FileAppender.File" /> property.
            </para>
        <para>
            The file can be opened in either append or overwrite mode 
            by specifying the <see cref="P:log4net.Appender.FileAppender.AppendToFile" /> property.
            If the file path is relative it is taken as relative from 
            the application base directory. The file encoding can be
            specified by setting the <see cref="P:log4net.Appender.FileAppender.Encoding" /> property.
            </para>
        <para>
            The layout's <see cref="P:log4net.Layout.ILayout.Header" /> and <see cref="P:log4net.Layout.ILayout.Footer" />
            values will be written each time the file is opened and closed
            respectively. If the <see cref="P:log4net.Appender.FileAppender.AppendToFile" /> property is <see langword="true" />
            then the file may contain multiple copies of the header and footer.
            </para>
        <para>
            This appender will first try to open the file for writing when <see cref="M:log4net.Appender.FileAppender.ActivateOptions" />
            is called. This will typically be during configuration.
            If the file cannot be opened for writing the appender will attempt
            to open the file again each time a message is logged to the appender.
            If the file cannot be opened for writing when a message is logged then
            the message will be discarded by this appender.
            </para>
        <para>
            The <see cref="T:log4net.Appender.FileAppender" /> supports pluggable file locking models via
            the <see cref="P:log4net.Appender.FileAppender.LockingModel" /> property.
            The default behavior, implemented by <see cref="T:log4net.Appender.FileAppender.ExclusiveLock" /> 
            is to obtain an exclusive write lock on the file until this appender is closed.
            The alternative model, <see cref="T:log4net.Appender.FileAppender.MinimalLock" />, only holds a
            write lock while the appender is writing a logging event.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Rodrigo B. de Oliveira</author>
      <author>Douglas de la Torre</author>
      <author>Niall Daley</author>
    </member>
    <member name="T:log4net.Appender.FileAppender.LockingStream">
      <summary>
            Write only <see cref="T:System.IO.Stream" /> that uses the <see cref="T:log4net.Appender.FileAppender.LockingModelBase" /> 
            to manage access to an underlying resource.
            </summary>
    </member>
    <member name="M:log4net.Appender.FileAppender.LockingStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
      <summary>
            True asynchronous writes are not supported, the implementation forces a synchronous write.
            </summary>
    </member>
    <member name="T:log4net.Appender.FileAppender.LockingModelBase">
      <summary>
            Locking model base class
            </summary>
      <remarks>
        <para>
            Base class for the locking models available to the <see cref="T:log4net.Appender.FileAppender" /> derived loggers.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.LockingModelBase.OpenFile(System.String,System.Boolean,System.Text.Encoding)">
      <summary>
            Open the output file
            </summary>
      <param name="filename">The filename to use</param>
      <param name="append">Whether to append to the file, or overwrite</param>
      <param name="encoding">The encoding to use</param>
      <remarks>
        <para>
            Open the file specified and prepare for logging. 
            No writes will be made until <see cref="M:log4net.Appender.FileAppender.LockingModelBase.AcquireLock" /> is called.
            Must be called before any calls to <see cref="M:log4net.Appender.FileAppender.LockingModelBase.AcquireLock" />,
            <see cref="M:log4net.Appender.FileAppender.LockingModelBase.ReleaseLock" /> and <see cref="M:log4net.Appender.FileAppender.LockingModelBase.CloseFile" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.LockingModelBase.CloseFile">
      <summary>
            Close the file
            </summary>
      <remarks>
        <para>
            Close the file. No further writes will be made.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.LockingModelBase.AcquireLock">
      <summary>
            Acquire the lock on the file
            </summary>
      <returns>A stream that is ready to be written to.</returns>
      <remarks>
        <para>
            Acquire the lock on the file in preparation for writing to it. 
            Return a stream pointing to the file. <see cref="M:log4net.Appender.FileAppender.LockingModelBase.ReleaseLock" />
            must be called to release the lock on the output file.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.LockingModelBase.ReleaseLock">
      <summary>
            Release the lock on the file
            </summary>
      <remarks>
        <para>
            Release the lock on the file. No further writes will be made to the 
            stream until <see cref="M:log4net.Appender.FileAppender.LockingModelBase.AcquireLock" /> is called again.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.FileAppender.LockingModelBase.CurrentAppender">
      <summary>
            Gets or sets the <see cref="T:log4net.Appender.FileAppender" /> for this LockingModel
            </summary>
      <value>
            The <see cref="T:log4net.Appender.FileAppender" /> for this LockingModel
            </value>
      <remarks>
        <para>
            The file appender this locking model is attached to and working on
            behalf of.
            </para>
        <para>
            The file appender is used to locate the security context and the error handler to use.
            </para>
        <para>
            The value of this property will be set before <see cref="M:log4net.Appender.FileAppender.LockingModelBase.OpenFile(System.String,System.Boolean,System.Text.Encoding)" /> is
            called.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.FileAppender.ExclusiveLock">
      <summary>
            Hold an exclusive lock on the output file
            </summary>
      <remarks>
        <para>
            Open the file once for writing and hold it open until <see cref="M:log4net.Appender.FileAppender.ExclusiveLock.CloseFile" /> is called. 
            Maintains an exclusive lock on the file during this time.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.ExclusiveLock.OpenFile(System.String,System.Boolean,System.Text.Encoding)">
      <summary>
            Open the file specified and prepare for logging.
            </summary>
      <param name="filename">The filename to use</param>
      <param name="append">Whether to append to the file, or overwrite</param>
      <param name="encoding">The encoding to use</param>
      <remarks>
        <para>
            Open the file specified and prepare for logging. 
            No writes will be made until <see cref="M:log4net.Appender.FileAppender.ExclusiveLock.AcquireLock" /> is called.
            Must be called before any calls to <see cref="M:log4net.Appender.FileAppender.ExclusiveLock.AcquireLock" />,
            <see cref="M:log4net.Appender.FileAppender.ExclusiveLock.ReleaseLock" /> and <see cref="M:log4net.Appender.FileAppender.ExclusiveLock.CloseFile" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.ExclusiveLock.CloseFile">
      <summary>
            Close the file
            </summary>
      <remarks>
        <para>
            Close the file. No further writes will be made.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.ExclusiveLock.AcquireLock">
      <summary>
            Acquire the lock on the file
            </summary>
      <returns>A stream that is ready to be written to.</returns>
      <remarks>
        <para>
            Does nothing. The lock is already taken
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.ExclusiveLock.ReleaseLock">
      <summary>
            Release the lock on the file
            </summary>
      <remarks>
        <para>
            Does nothing. The lock will be released when the file is closed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.FileAppender.MinimalLock">
      <summary>
            Acquires the file lock for each write
            </summary>
      <remarks>
        <para>
            Opens the file once for each <see cref="M:log4net.Appender.FileAppender.MinimalLock.AcquireLock" />/<see cref="M:log4net.Appender.FileAppender.MinimalLock.ReleaseLock" /> cycle, 
            thus holding the lock for the minimal amount of time. This method of locking
            is considerably slower than <see cref="T:log4net.Appender.FileAppender.ExclusiveLock" /> but allows 
            other processes to move/delete the log file whilst logging continues.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.MinimalLock.OpenFile(System.String,System.Boolean,System.Text.Encoding)">
      <summary>
            Prepares to open the file when the first message is logged.
            </summary>
      <param name="filename">The filename to use</param>
      <param name="append">Whether to append to the file, or overwrite</param>
      <param name="encoding">The encoding to use</param>
      <remarks>
        <para>
            Open the file specified and prepare for logging. 
            No writes will be made until <see cref="M:log4net.Appender.FileAppender.MinimalLock.AcquireLock" /> is called.
            Must be called before any calls to <see cref="M:log4net.Appender.FileAppender.MinimalLock.AcquireLock" />,
            <see cref="M:log4net.Appender.FileAppender.MinimalLock.ReleaseLock" /> and <see cref="M:log4net.Appender.FileAppender.MinimalLock.CloseFile" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.MinimalLock.CloseFile">
      <summary>
            Close the file
            </summary>
      <remarks>
        <para>
            Close the file. No further writes will be made.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.MinimalLock.AcquireLock">
      <summary>
            Acquire the lock on the file
            </summary>
      <returns>A stream that is ready to be written to.</returns>
      <remarks>
        <para>
            Acquire the lock on the file in preparation for writing to it. 
            Return a stream pointing to the file. <see cref="M:log4net.Appender.FileAppender.MinimalLock.ReleaseLock" />
            must be called to release the lock on the output file.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.MinimalLock.ReleaseLock">
      <summary>
            Release the lock on the file
            </summary>
      <remarks>
        <para>
            Release the lock on the file. No further writes will be made to the 
            stream until <see cref="M:log4net.Appender.FileAppender.MinimalLock.AcquireLock" /> is called again.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.FileAppender.m_appendToFile">
      <summary>
            Flag to indicate if we should append to the file
            or overwrite the file. The default is to append.
            </summary>
    </member>
    <member name="F:log4net.Appender.FileAppender.m_fileName">
      <summary>
            The name of the log file.
            </summary>
    </member>
    <member name="F:log4net.Appender.FileAppender.m_encoding">
      <summary>
            The encoding to use for the file stream.
            </summary>
    </member>
    <member name="F:log4net.Appender.FileAppender.m_securityContext">
      <summary>
            The security context to use for privileged calls
            </summary>
    </member>
    <member name="F:log4net.Appender.FileAppender.m_stream">
      <summary>
            The stream to log to. Has added locking semantics
            </summary>
    </member>
    <member name="F:log4net.Appender.FileAppender.m_lockingModel">
      <summary>
            The locking model to use
            </summary>
    </member>
    <member name="M:log4net.Appender.FileAppender.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.#ctor(log4net.Layout.ILayout,System.String,System.Boolean)">
      <summary>
            Construct a new appender using the layout, file and append mode.
            </summary>
      <param name="layout">the layout to use with this appender</param>
      <param name="filename">the full path to the file to write to</param>
      <param name="append">flag to indicate if the file should be appended to</param>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.#ctor(log4net.Layout.ILayout,System.String)">
      <summary>
            Construct a new appender using the layout and file specified.
            The file will be appended to.
            </summary>
      <param name="layout">the layout to use with this appender</param>
      <param name="filename">the full path to the file to write to</param>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.ActivateOptions">
      <summary>
            Activate the options on the file appender. 
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.FileAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.FileAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.FileAppender.ActivateOptions" /> must be called again.
            </para>
        <para>
            This will cause the file to be opened.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.Reset">
      <summary>
            Closes any previously opened file and calls the parent's <see cref="M:log4net.Appender.TextWriterAppender.Reset" />.
            </summary>
      <remarks>
        <para>
            Resets the filename and the file stream.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.PrepareWriter">
      <summary>
            Called to initialize the file writer
            </summary>
      <remarks>
        <para>
            Will be called for each logged message until the file is
            successfully opened.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" />
            method. 
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes a log statement to the output stream if the output stream exists 
            and is writable.  
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.Append(log4net.Core.LoggingEvent[])">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent[])" />
            method. 
            </summary>
      <param name="loggingEvents">The array of events to log.</param>
      <remarks>
        <para>
            Acquires the output file locks once before writing all the events to
            the stream.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.WriteFooter">
      <summary>
            Writes a footer as produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Footer" /> property.
            </summary>
      <remarks>
        <para>
            Writes a footer as produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Footer" /> property.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.WriteHeader">
      <summary>
            Writes a header produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Header" /> property.
            </summary>
      <remarks>
        <para>
            Writes a header produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Header" /> property.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.CloseWriter">
      <summary>
            Closes the underlying <see cref="T:System.IO.TextWriter" />.
            </summary>
      <remarks>
        <para>
            Closes the underlying <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.CloseFile">
      <summary>
            Closes the previously opened file.
            </summary>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Layout.ILayout.Footer" /> to the file and then
            closes the file.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.SafeOpenFile(System.String,System.Boolean)">
      <summary>
            Sets and <i>opens</i> the file where the log output will go. The specified file must be writable.
            </summary>
      <param name="fileName">The path to the log file. Must be a fully qualified path.</param>
      <param name="append">If true will append to fileName. Otherwise will truncate fileName</param>
      <remarks>
        <para>
            Calls <see cref="M:log4net.Appender.FileAppender.OpenFile(System.String,System.Boolean)" /> but guarantees not to throw an exception.
            Errors are passed to the <see cref="P:log4net.Appender.TextWriterAppender.ErrorHandler" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.OpenFile(System.String,System.Boolean)">
      <summary>
            Sets and <i>opens</i> the file where the log output will go. The specified file must be writable.
            </summary>
      <param name="fileName">The path to the log file. Must be a fully qualified path.</param>
      <param name="append">If true will append to fileName. Otherwise will truncate fileName</param>
      <remarks>
        <para>
            If there was already an opened file, then the previous file
            is closed first.
            </para>
        <para>
            This method will ensure that the directory structure
            for the <paramref name="fileName" /> specified exists.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.SetQWForFiles(System.IO.Stream)">
      <summary>
            Sets the quiet writer used for file output
            </summary>
      <param name="fileStream">the file stream that has been opened for writing</param>
      <remarks>
        <para>
            This implementation of <see cref="M:log4net.Appender.FileAppender.SetQWForFiles(System.IO.Stream)" /> creates a <see cref="T:System.IO.StreamWriter" />
            over the <paramref name="fileStream" /> and passes it to the 
            <see cref="M:log4net.Appender.FileAppender.SetQWForFiles(System.IO.TextWriter)" /> method.
            </para>
        <para>
            This method can be overridden by sub classes that want to wrap the
            <see cref="T:System.IO.Stream" /> in some way, for example to encrypt the output
            data using a <c>System.Security.Cryptography.CryptoStream</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.SetQWForFiles(System.IO.TextWriter)">
      <summary>
            Sets the quiet writer being used.
            </summary>
      <param name="writer">the writer over the file stream that has been opened for writing</param>
      <remarks>
        <para>
            This method can be overridden by sub classes that want to
            wrap the <see cref="T:System.IO.TextWriter" /> in some way.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.FileAppender.ConvertToFullPath(System.String)">
      <summary>
            Convert a path into a fully qualified path.
            </summary>
      <param name="path">The path to convert.</param>
      <returns>The fully qualified path.</returns>
      <remarks>
        <para>
            Converts the path specified to a fully
            qualified path. If the path is relative it is
            taken as relative from the application base 
            directory.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.FileAppender.File">
      <summary>
            Gets or sets the path to the file that logging will be written to.
            </summary>
      <value>
            The path to the file that logging will be written to.
            </value>
      <remarks>
        <para>
            If the path is relative it is taken as relative from 
            the application base directory.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.FileAppender.AppendToFile">
      <summary>
            Gets or sets a flag that indicates whether the file should be
            appended to or overwritten.
            </summary>
      <value>
            Indicates whether the file should be appended to or overwritten.
            </value>
      <remarks>
        <para>
            If the value is set to false then the file will be overwritten, if 
            it is set to true then the file will be appended to.
            </para>
            The default value is true.
            </remarks>
    </member>
    <member name="P:log4net.Appender.FileAppender.Encoding">
      <summary>
            Gets or sets <see cref="P:log4net.Appender.FileAppender.Encoding" /> used to write to the file.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.FileAppender.Encoding" /> used to write to the file.
            </value>
      <remarks>
        <para>
            The default encoding set is <see cref="P:System.Text.Encoding.Default" />
            which is the encoding for the system's current ANSI code page.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.FileAppender.SecurityContext">
      <summary>
            Gets or sets the <see cref="P:log4net.Appender.FileAppender.SecurityContext" /> used to write to the file.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.FileAppender.SecurityContext" /> used to write to the file.
            </value>
      <remarks>
        <para>
            Unless a <see cref="P:log4net.Appender.FileAppender.SecurityContext" /> specified here for this appender
            the <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> is queried for the
            security context to use. The default behavior is to use the security context
            of the current thread.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.FileAppender.LockingModel">
      <summary>
            Gets or sets the <see cref="P:log4net.Appender.FileAppender.LockingModel" /> used to handle locking of the file.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.FileAppender.LockingModel" /> used to lock the file.
            </value>
      <remarks>
        <para>
            Gets or sets the <see cref="P:log4net.Appender.FileAppender.LockingModel" /> used to handle locking of the file.
            </para>
        <para>
            There are two built in locking models, <see cref="T:log4net.Appender.FileAppender.ExclusiveLock" /> and <see cref="T:log4net.Appender.FileAppender.MinimalLock" />.
            The former locks the file from the start of logging to the end and the 
            later lock only for the minimal amount of time when logging each message.
            </para>
        <para>
            The default locking model is the <see cref="T:log4net.Appender.FileAppender.ExclusiveLock" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LogException">
      <summary>
            Exception base type for log4net.
            </summary>
      <remarks>
        <para>
            This type extends <see cref="T:System.ApplicationException" />. It
            does not add any new functionality but does differentiate the
            type of exception being thrown.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Core.LogException.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LogException" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogException.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="message">A message to include with the exception.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LogException" /> class with
            the specified message.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogException.#ctor(System.String,System.Exception)">
      <summary>
            Constructor
            </summary>
      <param name="message">A message to include with the exception.</param>
      <param name="innerException">A nested exception to include.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LogException" /> class
            with the specified message and inner exception.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serialization constructor
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LogException" /> class 
            with serialized data.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.ForwardingAppender">
      <summary>
            This appender forwards logging events to attached appenders.
            </summary>
      <remarks>
        <para>
            The forwarding appender can be used to specify different thresholds
            and filters for the same appender at different locations within the hierarchy.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.ForwardingAppender.m_appenderAttachedImpl">
      <summary>
            Implementation of the <see cref="T:log4net.Core.IAppenderAttachable" /> interface
            </summary>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.ForwardingAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.OnClose">
      <summary>
            Closes the appender and releases resources.
            </summary>
      <remarks>
        <para>
            Releases any resources allocated within the appender such as file handles, 
            network connections, etc.
            </para>
        <para>
            It is a programming error to append to a closed appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Forward the logging event to the attached appenders 
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Delivers the logging event to all the attached appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.Append(log4net.Core.LoggingEvent[])">
      <summary>
            Forward the logging events to the attached appenders 
            </summary>
      <param name="loggingEvents">The array of events to log.</param>
      <remarks>
        <para>
            Delivers the logging events to all the attached appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.AddAppender(log4net.Appender.IAppender)">
      <summary>
            Adds an <see cref="T:log4net.Appender.IAppender" /> to the list of appenders of this
            instance.
            </summary>
      <param name="newAppender">The <see cref="T:log4net.Appender.IAppender" /> to add to this appender.</param>
      <remarks>
        <para>
            If the specified <see cref="T:log4net.Appender.IAppender" /> is already in the list of
            appenders, then it won't be added again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.GetAppender(System.String)">
      <summary>
            Looks for the appender with the specified name.
            </summary>
      <param name="name">The name of the appender to lookup.</param>
      <returns>
            The appender with the specified name, or <c>null</c>.
            </returns>
      <remarks>
        <para>
            Get the named appender attached to this appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.RemoveAllAppenders">
      <summary>
            Removes all previously added appenders from this appender.
            </summary>
      <remarks>
        <para>
            This is useful when re-reading configuration information.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.RemoveAppender(log4net.Appender.IAppender)">
      <summary>
            Removes the specified appender from the list of appenders.
            </summary>
      <param name="appender">The appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </remarks>
    </member>
    <member name="M:log4net.Appender.ForwardingAppender.RemoveAppender(System.String)">
      <summary>
            Removes the appender with the specified name from the list of appenders.
            </summary>
      <param name="name">The name of the appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </remarks>
    </member>
    <member name="P:log4net.Appender.ForwardingAppender.Appenders">
      <summary>
            Gets the appenders contained in this appender as an 
            <see cref="T:System.Collections.ICollection" />.
            </summary>
      <remarks>
            If no appenders can be found, then an <see cref="T:log4net.Util.EmptyCollection" /> 
            is returned.
            </remarks>
      <returns>
            A collection of the appenders in this appender.
            </returns>
    </member>
    <member name="T:log4net.Appender.LocalSyslogAppender">
      <summary>
            Logs events to a local syslog service.
            </summary>
      <remarks>
        <note>
            This appender uses the POSIX libc library functions <c>openlog</c>, <c>syslog</c>, and <c>closelog</c>.
            If these functions are not available on the local system then this appender will not work!
            </note>
        <para>
            The functions <c>openlog</c>, <c>syslog</c>, and <c>closelog</c> are specified in SUSv2 and 
            POSIX 1003.1-2001 standards. These are used to log messages to the local syslog service.
            </para>
        <para>
            This appender talks to a local syslog service. If you need to log to a remote syslog
            daemon and you cannot configure your local syslog service to do this you may be
            able to use the <see cref="T:log4net.Appender.RemoteSyslogAppender" /> to log via UDP.
            </para>
        <para>
            Syslog messages must have a facility and and a severity. The severity
            is derived from the Level of the logging event.
            The facility must be chosen from the set of defined syslog 
            <see cref="T:log4net.Appender.LocalSyslogAppender.SyslogFacility" /> values. The facilities list is predefined
            and cannot be extended.
            </para>
        <para>
            An identifier is specified with each log message. This can be specified
            by setting the <see cref="P:log4net.Appender.LocalSyslogAppender.Identity" /> property. The identity (also know 
            as the tag) must not contain white space. The default value for the
            identity is the application name (from <see cref="P:log4net.Util.SystemInfo.ApplicationFriendlyName" />).
            </para>
      </remarks>
      <author>Rob Lyon</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Appender.LocalSyslogAppender.SyslogSeverity">
      <summary>
            syslog severities
            </summary>
      <remarks>
        <para>
            The log4net Level maps to a syslog severity using the
            <see cref="M:log4net.Appender.LocalSyslogAppender.AddMapping(log4net.Appender.LocalSyslogAppender.LevelSeverity)" /> method and the <see cref="T:log4net.Appender.LocalSyslogAppender.LevelSeverity" />
            class. The severity is set on <see cref="P:log4net.Appender.LocalSyslogAppender.LevelSeverity.Severity" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.LocalSyslogAppender.SyslogFacility">
      <summary>
            syslog facilities
            </summary>
      <remarks>
        <para>
            The syslog facility defines which subsystem the logging comes from.
            This is set on the <see cref="P:log4net.Appender.LocalSyslogAppender.Facility" /> property.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.LocalSyslogAppender.LevelSeverity">
      <summary>
            A class to act as a mapping between the level that a logging call is made at and
            the syslog severity that is should be logged at.
            </summary>
      <remarks>
        <para>
            A class to act as a mapping between the level that a logging call is made at and
            the syslog severity that is should be logged at.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.LocalSyslogAppender.LevelSeverity.Severity">
      <summary>
            The mapped syslog severity for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped syslog severity for the specified level
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.LocalSyslogAppender.m_facility">
      <summary>
            The facility. The default facility is <see cref="F:log4net.Appender.LocalSyslogAppender.SyslogFacility.User" />.
            </summary>
    </member>
    <member name="F:log4net.Appender.LocalSyslogAppender.m_identity">
      <summary>
            The message identity
            </summary>
    </member>
    <member name="F:log4net.Appender.LocalSyslogAppender.m_handleToIdentity">
      <summary>
            Marshaled handle to the identity string. We have to hold on to the
            string as the <c>openlog</c> and <c>syslog</c> APIs just hold the
            pointer to the ident and dereference it for each log message.
            </summary>
    </member>
    <member name="F:log4net.Appender.LocalSyslogAppender.m_levelMapping">
      <summary>
            Mapping from level object to syslog severity
            </summary>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.LocalSyslogAppender" /> class.
            </summary>
      <remarks>
            This instance of the <see cref="T:log4net.Appender.LocalSyslogAppender" /> class is set up to write 
            to a local syslog service.
            </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.AddMapping(log4net.Appender.LocalSyslogAppender.LevelSeverity)">
      <summary>
            Add a mapping of level to severity
            </summary>
      <param name="mapping">The mapping to add</param>
      <remarks>
        <para>
            Adds a <see cref="T:log4net.Appender.LocalSyslogAppender.LevelSeverity" /> to this appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set.
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.LocalSyslogAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.LocalSyslogAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.LocalSyslogAppender.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the event to a remote syslog daemon.
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.OnClose">
      <summary>
            Close the syslog when the appender is closed
            </summary>
      <remarks>
        <para>
            Close the syslog when the appender is closed
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.GetSeverity(log4net.Core.Level)">
      <summary>
            Translates a log4net level to a syslog severity.
            </summary>
      <param name="level">A log4net level.</param>
      <returns>A syslog severity.</returns>
      <remarks>
        <para>
            Translates a log4net level to a syslog severity.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.GeneratePriority(log4net.Appender.LocalSyslogAppender.SyslogFacility,log4net.Appender.LocalSyslogAppender.SyslogSeverity)">
      <summary>
            Generate a syslog priority.
            </summary>
      <param name="facility">The syslog facility.</param>
      <param name="severity">The syslog severity.</param>
      <returns>A syslog priority.</returns>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.openlog(System.IntPtr,System.Int32,log4net.Appender.LocalSyslogAppender.SyslogFacility)">
      <summary>
            Open connection to system logger.
            </summary>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.syslog(System.Int32,System.String,System.String)">
      <summary>
            Generate a log message.
            </summary>
      <remarks>
        <para>
            The libc syslog method takes a format string and a variable argument list similar
            to the classic printf function. As this type of vararg list is not supported
            by C# we need to specify the arguments explicitly. Here we have specified the
            format string with a single message argument. The caller must set the format 
            string to <c>"%s"</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.LocalSyslogAppender.closelog">
      <summary>
            Close descriptor used to write to system logger.
            </summary>
    </member>
    <member name="P:log4net.Appender.LocalSyslogAppender.Identity">
      <summary>
            Message identity
            </summary>
      <remarks>
        <para>
            An identifier is specified with each log message. This can be specified
            by setting the <see cref="P:log4net.Appender.LocalSyslogAppender.Identity" /> property. The identity (also know 
            as the tag) must not contain white space. The default value for the
            identity is the application name (from <see cref="P:log4net.Util.SystemInfo.ApplicationFriendlyName" />).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.LocalSyslogAppender.Facility">
      <summary>
            Syslog facility
            </summary>
      <remarks>
            Set to one of the <see cref="T:log4net.Appender.LocalSyslogAppender.SyslogFacility" /> values. The list of
            facilities is predefined and cannot be extended. The default value
            is <see cref="F:log4net.Appender.LocalSyslogAppender.SyslogFacility.User" />.
            </remarks>
    </member>
    <member name="P:log4net.Appender.LocalSyslogAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="P:log4net.Appender.AppenderSkeleton.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="P:log4net.Appender.AppenderSkeleton.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.MemoryAppender">
      <summary>
            Stores logging events in an array.
            </summary>
      <remarks>
        <para>
            The memory appender stores all the logging events
            that are appended in an in-memory array.
            </para>
        <para>
            Use the <see cref="M:log4net.Appender.MemoryAppender.GetEvents" /> method to get
            the current list of events that have been appended.
            </para>
        <para>
            Use the <see cref="M:log4net.Appender.MemoryAppender.Clear" /> method to clear the
            current list of events.
            </para>
      </remarks>
      <author>Julian Biddle</author>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.MemoryAppender.m_eventsList">
      <summary>
            The list of events that have been appended.
            </summary>
    </member>
    <member name="F:log4net.Appender.MemoryAppender.m_fixFlags">
      <summary>
            Value indicating which fields in the event should be fixed
            </summary>
      <remarks>
            By default all fields are fixed
            </remarks>
    </member>
    <member name="M:log4net.Appender.MemoryAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.MemoryAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.MemoryAppender.GetEvents">
      <summary>
            Gets the events that have been logged.
            </summary>
      <returns>The events that have been logged</returns>
      <remarks>
        <para>
            Gets the events that have been logged.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.MemoryAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" /> method. 
            </summary>
      <param name="loggingEvent">the event to log</param>
      <remarks>
        <para>Stores the <paramref name="loggingEvent" /> in the events list.</para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.MemoryAppender.Clear">
      <summary>
            Clear the list of events
            </summary>
      <remarks>
            Clear the list of events
            </remarks>
    </member>
    <member name="P:log4net.Appender.MemoryAppender.OnlyFixPartialEventData">
      <summary>
            Gets or sets a value indicating whether only part of the logging event 
            data should be fixed.
            </summary>
      <value>
        <c>true</c> if the appender should only fix part of the logging event 
            data, otherwise <c>false</c>. The default is <c>false</c>.
            </value>
      <remarks>
        <para>
            Setting this property to <c>true</c> will cause only part of the event 
            data to be fixed and stored in the appender, hereby improving performance. 
            </para>
        <para>
            See <see cref="M:log4net.Core.LoggingEvent.FixVolatileData(System.Boolean)" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.MemoryAppender.Fix">
      <summary>
            Gets or sets the fields that will be fixed in the event
            </summary>
      <remarks>
        <para>
            The logging event needs to have certain thread specific values 
            captured before it can be buffered. See <see cref="P:log4net.Core.LoggingEvent.Fix" />
            for details.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.NetSendAppender">
      <summary>
            Logs entries by sending network messages using the 
            <see cref="M:log4net.Appender.NetSendAppender.NetMessageBufferSend(System.String,System.String,System.String,System.String,System.Int32)" /> native function.
            </summary>
      <remarks>
        <para>
            You can send messages only to names that are active 
            on the network. If you send the message to a user name, 
            that user must be logged on and running the Messenger 
            service to receive the message.
            </para>
        <para>
            The receiver will get a top most window displaying the 
            messages one at a time, therefore this appender should 
            not be used to deliver a high volume of messages.
            </para>
        <para>
            The following table lists some possible uses for this appender :
            </para>
        <para>
          <list type="table">
            <listheader>
              <term>Action</term>
              <description>Property Value(s)</description>
            </listheader>
            <item>
              <term>Send a message to a user account on the local machine</term>
              <description>
                <para>
                  <paramref name="Server" /> = &lt;name of the local machine&gt;
                        </para>
                <para>
                  <paramref name="Recipient" /> = &lt;user name&gt;
                        </para>
              </description>
            </item>
            <item>
              <term>Send a message to a user account on a remote machine</term>
              <description>
                <para>
                  <paramref name="Server" /> = &lt;name of the remote machine&gt;
                        </para>
                <para>
                  <paramref name="Recipient" /> = &lt;user name&gt;
                        </para>
              </description>
            </item>
            <item>
              <term>Send a message to a domain user account</term>
              <description>
                <para>
                  <paramref name="Server" /> = &lt;name of a domain controller | uninitialized&gt;
                        </para>
                <para>
                  <paramref name="Recipient" /> = &lt;user name&gt;
                        </para>
              </description>
            </item>
            <item>
              <term>Send a message to all the names in a workgroup or domain</term>
              <description>
                <para>
                  <paramref name="Recipient" /> = &lt;workgroup name | domain name&gt;*
                        </para>
              </description>
            </item>
            <item>
              <term>Send a message from the local machine to a remote machine</term>
              <description>
                <para>
                  <paramref name="Server" /> = &lt;name of the local machine | uninitialized&gt;
                        </para>
                <para>
                  <paramref name="Recipient" /> = &lt;name of the remote machine&gt;
                        </para>
              </description>
            </item>
          </list>
        </para>
        <para>
          <b>Note :</b> security restrictions apply for sending 
            network messages, see <see cref="M:log4net.Appender.NetSendAppender.NetMessageBufferSend(System.String,System.String,System.String,System.String,System.Int32)" /> 
            for more information.
            </para>
      </remarks>
      <example>
        <para>
            An example configuration section to log information 
            using this appender from the local machine, named 
            LOCAL_PC, to machine OPERATOR_PC :
            </para>
        <code lang="XML" escaped="true">
          <appender name="NetSendAppender_Operator" type="log4net.Appender.NetSendAppender">
            <server value="LOCAL_PC" />
            <recipient value="OPERATOR_PC" />
            <layout type="log4net.Layout.PatternLayout" value="%-5p %c [%x] - %m%n" />
          </appender>
        </code>
      </example>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.NetSendAppender.m_server">
      <summary>
            The DNS or NetBIOS name of the server on which the function is to execute.
            </summary>
    </member>
    <member name="F:log4net.Appender.NetSendAppender.m_sender">
      <summary>
            The sender of the network message.
            </summary>
    </member>
    <member name="F:log4net.Appender.NetSendAppender.m_recipient">
      <summary>
            The message alias to which the message should be sent.
            </summary>
    </member>
    <member name="F:log4net.Appender.NetSendAppender.m_securityContext">
      <summary>
            The security context to use for privileged calls
            </summary>
    </member>
    <member name="M:log4net.Appender.NetSendAppender.#ctor">
      <summary>
            Initializes the appender.
            </summary>
      <remarks>
            The default constructor initializes all fields to their default values.
            </remarks>
    </member>
    <member name="M:log4net.Appender.NetSendAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set.
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.NetSendAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.NetSendAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.NetSendAppender.ActivateOptions" /> must be called again.
            </para>
        <para>
            The appender will be ignored if no <see cref="P:log4net.Appender.NetSendAppender.Recipient" /> was specified.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">The required property <see cref="P:log4net.Appender.NetSendAppender.Recipient" /> was not specified.</exception>
    </member>
    <member name="M:log4net.Appender.NetSendAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Sends the event using a network message.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.NetSendAppender.NetMessageBufferSend(System.String,System.String,System.String,System.String,System.Int32)">
      <summary>
            Sends a buffer of information to a registered message alias.
            </summary>
      <param name="serverName">The DNS or NetBIOS name of the server on which the function is to execute.</param>
      <param name="msgName">The message alias to which the message buffer should be sent</param>
      <param name="fromName">The originator of the message.</param>
      <param name="buffer">The message text.</param>
      <param name="bufferSize">The length, in bytes, of the message text.</param>
      <remarks>
        <para>
            The following restrictions apply for sending network messages:
            </para>
        <para>
          <list type="table">
            <listheader>
              <term>Platform</term>
              <description>Requirements</description>
            </listheader>
            <item>
              <term>Windows NT</term>
              <description>
                <para>
                        No special group membership is required to send a network message.
                        </para>
                <para>
                        Admin, Accounts, Print, or Server Operator group membership is required to 
                        successfully send a network message on a remote server.
                        </para>
              </description>
            </item>
            <item>
              <term>Windows 2000 or later</term>
              <description>
                <para>
                        If you send a message on a domain controller that is running Active Directory, 
                        access is allowed or denied based on the access control list (ACL) for the securable 
                        object. The default ACL permits only Domain Admins and Account Operators to send a network message. 
                        </para>
                <para>
                        On a member server or workstation, only Administrators and Server Operators can send a network message. 
                        </para>
              </description>
            </item>
          </list>
        </para>
        <para>
            For more information see <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/security_requirements_for_the_network_management_functions.asp">Security Requirements for the Network Management Functions</a>.
            </para>
      </remarks>
      <returns>
        <para>
            If the function succeeds, the return value is zero.
            </para>
      </returns>
    </member>
    <member name="P:log4net.Appender.NetSendAppender.Sender">
      <summary>
            Gets or sets the sender of the message.
            </summary>
      <value>
            The sender of the message.
            </value>
      <remarks>
            If this property is not specified, the message is sent from the local computer.
            </remarks>
    </member>
    <member name="P:log4net.Appender.NetSendAppender.Recipient">
      <summary>
            Gets or sets the message alias to which the message should be sent.
            </summary>
      <value>
            The recipient of the message.
            </value>
      <remarks>
            This property should always be specified in order to send a message.
            </remarks>
    </member>
    <member name="P:log4net.Appender.NetSendAppender.Server">
      <summary>
            Gets or sets the DNS or NetBIOS name of the remote server on which the function is to execute.
            </summary>
      <value>
            DNS or NetBIOS name of the remote server on which the function is to execute.
            </value>
      <remarks>
        <para>
            For Windows NT 4.0 and earlier, the string should begin with \\.
            </para>
        <para>
            If this property is not specified, the local computer is used. 
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.NetSendAppender.SecurityContext">
      <summary>
            Gets or sets the <see cref="P:log4net.Appender.NetSendAppender.SecurityContext" /> used to call the NetSend method.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.NetSendAppender.SecurityContext" /> used to call the NetSend method.
            </value>
      <remarks>
        <para>
            Unless a <see cref="P:log4net.Appender.NetSendAppender.SecurityContext" /> specified here for this appender
            the <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> is queried for the
            security context to use. The default behavior is to use the security context
            of the current thread.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.NetSendAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.OutputDebugStringAppender">
      <summary>
            Appends log events to the OutputDebugString system.
            </summary>
      <remarks>
        <para>
            OutputDebugStringAppender appends log events to the
            OutputDebugString system.
            </para>
        <para>
            The string is passed to the native <c>OutputDebugString</c> 
            function.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Appender.OutputDebugStringAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.OutputDebugStringAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.OutputDebugStringAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Write the logging event to the output debug string API
            </summary>
      <param name="loggingEvent">the event to log</param>
      <remarks>
        <para>
            Write the logging event to the output debug string API
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.OutputDebugStringAppender.OutputDebugString(System.String)">
      <summary>
            Stub for OutputDebugString native method
            </summary>
      <param name="message">the string to output</param>
      <remarks>
        <para>
            Stub for OutputDebugString native method
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.OutputDebugStringAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.UdpAppender">
      <summary>
             Sends logging events as connectionless UDP datagrams to a remote host or a 
             multicast group using an <see cref="T:System.Net.Sockets.UdpClient" />.
             </summary>
      <remarks>
        <para>
             UDP guarantees neither that messages arrive, nor that they arrive in the correct order.
             </para>
        <para>
             To view the logging results, a custom application can be developed that listens for logging 
             events.
             </para>
        <para>
             When decoding events send via this appender remember to use the same encoding
             to decode the events as was used to send the events. See the <see cref="P:log4net.Appender.UdpAppender.Encoding" />
             property to specify the encoding to use.
             </para>
      </remarks>
      <example>
             This example shows how to log receive logging events that are sent 
             on IP address 244.0.0.1 and port 8080 to the console. The event is 
             encoded in the packet as a unicode string and it is decoded as such. 
             <code lang="C#">
             IPEndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
             UdpClient udpClient;
             byte[] buffer;
             string loggingEvent;
             
             try 
             {
                 udpClient = new UdpClient(8080);
                 
                 while(true) 
                 {
                     buffer = udpClient.Receive(ref remoteEndPoint);
                     loggingEvent = System.Text.Encoding.Unicode.GetString(buffer);
                     Console.WriteLine(loggingEvent);
                 }
             } 
             catch(Exception e) 
             {
                 Console.WriteLine(e.ToString());
             }
             </code><code lang="Visual Basic">
             Dim remoteEndPoint as IPEndPoint
             Dim udpClient as UdpClient
             Dim buffer as Byte()
             Dim loggingEvent as String
             
             Try 
                 remoteEndPoint = new IPEndPoint(IPAddress.Any, 0)
                 udpClient = new UdpClient(8080)
            
                 While True
                     buffer = udpClient.Receive(ByRef remoteEndPoint)
                     loggingEvent = System.Text.Encoding.Unicode.GetString(buffer)
                     Console.WriteLine(loggingEvent)
                 Wend
             Catch e As Exception
                 Console.WriteLine(e.ToString())
             End Try
             </code><para>
             An example configuration section to log information using this appender to the 
             IP 224.0.0.1 on port 8080:
             </para><code lang="XML" escaped="true"><appender name="UdpAppender" type="log4net.Appender.UdpAppender"><remoteAddress value="224.0.0.1" /><remotePort value="8080" /><layout type="log4net.Layout.PatternLayout" value="%-5level %logger [%ndc] - %message%newline" /></appender></code></example>
      <author>Gert Driesen</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Appender.UdpAppender.m_remoteAddress">
      <summary>
            The IP address of the remote host or multicast group to which 
            the logging event will be sent.
            </summary>
    </member>
    <member name="F:log4net.Appender.UdpAppender.m_remotePort">
      <summary>
            The TCP port number of the remote host or multicast group to 
            which the logging event will be sent.
            </summary>
    </member>
    <member name="F:log4net.Appender.UdpAppender.m_remoteEndPoint">
      <summary>
            The cached remote endpoint to which the logging events will be sent.
            </summary>
    </member>
    <member name="F:log4net.Appender.UdpAppender.m_localPort">
      <summary>
            The TCP port number from which the <see cref="T:System.Net.Sockets.UdpClient" /> will communicate.
            </summary>
    </member>
    <member name="F:log4net.Appender.UdpAppender.m_client">
      <summary>
            The <see cref="T:System.Net.Sockets.UdpClient" /> instance that will be used for sending the 
            logging events.
            </summary>
    </member>
    <member name="F:log4net.Appender.UdpAppender.m_encoding">
      <summary>
            The encoding to use for the packet.
            </summary>
    </member>
    <member name="M:log4net.Appender.UdpAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.UdpAppender" /> class.
            </summary>
      <remarks>
            The default constructor initializes all fields to their default values.
            </remarks>
    </member>
    <member name="M:log4net.Appender.UdpAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set.
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.UdpAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.UdpAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.UdpAppender.ActivateOptions" /> must be called again.
            </para>
        <para>
            The appender will be ignored if no <see cref="P:log4net.Appender.UdpAppender.RemoteAddress" /> was specified or 
            an invalid remote or local TCP port number was specified.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">The required property <see cref="P:log4net.Appender.UdpAppender.RemoteAddress" /> was not specified.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">The TCP port number assigned to <see cref="P:log4net.Appender.UdpAppender.LocalPort" /> or <see cref="P:log4net.Appender.UdpAppender.RemotePort" /> is less than <see cref="F:System.Net.IPEndPoint.MinPort" /> or greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
    </member>
    <member name="M:log4net.Appender.UdpAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Sends the event using an UDP datagram.
            </para>
        <para>
            Exceptions are passed to the <see cref="P:log4net.Appender.AppenderSkeleton.ErrorHandler" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.UdpAppender.OnClose">
      <summary>
            Closes the UDP connection and releases all resources associated with 
            this <see cref="T:log4net.Appender.UdpAppender" /> instance.
            </summary>
      <remarks>
        <para>
            Disables the underlying <see cref="T:System.Net.Sockets.UdpClient" /> and releases all managed 
            and unmanaged resources associated with the <see cref="T:log4net.Appender.UdpAppender" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.UdpAppender.InitializeClientConnection">
      <summary>
            Initializes the underlying  <see cref="T:System.Net.Sockets.UdpClient" /> connection.
            </summary>
      <remarks>
        <para>
            The underlying <see cref="T:System.Net.Sockets.UdpClient" /> is initialized and binds to the 
            port number from which you intend to communicate.
            </para>
        <para>
            Exceptions are passed to the <see cref="P:log4net.Appender.AppenderSkeleton.ErrorHandler" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.UdpAppender.RemoteAddress">
      <summary>
            Gets or sets the IP address of the remote host or multicast group to which
            the underlying <see cref="T:System.Net.Sockets.UdpClient" /> should sent the logging event.
            </summary>
      <value>
            The IP address of the remote host or multicast group to which the logging event 
            will be sent.
            </value>
      <remarks>
        <para>
            Multicast addresses are identified by IP class <b>D</b> addresses (in the range 224.0.0.0 to
            239.255.255.255).  Multicast packets can pass across different networks through routers, so
            it is possible to use multicasts in an Internet scenario as long as your network provider 
            supports multicasting.
            </para>
        <para>
            Hosts that want to receive particular multicast messages must register their interest by joining
            the multicast group.  Multicast messages are not sent to networks where no host has joined
            the multicast group.  Class <b>D</b> IP addresses are used for multicast groups, to differentiate
            them from normal host addresses, allowing nodes to easily detect if a message is of interest.
            </para>
        <para>
            Static multicast addresses that are needed globally are assigned by IANA.  A few examples are listed in the table below:
            </para>
        <para>
          <list type="table">
            <listheader>
              <term>IP Address</term>
              <description>Description</description>
            </listheader>
            <item>
              <term>224.0.0.1</term>
              <description>
                <para>
                        Sends a message to all system on the subnet.
                        </para>
              </description>
            </item>
            <item>
              <term>224.0.0.2</term>
              <description>
                <para>
                        Sends a message to all routers on the subnet.
                        </para>
              </description>
            </item>
            <item>
              <term>224.0.0.12</term>
              <description>
                <para>
                        The DHCP server answers messages on the IP address 224.0.0.12, but only on a subnet.
                        </para>
              </description>
            </item>
          </list>
        </para>
        <para>
            A complete list of actually reserved multicast addresses and their owners in the ranges
            defined by RFC 3171 can be found at the <A href="http://www.iana.org/assignments/multicast-addresses">IANA web site</A>. 
            </para>
        <para>
            The address range 239.0.0.0 to 239.255.255.255 is reserved for administrative scope-relative 
            addresses.  These addresses can be reused with other local groups.  Routers are typically 
            configured with filters to prevent multicast traffic in this range from flowing outside
            of the local network.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.UdpAppender.RemotePort">
      <summary>
            Gets or sets the TCP port number of the remote host or multicast group to which 
            the underlying <see cref="T:System.Net.Sockets.UdpClient" /> should sent the logging event.
            </summary>
      <value>
            An integer value in the range <see cref="F:System.Net.IPEndPoint.MinPort" /> to <see cref="F:System.Net.IPEndPoint.MaxPort" /> 
            indicating the TCP port number of the remote host or multicast group to which the logging event 
            will be sent.
            </value>
      <remarks>
            The underlying <see cref="T:System.Net.Sockets.UdpClient" /> will send messages to this TCP port number
            on the remote host or multicast group.
            </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than <see cref="F:System.Net.IPEndPoint.MinPort" /> or greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
    </member>
    <member name="P:log4net.Appender.UdpAppender.LocalPort">
      <summary>
            Gets or sets the TCP port number from which the underlying <see cref="T:System.Net.Sockets.UdpClient" /> will communicate.
            </summary>
      <value>
            An integer value in the range <see cref="F:System.Net.IPEndPoint.MinPort" /> to <see cref="F:System.Net.IPEndPoint.MaxPort" /> 
            indicating the TCP port number from which the underlying <see cref="T:System.Net.Sockets.UdpClient" /> will communicate.
            </value>
      <remarks>
        <para>
            The underlying <see cref="T:System.Net.Sockets.UdpClient" /> will bind to this port for sending messages.
            </para>
        <para>
            Setting the value to 0 (the default) will cause the udp client not to bind to
            a local port.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than <see cref="F:System.Net.IPEndPoint.MinPort" /> or greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
    </member>
    <member name="P:log4net.Appender.UdpAppender.Encoding">
      <summary>
            Gets or sets <see cref="P:log4net.Appender.UdpAppender.Encoding" /> used to write the packets.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.UdpAppender.Encoding" /> used to write the packets.
            </value>
      <remarks>
        <para>
            The <see cref="P:log4net.Appender.UdpAppender.Encoding" /> used to write the packets.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.UdpAppender.Client">
      <summary>
            Gets or sets the underlying <see cref="T:System.Net.Sockets.UdpClient" />.
            </summary>
      <value>
            The underlying <see cref="T:System.Net.Sockets.UdpClient" />.
            </value>
      <remarks>
        <see cref="T:log4net.Appender.UdpAppender" /> creates a <see cref="T:System.Net.Sockets.UdpClient" /> to send logging events 
            over a network.  Classes deriving from <see cref="T:log4net.Appender.UdpAppender" /> can use this
            property to get or set this <see cref="T:System.Net.Sockets.UdpClient" />.  Use the underlying <see cref="T:System.Net.Sockets.UdpClient" />
            returned from <see cref="P:log4net.Appender.UdpAppender.Client" /> if you require access beyond that which 
            <see cref="T:log4net.Appender.UdpAppender" /> provides.
            </remarks>
    </member>
    <member name="P:log4net.Appender.UdpAppender.RemoteEndPoint">
      <summary>
            Gets or sets the cached remote endpoint to which the logging events should be sent.
            </summary>
      <value>
            The cached remote endpoint to which the logging events will be sent.
            </value>
      <remarks>
            The <see cref="M:log4net.Appender.UdpAppender.ActivateOptions" /> method will initialize the remote endpoint 
            with the values of the <see cref="P:log4net.Appender.UdpAppender.RemoteAddress" /> and <see cref="P:log4net.Appender.UdpAppender.RemotePort" />
            properties.
            </remarks>
    </member>
    <member name="P:log4net.Appender.UdpAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RemoteSyslogAppender">
      <summary>
            Logs events to a remote syslog daemon.
            </summary>
      <remarks>
        <para>
            The BSD syslog protocol is used to remotely log to
            a syslog daemon. The syslogd listens for for messages
            on UDP port 514.
            </para>
        <para>
            The syslog UDP protocol is not authenticated. Most syslog daemons
            do not accept remote log messages because of the security implications.
            You may be able to use the LocalSyslogAppender to talk to a local
            syslog service.
            </para>
        <para>
            There is an RFC 3164 that claims to document the BSD Syslog Protocol.
            This RFC can be seen here: http://www.faqs.org/rfcs/rfc3164.html.
            This appender generates what the RFC calls an "Original Device Message",
            i.e. does not include the TIMESTAMP or HOSTNAME fields. By observation
            this format of message will be accepted by all current syslog daemon
            implementations. The daemon will attach the current time and the source
            hostname or IP address to any messages received.
            </para>
        <para>
            Syslog messages must have a facility and and a severity. The severity
            is derived from the Level of the logging event.
            The facility must be chosen from the set of defined syslog 
            <see cref="T:log4net.Appender.RemoteSyslogAppender.SyslogFacility" /> values. The facilities list is predefined
            and cannot be extended.
            </para>
        <para>
            An identifier is specified with each log message. This can be specified
            by setting the <see cref="P:log4net.Appender.RemoteSyslogAppender.Identity" /> property. The identity (also know 
            as the tag) must not contain white space. The default value for the
            identity is the application name (from <see cref="P:log4net.Core.LoggingEvent.Domain" />).
            </para>
      </remarks>
      <author>Rob Lyon</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Appender.RemoteSyslogAppender.SyslogSeverity">
      <summary>
            syslog severities
            </summary>
      <remarks>
        <para>
            The syslog severities.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RemoteSyslogAppender.SyslogFacility">
      <summary>
            syslog facilities
            </summary>
      <remarks>
        <para>
            The syslog facilities
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RemoteSyslogAppender.LevelSeverity">
      <summary>
            A class to act as a mapping between the level that a logging call is made at and
            the syslog severity that is should be logged at.
            </summary>
      <remarks>
        <para>
            A class to act as a mapping between the level that a logging call is made at and
            the syslog severity that is should be logged at.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RemoteSyslogAppender.LevelSeverity.Severity">
      <summary>
            The mapped syslog severity for the specified level
            </summary>
      <remarks>
        <para>
            Required property.
            The mapped syslog severity for the specified level
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.RemoteSyslogAppender.DefaultSyslogPort">
      <summary>
            Syslog port 514
            </summary>
    </member>
    <member name="F:log4net.Appender.RemoteSyslogAppender.m_facility">
      <summary>
            The facility. The default facility is <see cref="F:log4net.Appender.RemoteSyslogAppender.SyslogFacility.User" />.
            </summary>
    </member>
    <member name="F:log4net.Appender.RemoteSyslogAppender.m_identity">
      <summary>
            The message identity
            </summary>
    </member>
    <member name="F:log4net.Appender.RemoteSyslogAppender.m_levelMapping">
      <summary>
            Mapping from level object to syslog severity
            </summary>
    </member>
    <member name="M:log4net.Appender.RemoteSyslogAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.RemoteSyslogAppender" /> class.
            </summary>
      <remarks>
            This instance of the <see cref="T:log4net.Appender.RemoteSyslogAppender" /> class is set up to write 
            to a remote syslog daemon.
            </remarks>
    </member>
    <member name="M:log4net.Appender.RemoteSyslogAppender.AddMapping(log4net.Appender.RemoteSyslogAppender.LevelSeverity)">
      <summary>
            Add a mapping of level to severity
            </summary>
      <param name="mapping">The mapping to add</param>
      <remarks>
        <para>
            Add a <see cref="T:log4net.Appender.RemoteSyslogAppender.LevelSeverity" /> mapping to this appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemoteSyslogAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)" /> method.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the event to a remote syslog daemon.
            </para>
        <para>
            The format of the output will depend on the appender's layout.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemoteSyslogAppender.ActivateOptions">
      <summary>
            Initialize the options for this appender
            </summary>
      <remarks>
        <para>
            Initialize the level to syslog severity mappings set on this appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemoteSyslogAppender.GetSeverity(log4net.Core.Level)">
      <summary>
            Translates a log4net level to a syslog severity.
            </summary>
      <param name="level">A log4net level.</param>
      <returns>A syslog severity.</returns>
      <remarks>
        <para>
            Translates a log4net level to a syslog severity.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemoteSyslogAppender.GeneratePriority(log4net.Appender.RemoteSyslogAppender.SyslogFacility,log4net.Appender.RemoteSyslogAppender.SyslogSeverity)">
      <summary>
            Generate a syslog priority.
            </summary>
      <param name="facility">The syslog facility.</param>
      <param name="severity">The syslog severity.</param>
      <returns>A syslog priority.</returns>
      <remarks>
        <para>
            Generate a syslog priority.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RemoteSyslogAppender.Identity">
      <summary>
            Message identity
            </summary>
      <remarks>
        <para>
            An identifier is specified with each log message. This can be specified
            by setting the <see cref="P:log4net.Appender.RemoteSyslogAppender.Identity" /> property. The identity (also know 
            as the tag) must not contain white space. The default value for the
            identity is the application name (from <see cref="P:log4net.Core.LoggingEvent.Domain" />).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RemoteSyslogAppender.Facility">
      <summary>
            Syslog facility
            </summary>
      <remarks>
            Set to one of the <see cref="T:log4net.Appender.RemoteSyslogAppender.SyslogFacility" /> values. The list of
            facilities is predefined and cannot be extended. The default value
            is <see cref="F:log4net.Appender.RemoteSyslogAppender.SyslogFacility.User" />.
            </remarks>
    </member>
    <member name="T:log4net.Appender.RemotingAppender">
      <summary>
            Delivers logging events to a remote logging sink. 
            </summary>
      <remarks>
        <para>
            This Appender is designed to deliver events to a remote sink. 
            That is any object that implements the <see cref="T:log4net.Appender.RemotingAppender.IRemoteLoggingSink" />
            interface. It delivers the events using .NET remoting. The
            object to deliver events to is specified by setting the
            appenders <see cref="P:log4net.Appender.RemotingAppender.Sink" /> property.</para>
        <para>
            The RemotingAppender buffers events before sending them. This allows it to 
            make more efficient use of the remoting infrastructure.</para>
        <para>
            Once the buffer is full the events are still not sent immediately. 
            They are scheduled to be sent using a pool thread. The effect is that 
            the send occurs asynchronously. This is very important for a 
            number of non obvious reasons. The remoting infrastructure will 
            flow thread local variables (stored in the <see cref="T:System.Runtime.Remoting.Messaging.CallContext" />),
            if they are marked as <see cref="T:System.Runtime.Remoting.Messaging.ILogicalThreadAffinative" />, across the 
            remoting boundary. If the server is not contactable then
            the remoting infrastructure will clear the <see cref="T:System.Runtime.Remoting.Messaging.ILogicalThreadAffinative" />
            objects from the <see cref="T:System.Runtime.Remoting.Messaging.CallContext" />. To prevent a logging failure from
            having side effects on the calling application the remoting call must be made
            from a separate thread to the one used by the application. A <see cref="T:System.Threading.ThreadPool" />
            thread is used for this. If no <see cref="T:System.Threading.ThreadPool" /> thread is available then
            the events will block in the thread pool manager until a thread is available.</para>
        <para>
            Because the events are sent asynchronously using pool threads it is possible to close 
            this appender before all the queued events have been sent.
            When closing the appender attempts to wait until all the queued events have been sent, but 
            this will timeout after 30 seconds regardless.</para>
        <para>
            If this appender is being closed because the <see cref="E:System.AppDomain.ProcessExit" />
            event has fired it may not be possible to send all the queued events. During process
            exit the runtime limits the time that a <see cref="E:System.AppDomain.ProcessExit" />
            event handler is allowed to run for. If the runtime terminates the threads before
            the queued events have been sent then they will be lost. To ensure that all events
            are sent the appender must be closed before the application exits. See 
            <see cref="M:log4net.Core.LoggerManager.Shutdown" /> for details on how to shutdown
            log4net programmatically.</para>
      </remarks>
      <seealso cref="T:log4net.Appender.RemotingAppender.IRemoteLoggingSink" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Daniel Cazzulino</author>
    </member>
    <member name="T:log4net.Appender.RemotingAppender.IRemoteLoggingSink">
      <summary>
            Interface used to deliver <see cref="T:log4net.Core.LoggingEvent" /> objects to a remote sink.
            </summary>
      <remarks>
            This interface must be implemented by a remoting sink
            if the <see cref="T:log4net.Appender.RemotingAppender" /> is to be used
            to deliver logging events to the sink.
            </remarks>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.IRemoteLoggingSink.LogEvents(log4net.Core.LoggingEvent[])">
      <summary>
            Delivers logging events to the remote sink
            </summary>
      <param name="events">Array of events to log.</param>
      <remarks>
        <para>
            Delivers logging events to the remote sink
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.RemotingAppender.m_sinkUrl">
      <summary>
            The URL of the remote sink.
            </summary>
    </member>
    <member name="F:log4net.Appender.RemotingAppender.m_sinkObj">
      <summary>
            The local proxy (.NET remoting) for the remote logging sink.
            </summary>
    </member>
    <member name="F:log4net.Appender.RemotingAppender.m_queuedCallbackCount">
      <summary>
            The number of queued callbacks currently waiting or executing
            </summary>
    </member>
    <member name="F:log4net.Appender.RemotingAppender.m_workQueueEmptyEvent">
      <summary>
            Event used to signal when there are no queued work items
            </summary>
      <remarks>
            This event is set when there are no queued work items. In this
            state it is safe to close the appender.
            </remarks>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.RemotingAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.RemotingAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.RemotingAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.RemotingAppender.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.SendBuffer(log4net.Core.LoggingEvent[])">
      <summary>
            Send the contents of the buffer to the remote sink.
            </summary>
      <remarks>
            The events are not sent immediately. They are scheduled to be sent
            using a pool thread. The effect is that the send occurs asynchronously.
            This is very important for a number of non obvious reasons. The remoting
            infrastructure will flow thread local variables (stored in the <see cref="T:System.Runtime.Remoting.Messaging.CallContext" />),
            if they are marked as <see cref="T:System.Runtime.Remoting.Messaging.ILogicalThreadAffinative" />, across the 
            remoting boundary. If the server is not contactable then
            the remoting infrastructure will clear the <see cref="T:System.Runtime.Remoting.Messaging.ILogicalThreadAffinative" />
            objects from the <see cref="T:System.Runtime.Remoting.Messaging.CallContext" />. To prevent a logging failure from
            having side effects on the calling application the remoting call must be made
            from a separate thread to the one used by the application. A <see cref="T:System.Threading.ThreadPool" />
            thread is used for this. If no <see cref="T:System.Threading.ThreadPool" /> thread is available then
            the events will block in the thread pool manager until a thread is available.
            </remarks>
      <param name="events">The events to send.</param>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.OnClose">
      <summary>
            Override base class close.
            </summary>
      <remarks>
        <para>
            This method waits while there are queued work items. The events are
            sent asynchronously using <see cref="T:System.Threading.ThreadPool" /> work items. These items
            will be sent once a thread pool thread is available to send them, therefore
            it is possible to close the appender before all the queued events have been
            sent.</para>
        <para>
            This method attempts to wait until all the queued events have been sent, but this 
            method will timeout after 30 seconds regardless.</para>
        <para>
            If the appender is being closed because the <see cref="E:System.AppDomain.ProcessExit" />
            event has fired it may not be possible to send all the queued events. During process
            exit the runtime limits the time that a <see cref="E:System.AppDomain.ProcessExit" />
            event handler is allowed to run for.</para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.BeginAsyncSend">
      <summary>
            A work item is being queued into the thread pool
            </summary>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.EndAsyncSend">
      <summary>
            A work item from the thread pool has completed
            </summary>
    </member>
    <member name="M:log4net.Appender.RemotingAppender.SendBufferCallback(System.Object)">
      <summary>
            Send the contents of the buffer to the remote sink.
            </summary>
      <remarks>
            This method is designed to be used with the <see cref="T:System.Threading.ThreadPool" />.
            This method expects to be passed an array of <see cref="T:log4net.Core.LoggingEvent" />
            objects in the state param.
            </remarks>
      <param name="state">the logging events to send</param>
    </member>
    <member name="P:log4net.Appender.RemotingAppender.Sink">
      <summary>
            Gets or sets the URL of the well-known object that will accept 
            the logging events.
            </summary>
      <value>
            The well-known URL of the remote sink.
            </value>
      <remarks>
        <para>
            The URL of the remoting sink that will accept logging events.
            The sink must implement the <see cref="T:log4net.Appender.RemotingAppender.IRemoteLoggingSink" />
            interface.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RollingFileAppender">
      <summary>
            Appender that rolls log files based on size or date or both.
            </summary>
      <remarks>
        <para>
            RollingFileAppender can roll log files based on size or date or both
            depending on the setting of the <see cref="P:log4net.Appender.RollingFileAppender.RollingStyle" /> property.
            When set to <see cref="F:log4net.Appender.RollingFileAppender.RollingMode.Size" /> the log file will be rolled
            once its size exceeds the <see cref="P:log4net.Appender.RollingFileAppender.MaximumFileSize" />.
            When set to <see cref="F:log4net.Appender.RollingFileAppender.RollingMode.Date" /> the log file will be rolled
            once the date boundary specified in the <see cref="P:log4net.Appender.RollingFileAppender.DatePattern" /> property
            is crossed.
            When set to <see cref="F:log4net.Appender.RollingFileAppender.RollingMode.Composite" /> the log file will be
            rolled once the date boundary specified in the <see cref="P:log4net.Appender.RollingFileAppender.DatePattern" /> property
            is crossed, but within a date boundary the file will also be rolled
            once its size exceeds the <see cref="P:log4net.Appender.RollingFileAppender.MaximumFileSize" />.
            When set to <see cref="F:log4net.Appender.RollingFileAppender.RollingMode.Once" /> the log file will be rolled when
            the appender is configured. This effectively means that the log file can be
            rolled once per program execution.
            </para>
        <para>
            A of few additional optional features have been added:
            <list type="bullet"><item>Attach date pattern for current log file <see cref="P:log4net.Appender.RollingFileAppender.StaticLogFileName" /></item><item>Backup number increments for newer files <see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /></item><item>Infinite number of backups by file size <see cref="P:log4net.Appender.RollingFileAppender.MaxSizeRollBackups" /></item></list></para>
        <note>
          <para>
            For large or infinite numbers of backup files a <see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /> 
            greater than zero is highly recommended, otherwise all the backup files need
            to be renamed each time a new backup is created.
            </para>
          <para>
            When Date/Time based rolling is used setting <see cref="P:log4net.Appender.RollingFileAppender.StaticLogFileName" /> 
            to <see langword="true" /> will reduce the number of file renamings to few or none.
            </para>
        </note>
        <note type="caution">
          <para>
            Changing <see cref="P:log4net.Appender.RollingFileAppender.StaticLogFileName" /> or <see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /> without clearing
            the log file directory of backup files will cause unexpected and unwanted side effects.  
            </para>
        </note>
        <para>
            If Date/Time based rolling is enabled this appender will attempt to roll existing files
            in the directory without a Date/Time tag based on the last write date of the base log file.
            The appender only rolls the log file when a message is logged. If Date/Time based rolling 
            is enabled then the appender will not roll the log file at the Date/Time boundary but
            at the point when the next message is logged after the boundary has been crossed.
            </para>
        <para>
            The <see cref="T:log4net.Appender.RollingFileAppender" /> extends the <see cref="T:log4net.Appender.FileAppender" /> and
            has the same behavior when opening the log file.
            The appender will first try to open the file for writing when <see cref="M:log4net.Appender.RollingFileAppender.ActivateOptions" />
            is called. This will typically be during configuration.
            If the file cannot be opened for writing the appender will attempt
            to open the file again each time a message is logged to the appender.
            If the file cannot be opened for writing when a message is logged then
            the message will be discarded by this appender.
            </para>
        <para>
            When rolling a backup file necessitates deleting an older backup file the
            file to be deleted is moved to a temporary name before being deleted.
            </para>
        <note type="caution">
          <para>
            A maximum number of backup files when rolling on date/time boundaries is not supported.
            </para>
        </note>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Aspi Havewala</author>
      <author>Douglas de la Torre</author>
      <author>Edward Smit</author>
    </member>
    <member name="T:log4net.Appender.RollingFileAppender.RollingMode">
      <summary>
            Style of rolling to use
            </summary>
      <remarks>
        <para>
            Style of rolling to use
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RollingFileAppender.RollPoint">
      <summary>
            The code assumes that the following 'time' constants are in a increasing sequence.
            </summary>
      <remarks>
        <para>
            The code assumes that the following 'time' constants are in a increasing sequence.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RollingFileAppender.IDateTime">
      <summary>
            This interface is used to supply Date/Time information to the <see cref="T:log4net.Appender.RollingFileAppender" />.
            </summary>
      <remarks>
            This interface is used to supply Date/Time information to the <see cref="T:log4net.Appender.RollingFileAppender" />.
            Used primarily to allow test classes to plug themselves in so they can
            supply test date/times.
            </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.IDateTime.Now">
      <summary>
            Gets the <i>current</i> time.
            </summary>
      <value>The <i>current</i> time.</value>
      <remarks>
        <para>
            Gets the <i>current</i> time.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.RollingFileAppender.DefaultDateTime">
      <summary>
            Default implementation of <see cref="T:log4net.Appender.RollingFileAppender.IDateTime" /> that returns the current time.
            </summary>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.DefaultDateTime.Now">
      <summary>
            Gets the <b>current</b> time.
            </summary>
      <value>The <b>current</b> time.</value>
      <remarks>
        <para>
            Gets the <b>current</b> time.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_dateTime">
      <summary>
            This object supplies the current date/time.  Allows test code to plug in
            a method to control this class when testing date/time based rolling.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_datePattern">
      <summary>
            The date pattern. By default, the pattern is set to <c>".yyyy-MM-dd"</c> 
            meaning daily rollover.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_scheduledFilename">
      <summary>
            The actual formatted filename that is currently being written to
            or will be the file transferred to on roll over
            (based on staticLogFileName).
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_nextCheck">
      <summary>
            The timestamp when we shall next recompute the filename.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_now">
      <summary>
            Holds date of last roll over
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_rollPoint">
      <summary>
            The type of rolling done
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_maxFileSize">
      <summary>
            The default maximum file size is 10MB
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_maxSizeRollBackups">
      <summary>
            There is zero backup files by default
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_curSizeRollBackups">
      <summary>
            How many sized based backups have been made so far
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_countDirection">
      <summary>
            The rolling file count direction. 
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_rollingStyle">
      <summary>
            The rolling mode used in this appender.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_rollDate">
      <summary>
            Cache flag set if we are rolling by date.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_rollSize">
      <summary>
            Cache flag set if we are rolling by size.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_staticLogFileName">
      <summary>
            Value indicating whether to always log to the same file.
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.m_baseFileName">
      <summary>
            FileName provided in configuration.  Used for rolling properly
            </summary>
    </member>
    <member name="F:log4net.Appender.RollingFileAppender.s_date1970">
      <summary>
            The 1st of January 1970 in UTC
            </summary>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.RollingFileAppender" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.SetQWForFiles(System.IO.TextWriter)">
      <summary>
            Sets the quiet writer being used.
            </summary>
      <remarks>
            This method can be overridden by sub classes.
            </remarks>
      <param name="writer">the writer to set</param>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Write out a logging event.
            </summary>
      <param name="loggingEvent">the event to write to file.</param>
      <remarks>
        <para>
            Handles append time behavior for RollingFileAppender.  This checks
            if a roll over either by date (checked first) or time (checked second)
            is need and then appends to the file last.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.Append(log4net.Core.LoggingEvent[])">
      <summary>
            Write out an array of logging events.
            </summary>
      <param name="loggingEvents">the events to write to file.</param>
      <remarks>
        <para>
            Handles append time behavior for RollingFileAppender.  This checks
            if a roll over either by date (checked first) or time (checked second)
            is need and then appends to the file last.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.AdjustFileBeforeAppend">
      <summary>
            Performs any required rolling before outputting the next event
            </summary>
      <remarks>
        <para>
            Handles append time behavior for RollingFileAppender.  This checks
            if a roll over either by date (checked first) or time (checked second)
            is need and then appends to the file last.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.OpenFile(System.String,System.Boolean)">
      <summary>
            Creates and opens the file for logging.  If <see cref="P:log4net.Appender.RollingFileAppender.StaticLogFileName" />
            is false then the fully qualified name is determined and used.
            </summary>
      <param name="fileName">the name of the file to open</param>
      <param name="append">true to append to existing file</param>
      <remarks>
        <para>This method will ensure that the directory structure
            for the <paramref name="fileName" /> specified exists.</para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.GetNextOutputFileName(System.String)">
      <summary>
            Get the current output file name
            </summary>
      <param name="fileName">the base file name</param>
      <returns>the output file name</returns>
      <remarks>
            The output file name is based on the base fileName specified.
            If <see cref="P:log4net.Appender.RollingFileAppender.StaticLogFileName" /> is set then the output 
            file name is the same as the base file passed in. Otherwise
            the output file depends on the date pattern, on the count
            direction or both.
            </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.DetermineCurSizeRollBackups">
      <summary>
            Determines curSizeRollBackups (only within the current roll point)
            </summary>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.GetWildcardPatternForFile(System.String)">
      <summary>
            Generates a wildcard pattern that can be used to find all files
            that are similar to the base file name.
            </summary>
      <param name="baseFileName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.GetExistingFiles(System.String)">
      <summary>
            Builds a list of filenames for all files matching the base filename plus a file
            pattern.
            </summary>
      <param name="baseFilePath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.RollOverIfDateBoundaryCrossing">
      <summary>
            Initiates a roll over if needed for crossing a date boundary since the last run.
            </summary>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.ExistingInit">
      <summary>
            Initializes based on existing conditions at time of <see cref="M:log4net.Appender.RollingFileAppender.ActivateOptions" />.
            </summary>
      <remarks>
        <para>
            Initializes based on existing conditions at time of <see cref="M:log4net.Appender.RollingFileAppender.ActivateOptions" />.
            The following is done
            <list type="bullet"><item>determine curSizeRollBackups (only within the current roll point)</item><item>initiates a roll over if needed for crossing a date boundary since the last run.</item></list></para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.InitializeFromOneFile(System.String,System.String)">
      <summary>
            Does the work of bumping the 'current' file counter higher
            to the highest count when an incremental file name is seen.
            The highest count is either the first file (when count direction
            is greater than 0) or the last file (when count direction less than 0).
            In either case, we want to know the highest count that is present.
            </summary>
      <param name="baseFile">
      </param>
      <param name="curFileName">
      </param>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.InitializeRollBackups(System.String,System.Collections.ArrayList)">
      <summary>
            Takes a list of files and a base file name, and looks for 
            'incremented' versions of the base file.  Bumps the max
            count up to the highest count seen.
            </summary>
      <param name="baseFile">
      </param>
      <param name="arrayFiles">
      </param>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.ComputeCheckPeriod(System.String)">
      <summary>
            Calculates the RollPoint for the datePattern supplied.
            </summary>
      <param name="datePattern">the date pattern to calculate the check period for</param>
      <returns>The RollPoint that is most accurate for the date pattern supplied</returns>
      <remarks>
            Essentially the date pattern is examined to determine what the
            most suitable roll point is. The roll point chosen is the roll point
            with the smallest period that can be detected using the date pattern
            supplied. i.e. if the date pattern only outputs the year, month, day 
            and hour then the smallest roll point that can be detected would be
            and hourly roll point as minutes could not be detected.
            </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.RollingFileAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.RollingFileAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.RollingFileAppender.ActivateOptions" /> must be called again.
            </para>
        <para>
            Sets initial conditions including date/time roll over information, first check,
            scheduledFilename, and calls <see cref="M:log4net.Appender.RollingFileAppender.ExistingInit" /> to initialize
            the current number of backups.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.RollOverTime(System.Boolean)">
      <summary>
            Rollover the file(s) to date/time tagged file(s).
            </summary>
      <param name="fileIsOpen">set to true if the file to be rolled is currently open</param>
      <remarks>
        <para>
            Rollover the file(s) to date/time tagged file(s).
            Resets curSizeRollBackups. 
            If fileIsOpen is set then the new file is opened (through SafeOpenFile).
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.RollFile(System.String,System.String)">
      <summary>
            Renames file <paramref name="fromFile" /> to file <paramref name="toFile" />.
            </summary>
      <param name="fromFile">Name of existing file to roll.</param>
      <param name="toFile">New name for file.</param>
      <remarks>
        <para>
            Renames file <paramref name="fromFile" /> to file <paramref name="toFile" />. It
            also checks for existence of target file and deletes if it does.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.FileExists(System.String)">
      <summary>
            Test if a file exists at a specified path
            </summary>
      <param name="path">the path to the file</param>
      <returns>true if the file exists</returns>
      <remarks>
        <para>
            Test if a file exists at a specified path
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.DeleteFile(System.String)">
      <summary>
            Deletes the specified file if it exists.
            </summary>
      <param name="fileName">The file to delete.</param>
      <remarks>
        <para>
            Delete a file if is exists.
            The file is first moved to a new filename then deleted.
            This allows the file to be removed even when it cannot
            be deleted, but it still can be moved.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.RollOverSize">
      <summary>
            Implements file roll base on file size.
            </summary>
      <remarks>
        <para>
            If the maximum number of size based backups is reached
            (<c>curSizeRollBackups == maxSizeRollBackups</c>) then the oldest
            file is deleted -- its index determined by the sign of countDirection.
            If <c>countDirection</c> &lt; 0, then files
            {<c>File.1</c>, ..., <c>File.curSizeRollBackups -1</c>}
            are renamed to {<c>File.2</c>, ...,
            <c>File.curSizeRollBackups</c>}. Moreover, <c>File</c> is
            renamed <c>File.1</c> and closed.
            </para>
        <para>
            A new file is created to receive further log output.
            </para>
        <para>
            If <c>maxSizeRollBackups</c> is equal to zero, then the
            <c>File</c> is truncated with no backup files created.
            </para>
        <para>
            If <c>maxSizeRollBackups</c> &lt; 0, then <c>File</c> is
            renamed if needed and no files are deleted.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.RollOverRenameFiles(System.String)">
      <summary>
            Implements file roll.
            </summary>
      <param name="baseFileName">the base name to rename</param>
      <remarks>
        <para>
            If the maximum number of size based backups is reached
            (<c>curSizeRollBackups == maxSizeRollBackups</c>) then the oldest
            file is deleted -- its index determined by the sign of countDirection.
            If <c>countDirection</c> &lt; 0, then files
            {<c>File.1</c>, ..., <c>File.curSizeRollBackups -1</c>}
            are renamed to {<c>File.2</c>, ...,
            <c>File.curSizeRollBackups</c>}. 
            </para>
        <para>
            If <c>maxSizeRollBackups</c> is equal to zero, then the
            <c>File</c> is truncated with no backup files created.
            </para>
        <para>
            If <c>maxSizeRollBackups</c> &lt; 0, then <c>File</c> is
            renamed if needed and no files are deleted.
            </para>
        <para>
            This is called by <see cref="M:log4net.Appender.RollingFileAppender.RollOverSize" /> to rename the files.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.RollingFileAppender.NextCheckDate(System.DateTime,log4net.Appender.RollingFileAppender.RollPoint)">
      <summary>
            Get the start time of the next window for the current rollpoint
            </summary>
      <param name="currentDateTime">the current date</param>
      <param name="rollPoint">the type of roll point we are working with</param>
      <returns>the start time for the next roll point an interval after the currentDateTime date</returns>
      <remarks>
        <para>
            Returns the date of the next roll point after the currentDateTime date passed to the method.
            </para>
        <para>
            The basic strategy is to subtract the time parts that are less significant
            than the rollpoint from the current time. This should roll the time back to
            the start of the time window for the current rollpoint. Then we add 1 window
            worth of time and get the start time of the next window for the rollpoint.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.DatePattern">
      <summary>
            Gets or sets the date pattern to be used for generating file names
            when rolling over on date.
            </summary>
      <value>
            The date pattern to be used for generating file names when rolling 
            over on date.
            </value>
      <remarks>
        <para>
            Takes a string in the same format as expected by 
            <see cref="T:log4net.DateFormatter.SimpleDateFormatter" />.
            </para>
        <para>
            This property determines the rollover schedule when rolling over
            on date.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.MaxSizeRollBackups">
      <summary>
            Gets or sets the maximum number of backup files that are kept before
            the oldest is erased.
            </summary>
      <value>
            The maximum number of backup files that are kept before the oldest is
            erased.
            </value>
      <remarks>
        <para>
            If set to zero, then there will be no backup files and the log file 
            will be truncated when it reaches <see cref="P:log4net.Appender.RollingFileAppender.MaxFileSize" />.  
            </para>
        <para>
            If a negative number is supplied then no deletions will be made.  Note 
            that this could result in very slow performance as a large number of 
            files are rolled over unless <see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /> is used.
            </para>
        <para>
            The maximum applies to <b>each</b> time based group of files and 
            <b>not</b> the total.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.MaxFileSize">
      <summary>
            Gets or sets the maximum size that the output file is allowed to reach
            before being rolled over to backup files.
            </summary>
      <value>
            The maximum size in bytes that the output file is allowed to reach before being 
            rolled over to backup files.
            </value>
      <remarks>
        <para>
            This property is equivalent to <see cref="P:log4net.Appender.RollingFileAppender.MaximumFileSize" /> except
            that it is required for differentiating the setter taking a
            <see cref="T:System.Int64" /> argument from the setter taking a <see cref="T:System.String" /> 
            argument.
            </para>
        <para>
            The default maximum file size is 10MB (10*1024*1024).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.MaximumFileSize">
      <summary>
            Gets or sets the maximum size that the output file is allowed to reach
            before being rolled over to backup files.
            </summary>
      <value>
            The maximum size that the output file is allowed to reach before being 
            rolled over to backup files.
            </value>
      <remarks>
        <para>
            This property allows you to specify the maximum size with the
            suffixes "KB", "MB" or "GB" so that the size is interpreted being 
            expressed respectively in kilobytes, megabytes or gigabytes. 
            </para>
        <para>
            For example, the value "10KB" will be interpreted as 10240 bytes.
            </para>
        <para>
            The default maximum file size is 10MB.
            </para>
        <para>
            If you have the option to set the maximum file size programmatically
            consider using the <see cref="P:log4net.Appender.RollingFileAppender.MaxFileSize" /> property instead as this
            allows you to set the size in bytes as a <see cref="T:System.Int64" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.CountDirection">
      <summary>
            Gets or sets the rolling file count direction. 
            </summary>
      <value>
            The rolling file count direction.
            </value>
      <remarks>
        <para>
            Indicates if the current file is the lowest numbered file or the
            highest numbered file.
            </para>
        <para>
            By default newer files have lower numbers (<see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /> &lt; 0),
            i.e. log.1 is most recent, log.5 is the 5th backup, etc...
            </para>
        <para>
          <see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /> &gt;= 0 does the opposite i.e.
            log.1 is the first backup made, log.5 is the 5th backup made, etc.
            For infinite backups use <see cref="P:log4net.Appender.RollingFileAppender.CountDirection" /> &gt;= 0 to reduce 
            rollover costs.
            </para>
        <para>The default file count direction is -1.</para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.RollingStyle">
      <summary>
            Gets or sets the rolling style.
            </summary>
      <value>The rolling style.</value>
      <remarks>
        <para>
            The default rolling style is <see cref="F:log4net.Appender.RollingFileAppender.RollingMode.Composite" />.
            </para>
        <para>
            When set to <see cref="F:log4net.Appender.RollingFileAppender.RollingMode.Once" /> this appender's
            <see cref="P:log4net.Appender.FileAppender.AppendToFile" /> property is set to <c>false</c>, otherwise
            the appender would append to a single file rather than rolling
            the file each time it is opened.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.RollingFileAppender.StaticLogFileName">
      <summary>
            Gets or sets a value indicating whether to always log to
            the same file.
            </summary>
      <value>
        <c>true</c> if always should be logged to the same file, otherwise <c>false</c>.
            </value>
      <remarks>
        <para>
            By default file.log is always the current file.  Optionally
            file.log.yyyy-mm-dd for current formatted datePattern can by the currently
            logging file (or file.log.curSizeRollBackup or even
            file.log.yyyy-mm-dd.curSizeRollBackup).
            </para>
        <para>
            This will make time based rollovers with a large number of backups 
            much faster as the appender it won't have to rename all the backups!
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.SmtpAppender">
      <summary>
            Send an e-mail when a specific logging event occurs, typically on errors 
            or fatal errors.
            </summary>
      <remarks>
        <para>
            The number of logging events delivered in this e-mail depend on
            the value of <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> option. The
            <see cref="T:log4net.Appender.SmtpAppender" /> keeps only the last
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> logging events in its 
            cyclic buffer. This keeps memory requirements at a reasonable level while 
            still delivering useful application context.
            </para>
        <note type="caution">
            Authentication and setting the server Port are only available on the MS .NET 1.1 runtime.
            For these features to be enabled you need to ensure that you are using a version of
            the log4net assembly that is built against the MS .NET 1.1 framework and that you are
            running the your application on the MS .NET 1.1 runtime. On all other platforms only sending
            unauthenticated messages to a server listening on port 25 (the default) is supported.
            </note>
        <para>
            Authentication is supported by setting the <see cref="P:log4net.Appender.SmtpAppender.Authentication" /> property to
            either <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Basic" /> or <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Ntlm" />.
            If using <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Basic" /> authentication then the <see cref="P:log4net.Appender.SmtpAppender.Username" />
            and <see cref="P:log4net.Appender.SmtpAppender.Password" /> properties must also be set.
            </para>
        <para>
            To set the SMTP server port use the <see cref="P:log4net.Appender.SmtpAppender.Port" /> property. The default port is 25.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Appender.SmtpAppender.SmtpAuthentication">
      <summary>
            Values for the <see cref="P:log4net.Appender.SmtpAppender.Authentication" /> property.
            </summary>
      <remarks>
        <para>
            SMTP authentication modes.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.SmtpAppender.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.SmtpAppender.SendBuffer(log4net.Core.LoggingEvent[])">
      <summary>
            Sends the contents of the cyclic buffer as an e-mail message.
            </summary>
      <param name="events">The logging events to send.</param>
    </member>
    <member name="M:log4net.Appender.SmtpAppender.SendEmail(System.String)">
      <summary>
            Send the email message
            </summary>
      <param name="messageBody">the body text to include in the mail</param>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.To">
      <summary>
            Gets or sets a semicolon-delimited list of recipient e-mail addresses.
            </summary>
      <value>
            A semicolon-delimited list of e-mail addresses.
            </value>
      <remarks>
        <para>
            A semicolon-delimited list of recipient e-mail addresses.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.From">
      <summary>
            Gets or sets the e-mail address of the sender.
            </summary>
      <value>
            The e-mail address of the sender.
            </value>
      <remarks>
        <para>
            The e-mail address of the sender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Subject">
      <summary>
            Gets or sets the subject line of the e-mail message.
            </summary>
      <value>
            The subject line of the e-mail message.
            </value>
      <remarks>
        <para>
            The subject line of the e-mail message.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.SmtpHost">
      <summary>
            Gets or sets the name of the SMTP relay mail server to use to send 
            the e-mail messages.
            </summary>
      <value>
            The name of the e-mail relay server. If SmtpServer is not set, the 
            name of the local SMTP server is used.
            </value>
      <remarks>
        <para>
            The name of the e-mail relay server. If SmtpServer is not set, the 
            name of the local SMTP server is used.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.LocationInfo">
      <summary>
            Obsolete
            </summary>
      <remarks>
            Use the BufferingAppenderSkeleton Fix methods instead 
            </remarks>
      <remarks>
        <para>
            Obsolete property.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Authentication">
      <summary>
            The mode to use to authentication with the SMTP server
            </summary>
      <remarks>
        <note type="caution">Authentication is only available on the MS .NET 1.1 runtime.</note>
        <para>
            Valid Authentication mode values are: <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.None" />, 
            <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Basic" />, and <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Ntlm" />. 
            The default value is <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.None" />. When using 
            <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Basic" /> you must specify the <see cref="P:log4net.Appender.SmtpAppender.Username" /> 
            and <see cref="P:log4net.Appender.SmtpAppender.Password" /> to use to authenticate.
            When using <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Ntlm" /> the Windows credentials for the current
            thread, if impersonating, or the process will be used to authenticate. 
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Username">
      <summary>
            The username to use to authenticate with the SMTP server
            </summary>
      <remarks>
        <note type="caution">Authentication is only available on the MS .NET 1.1 runtime.</note>
        <para>
            A <see cref="P:log4net.Appender.SmtpAppender.Username" /> and <see cref="P:log4net.Appender.SmtpAppender.Password" /> must be specified when 
            <see cref="P:log4net.Appender.SmtpAppender.Authentication" /> is set to <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Basic" />, 
            otherwise the username will be ignored. 
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Password">
      <summary>
            The password to use to authenticate with the SMTP server
            </summary>
      <remarks>
        <note type="caution">Authentication is only available on the MS .NET 1.1 runtime.</note>
        <para>
            A <see cref="P:log4net.Appender.SmtpAppender.Username" /> and <see cref="P:log4net.Appender.SmtpAppender.Password" /> must be specified when 
            <see cref="P:log4net.Appender.SmtpAppender.Authentication" /> is set to <see cref="F:log4net.Appender.SmtpAppender.SmtpAuthentication.Basic" />, 
            otherwise the password will be ignored. 
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Port">
      <summary>
            The port on which the SMTP server is listening
            </summary>
      <remarks>
        <note type="caution">Server Port is only available on the MS .NET 1.1 runtime.</note>
        <para>
            The port on which the SMTP server is listening. The default
            port is <c>25</c>. The Port can only be changed when running on
            the MS .NET 1.1 runtime.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.Priority">
      <summary>
            Gets or sets the priority of the e-mail message
            </summary>
      <value>
            One of the <see cref="T:System.Net.Mail.MailPriority" /> values.
            </value>
      <remarks>
        <para>
            Sets the priority of the e-mails generated by this
            appender. The default priority is <see cref="F:System.Net.Mail.MailPriority.Normal" />.
            </para>
        <para>
            If you are using this appender to report errors then
            you may want to set the priority to <see cref="F:System.Net.Mail.MailPriority.High" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.SmtpPickupDirAppender">
      <summary>
            Send an email when a specific logging event occurs, typically on errors 
            or fatal errors. Rather than sending via smtp it writes a file into the
            directory specified by <see cref="P:log4net.Appender.SmtpPickupDirAppender.PickupDir" />. This allows services such
            as the IIS SMTP agent to manage sending the messages.
            </summary>
      <remarks>
        <para>
            The configuration for this appender is identical to that of the <c>SMTPAppender</c>,
            except that instead of specifying the <c>SMTPAppender.SMTPHost</c> you specify
            <see cref="P:log4net.Appender.SmtpPickupDirAppender.PickupDir" />.
            </para>
        <para>
            The number of logging events delivered in this e-mail depend on
            the value of <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> option. The
            <see cref="T:log4net.Appender.SmtpPickupDirAppender" /> keeps only the last
            <see cref="P:log4net.Appender.BufferingAppenderSkeleton.BufferSize" /> logging events in its 
            cyclic buffer. This keeps memory requirements at a reasonable level while 
            still delivering useful application context.
            </para>
      </remarks>
      <author>Niall Daley</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Appender.SmtpPickupDirAppender.m_securityContext">
      <summary>
            The security context to use for privileged calls
            </summary>
    </member>
    <member name="M:log4net.Appender.SmtpPickupDirAppender.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.SmtpPickupDirAppender.SendBuffer(log4net.Core.LoggingEvent[])">
      <summary>
            Sends the contents of the cyclic buffer as an e-mail message.
            </summary>
      <param name="events">The logging events to send.</param>
      <remarks>
        <para>
            Sends the contents of the cyclic buffer as an e-mail message.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.SmtpPickupDirAppender.ActivateOptions">
      <summary>
            Activate the options on this appender. 
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.SmtpPickupDirAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.SmtpPickupDirAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.SmtpPickupDirAppender.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.SmtpPickupDirAppender.ConvertToFullPath(System.String)">
      <summary>
            Convert a path into a fully qualified path.
            </summary>
      <param name="path">The path to convert.</param>
      <returns>The fully qualified path.</returns>
      <remarks>
        <para>
            Converts the path specified to a fully
            qualified path. If the path is relative it is
            taken as relative from the application base 
            directory.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpPickupDirAppender.To">
      <summary>
            Gets or sets a semicolon-delimited list of recipient e-mail addresses.
            </summary>
      <value>
            A semicolon-delimited list of e-mail addresses.
            </value>
      <remarks>
        <para>
            A semicolon-delimited list of e-mail addresses.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpPickupDirAppender.From">
      <summary>
            Gets or sets the e-mail address of the sender.
            </summary>
      <value>
            The e-mail address of the sender.
            </value>
      <remarks>
        <para>
            The e-mail address of the sender.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpPickupDirAppender.Subject">
      <summary>
            Gets or sets the subject line of the e-mail message.
            </summary>
      <value>
            The subject line of the e-mail message.
            </value>
      <remarks>
        <para>
            The subject line of the e-mail message.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpPickupDirAppender.PickupDir">
      <summary>
            Gets or sets the path to write the messages to.
            </summary>
      <remarks>
        <para>
            Gets or sets the path to write the messages to. This should be the same
            as that used by the agent sending the messages.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpPickupDirAppender.SecurityContext">
      <summary>
            Gets or sets the <see cref="P:log4net.Appender.SmtpPickupDirAppender.SecurityContext" /> used to write to the pickup directory.
            </summary>
      <value>
            The <see cref="P:log4net.Appender.SmtpPickupDirAppender.SecurityContext" /> used to write to the pickup directory.
            </value>
      <remarks>
        <para>
            Unless a <see cref="P:log4net.Appender.SmtpPickupDirAppender.SecurityContext" /> specified here for this appender
            the <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> is queried for the
            security context to use. The default behavior is to use the security context
            of the current thread.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.SmtpPickupDirAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.TelnetAppender">
      <summary>
            Appender that allows clients to connect via Telnet to receive log messages
            </summary>
      <remarks>
        <para>
            The TelnetAppender accepts socket connections and streams logging messages
            back to the client.  
            The output is provided in a telnet-friendly way so that a log can be monitored 
            over a TCP/IP socket.
            This allows simple remote monitoring of application logging.
            </para>
        <para>
            The default <see cref="P:log4net.Appender.TelnetAppender.Port" /> is 23 (the telnet port).
            </para>
      </remarks>
      <author>Keith Long</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Appender.TelnetAppender.SocketHandler">
      <summary>
            Helper class to manage connected clients
            </summary>
      <remarks>
        <para>
            The SocketHandler class is used to accept connections from
            clients.  It is threaded so that clients can connect/disconnect
            asynchronously.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.TelnetAppender.SocketHandler.SocketClient">
      <summary>
            Class that represents a client connected to this handler
            </summary>
      <remarks>
        <para>
            Class that represents a client connected to this handler
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.SocketClient.#ctor(System.Net.Sockets.Socket)">
      <summary>
            Create this <see cref="T:log4net.Appender.TelnetAppender.SocketHandler.SocketClient" /> for the specified <see cref="T:System.Net.Sockets.Socket" /></summary>
      <param name="socket">the client's socket</param>
      <remarks>
        <para>
            Opens a stream writer on the socket.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.SocketClient.Send(System.String)">
      <summary>
            Write a string to the client
            </summary>
      <param name="message">string to send</param>
      <remarks>
        <para>
            Write a string to the client
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.SocketClient.Dispose">
      <summary>
            Cleanup the clients connection
            </summary>
      <remarks>
        <para>
            Close the socket connection.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.#ctor(System.Int32)">
      <summary>
            Opens a new server port on <paramref ref="port" /></summary>
      <param name="port">the local port to listen on for connections</param>
      <remarks>
        <para>
            Creates a socket handler on the specified local server port.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.Send(System.String)">
      <summary>
            Sends a string message to each of the connected clients
            </summary>
      <param name="message">the text to send</param>
      <remarks>
        <para>
            Sends a string message to each of the connected clients
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.AddClient(log4net.Appender.TelnetAppender.SocketHandler.SocketClient)">
      <summary>
            Add a client to the internal clients list
            </summary>
      <param name="client">client to add</param>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.RemoveClient(log4net.Appender.TelnetAppender.SocketHandler.SocketClient)">
      <summary>
            Remove a client from the internal clients list
            </summary>
      <param name="client">client to remove</param>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.OnConnect(System.IAsyncResult)">
      <summary>
            Callback used to accept a connection on the server socket
            </summary>
      <param name="asyncResult">The result of the asynchronous operation</param>
      <remarks>
        <para>
            On connection adds to the list of connections 
            if there are two many open connections you will be disconnected
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.SocketHandler.Dispose">
      <summary>
            Close all network connections
            </summary>
      <remarks>
        <para>
            Make sure we close all network connections
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TelnetAppender.SocketHandler.HasConnections">
      <summary>
            Test if this handler has active connections
            </summary>
      <value>
        <c>true</c> if this handler has active connections
            </value>
      <remarks>
        <para>
            This property will be <c>true</c> while this handler has
            active connections, that is at least one connection that 
            the handler will attempt to send a message to.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.OnClose">
      <summary>
            Overrides the parent method to close the socket handler
            </summary>
      <remarks>
        <para>
            Closes all the outstanding connections.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.ActivateOptions">
      <summary>
            Initialize the appender based on the options set.
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Appender.TelnetAppender.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Appender.TelnetAppender.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Appender.TelnetAppender.ActivateOptions" /> must be called again.
            </para>
        <para>
            Create the socket handler and wait for connections
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TelnetAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Writes the logging event to each connected client.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the logging event to each connected client.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TelnetAppender.Port">
      <summary>
            Gets or sets the TCP port number on which this <see cref="T:log4net.Appender.TelnetAppender" /> will listen for connections.
            </summary>
      <value>
            An integer value in the range <see cref="F:System.Net.IPEndPoint.MinPort" /> to <see cref="F:System.Net.IPEndPoint.MaxPort" /> 
            indicating the TCP port number on which this <see cref="T:log4net.Appender.TelnetAppender" /> will listen for connections.
            </value>
      <remarks>
        <para>
            The default value is 23 (the telnet port).
            </para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than <see cref="F:System.Net.IPEndPoint.MinPort" /> 
            or greater than <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
    </member>
    <member name="P:log4net.Appender.TelnetAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Appender.TraceAppender">
      <summary>
            Appends log events to the <see cref="T:System.Diagnostics.Trace" /> system.
            </summary>
      <remarks>
        <para>
            The application configuration file can be used to control what listeners 
            are actually used. See the MSDN documentation for the 
            <see cref="T:System.Diagnostics.Trace" /> class for details on configuring the
            trace system.
            </para>
        <para>
            Events are written using the <c>System.Diagnostics.Trace.Write(string,string)</c>
            method. The event's logger name is passed as the value for the category name to the Write method.
            </para>
        <para>
          <b>Compact Framework</b>
          <br />
            The Compact Framework does not support the <see cref="T:System.Diagnostics.Trace" />
            class for any operation except <c>Assert</c>. When using the Compact Framework this
            appender will write to the <see cref="T:System.Diagnostics.Debug" /> system rather than
            the Trace system. This appender will therefore behave like the <see cref="T:log4net.Appender.DebugAppender" />.
            </para>
      </remarks>
      <author>Douglas de la Torre</author>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Appender.TraceAppender.m_immediateFlush">
      <summary>
            Immediate flush means that the underlying writer or output stream
            will be flushed at the end of each append operation.
            </summary>
      <remarks>
        <para>
            Immediate flush is slower but ensures that each append request is 
            actually written. If <see cref="P:log4net.Appender.TraceAppender.ImmediateFlush" /> is set to
            <c>false</c>, then there is a good chance that the last few
            logs events are not actually written to persistent media if and
            when the application crashes.
            </para>
        <para>
            The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TraceAppender.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.TraceAppender" />.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TraceAppender.#ctor(log4net.Layout.ILayout)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Appender.TraceAppender" /> 
            with a specified layout.
            </summary>
      <param name="layout">The layout to use with this appender.</param>
      <remarks>
        <para>
            Obsolete constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Appender.TraceAppender.Append(log4net.Core.LoggingEvent)">
      <summary>
            Writes the logging event to the <see cref="T:System.Diagnostics.Trace" /> system.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Writes the logging event to the <see cref="T:System.Diagnostics.Trace" /> system.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TraceAppender.ImmediateFlush">
      <summary>
            Gets or sets a value that indicates whether the appender will 
            flush at the end of each write.
            </summary>
      <remarks>
        <para>The default behavior is to flush at the end of each 
            write. If the option is set to<c>false</c>, then the underlying 
            stream can defer writing to physical medium to a later time. 
            </para>
        <para>
            Avoiding the flush operation at the end of each append results 
            in a performance gain of 10 to 20 percent. However, there is safety
            trade-off involved in skipping flushing. Indeed, when flushing is
            skipped, then it is likely that the last few log events will not
            be recorded on disk when the application exits. This is a high
            price to pay even for a 20% performance gain.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Appender.TraceAppender.RequiresLayout">
      <summary>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            This appender requires a <see cref="N:log4net.Layout" /> to be set.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.AliasRepositoryAttribute">
      <summary>
            Assembly level attribute that specifies a repository to alias to this assembly's repository.
            </summary>
      <remarks>
        <para>
            An assembly's logger repository is defined by its <see cref="T:log4net.Config.RepositoryAttribute" />,
            however this can be overridden by an assembly loaded before the target assembly.
            </para>
        <para>
            An assembly can alias another assembly's repository to its repository by
            specifying this attribute with the name of the target repository.
            </para>
        <para>
            This attribute can only be specified on the assembly and may be used
            as many times as necessary to alias all the required repositories.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.AliasRepositoryAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.AliasRepositoryAttribute" /> class with 
            the specified repository to alias to this assembly's repository.
            </summary>
      <param name="name">The repository to alias to this assemby's repository.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Config.AliasRepositoryAttribute" /> class with 
            the specified repository to alias to this assembly's repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.AliasRepositoryAttribute.Name">
      <summary>
            Gets or sets the repository to alias to this assemby's repository.
            </summary>
      <value>
            The repository to alias to this assemby's repository.
            </value>
      <remarks>
        <para>
            The name of the repository to alias to this assemby's repository.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.AliasDomainAttribute">
      <summary>
            Assembly level attribute that specifies a domain to alias to this assembly's repository.
            </summary>
      <remarks>
        <para>
          <b>AliasDomainAttribute is obsolete. Use AliasRepositoryAttribute instead of AliasDomainAttribute.</b>
        </para>
        <para>
            An assembly's logger repository is defined by its <see cref="T:log4net.Config.DomainAttribute" />,
            however this can be overridden by an assembly loaded before the target assembly.
            </para>
        <para>
            An assembly can alias another assembly's domain to its repository by
            specifying this attribute with the name of the target domain.
            </para>
        <para>
            This attribute can only be specified on the assembly and may be used
            as many times as necessary to alias all the required domains.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.AliasDomainAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.AliasDomainAttribute" /> class with 
            the specified domain to alias to this assembly's repository.
            </summary>
      <param name="name">The domain to alias to this assemby's repository.</param>
      <remarks>
        <para>
            Obsolete. Use <see cref="T:log4net.Config.AliasRepositoryAttribute" /> instead of <see cref="T:log4net.Config.AliasDomainAttribute" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.BasicConfigurator">
      <summary>
            Use this class to quickly configure a <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />.
            </summary>
      <remarks>
        <para>
            Allows very simple programmatic configuration of log4net.
            </para>
        <para>
            Only one appender can be configured using this configurator.
            The appender is set at the root of the hierarchy and all logging
            events will be delivered to that appender.
            </para>
        <para>
            Appenders can also implement the <see cref="T:log4net.Core.IOptionHandler" /> interface. Therefore
            they would require that the <see cref="M:log4net.Core.IOptionHandler.ActivateOptions" /> method
            be called after the appenders properties have been configured.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.BasicConfigurator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.BasicConfigurator" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to prevent instantiation of this class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.BasicConfigurator.Configure">
      <summary>
            Initializes the log4net system with a default configuration.
            </summary>
      <remarks>
        <para>
            Initializes the log4net logging system using a <see cref="T:log4net.Appender.ConsoleAppender" />
            that will write to <c>Console.Out</c>. The log messages are
            formatted using the <see cref="T:log4net.Layout.PatternLayout" /> layout object
            with the <see cref="F:log4net.Layout.PatternLayout.DetailConversionPattern" />
            layout style.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.BasicConfigurator.Configure(log4net.Appender.IAppender)">
      <summary>
            Initializes the log4net system using the specified appender.
            </summary>
      <param name="appender">The appender to use to log all logging events.</param>
      <remarks>
        <para>
            Initializes the log4net system using the specified appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.BasicConfigurator.Configure(log4net.Repository.ILoggerRepository)">
      <summary>
            Initializes the <see cref="T:log4net.Repository.ILoggerRepository" /> with a default configuration.
            </summary>
      <param name="repository">The repository to configure.</param>
      <remarks>
        <para>
            Initializes the specified repository using a <see cref="T:log4net.Appender.ConsoleAppender" />
            that will write to <c>Console.Out</c>. The log messages are
            formatted using the <see cref="T:log4net.Layout.PatternLayout" /> layout object
            with the <see cref="F:log4net.Layout.PatternLayout.DetailConversionPattern" />
            layout style.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.BasicConfigurator.Configure(log4net.Repository.ILoggerRepository,log4net.Appender.IAppender)">
      <summary>
            Initializes the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified appender.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="appender">The appender to use to log all logging events.</param>
      <remarks>
        <para>
            Initializes the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified appender.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.ConfiguratorAttribute">
      <summary>
            Base class for all log4net configuration attributes.
            </summary>
      <remarks>
            This is an abstract class that must be extended by 
            specific configurators. This attribute allows the
            configurator to be parameterized by an assembly level
            attribute.
            </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.ConfiguratorAttribute.#ctor(System.Int32)">
      <summary>
            Constructor used by subclasses.
            </summary>
      <param name="priority">the ordering priority for this configurator</param>
      <remarks>
        <para>
            The <paramref name="priority" /> is used to order the configurator
            attributes before they are invoked. Higher priority configurators are executed
            before lower priority ones.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.ConfiguratorAttribute.Configure(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified assembly.
            </summary>
      <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
      <param name="targetRepository">The repository to configure.</param>
      <remarks>
        <para>
            Abstract method implemented by a subclass. When this method is called
            the subclass should configure the <paramref name="targetRepository" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.ConfiguratorAttribute.CompareTo(System.Object)">
      <summary>
            Compare this instance to another ConfiguratorAttribute
            </summary>
      <param name="obj">the object to compare to</param>
      <returns>see <see cref="M:System.IComparable.CompareTo(System.Object)" /></returns>
      <remarks>
        <para>
            Compares the priorities of the two <see cref="T:log4net.Config.ConfiguratorAttribute" /> instances.
            Sorts by priority in descending order. Objects with the same priority are
            randomly ordered.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.RepositoryAttribute">
      <summary>
            Assembly level attribute that specifies the logging repository for the assembly.
            </summary>
      <remarks>
        <para>
            Assemblies are mapped to logging repository. This attribute specified 
            on the assembly controls
            the configuration of the repository. The <see cref="P:log4net.Config.RepositoryAttribute.Name" /> property specifies the name
            of the repository that this assembly is a part of. The <see cref="P:log4net.Config.RepositoryAttribute.RepositoryType" />
            specifies the type of the <see cref="T:log4net.Repository.ILoggerRepository" /> object 
            to create for the assembly. If this attribute is not specified or a <see cref="P:log4net.Config.RepositoryAttribute.Name" /> 
            is not specified then the assembly will be part of the default shared logging repository.
            </para>
        <para>
            This attribute can only be specified on the assembly and may only be used
            once per assembly.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.RepositoryAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.RepositoryAttribute" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.RepositoryAttribute.#ctor(System.String)">
      <summary>
            Initialize a new instance of the <see cref="T:log4net.Config.RepositoryAttribute" /> class 
            with the name of the repository.
            </summary>
      <param name="name">The name of the repository.</param>
      <remarks>
        <para>
            Initialize the attribute with the name for the assembly's repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.RepositoryAttribute.Name">
      <summary>
            Gets or sets the name of the logging repository.
            </summary>
      <value>
            The string name to use as the name of the repository associated with this
            assembly.
            </value>
      <remarks>
        <para>
            This value does not have to be unique. Several assemblies can share the
            same repository. They will share the logging configuration of the repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.RepositoryAttribute.RepositoryType">
      <summary>
            Gets or sets the type of repository to create for this assembly.
            </summary>
      <value>
            The type of repository to create for this assembly.
            </value>
      <remarks>
        <para>
            The type of the repository to create for the assembly.
            The type must implement the <see cref="T:log4net.Repository.ILoggerRepository" />
            interface.
            </para>
        <para>
            This will be the type of repository created when 
            the repository is created. If multiple assemblies reference the
            same repository then the repository is only created once using the
            <see cref="P:log4net.Config.RepositoryAttribute.RepositoryType" /> of the first assembly to call into the 
            repository.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.DomainAttribute">
      <summary>
            Assembly level attribute that specifies the logging domain for the assembly.
            </summary>
      <remarks>
        <para>
          <b>DomainAttribute is obsolete. Use RepositoryAttribute instead of DomainAttribute.</b>
        </para>
        <para>
            Assemblies are mapped to logging domains. Each domain has its own
            logging repository. This attribute specified on the assembly controls
            the configuration of the domain. The <see cref="P:log4net.Config.RepositoryAttribute.Name" /> property specifies the name
            of the domain that this assembly is a part of. The <see cref="P:log4net.Config.RepositoryAttribute.RepositoryType" />
            specifies the type of the repository objects to create for the domain. If 
            this attribute is not specified and a <see cref="P:log4net.Config.RepositoryAttribute.Name" /> is not specified
            then the assembly will be part of the default shared logging domain.
            </para>
        <para>
            This attribute can only be specified on the assembly and may only be used
            once per assembly.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.DomainAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.DomainAttribute" /> class.
            </summary>
      <remarks>
        <para>
            Obsolete. Use RepositoryAttribute instead of DomainAttribute.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.DomainAttribute.#ctor(System.String)">
      <summary>
            Initialize a new instance of the <see cref="T:log4net.Config.DomainAttribute" /> class 
            with the name of the domain.
            </summary>
      <param name="name">The name of the domain.</param>
      <remarks>
        <para>
            Obsolete. Use RepositoryAttribute instead of DomainAttribute.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.DOMConfigurator">
      <summary>
            Use this class to initialize the log4net environment using an Xml tree.
            </summary>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            Configures a <see cref="T:log4net.Repository.ILoggerRepository" /> using an Xml tree.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.#ctor">
      <summary>
            Private constructor
            </summary>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure">
      <summary>
            Automatically configures the log4net system based on the 
            application's configuration settings.
            </summary>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
            Each application has a configuration file. This has the
            same name as the application with '.config' appended.
            This file is XML and calling this function prompts the
            configurator to look in that file for a section called
            <c>log4net</c> that contains the configuration data.
            </remarks>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(log4net.Repository.ILoggerRepository)">
      <summary>
            Automatically configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using settings
            stored in the application's configuration file.
            </summary>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
            Each application has a configuration file. This has the
            same name as the application with '.config' appended.
            This file is XML and calling this function prompts the
            configurator to look in that file for a section called
            <c>log4net</c> that contains the configuration data.
            </remarks>
      <param name="repository">The repository to configure.</param>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(System.Xml.XmlElement)">
      <summary>
            Configures log4net using a <c>log4net</c> element
            </summary>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
            Loads the log4net configuration from the XML element
            supplied as <paramref name="element" />.
            </remarks>
      <param name="element">The element to parse.</param>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(log4net.Repository.ILoggerRepository,System.Xml.XmlElement)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified XML 
            element.
            </summary>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
            Loads the log4net configuration from the XML element
            supplied as <paramref name="element" />.
            </remarks>
      <param name="repository">The repository to configure.</param>
      <param name="element">The element to parse.</param>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(System.IO.FileInfo)">
      <summary>
            Configures log4net using the specified configuration file.
            </summary>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the log4net configuration data.
            </para>
        <para>
            The log4net configuration file can possible be specified in the application's
            configuration file (either <c>MyAppName.exe.config</c> for a
            normal application on <c>Web.config</c> for an ASP.NET application).
            </para>
        <example>
            The following example configures log4net using a configuration file, of which the 
            location is stored in the application's configuration file :
            </example>
        <code lang="C#">
            using log4net.Config;
            using System.IO;
            using System.Configuration;
            
            ...
            
            DOMConfigurator.Configure(new FileInfo(ConfigurationSettings.AppSettings["log4net-config-file"]));
            </code>
        <para>
            In the <c>.config</c> file, the path to the log4net can be specified like this :
            </para>
        <code lang="XML" escaped="true">
          <configuration>
            <appSettings>
              <add key="log4net-config-file" value="log.config" />
            </appSettings>
          </configuration>
        </code>
      </remarks>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(System.IO.Stream)">
      <summary>
            Configures log4net using the specified configuration file.
            </summary>
      <param name="configStream">A stream to load the XML configuration from.</param>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            The configuration data must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the log4net configuration data.
            </para>
        <para>
            Note that this method will NOT close the stream parameter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified configuration 
            file.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The log4net configuration file can possible be specified in the application's
            configuration file (either <c>MyAppName.exe.config</c> for a
            normal application on <c>Web.config</c> for an ASP.NET application).
            </para>
        <example>
            The following example configures log4net using a configuration file, of which the 
            location is stored in the application's configuration file :
            </example>
        <code lang="C#">
            using log4net.Config;
            using System.IO;
            using System.Configuration;
            
            ...
            
            DOMConfigurator.Configure(new FileInfo(ConfigurationSettings.AppSettings["log4net-config-file"]));
            </code>
        <para>
            In the <c>.config</c> file, the path to the log4net can be specified like this :
            </para>
        <code lang="XML" escaped="true">
          <configuration>
            <appSettings>
              <add key="log4net-config-file" value="log.config" />
            </appSettings>
          </configuration>
        </code>
      </remarks>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.Configure(log4net.Repository.ILoggerRepository,System.IO.Stream)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified configuration 
            file.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configStream">The stream to load the XML configuration from.</param>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            The configuration data must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            Note that this method will NOT close the stream parameter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.DOMConfigurator.ConfigureAndWatch(System.IO.FileInfo)">
      <summary>
            Configures log4net using the file specified, monitors the file for changes 
            and reloads the configuration if a change is detected.
            </summary>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The configuration file will be monitored using a <see cref="T:System.IO.FileSystemWatcher" />
            and depends on the behavior of that class.
            </para>
        <para>
            For more information on how to configure log4net using
            a separate configuration file, see <see cref="M:log4net.Config.DOMConfigurator.Configure(System.IO.FileInfo)" />.
            </para>
      </remarks>
      <seealso cref="M:log4net.Config.DOMConfigurator.Configure(System.IO.FileInfo)" />
    </member>
    <member name="M:log4net.Config.DOMConfigurator.ConfigureAndWatch(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the file specified, 
            monitors the file for changes and reloads the configuration if a change 
            is detected.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
          <b>DOMConfigurator is obsolete. Use XmlConfigurator instead of DOMConfigurator.</b>
        </para>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The configuration file will be monitored using a <see cref="T:System.IO.FileSystemWatcher" />
            and depends on the behavior of that class.
            </para>
        <para>
            For more information on how to configure log4net using
            a separate configuration file, see <see cref="M:log4net.Config.DOMConfigurator.Configure(System.IO.FileInfo)" />.
            </para>
      </remarks>
      <seealso cref="M:log4net.Config.DOMConfigurator.Configure(System.IO.FileInfo)" />
    </member>
    <member name="T:log4net.Config.XmlConfiguratorAttribute">
      <summary>
            Assembly level attribute to configure the <see cref="T:log4net.Config.XmlConfigurator" />.
            </summary>
      <remarks>
        <para>
            This attribute may only be used at the assembly scope and can only
            be used once per assembly.
            </para>
        <para>
            Use this attribute to configure the <see cref="T:log4net.Config.XmlConfigurator" />
            without calling one of the <see cref="M:log4net.Config.XmlConfigurator.Configure" />
            methods.
            </para>
        <para>
            If neither of the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile" /> or <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" />
            properties are set the configuration is loaded from the application's .config file.
            If set the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile" /> property takes priority over the
            <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" /> property. The <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile" /> property
            specifies a path to a file to load the config from. The path is relative to the
            application's base directory; <see cref="P:System.AppDomain.BaseDirectory" />.
            The <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" /> property is used as a postfix to the assembly file name.
            The config file must be located in the  application's base directory; <see cref="P:System.AppDomain.BaseDirectory" />.
            For example in a console application setting the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" /> to
            <c>config</c> has the same effect as not specifying the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile" /> or 
            <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" /> properties.
            </para>
        <para>
            The <see cref="P:log4net.Config.XmlConfiguratorAttribute.Watch" /> property can be set to cause the <see cref="T:log4net.Config.XmlConfigurator" />
            to watch the configuration file for changes.
            </para>
        <note>
          <para>
            Log4net will only look for assembly level configuration attributes once.
            When using the log4net assembly level attributes to control the configuration 
            of log4net you must ensure that the first call to any of the 
            <see cref="T:log4net.Core.LoggerManager" /> methods is made from the assembly with the configuration
            attributes. 
            </para>
          <para>
            If you cannot guarantee the order in which log4net calls will be made from 
            different assemblies you must use programmatic configuration instead, i.e.
            call the <see cref="M:log4net.Config.XmlConfigurator.Configure" /> method directly.
            </para>
        </note>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.XmlConfiguratorAttribute.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfiguratorAttribute.Configure(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified assembly.
            </summary>
      <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
      <param name="targetRepository">The repository to configure.</param>
      <remarks>
        <para>
            Configure the repository using the <see cref="T:log4net.Config.XmlConfigurator" />.
            The <paramref name="targetRepository" /> specified must extend the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />
            class otherwise the <see cref="T:log4net.Config.XmlConfigurator" /> will not be able to
            configure it.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="repository" /> does not extend <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />.</exception>
    </member>
    <member name="M:log4net.Config.XmlConfiguratorAttribute.ConfigureFromFile(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Attempt to load configuration from the local file system
            </summary>
      <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
      <param name="targetRepository">The repository to configure.</param>
    </member>
    <member name="M:log4net.Config.XmlConfiguratorAttribute.ConfigureFromFile(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Configure the specified repository using a <see cref="T:System.IO.FileInfo" /></summary>
      <param name="targetRepository">The repository to configure.</param>
      <param name="configFile">the FileInfo pointing to the config file</param>
    </member>
    <member name="M:log4net.Config.XmlConfiguratorAttribute.ConfigureFromUri(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Attempt to load configuration from a URI
            </summary>
      <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
      <param name="targetRepository">The repository to configure.</param>
    </member>
    <member name="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile">
      <summary>
            Gets or sets the filename of the configuration file.
            </summary>
      <value>
            The filename of the configuration file.
            </value>
      <remarks>
        <para>
            If specified, this is the name of the configuration file to use with
            the <see cref="T:log4net.Config.XmlConfigurator" />. This file path is relative to the
            <b>application base</b> directory (<see cref="P:System.AppDomain.BaseDirectory" />).
            </para>
        <para>
            The <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile" /> takes priority over the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension">
      <summary>
            Gets or sets the extension of the configuration file.
            </summary>
      <value>
            The extension of the configuration file.
            </value>
      <remarks>
        <para>
            If specified this is the extension for the configuration file.
            The path to the config file is built by using the <b>application 
            base</b> directory (<see cref="P:System.AppDomain.BaseDirectory" />),
            the <b>assembly file name</b> and the config file extension.
            </para>
        <para>
            If the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" /> is set to <c>MyExt</c> then
            possible config file names would be: <c>MyConsoleApp.exe.MyExt</c> or
            <c>MyClassLibrary.dll.MyExt</c>.
            </para>
        <para>
            The <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFile" /> takes priority over the <see cref="P:log4net.Config.XmlConfiguratorAttribute.ConfigFileExtension" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.XmlConfiguratorAttribute.Watch">
      <summary>
            Gets or sets a value indicating whether to watch the configuration file.
            </summary>
      <value>
        <c>true</c> if the configuration should be watched, <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            If this flag is specified and set to <c>true</c> then the framework
            will watch the configuration file and will reload the config each time 
            the file is modified.
            </para>
        <para>
            The config file can only be watched if it is loaded from local disk.
            In a No-Touch (Smart Client) deployment where the application is downloaded
            from a web server the config file may not reside on the local disk
            and therefore it may not be able to watch it.
            </para>
        <note>
            Watching configuration is not supported on the SSCLI.
            </note>
      </remarks>
    </member>
    <member name="T:log4net.Config.DOMConfiguratorAttribute">
      <summary>
            Assembly level attribute to configure the <see cref="T:log4net.Config.XmlConfigurator" />.
            </summary>
      <remarks>
        <para>
          <b>AliasDomainAttribute is obsolete. Use AliasRepositoryAttribute instead of AliasDomainAttribute.</b>
        </para>
        <para>
            This attribute may only be used at the assembly scope and can only
            be used once per assembly.
            </para>
        <para>
            Use this attribute to configure the <see cref="T:log4net.Config.XmlConfigurator" />
            without calling one of the <see cref="M:log4net.Config.XmlConfigurator.Configure" />
            methods.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Config.Log4NetConfigurationSectionHandler">
      <summary>
            Class to register for the log4net section of the configuration file
            </summary>
      <remarks>
            The log4net section of the configuration file needs to have a section
            handler registered. This is the section handler used. It simply returns
            the XML element that is the root of the section.
            </remarks>
      <example>
            Example of registering the log4net section handler :
            <code lang="XML" escaped="true"><configuration><configSections><section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net" /></configSections><log4net>
            		log4net configuration XML goes here
            	</log4net></configuration></code></example>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.Log4NetConfigurationSectionHandler.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.Log4NetConfigurationSectionHandler" /> class.
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.Log4NetConfigurationSectionHandler.Create(System.Object,System.Object,System.Xml.XmlNode)">
      <summary>
            Parses the configuration section.
            </summary>
      <param name="parent">The configuration settings in a corresponding parent configuration section.</param>
      <param name="configContext">The configuration context when called from the ASP.NET configuration system. Otherwise, this parameter is reserved and is a null reference.</param>
      <param name="section">The <see cref="T:System.Xml.XmlNode" /> for the log4net section.</param>
      <returns>The <see cref="T:System.Xml.XmlNode" /> for the log4net section.</returns>
      <remarks>
        <para>
            Returns the <see cref="T:System.Xml.XmlNode" /> containing the configuration data,
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Plugin.IPluginFactory">
      <summary>
            Interface used to create plugins.
            </summary>
      <remarks>
        <para>
            Interface used to create  a plugin.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Plugin.IPluginFactory.CreatePlugin">
      <summary>
            Creates the plugin object.
            </summary>
      <returns>the new plugin instance</returns>
      <remarks>
        <para>
            Create and return a new plugin instance.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.PluginAttribute">
      <summary>
            Assembly level attribute that specifies a plugin to attach to 
            the repository.
            </summary>
      <remarks>
        <para>
            Specifies the type of a plugin to create and attach to the
            assembly's repository. The plugin type must implement the
            <see cref="T:log4net.Plugin.IPlugin" /> interface.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Config.PluginAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.PluginAttribute" /> class
            with the specified type.
            </summary>
      <param name="typeName">The type name of plugin to create.</param>
      <remarks>
        <para>
            Create the attribute with the plugin type specified.
            </para>
        <para>
            Where possible use the constructor that takes a <see cref="T:System.Type" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.PluginAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.PluginAttribute" /> class
            with the specified type.
            </summary>
      <param name="type">The type of plugin to create.</param>
      <remarks>
        <para>
            Create the attribute with the plugin type specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.PluginAttribute.CreatePlugin">
      <summary>
            Creates the plugin object defined by this attribute.
            </summary>
      <remarks>
        <para>
            Creates the instance of the <see cref="T:log4net.Plugin.IPlugin" /> object as 
            specified by this attribute.
            </para>
      </remarks>
      <returns>The plugin object.</returns>
    </member>
    <member name="M:log4net.Config.PluginAttribute.ToString">
      <summary>
            Returns a representation of the properties of this object.
            </summary>
      <remarks>
        <para>
            Overrides base class <see cref="M:System.Object.ToString" /> method to 
            return a representation of the properties of this object.
            </para>
      </remarks>
      <returns>A representation of the properties of this object</returns>
    </member>
    <member name="P:log4net.Config.PluginAttribute.Type">
      <summary>
            Gets or sets the type for the plugin.
            </summary>
      <value>
            The type for the plugin.
            </value>
      <remarks>
        <para>
            The type for the plugin.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.PluginAttribute.TypeName">
      <summary>
            Gets or sets the type name for the plugin.
            </summary>
      <value>
            The type name for the plugin.
            </value>
      <remarks>
        <para>
            The type name for the plugin.
            </para>
        <para>
            Where possible use the <see cref="P:log4net.Config.PluginAttribute.Type" /> property instead.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.SecurityContextProviderAttribute">
      <summary>
            Assembly level attribute to configure the <see cref="T:log4net.Core.SecurityContextProvider" />.
            </summary>
      <remarks>
        <para>
            This attribute may only be used at the assembly scope and can only
            be used once per assembly.
            </para>
        <para>
            Use this attribute to configure the <see cref="T:log4net.Config.XmlConfigurator" />
            without calling one of the <see cref="M:log4net.Config.XmlConfigurator.Configure" />
            methods.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Config.SecurityContextProviderAttribute.#ctor(System.Type)">
      <summary>
            Construct provider attribute with type specified
            </summary>
      <param name="providerType">the type of the provider to use</param>
      <remarks>
        <para>
            The provider specified must subclass the <see cref="T:log4net.Core.SecurityContextProvider" />
            class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.SecurityContextProviderAttribute.Configure(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Configures the SecurityContextProvider
            </summary>
      <param name="sourceAssembly">The assembly that this attribute was defined on.</param>
      <param name="targetRepository">The repository to configure.</param>
      <remarks>
        <para>
            Creates a provider instance from the <see cref="P:log4net.Config.SecurityContextProviderAttribute.ProviderType" /> specified.
            Sets this as the default security context provider <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Config.SecurityContextProviderAttribute.ProviderType">
      <summary>
            Gets or sets the type of the provider to use.
            </summary>
      <value>
            the type of the provider to use.
            </value>
      <remarks>
        <para>
            The provider specified must subclass the <see cref="T:log4net.Core.SecurityContextProvider" />
            class.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Config.XmlConfigurator">
      <summary>
            Use this class to initialize the log4net environment using an Xml tree.
            </summary>
      <remarks>
        <para>
            Configures a <see cref="T:log4net.Repository.ILoggerRepository" /> using an Xml tree.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler">
      <summary>
            Class used to watch config files.
            </summary>
      <remarks>
        <para>
            Uses the <see cref="T:System.IO.FileSystemWatcher" /> to monitor
            changes to a specified file. Because multiple change notifications
            may be raised when the file is modified, a timer is used to
            compress the notifications into a single event. The timer
            waits for <see cref="F:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.TimeoutMillis" /> time before delivering
            the event notification. If any further <see cref="T:System.IO.FileSystemWatcher" />
            change notifications arrive while the timer is waiting it
            is reset and waits again for <see cref="F:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.TimeoutMillis" /> to
            elapse.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.StartWatching(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Watch a specified config file used to configure a repository
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configFile">The configuration file to watch.</param>
      <remarks>
        <para>
            Watch a specified config file used to configure a repository
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.#ctor(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler" /> class.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configFile">The configuration file to watch.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler_OnChanged(System.Object,System.IO.FileSystemEventArgs)">
      <summary>
            Event handler used by <see cref="T:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler" />.
            </summary>
      <param name="source">The <see cref="T:System.IO.FileSystemWatcher" /> firing the event.</param>
      <param name="e">The argument indicates the file that caused the event to be fired.</param>
      <remarks>
        <para>
            This handler reloads the configuration from the file when the event is fired.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.ConfigureAndWatchHandler_OnRenamed(System.Object,System.IO.RenamedEventArgs)">
      <summary>
            Event handler used by <see cref="T:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler" />.
            </summary>
      <param name="source">The <see cref="T:System.IO.FileSystemWatcher" /> firing the event.</param>
      <param name="e">The argument indicates the file that caused the event to be fired.</param>
      <remarks>
        <para>
            This handler reloads the configuration from the file when the event is fired.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatchHandler.OnWatchedFileChange(System.Object)">
      <summary>
            Called by the timer when the configuration has been updated.
            </summary>
      <param name="state">null</param>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.#ctor">
      <summary>
            Private constructor
            </summary>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure">
      <summary>
            Automatically configures the log4net system based on the 
            application's configuration settings.
            </summary>
      <remarks>
        <para>
            Each application has a configuration file. This has the
            same name as the application with '.config' appended.
            This file is XML and calling this function prompts the
            configurator to look in that file for a section called
            <c>log4net</c> that contains the configuration data.
            </para>
        <para>
            To use this method to configure log4net you must specify 
            the <see cref="T:log4net.Config.Log4NetConfigurationSectionHandler" /> section
            handler for the <c>log4net</c> configuration section. See the
            <see cref="T:log4net.Config.Log4NetConfigurationSectionHandler" /> for an example.
            </para>
      </remarks>
      <seealso cref="T:log4net.Config.Log4NetConfigurationSectionHandler" />
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(log4net.Repository.ILoggerRepository)">
      <summary>
            Automatically configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using settings
            stored in the application's configuration file.
            </summary>
      <remarks>
        <para>
            Each application has a configuration file. This has the
            same name as the application with '.config' appended.
            This file is XML and calling this function prompts the
            configurator to look in that file for a section called
            <c>log4net</c> that contains the configuration data.
            </para>
        <para>
            To use this method to configure log4net you must specify 
            the <see cref="T:log4net.Config.Log4NetConfigurationSectionHandler" /> section
            handler for the <c>log4net</c> configuration section. See the
            <see cref="T:log4net.Config.Log4NetConfigurationSectionHandler" /> for an example.
            </para>
      </remarks>
      <param name="repository">The repository to configure.</param>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(System.Xml.XmlElement)">
      <summary>
            Configures log4net using a <c>log4net</c> element
            </summary>
      <remarks>
        <para>
            Loads the log4net configuration from the XML element
            supplied as <paramref name="element" />.
            </para>
      </remarks>
      <param name="element">The element to parse.</param>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(log4net.Repository.ILoggerRepository,System.Xml.XmlElement)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified XML 
            element.
            </summary>
      <remarks>
            Loads the log4net configuration from the XML element
            supplied as <paramref name="element" />.
            </remarks>
      <param name="repository">The repository to configure.</param>
      <param name="element">The element to parse.</param>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(System.IO.FileInfo)">
      <summary>
            Configures log4net using the specified configuration file.
            </summary>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the log4net configuration data.
            </para>
        <para>
            The log4net configuration file can possible be specified in the application's
            configuration file (either <c>MyAppName.exe.config</c> for a
            normal application on <c>Web.config</c> for an ASP.NET application).
            </para>
        <para>
            The first element matching <c>&lt;configuration&gt;</c> will be read as the 
            configuration. If this file is also a .NET .config file then you must specify 
            a configuration section for the <c>log4net</c> element otherwise .NET will 
            complain. Set the type for the section handler to <see cref="T:System.Configuration.IgnoreSectionHandler" />, for example:
            <code lang="XML" escaped="true"><configSections><section name="log4net" type="System.Configuration.IgnoreSectionHandler" /></configSections></code></para>
        <example>
            The following example configures log4net using a configuration file, of which the 
            location is stored in the application's configuration file :
            </example>
        <code lang="C#">
            using log4net.Config;
            using System.IO;
            using System.Configuration;
            
            ...
            
            XmlConfigurator.Configure(new FileInfo(ConfigurationSettings.AppSettings["log4net-config-file"]));
            </code>
        <para>
            In the <c>.config</c> file, the path to the log4net can be specified like this :
            </para>
        <code lang="XML" escaped="true">
          <configuration>
            <appSettings>
              <add key="log4net-config-file" value="log.config" />
            </appSettings>
          </configuration>
        </code>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(System.Uri)">
      <summary>
            Configures log4net using the specified configuration URI.
            </summary>
      <param name="configUri">A URI to load the XML configuration from.</param>
      <remarks>
        <para>
            The configuration data must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the log4net configuration data.
            </para>
        <para>
            The <see cref="T:System.Net.WebRequest" /> must support the URI scheme specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(System.IO.Stream)">
      <summary>
            Configures log4net using the specified configuration data stream.
            </summary>
      <param name="configStream">A stream to load the XML configuration from.</param>
      <remarks>
        <para>
            The configuration data must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the log4net configuration data.
            </para>
        <para>
            Note that this method will NOT close the stream parameter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified configuration 
            file.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The log4net configuration file can possible be specified in the application's
            configuration file (either <c>MyAppName.exe.config</c> for a
            normal application on <c>Web.config</c> for an ASP.NET application).
            </para>
        <para>
            The first element matching <c>&lt;configuration&gt;</c> will be read as the 
            configuration. If this file is also a .NET .config file then you must specify 
            a configuration section for the <c>log4net</c> element otherwise .NET will 
            complain. Set the type for the section handler to <see cref="T:System.Configuration.IgnoreSectionHandler" />, for example:
            <code lang="XML" escaped="true"><configSections><section name="log4net" type="System.Configuration.IgnoreSectionHandler" /></configSections></code></para>
        <example>
            The following example configures log4net using a configuration file, of which the 
            location is stored in the application's configuration file :
            </example>
        <code lang="C#">
            using log4net.Config;
            using System.IO;
            using System.Configuration;
            
            ...
            
            XmlConfigurator.Configure(new FileInfo(ConfigurationSettings.AppSettings["log4net-config-file"]));
            </code>
        <para>
            In the <c>.config</c> file, the path to the log4net can be specified like this :
            </para>
        <code lang="XML" escaped="true">
          <configuration>
            <appSettings>
              <add key="log4net-config-file" value="log.config" />
            </appSettings>
          </configuration>
        </code>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(log4net.Repository.ILoggerRepository,System.Uri)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified configuration 
            URI.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configUri">A URI to load the XML configuration from.</param>
      <remarks>
        <para>
            The configuration data must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The <see cref="T:System.Net.WebRequest" /> must support the URI scheme specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.Configure(log4net.Repository.ILoggerRepository,System.IO.Stream)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the specified configuration 
            file.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configStream">The stream to load the XML configuration from.</param>
      <remarks>
        <para>
            The configuration data must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            Note that this method will NOT close the stream parameter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatch(System.IO.FileInfo)">
      <summary>
            Configures log4net using the file specified, monitors the file for changes 
            and reloads the configuration if a change is detected.
            </summary>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The configuration file will be monitored using a <see cref="T:System.IO.FileSystemWatcher" />
            and depends on the behavior of that class.
            </para>
        <para>
            For more information on how to configure log4net using
            a separate configuration file, see <see cref="M:log4net.Config.XmlConfigurator.Configure(System.IO.FileInfo)" />.
            </para>
      </remarks>
      <seealso cref="M:log4net.Config.XmlConfigurator.Configure(System.IO.FileInfo)" />
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureAndWatch(log4net.Repository.ILoggerRepository,System.IO.FileInfo)">
      <summary>
            Configures the <see cref="T:log4net.Repository.ILoggerRepository" /> using the file specified, 
            monitors the file for changes and reloads the configuration if a change 
            is detected.
            </summary>
      <param name="repository">The repository to configure.</param>
      <param name="configFile">The XML file to load the configuration from.</param>
      <remarks>
        <para>
            The configuration file must be valid XML. It must contain
            at least one element called <c>log4net</c> that holds
            the configuration data.
            </para>
        <para>
            The configuration file will be monitored using a <see cref="T:System.IO.FileSystemWatcher" />
            and depends on the behavior of that class.
            </para>
        <para>
            For more information on how to configure log4net using
            a separate configuration file, see <see cref="M:log4net.Config.XmlConfigurator.Configure(System.IO.FileInfo)" />.
            </para>
      </remarks>
      <seealso cref="M:log4net.Config.XmlConfigurator.Configure(System.IO.FileInfo)" />
    </member>
    <member name="M:log4net.Config.XmlConfigurator.ConfigureFromXml(log4net.Repository.ILoggerRepository,System.Xml.XmlElement)">
      <summary>
            Configures the specified repository using a <c>log4net</c> element.
            </summary>
      <param name="repository">The hierarchy to configure.</param>
      <param name="element">The element to parse.</param>
      <remarks>
        <para>
            Loads the log4net configuration from the XML element
            supplied as <paramref name="element" />.
            </para>
        <para>
            This method is ultimately called by one of the Configure methods 
            to load the configuration from an <see cref="T:System.Xml.XmlElement" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.IRepositorySelector">
      <summary>
            Interface used by the <see cref="T:log4net.LogManager" /> to select the <see cref="T:log4net.Repository.ILoggerRepository" />.
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.LogManager" /> uses a <see cref="T:log4net.Core.IRepositorySelector" /> 
            to specify the policy for selecting the correct <see cref="T:log4net.Repository.ILoggerRepository" /> 
            to return to the caller.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Core.IRepositorySelector.GetRepository(System.Reflection.Assembly)">
      <summary>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified assembly.
            </summary>
      <param name="assembly">The assembly to use to lookup to the <see cref="T:log4net.Repository.ILoggerRepository" /></param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> for the assembly.</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified assembly.
            </para>
        <para>
            How the association between <see cref="T:System.Reflection.Assembly" /> and <see cref="T:log4net.Repository.ILoggerRepository" />
            is made is not defined. The implementation may choose any method for
            this association. The results of this method must be repeatable, i.e.
            when called again with the same arguments the result must be the
            save value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IRepositorySelector.GetRepository(System.String)">
      <summary>
            Gets the named <see cref="T:log4net.Repository.ILoggerRepository" />.
            </summary>
      <param name="repositoryName">The name to use to lookup to the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <returns>The named <see cref="T:log4net.Repository.ILoggerRepository" /></returns>
      <remarks>
            Lookup a named <see cref="T:log4net.Repository.ILoggerRepository" />. This is the repository created by
            calling <see cref="M:log4net.Core.IRepositorySelector.CreateRepository(System.String,System.Type)" />.
            </remarks>
    </member>
    <member name="M:log4net.Core.IRepositorySelector.CreateRepository(System.Reflection.Assembly,System.Type)">
      <summary>
            Creates a new repository for the assembly specified.
            </summary>
      <param name="assembly">The assembly to use to create the domain to associate with the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <param name="repositoryType">The type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <returns>The repository created.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the domain
            specified such that a call to <see cref="M:log4net.Core.IRepositorySelector.GetRepository(System.Reflection.Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
        <para>
            How the association between <see cref="T:System.Reflection.Assembly" /> and <see cref="T:log4net.Repository.ILoggerRepository" />
            is made is not defined. The implementation may choose any method for
            this association.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IRepositorySelector.CreateRepository(System.String,System.Type)">
      <summary>
            Creates a new repository with the name specified.
            </summary>
      <param name="repositoryName">The name to associate with the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <param name="repositoryType">The type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <returns>The repository created.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the name
            specified such that a call to <see cref="M:log4net.Core.IRepositorySelector.GetRepository(System.String)" /> with the
            same name will return the same repository instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IRepositorySelector.ExistsRepository(System.String)">
      <summary>
            Test if a named repository exists
            </summary>
      <param name="repositoryName">the named repository to check</param>
      <returns>
        <c>true</c> if the repository exists</returns>
      <remarks>
        <para>
            Test if a named repository exists. Use <see cref="M:log4net.Core.IRepositorySelector.CreateRepository(System.Reflection.Assembly,System.Type)" />
            to create a new repository and <see cref="M:log4net.Core.IRepositorySelector.GetRepository(System.Reflection.Assembly)" /> to retrieve 
            a repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IRepositorySelector.GetAllRepositories">
      <summary>
            Gets an array of all currently defined repositories.
            </summary>
      <returns>
            An array of the <see cref="T:log4net.Repository.ILoggerRepository" /> instances created by 
            this <see cref="T:log4net.Core.IRepositorySelector" />.</returns>
      <remarks>
        <para>
            Gets an array of all of the repositories created by this selector.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Core.IRepositorySelector.LoggerRepositoryCreatedEvent">
      <summary>
            Event to notify that a logger repository has been created.
            </summary>
      <value>
            Event to notify that a logger repository has been created.
            </value>
      <remarks>
        <para>
            Event raised when a new repository is created.
            The event source will be this selector. The event args will
            be a <see cref="T:log4net.Core.LoggerRepositoryCreationEventArgs" /> which
            holds the newly created <see cref="T:log4net.Repository.ILoggerRepository" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.CompactRepositorySelector">
      <summary>
            The implementation of the <see cref="T:log4net.Core.IRepositorySelector" /> interface suitable
            for use with the compact framework
            </summary>
      <remarks>
        <para>
            This <see cref="T:log4net.Core.IRepositorySelector" /> implementation is a simple
            mapping between repository name and <see cref="T:log4net.Repository.ILoggerRepository" />
            object.
            </para>
        <para>
            The .NET Compact Framework 1.0 does not support retrieving assembly
            level attributes therefore unlike the <c>DefaultRepositorySelector</c>
            this selector does not examine the calling assembly for attributes.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.#ctor(System.Type)">
      <summary>
            Create a new repository selector
            </summary>
      <param name="defaultRepositoryType">the type of the repositories to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" /></param>
      <remarks>
        <para>
            Create an new compact repository selector.
            The default type for repositories must be specified,
            an appropriate value would be <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">throw if <paramref name="defaultRepositoryType" /> is null</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">throw if <paramref name="defaultRepositoryType" /> does not implement <see cref="T:log4net.Repository.ILoggerRepository" /></exception>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.GetRepository(System.Reflection.Assembly)">
      <summary>
            Get the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified assembly
            </summary>
      <param name="assembly">not used</param>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /></returns>
      <remarks>
        <para>
            The <paramref name="assembly" /> argument is not used. This selector does not create a
            separate repository for each assembly. 
            </para>
        <para>
            As a named repository is not specified the default repository is 
            returned. The default repository is named <c>log4net-default-repository</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.GetRepository(System.String)">
      <summary>
            Get the named <see cref="T:log4net.Repository.ILoggerRepository" /></summary>
      <param name="repositoryName">the name of the repository to lookup</param>
      <returns>The named <see cref="T:log4net.Repository.ILoggerRepository" /></returns>
      <remarks>
        <para>
            Get the named <see cref="T:log4net.Repository.ILoggerRepository" />. The default 
            repository is <c>log4net-default-repository</c>. Other repositories 
            must be created using the <see cref="M:log4net.Core.CompactRepositorySelector.CreateRepository(System.String,System.Type)" />.
            If the named repository does not exist an exception is thrown.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">throw if <paramref name="repositoryName" /> is null</exception>
      <exception cref="T:log4net.Core.LogException">throw if the <paramref name="repositoryName" /> does not exist</exception>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.CreateRepository(System.Reflection.Assembly,System.Type)">
      <summary>
            Create a new repository for the assembly specified 
            </summary>
      <param name="assembly">not used</param>
      <param name="repositoryType">the type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" /></param>
      <returns>the repository created</returns>
      <remarks>
        <para>
            The <paramref name="assembly" /> argument is not used. This selector does not create a
            separate repository for each assembly. 
            </para>
        <para>
            If the <paramref name="repositoryType" /> is <c>null</c> then the
            default repository type specified to the constructor is used.
            </para>
        <para>
            As a named repository is not specified the default repository is 
            returned. The default repository is named <c>log4net-default-repository</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.CreateRepository(System.String,System.Type)">
      <summary>
            Create a new repository for the repository specified
            </summary>
      <param name="repositoryName">the repository to associate with the <see cref="T:log4net.Repository.ILoggerRepository" /></param>
      <param name="repositoryType">the type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" />.
            If this param is null then the default repository type is used.</param>
      <returns>the repository created</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:log4net.Core.CompactRepositorySelector.GetRepository(System.String)" /> with the
            same repository specified will return the same repository instance.
            </para>
        <para>
            If the named repository already exists an exception will be thrown.
            </para>
        <para>
            If <paramref name="repositoryType" /> is <c>null</c> then the default 
            repository type specified to the constructor is used.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">throw if <paramref name="repositoryName" /> is null</exception>
      <exception cref="T:log4net.Core.LogException">throw if the <paramref name="repositoryName" /> already exists</exception>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.ExistsRepository(System.String)">
      <summary>
            Test if a named repository exists
            </summary>
      <param name="repositoryName">the named repository to check</param>
      <returns>
        <c>true</c> if the repository exists</returns>
      <remarks>
        <para>
            Test if a named repository exists. Use <see cref="M:log4net.Core.CompactRepositorySelector.CreateRepository(System.String,System.Type)" />
            to create a new repository and <see cref="M:log4net.Core.CompactRepositorySelector.GetRepository(System.String)" /> to retrieve 
            a repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.GetAllRepositories">
      <summary>
            Gets a list of <see cref="T:log4net.Repository.ILoggerRepository" /> objects
            </summary>
      <returns>an array of all known <see cref="T:log4net.Repository.ILoggerRepository" /> objects</returns>
      <remarks>
        <para>
            Gets an array of all of the repositories created by this selector.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.CompactRepositorySelector.OnLoggerRepositoryCreatedEvent(log4net.Repository.ILoggerRepository)">
      <summary>
            Notify the registered listeners that the repository has been created
            </summary>
      <param name="repository">The repository that has been created</param>
      <remarks>
        <para>
            Raises the <event cref="E:log4net.Core.CompactRepositorySelector.LoggerRepositoryCreatedEvent">LoggerRepositoryCreatedEvent</event>
            event.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Core.CompactRepositorySelector.LoggerRepositoryCreatedEvent">
      <summary>
            Event to notify that a logger repository has been created.
            </summary>
      <value>
            Event to notify that a logger repository has been created.
            </value>
      <remarks>
        <para>
            Event raised when a new repository is created.
            The event source will be this selector. The event args will
            be a <see cref="T:log4net.Core.LoggerRepositoryCreationEventArgs" /> which
            holds the newly created <see cref="T:log4net.Repository.ILoggerRepository" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.DefaultRepositorySelector">
      <summary>
            The default implementation of the <see cref="T:log4net.Core.IRepositorySelector" /> interface.
            </summary>
      <remarks>
        <para>
            Uses attributes defined on the calling assembly to determine how to
            configure the hierarchy for the repository.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.#ctor(System.Type)">
      <summary>
            Creates a new repository selector.
            </summary>
      <param name="defaultRepositoryType">The type of the repositories to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" /></param>
      <remarks>
        <para>
            Create an new repository selector.
            The default type for repositories must be specified,
            an appropriate value would be <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="defaultRepositoryType" /> is <see langword="null" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="defaultRepositoryType" /> does not implement <see cref="T:log4net.Repository.ILoggerRepository" />.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.GetRepository(System.Reflection.Assembly)">
      <summary>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified assembly.
            </summary>
      <param name="repositoryAssembly">The assembly use to lookup the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <remarks>
        <para>
            The type of the <see cref="T:log4net.Repository.ILoggerRepository" /> created and the repository 
            to create can be overridden by specifying the <see cref="T:log4net.Config.RepositoryAttribute" /> 
            attribute on the <paramref name="repositoryAssembly" />.
            </para>
        <para>
            The default values are to use the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> 
            implementation of the <see cref="T:log4net.Repository.ILoggerRepository" /> interface and to use the
            <see cref="P:System.Reflection.AssemblyName.Name" /> as the name of the repository.
            </para>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be automatically configured using 
            any <see cref="T:log4net.Config.ConfiguratorAttribute" /> attributes defined on
            the <paramref name="repositoryAssembly" />.
            </para>
      </remarks>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> for the assembly</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="repositoryAssembly" /> is <see langword="null" />.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.GetRepository(System.String)">
      <summary>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified repository.
            </summary>
      <param name="repositoryName">The repository to use to lookup the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> for the specified repository.</returns>
      <remarks>
        <para>
            Returns the named repository. If <paramref name="repositoryName" /> is <c>null</c>
            a <see cref="T:System.ArgumentNullException" /> is thrown. If the repository 
            does not exist a <see cref="T:log4net.Core.LogException" /> is thrown.
            </para>
        <para>
            Use <see cref="M:log4net.Core.DefaultRepositorySelector.CreateRepository(System.String,System.Type)" /> to create a repository.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="repositoryName" /> is <see langword="null" />.</exception>
      <exception cref="T:log4net.Core.LogException">
        <paramref name="repositoryName" /> does not exist.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.CreateRepository(System.Reflection.Assembly,System.Type)">
      <summary>
            Create a new repository for the assembly specified 
            </summary>
      <param name="repositoryAssembly">the assembly to use to create the repository to associate with the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <param name="repositoryType">The type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <returns>The repository created.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:log4net.Core.DefaultRepositorySelector.GetRepository(System.Reflection.Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
        <para>
            The type of the <see cref="T:log4net.Repository.ILoggerRepository" /> created and
            the repository to create can be overridden by specifying the
            <see cref="T:log4net.Config.RepositoryAttribute" /> attribute on the 
            <paramref name="repositoryAssembly" />.  The default values are to use the 
            <paramref name="repositoryType" /> implementation of the 
            <see cref="T:log4net.Repository.ILoggerRepository" /> interface and to use the
            <see cref="P:System.Reflection.AssemblyName.Name" /> as the name of the repository.
            </para>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be automatically
            configured using any <see cref="T:log4net.Config.ConfiguratorAttribute" /> 
            attributes defined on the <paramref name="repositoryAssembly" />.
            </para>
        <para>
            If a repository for the <paramref name="repositoryAssembly" /> already exists
            that repository will be returned. An error will not be raised and that 
            repository may be of a different type to that specified in <paramref name="repositoryType" />.
            Also the <see cref="T:log4net.Config.RepositoryAttribute" /> attribute on the
            assembly may be used to override the repository type specified in 
            <paramref name="repositoryType" />.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="repositoryAssembly" /> is <see langword="null" />.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.CreateRepository(System.Reflection.Assembly,System.Type,System.String,System.Boolean)">
      <summary>
            Creates a new repository for the assembly specified.
            </summary>
      <param name="repositoryAssembly">the assembly to use to create the repository to associate with the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <param name="repositoryType">The type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <param name="repositoryName">The name to assign to the created repository</param>
      <param name="readAssemblyAttributes">Set to <c>true</c> to read and apply the assembly attributes</param>
      <returns>The repository created.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:log4net.Core.DefaultRepositorySelector.GetRepository(System.Reflection.Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
        <para>
            The type of the <see cref="T:log4net.Repository.ILoggerRepository" /> created and
            the repository to create can be overridden by specifying the
            <see cref="T:log4net.Config.RepositoryAttribute" /> attribute on the 
            <paramref name="repositoryAssembly" />.  The default values are to use the 
            <paramref name="repositoryType" /> implementation of the 
            <see cref="T:log4net.Repository.ILoggerRepository" /> interface and to use the
            <see cref="P:System.Reflection.AssemblyName.Name" /> as the name of the repository.
            </para>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be automatically
            configured using any <see cref="T:log4net.Config.ConfiguratorAttribute" /> 
            attributes defined on the <paramref name="repositoryAssembly" />.
            </para>
        <para>
            If a repository for the <paramref name="repositoryAssembly" /> already exists
            that repository will be returned. An error will not be raised and that 
            repository may be of a different type to that specified in <paramref name="repositoryType" />.
            Also the <see cref="T:log4net.Config.RepositoryAttribute" /> attribute on the
            assembly may be used to override the repository type specified in 
            <paramref name="repositoryType" />.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="repositoryAssembly" /> is <see langword="null" />.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.CreateRepository(System.String,System.Type)">
      <summary>
            Creates a new repository for the specified repository.
            </summary>
      <param name="repositoryName">The repository to associate with the <see cref="T:log4net.Repository.ILoggerRepository" />.</param>
      <param name="repositoryType">The type of repository to create, must implement <see cref="T:log4net.Repository.ILoggerRepository" />.
            If this param is <see langword="null" /> then the default repository type is used.</param>
      <returns>The new repository.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:log4net.Core.DefaultRepositorySelector.GetRepository(System.String)" /> with the
            same repository specified will return the same repository instance.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="repositoryName" /> is <see langword="null" />.</exception>
      <exception cref="T:log4net.Core.LogException">
        <paramref name="repositoryName" /> already exists.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.ExistsRepository(System.String)">
      <summary>
            Test if a named repository exists
            </summary>
      <param name="repositoryName">the named repository to check</param>
      <returns>
        <c>true</c> if the repository exists</returns>
      <remarks>
        <para>
            Test if a named repository exists. Use <see cref="M:log4net.Core.DefaultRepositorySelector.CreateRepository(System.String,System.Type)" />
            to create a new repository and <see cref="M:log4net.Core.DefaultRepositorySelector.GetRepository(System.String)" /> to retrieve 
            a repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.GetAllRepositories">
      <summary>
            Gets a list of <see cref="T:log4net.Repository.ILoggerRepository" /> objects
            </summary>
      <returns>an array of all known <see cref="T:log4net.Repository.ILoggerRepository" /> objects</returns>
      <remarks>
        <para>
            Gets an array of all of the repositories created by this selector.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.AliasRepository(System.String,log4net.Repository.ILoggerRepository)">
      <summary>
            Aliases a repository to an existing repository.
            </summary>
      <param name="repositoryAlias">The repository to alias.</param>
      <param name="repositoryTarget">The repository that the repository is aliased to.</param>
      <remarks>
        <para>
            The repository specified will be aliased to the repository when created. 
            The repository must not already exist.
            </para>
        <para>
            When the repository is created it must utilize the same repository type as 
            the repository it is aliased to, otherwise the aliasing will fail.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <paramref name="repositoryAlias" /> is <see langword="null" />.</para>
        <para>-or-</para>
        <para>
          <paramref name="repositoryTarget" /> is <see langword="null" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.OnLoggerRepositoryCreatedEvent(log4net.Repository.ILoggerRepository)">
      <summary>
            Notifies the registered listeners that the repository has been created.
            </summary>
      <param name="repository">The repository that has been created.</param>
      <remarks>
        <para>
            Raises the <see cref="E:log4net.Core.DefaultRepositorySelector.LoggerRepositoryCreatedEvent" /> event.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.GetInfoForAssembly(System.Reflection.Assembly,System.String@,System.Type@)">
      <summary>
            Gets the repository name and repository type for the specified assembly.
            </summary>
      <param name="assembly">The assembly that has a <see cref="T:log4net.Config.RepositoryAttribute" />.</param>
      <param name="repositoryName">in/out param to hold the repository name to use for the assembly, caller should set this to the default value before calling.</param>
      <param name="repositoryType">in/out param to hold the type of the repository to create for the assembly, caller should set this to the default value before calling.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="assembly" /> is <see langword="null" />.</exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.ConfigureRepository(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Configures the repository using information from the assembly.
            </summary>
      <param name="assembly">The assembly containing <see cref="T:log4net.Config.ConfiguratorAttribute" />
            attributes which define the configuration for the repository.</param>
      <param name="repository">The repository to configure.</param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <paramref name="assembly" /> is <see langword="null" />.</para>
        <para>-or-</para>
        <para>
          <paramref name="repository" /> is <see langword="null" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.LoadPlugins(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Loads the attribute defined plugins on the assembly.
            </summary>
      <param name="assembly">The assembly that contains the attributes.</param>
      <param name="repository">The repository to add the plugins to.</param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <paramref name="assembly" /> is <see langword="null" />.</para>
        <para>-or-</para>
        <para>
          <paramref name="repository" /> is <see langword="null" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Core.DefaultRepositorySelector.LoadAliases(System.Reflection.Assembly,log4net.Repository.ILoggerRepository)">
      <summary>
            Loads the attribute defined aliases on the assembly.
            </summary>
      <param name="assembly">The assembly that contains the attributes.</param>
      <param name="repository">The repository to alias to.</param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <paramref name="assembly" /> is <see langword="null" />.</para>
        <para>-or-</para>
        <para>
          <paramref name="repository" /> is <see langword="null" />.</para>
      </exception>
    </member>
    <member name="E:log4net.Core.DefaultRepositorySelector.LoggerRepositoryCreatedEvent">
      <summary>
            Event to notify that a logger repository has been created.
            </summary>
      <value>
            Event to notify that a logger repository has been created.
            </value>
      <remarks>
        <para>
            Event raised when a new repository is created.
            The event source will be this selector. The event args will
            be a <see cref="T:log4net.Core.LoggerRepositoryCreationEventArgs" /> which
            holds the newly created <see cref="T:log4net.Repository.ILoggerRepository" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.ErrorCode">
      <summary>
            Defined error codes that can be passed to the <see cref="M:log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" /> method.
            </summary>
      <remarks>
        <para>
            Values passed to the <see cref="M:log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" /> method.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.ErrorCode.GenericFailure">
      <summary>
            A general error
            </summary>
    </member>
    <member name="F:log4net.Core.ErrorCode.WriteFailure">
      <summary>
            Error while writing output
            </summary>
    </member>
    <member name="F:log4net.Core.ErrorCode.FlushFailure">
      <summary>
            Failed to flush file
            </summary>
    </member>
    <member name="F:log4net.Core.ErrorCode.CloseFailure">
      <summary>
            Failed to close file
            </summary>
    </member>
    <member name="F:log4net.Core.ErrorCode.FileOpenFailure">
      <summary>
            Unable to open output file
            </summary>
    </member>
    <member name="F:log4net.Core.ErrorCode.MissingLayout">
      <summary>
            No layout specified
            </summary>
    </member>
    <member name="F:log4net.Core.ErrorCode.AddressParseFailure">
      <summary>
            Failed to parse address
            </summary>
    </member>
    <member name="T:log4net.Core.IErrorHandler">
      <summary>
            Appenders may delegate their error handling to an <see cref="T:log4net.Core.IErrorHandler" />.
            </summary>
      <remarks>
        <para>
            Error handling is a particularly tedious to get right because by
            definition errors are hard to predict and to reproduce. 
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)">
      <summary>
            Handles the error and information about the error condition is passed as 
            a parameter.
            </summary>
      <param name="message">The message associated with the error.</param>
      <param name="e">The <see cref="T:System.Exception" /> that was thrown when the error occurred.</param>
      <param name="errorCode">The error code associated with the error.</param>
      <remarks>
        <para>
            Handles the error and information about the error condition is passed as 
            a parameter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IErrorHandler.Error(System.String,System.Exception)">
      <summary>
            Prints the error message passed as a parameter.
            </summary>
      <param name="message">The message associated with the error.</param>
      <param name="e">The <see cref="T:System.Exception" /> that was thrown when the error occurred.</param>
      <remarks>
        <para>
            See <see cref="M:log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.IErrorHandler.Error(System.String)">
      <summary>
            Prints the error message passed as a parameter.
            </summary>
      <param name="message">The message associated with the error.</param>
      <remarks>
        <para>
            See <see cref="M:log4net.Core.IErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.IFixingRequired">
      <summary>
            Interface for objects that require fixing.
            </summary>
      <remarks>
        <para>
            Interface that indicates that the object requires fixing before it
            can be taken outside the context of the appender's 
            <see cref="M:log4net.Appender.IAppender.DoAppend(log4net.Core.LoggingEvent)" /> method.
            </para>
        <para>
            When objects that implement this interface are stored 
            in the context properties maps <see cref="T:log4net.GlobalContext" /><see cref="P:log4net.GlobalContext.Properties" /> and <see cref="T:log4net.ThreadContext" /><see cref="P:log4net.ThreadContext.Properties" /> are fixed 
            (see <see cref="P:log4net.Core.LoggingEvent.Fix" />) the <see cref="M:log4net.Core.IFixingRequired.GetFixedObject" />
            method will be called.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Core.IFixingRequired.GetFixedObject">
      <summary>
            Get a portable version of this object
            </summary>
      <returns>the portable instance of this object</returns>
      <remarks>
        <para>
            Get a portable instance object that represents the current
            state of this object. The portable object can be stored
            and logged from any thread with identical results.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.ILogger">
      <summary>
            Interface that all loggers implement
            </summary>
      <remarks>
        <para>
            This interface supports logging events and testing if a level
            is enabled for logging.
            </para>
        <para>
            These methods will not throw exceptions. Note to implementor, ensure
            that the implementation of these methods cannot allow an exception
            to be thrown to the caller.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Core.ILogger.Log(System.Type,log4net.Core.Level,System.Object,System.Exception)">
      <summary>
            This generic form is intended to be used by wrappers.
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <param name="level">The level of the message to be logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">the exception to log, including its stack trace. Pass <c>null</c> to not log an exception.</param>
      <remarks>
        <para>
            Generates a logging event for the specified <paramref name="level" /> using
            the <paramref name="message" /> and <paramref name="exception" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.ILogger.Log(log4net.Core.LoggingEvent)">
      <summary>
            This is the most generic printing method that is intended to be used 
            by wrappers.
            </summary>
      <param name="logEvent">The event being logged.</param>
      <remarks>
        <para>
            Logs the specified logging event through this logger.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.ILogger.IsEnabledFor(log4net.Core.Level)">
      <summary>
            Checks if this logger is enabled for a given <see cref="T:log4net.Core.Level" /> passed as parameter.
            </summary>
      <param name="level">The level to check.</param>
      <returns>
        <c>true</c> if this logger is enabled for <c>level</c>, otherwise <c>false</c>.
            </returns>
      <remarks>
        <para>
            Test if this logger is going to log events of the specified <paramref name="level" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.ILogger.Name">
      <summary>
            Gets the name of the logger.
            </summary>
      <value>
            The name of the logger.
            </value>
      <remarks>
        <para>
            The name of this logger
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.ILogger.Repository">
      <summary>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> where this 
            <c>Logger</c> instance is attached to.
            </summary>
      <value>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that this logger belongs to.
            </value>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> where this 
            <c>Logger</c> instance is attached to.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.ILoggerWrapper">
      <summary>
            Base interface for all wrappers
            </summary>
      <remarks>
        <para>
            Base interface for all wrappers.
            </para>
        <para>
            All wrappers must implement this interface.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="P:log4net.Core.ILoggerWrapper.Logger">
      <summary>
            Get the implementation behind this wrapper object.
            </summary>
      <value>
            The <see cref="T:log4net.Core.ILogger" /> object that in implementing this object.
            </value>
      <remarks>
        <para>
            The <see cref="T:log4net.Core.ILogger" /> object that in implementing this
            object. The <c>Logger</c> object may not 
            be the same object as this object because of logger decorators.
            This gets the actual underlying objects that is used to process
            the log events.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LoggerRepositoryCreationEventHandler">
      <summary>
            Delegate used to handle logger repository creation event notifications
            </summary>
      <param name="sender">The <see cref="T:log4net.Core.IRepositorySelector" /> which created the repository.</param>
      <param name="e">The <see cref="T:log4net.Core.LoggerRepositoryCreationEventArgs" /> event args
            that holds the <see cref="T:log4net.Repository.ILoggerRepository" /> instance that has been created.</param>
      <remarks>
        <para>
            Delegate used to handle logger repository creation event notifications.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LoggerRepositoryCreationEventArgs">
      <summary>
            Provides data for the <see cref="E:log4net.Core.IRepositorySelector.LoggerRepositoryCreatedEvent" /> event.
            </summary>
      <remarks>
        <para>
            A <see cref="E:log4net.Core.IRepositorySelector.LoggerRepositoryCreatedEvent" /> 
            event is raised every time a <see cref="T:log4net.Repository.ILoggerRepository" /> is created.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggerRepositoryCreationEventArgs.m_repository">
      <summary>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created
            </summary>
    </member>
    <member name="M:log4net.Core.LoggerRepositoryCreationEventArgs.#ctor(log4net.Repository.ILoggerRepository)">
      <summary>
            Construct instance using <see cref="T:log4net.Repository.ILoggerRepository" /> specified
            </summary>
      <param name="repository">the <see cref="T:log4net.Repository.ILoggerRepository" /> that has been created</param>
      <remarks>
        <para>
            Construct instance using <see cref="T:log4net.Repository.ILoggerRepository" /> specified
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggerRepositoryCreationEventArgs.LoggerRepository">
      <summary>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that has been created
            </summary>
      <value>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that has been created
            </value>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that has been created
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.ITriggeringEventEvaluator">
      <summary>
            Test if an <see cref="T:log4net.Core.LoggingEvent" /> triggers an action
            </summary>
      <remarks>
        <para>
            Implementations of this interface allow certain appenders to decide
            when to perform an appender specific action.
            </para>
        <para>
            The action or behavior triggered is defined by the implementation.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Core.ITriggeringEventEvaluator.IsTriggeringEvent(log4net.Core.LoggingEvent)">
      <summary>
            Test if this event triggers the action
            </summary>
      <param name="loggingEvent">The event to check</param>
      <returns>
        <c>true</c> if this event triggers the action, otherwise <c>false</c></returns>
      <remarks>
        <para>
            Return <c>true</c> if this event triggers the action
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.Level">
      <summary>
            Defines the default set of levels recognized by the system.
            </summary>
      <remarks>
        <para>
            Each <see cref="T:log4net.Core.LoggingEvent" /> has an associated <see cref="T:log4net.Core.Level" />.
            </para>
        <para>
            Levels have a numeric <see cref="P:log4net.Core.Level.Value" /> that defines the relative 
            ordering between levels. Two Levels with the same <see cref="P:log4net.Core.Level.Value" /> 
            are deemed to be equivalent.
            </para>
        <para>
            The levels that are recognized by log4net are set for each <see cref="T:log4net.Repository.ILoggerRepository" />
            and each repository can have different levels defined. The levels are stored
            in the <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" /> on the repository. Levels are
            looked up by name from the <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" />.
            </para>
        <para>
            When logging at level INFO the actual level used is not <see cref="F:log4net.Core.Level.Info" /> but
            the value of <c>LoggerRepository.LevelMap["INFO"]</c>. The default value for this is
            <see cref="F:log4net.Core.Level.Info" />, but this can be changed by reconfiguring the level map.
            </para>
        <para>
            Each level has a <see cref="P:log4net.Core.Level.DisplayName" /> in addition to its <see cref="P:log4net.Core.Level.Name" />. The 
            <see cref="P:log4net.Core.Level.DisplayName" /> is the string that is written into the output log. By default
            the display name is the same as the level name, but this can be used to alias levels
            or to localize the log output.
            </para>
        <para>
            Some of the predefined levels recognized by the system are:
            </para>
        <list type="bullet">
          <item>
            <description>
              <see cref="F:log4net.Core.Level.Off" />.</description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.Level.Fatal" />.</description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.Level.Error" />.</description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.Level.Warn" />.</description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.Level.Info" />.</description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.Level.Debug" />.</description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.Level.All" />.</description>
          </item>
        </list>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.Level.Off">
      <summary>
            The <see cref="F:log4net.Core.Level.Off" /> level designates a higher level than all the rest.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Emergency">
      <summary>
            The <see cref="F:log4net.Core.Level.Emergency" /> level designates very severe error events. 
            System unusable, emergencies.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Fatal">
      <summary>
            The <see cref="F:log4net.Core.Level.Fatal" /> level designates very severe error events 
            that will presumably lead the application to abort.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Alert">
      <summary>
            The <see cref="F:log4net.Core.Level.Alert" /> level designates very severe error events. 
            Take immediate action, alerts.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Critical">
      <summary>
            The <see cref="F:log4net.Core.Level.Critical" /> level designates very severe error events. 
            Critical condition, critical.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Severe">
      <summary>
            The <see cref="F:log4net.Core.Level.Severe" /> level designates very severe error events.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Error">
      <summary>
            The <see cref="F:log4net.Core.Level.Error" /> level designates error events that might 
            still allow the application to continue running.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Warn">
      <summary>
            The <see cref="F:log4net.Core.Level.Warn" /> level designates potentially harmful 
            situations.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Notice">
      <summary>
            The <see cref="F:log4net.Core.Level.Notice" /> level designates informational messages 
            that highlight the progress of the application at the highest level.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Info">
      <summary>
            The <see cref="F:log4net.Core.Level.Info" /> level designates informational messages that 
            highlight the progress of the application at coarse-grained level.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Debug">
      <summary>
            The <see cref="F:log4net.Core.Level.Debug" /> level designates fine-grained informational 
            events that are most useful to debug an application.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Fine">
      <summary>
            The <see cref="F:log4net.Core.Level.Fine" /> level designates fine-grained informational 
            events that are most useful to debug an application.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Trace">
      <summary>
            The <see cref="F:log4net.Core.Level.Trace" /> level designates fine-grained informational 
            events that are most useful to debug an application.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Finer">
      <summary>
            The <see cref="F:log4net.Core.Level.Finer" /> level designates fine-grained informational 
            events that are most useful to debug an application.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Verbose">
      <summary>
            The <see cref="F:log4net.Core.Level.Verbose" /> level designates fine-grained informational 
            events that are most useful to debug an application.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.Finest">
      <summary>
            The <see cref="F:log4net.Core.Level.Finest" /> level designates fine-grained informational 
            events that are most useful to debug an application.
            </summary>
    </member>
    <member name="F:log4net.Core.Level.All">
      <summary>
            The <see cref="F:log4net.Core.Level.All" /> level designates the lowest level possible.
            </summary>
    </member>
    <member name="M:log4net.Core.Level.#ctor(System.Int32,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="level">Integer value for this level, higher values represent more severe levels.</param>
      <param name="levelName">The string name of this level.</param>
      <param name="displayName">The display name for this level. This may be localized or otherwise different from the name</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.Level" /> class with
            the specified level name and value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.#ctor(System.Int32,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="level">Integer value for this level, higher values represent more severe levels.</param>
      <param name="levelName">The string name of this level.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.Level" /> class with
            the specified level name and value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.ToString">
      <summary>
            Returns the <see cref="T:System.String" /> representation of the current 
            <see cref="T:log4net.Core.Level" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> representation of the current <see cref="T:log4net.Core.Level" />.
            </returns>
      <remarks>
        <para>
            Returns the level <see cref="P:log4net.Core.Level.Name" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.Equals(System.Object)">
      <summary>
            Compares levels.
            </summary>
      <param name="o">The object to compare against.</param>
      <returns>
        <c>true</c> if the objects are equal.</returns>
      <remarks>
        <para>
            Compares the levels of <see cref="T:log4net.Core.Level" /> instances, and 
            defers to base class if the target object is not a <see cref="T:log4net.Core.Level" />
            instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.GetHashCode">
      <summary>
            Returns a hash code
            </summary>
      <returns>A hash code for the current <see cref="T:log4net.Core.Level" />.</returns>
      <remarks>
        <para>
            Returns a hash code suitable for use in hashing algorithms and data 
            structures like a hash table.
            </para>
        <para>
            Returns the hash code of the level <see cref="P:log4net.Core.Level.Value" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.CompareTo(System.Object)">
      <summary>
            Compares this instance to a specified object and returns an 
            indication of their relative values.
            </summary>
      <param name="r">A <see cref="T:log4net.Core.Level" /> instance or <see langword="null" /> to compare with this instance.</param>
      <returns>
            A 32-bit signed integer that indicates the relative order of the 
            values compared. The return value has these meanings:
            <list type="table"><listheader><term>Value</term><description>Meaning</description></listheader><item><term>Less than zero</term><description>This instance is less than <paramref name="r" />.</description></item><item><term>Zero</term><description>This instance is equal to <paramref name="r" />.</description></item><item><term>Greater than zero</term><description><para>This instance is greater than <paramref name="r" />.</para><para>-or-</para><para><paramref name="r" /> is <see langword="null" />.</para></description></item></list></returns>
      <remarks>
        <para>
          <paramref name="r" /> must be an instance of <see cref="T:log4net.Core.Level" /> 
            or <see langword="null" />; otherwise, an exception is thrown.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="r" /> is not a <see cref="T:log4net.Core.Level" />.</exception>
    </member>
    <member name="M:log4net.Core.Level.op_GreaterThan(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Returns a value indicating whether a specified <see cref="T:log4net.Core.Level" /> 
            is greater than another specified <see cref="T:log4net.Core.Level" />.
            </summary>
      <param name="l">A <see cref="T:log4net.Core.Level" /></param>
      <param name="r">A <see cref="T:log4net.Core.Level" /></param>
      <returns>
        <c>true</c> if <paramref name="l" /> is greater than 
            <paramref name="r" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.op_LessThan(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Returns a value indicating whether a specified <see cref="T:log4net.Core.Level" /> 
            is less than another specified <see cref="T:log4net.Core.Level" />.
            </summary>
      <param name="l">A <see cref="T:log4net.Core.Level" /></param>
      <param name="r">A <see cref="T:log4net.Core.Level" /></param>
      <returns>
        <c>true</c> if <paramref name="l" /> is less than 
            <paramref name="r" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.op_GreaterThanOrEqual(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Returns a value indicating whether a specified <see cref="T:log4net.Core.Level" /> 
            is greater than or equal to another specified <see cref="T:log4net.Core.Level" />.
            </summary>
      <param name="l">A <see cref="T:log4net.Core.Level" /></param>
      <param name="r">A <see cref="T:log4net.Core.Level" /></param>
      <returns>
        <c>true</c> if <paramref name="l" /> is greater than or equal to 
            <paramref name="r" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.op_LessThanOrEqual(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Returns a value indicating whether a specified <see cref="T:log4net.Core.Level" /> 
            is less than or equal to another specified <see cref="T:log4net.Core.Level" />.
            </summary>
      <param name="l">A <see cref="T:log4net.Core.Level" /></param>
      <param name="r">A <see cref="T:log4net.Core.Level" /></param>
      <returns>
        <c>true</c> if <paramref name="l" /> is less than or equal to 
            <paramref name="r" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.op_Equality(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Returns a value indicating whether two specified <see cref="T:log4net.Core.Level" /> 
            objects have the same value.
            </summary>
      <param name="l">A <see cref="T:log4net.Core.Level" /> or <see langword="null" />.</param>
      <param name="r">A <see cref="T:log4net.Core.Level" /> or <see langword="null" />.</param>
      <returns>
        <c>true</c> if the value of <paramref name="l" /> is the same as the 
            value of <paramref name="r" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.op_Inequality(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Returns a value indicating whether two specified <see cref="T:log4net.Core.Level" /> 
            objects have different values.
            </summary>
      <param name="l">A <see cref="T:log4net.Core.Level" /> or <see langword="null" />.</param>
      <param name="r">A <see cref="T:log4net.Core.Level" /> or <see langword="null" />.</param>
      <returns>
        <c>true</c> if the value of <paramref name="l" /> is different from
            the value of <paramref name="r" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.Level.Compare(log4net.Core.Level,log4net.Core.Level)">
      <summary>
            Compares two specified <see cref="T:log4net.Core.Level" /> instances.
            </summary>
      <param name="l">The first <see cref="T:log4net.Core.Level" /> to compare.</param>
      <param name="r">The second <see cref="T:log4net.Core.Level" /> to compare.</param>
      <returns>
            A 32-bit signed integer that indicates the relative order of the 
            two values compared. The return value has these meanings:
            <list type="table"><listheader><term>Value</term><description>Meaning</description></listheader><item><term>Less than zero</term><description><paramref name="l" /> is less than <paramref name="r" />.</description></item><item><term>Zero</term><description><paramref name="l" /> is equal to <paramref name="r" />.</description></item><item><term>Greater than zero</term><description><paramref name="l" /> is greater than <paramref name="r" />.</description></item></list></returns>
      <remarks>
        <para>
            Compares two levels.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.Level.Name">
      <summary>
            Gets the name of this level.
            </summary>
      <value>
            The name of this level.
            </value>
      <remarks>
        <para>
            Gets the name of this level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.Level.Value">
      <summary>
            Gets the value of this level.
            </summary>
      <value>
            The value of this level.
            </value>
      <remarks>
        <para>
            Gets the value of this level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.Level.DisplayName">
      <summary>
            Gets the display name of this level.
            </summary>
      <value>
            The display name of this level.
            </value>
      <remarks>
        <para>
            Gets the display name of this level.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LevelCollection">
      <summary>
            A strongly-typed collection of <see cref="T:log4net.Core.Level" /> objects.
            </summary>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Core.LevelCollection.ILevelCollectionEnumerator">
      <summary>
            Supports type-safe iteration over a <see cref="T:log4net.Core.LevelCollection" />.
            </summary>
    </member>
    <member name="M:log4net.Core.LevelCollection.ILevelCollectionEnumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element in the collection.
            </summary>
      <returns>
        <c>true</c> if the enumerator was successfully advanced to the next element; 
            <c>false</c> if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
    </member>
    <member name="M:log4net.Core.LevelCollection.ILevelCollectionEnumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
    </member>
    <member name="P:log4net.Core.LevelCollection.ILevelCollectionEnumerator.Current">
      <summary>
            Gets the current element in the collection.
            </summary>
    </member>
    <member name="T:log4net.Core.LevelCollection.Tag">
      <summary>
            Type visible only to our subclasses
            Used to access protected constructor
            </summary>
    </member>
    <member name="T:log4net.Core.LevelCollection.Enumerator">
      <summary>
            Supports simple iteration over a <see cref="T:log4net.Core.LevelCollection" />.
            </summary>
    </member>
    <member name="M:log4net.Core.LevelCollection.Enumerator.#ctor(log4net.Core.LevelCollection)">
      <summary>
            Initializes a new instance of the <c>Enumerator</c> class.
            </summary>
      <param name="tc">
      </param>
    </member>
    <member name="M:log4net.Core.LevelCollection.Enumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element in the collection.
            </summary>
      <returns>
        <c>true</c> if the enumerator was successfully advanced to the next element; 
            <c>false</c> if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
    </member>
    <member name="M:log4net.Core.LevelCollection.Enumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
    </member>
    <member name="P:log4net.Core.LevelCollection.Enumerator.Current">
      <summary>
            Gets the current element in the collection.
            </summary>
    </member>
    <member name="M:log4net.Core.LevelCollection.ReadOnly(log4net.Core.LevelCollection)">
      <summary>
            Creates a read-only wrapper for a <c>LevelCollection</c> instance.
            </summary>
      <param name="list">list to create a readonly wrapper arround</param>
      <returns>
            A <c>LevelCollection</c> wrapper that is read-only.
            </returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.#ctor">
      <summary>
            Initializes a new instance of the <c>LevelCollection</c> class
            that is empty and has the default initial capacity.
            </summary>
    </member>
    <member name="M:log4net.Core.LevelCollection.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <c>LevelCollection</c> class
            that has the specified initial capacity.
            </summary>
      <param name="capacity">
            The number of elements that the new <c>LevelCollection</c> is initially capable of storing.
            </param>
    </member>
    <member name="M:log4net.Core.LevelCollection.#ctor(log4net.Core.LevelCollection)">
      <summary>
            Initializes a new instance of the <c>LevelCollection</c> class
            that contains elements copied from the specified <c>LevelCollection</c>.
            </summary>
      <param name="c">The <c>LevelCollection</c> whose elements are copied to the new collection.</param>
    </member>
    <member name="M:log4net.Core.LevelCollection.#ctor(log4net.Core.Level[])">
      <summary>
            Initializes a new instance of the <c>LevelCollection</c> class
            that contains elements copied from the specified <see cref="T:log4net.Core.Level" /> array.
            </summary>
      <param name="a">The <see cref="T:log4net.Core.Level" /> array whose elements are copied to the new list.</param>
    </member>
    <member name="M:log4net.Core.LevelCollection.#ctor(System.Collections.ICollection)">
      <summary>
            Initializes a new instance of the <c>LevelCollection</c> class
            that contains elements copied from the specified <see cref="T:log4net.Core.Level" /> collection.
            </summary>
      <param name="col">The <see cref="T:log4net.Core.Level" /> collection whose elements are copied to the new list.</param>
    </member>
    <member name="M:log4net.Core.LevelCollection.#ctor(log4net.Core.LevelCollection.Tag)">
      <summary>
            Allow subclasses to avoid our default constructors
            </summary>
      <param name="tag">
      </param>
    </member>
    <member name="M:log4net.Core.LevelCollection.CopyTo(log4net.Core.Level[])">
      <summary>
            Copies the entire <c>LevelCollection</c> to a one-dimensional
            <see cref="T:log4net.Core.Level" /> array.
            </summary>
      <param name="array">The one-dimensional <see cref="T:log4net.Core.Level" /> array to copy to.</param>
    </member>
    <member name="M:log4net.Core.LevelCollection.CopyTo(log4net.Core.Level[],System.Int32)">
      <summary>
            Copies the entire <c>LevelCollection</c> to a one-dimensional
            <see cref="T:log4net.Core.Level" /> array, starting at the specified index of the target array.
            </summary>
      <param name="array">The one-dimensional <see cref="T:log4net.Core.Level" /> array to copy to.</param>
      <param name="start">The zero-based index in <paramref name="array" /> at which copying begins.</param>
    </member>
    <member name="M:log4net.Core.LevelCollection.Add(log4net.Core.Level)">
      <summary>
            Adds a <see cref="T:log4net.Core.Level" /> to the end of the <c>LevelCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Core.Level" /> to be added to the end of the <c>LevelCollection</c>.</param>
      <returns>The index at which the value has been added.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.Clear">
      <summary>
            Removes all elements from the <c>LevelCollection</c>.
            </summary>
    </member>
    <member name="M:log4net.Core.LevelCollection.Clone">
      <summary>
            Creates a shallow copy of the <see cref="T:log4net.Core.LevelCollection" />.
            </summary>
      <returns>A new <see cref="T:log4net.Core.LevelCollection" /> with a shallow copy of the collection data.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.Contains(log4net.Core.Level)">
      <summary>
            Determines whether a given <see cref="T:log4net.Core.Level" /> is in the <c>LevelCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Core.Level" /> to check for.</param>
      <returns>
        <c>true</c> if <paramref name="item" /> is found in the <c>LevelCollection</c>; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.IndexOf(log4net.Core.Level)">
      <summary>
            Returns the zero-based index of the first occurrence of a <see cref="T:log4net.Core.Level" />
            in the <c>LevelCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Core.Level" /> to locate in the <c>LevelCollection</c>.</param>
      <returns>
            The zero-based index of the first occurrence of <paramref name="item" /> 
            in the entire <c>LevelCollection</c>, if found; otherwise, -1.
            </returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.Insert(System.Int32,log4net.Core.Level)">
      <summary>
            Inserts an element into the <c>LevelCollection</c> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
      <param name="item">The <see cref="T:log4net.Core.Level" /> to insert.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Core.LevelCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Core.LevelCollection.Remove(log4net.Core.Level)">
      <summary>
            Removes the first occurrence of a specific <see cref="T:log4net.Core.Level" /> from the <c>LevelCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Core.Level" /> to remove from the <c>LevelCollection</c>.</param>
      <exception cref="T:System.ArgumentException">
            The specified <see cref="T:log4net.Core.Level" /> was not found in the <c>LevelCollection</c>.
            </exception>
    </member>
    <member name="M:log4net.Core.LevelCollection.RemoveAt(System.Int32)">
      <summary>
            Removes the element at the specified index of the <c>LevelCollection</c>.
            </summary>
      <param name="index">The zero-based index of the element to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Core.LevelCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Core.LevelCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through the <c>LevelCollection</c>.
            </summary>
      <returns>An <see cref="T:log4net.Core.LevelCollection.Enumerator" /> for the entire <c>LevelCollection</c>.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.AddRange(log4net.Core.LevelCollection)">
      <summary>
            Adds the elements of another <c>LevelCollection</c> to the current <c>LevelCollection</c>.
            </summary>
      <param name="x">The <c>LevelCollection</c> whose elements should be added to the end of the current <c>LevelCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Core.LevelCollection.Count" /> of the <c>LevelCollection</c>.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.AddRange(log4net.Core.Level[])">
      <summary>
            Adds the elements of a <see cref="T:log4net.Core.Level" /> array to the current <c>LevelCollection</c>.
            </summary>
      <param name="x">The <see cref="T:log4net.Core.Level" /> array whose elements should be added to the end of the <c>LevelCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Core.LevelCollection.Count" /> of the <c>LevelCollection</c>.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.AddRange(System.Collections.ICollection)">
      <summary>
            Adds the elements of a <see cref="T:log4net.Core.Level" /> collection to the current <c>LevelCollection</c>.
            </summary>
      <param name="col">The <see cref="T:log4net.Core.Level" /> collection whose elements should be added to the end of the <c>LevelCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Core.LevelCollection.Count" /> of the <c>LevelCollection</c>.</returns>
    </member>
    <member name="M:log4net.Core.LevelCollection.TrimToSize">
      <summary>
            Sets the capacity to the actual number of elements.
            </summary>
    </member>
    <member name="M:log4net.Core.LevelCollection.ValidateIndex(System.Int32)">
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Core.LevelCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Core.LevelCollection.ValidateIndex(System.Int32,System.Boolean)">
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Core.LevelCollection.Count" />.</para>
      </exception>
    </member>
    <member name="P:log4net.Core.LevelCollection.Count">
      <summary>
            Gets the number of elements actually contained in the <c>LevelCollection</c>.
            </summary>
    </member>
    <member name="P:log4net.Core.LevelCollection.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the collection is synchronized (thread-safe).
            </summary>
      <value>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</value>
    </member>
    <member name="P:log4net.Core.LevelCollection.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the collection.
            </summary>
    </member>
    <member name="P:log4net.Core.LevelCollection.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="T:log4net.Core.Level" /> at the specified index.
            </summary>
      <param name="index">The zero-based index of the element to get or set.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Core.LevelCollection.Count" />.</para>
      </exception>
    </member>
    <member name="P:log4net.Core.LevelCollection.IsFixedSize">
      <summary>
            Gets a value indicating whether the collection has a fixed size.
            </summary>
      <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
    </member>
    <member name="P:log4net.Core.LevelCollection.IsReadOnly">
      <summary>
            Gets a value indicating whether the IList is read-only.
            </summary>
      <value>true if the collection is read-only; otherwise, false. The default is false</value>
    </member>
    <member name="P:log4net.Core.LevelCollection.Capacity">
      <summary>
            Gets or sets the number of elements the <c>LevelCollection</c> can contain.
            </summary>
    </member>
    <member name="T:log4net.Core.LevelEvaluator">
      <summary>
            An evaluator that triggers at a threshold level
            </summary>
      <remarks>
        <para>
            This evaluator will trigger if the level of the event
            passed to <see cref="M:log4net.Core.LevelEvaluator.IsTriggeringEvent(log4net.Core.LoggingEvent)" />
            is equal to or greater than the <see cref="P:log4net.Core.LevelEvaluator.Threshold" />
            level.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.LevelEvaluator.m_threshold">
      <summary>
            The threshold for triggering
            </summary>
    </member>
    <member name="M:log4net.Core.LevelEvaluator.#ctor">
      <summary>
            Create a new evaluator using the <see cref="F:log4net.Core.Level.Off" /> threshold.
            </summary>
      <remarks>
        <para>
            Create a new evaluator using the <see cref="F:log4net.Core.Level.Off" /> threshold.
            </para>
        <para>
            This evaluator will trigger if the level of the event
            passed to <see cref="M:log4net.Core.LevelEvaluator.IsTriggeringEvent(log4net.Core.LoggingEvent)" />
            is equal to or greater than the <see cref="P:log4net.Core.LevelEvaluator.Threshold" />
            level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LevelEvaluator.#ctor(log4net.Core.Level)">
      <summary>
            Create a new evaluator using the specified <see cref="T:log4net.Core.Level" /> threshold.
            </summary>
      <param name="threshold">the threshold to trigger at</param>
      <remarks>
        <para>
            Create a new evaluator using the specified <see cref="T:log4net.Core.Level" /> threshold.
            </para>
        <para>
            This evaluator will trigger if the level of the event
            passed to <see cref="M:log4net.Core.LevelEvaluator.IsTriggeringEvent(log4net.Core.LoggingEvent)" />
            is equal to or greater than the <see cref="P:log4net.Core.LevelEvaluator.Threshold" />
            level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LevelEvaluator.IsTriggeringEvent(log4net.Core.LoggingEvent)">
      <summary>
            Is this <paramref name="loggingEvent" /> the triggering event?
            </summary>
      <param name="loggingEvent">The event to check</param>
      <returns>This method returns <c>true</c>, if the event level
            is equal or higher than the <see cref="P:log4net.Core.LevelEvaluator.Threshold" />. 
            Otherwise it returns <c>false</c></returns>
      <remarks>
        <para>
            This evaluator will trigger if the level of the event
            passed to <see cref="M:log4net.Core.LevelEvaluator.IsTriggeringEvent(log4net.Core.LoggingEvent)" />
            is equal to or greater than the <see cref="P:log4net.Core.LevelEvaluator.Threshold" />
            level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LevelEvaluator.Threshold">
      <summary>
            the threshold to trigger at
            </summary>
      <value>
            The <see cref="T:log4net.Core.Level" /> that will cause this evaluator to trigger
            </value>
      <remarks>
        <para>
            This evaluator will trigger if the level of the event
            passed to <see cref="M:log4net.Core.LevelEvaluator.IsTriggeringEvent(log4net.Core.LoggingEvent)" />
            is equal to or greater than the <see cref="P:log4net.Core.LevelEvaluator.Threshold" />
            level.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LevelMap">
      <summary>
            Mapping between string name and Level object
            </summary>
      <remarks>
        <para>
            Mapping between string name and <see cref="T:log4net.Core.Level" /> object.
            This mapping is held separately for each <see cref="T:log4net.Repository.ILoggerRepository" />.
            The level name is case insensitive.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.LevelMap.m_mapName2Level">
      <summary>
            Mapping from level name to Level object. The
            level name is case insensitive
            </summary>
    </member>
    <member name="M:log4net.Core.LevelMap.#ctor">
      <summary>
            Construct the level map
            </summary>
      <remarks>
        <para>
            Construct the level map.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LevelMap.Clear">
      <summary>
            Clear the internal maps of all levels
            </summary>
      <remarks>
        <para>
            Clear the internal maps of all levels
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LevelMap.Add(System.String,System.Int32)">
      <summary>
            Create a new Level and add it to the map
            </summary>
      <param name="name">the string to display for the Level</param>
      <param name="value">the level value to give to the Level</param>
      <remarks>
        <para>
            Create a new Level and add it to the map
            </para>
      </remarks>
      <seealso cref="M:log4net.Core.LevelMap.Add(System.String,System.Int32,System.String)" />
    </member>
    <member name="M:log4net.Core.LevelMap.Add(System.String,System.Int32,System.String)">
      <summary>
            Create a new Level and add it to the map
            </summary>
      <param name="name">the string to display for the Level</param>
      <param name="value">the level value to give to the Level</param>
      <param name="displayName">the display name to give to the Level</param>
      <remarks>
        <para>
            Create a new Level and add it to the map
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LevelMap.Add(log4net.Core.Level)">
      <summary>
            Add a Level to the map
            </summary>
      <param name="level">the Level to add</param>
      <remarks>
        <para>
            Add a Level to the map
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LevelMap.LookupWithDefault(log4net.Core.Level)">
      <summary>
            Lookup a named level from the map
            </summary>
      <param name="defaultLevel">the name of the level to lookup is taken from this level. 
            If the level is not set on the map then this level is added</param>
      <returns>the level in the map with the name specified</returns>
      <remarks>
        <para>
            Lookup a named level from the map. The name of the level to lookup is taken
            from the <see cref="P:log4net.Core.Level.Name" /> property of the <paramref name="defaultLevel" />
            argument.
            </para>
        <para>
            If no level with the specified name is found then the 
            <paramref name="defaultLevel" /> argument is added to the level map
            and returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LevelMap.Item(System.String)">
      <summary>
            Lookup a <see cref="T:log4net.Core.Level" /> by name
            </summary>
      <param name="name">The name of the Level to lookup</param>
      <returns>a Level from the map with the name specified</returns>
      <remarks>
        <para>
            Returns the <see cref="T:log4net.Core.Level" /> from the
            map with the name specified. If the no level is
            found then <c>null</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LevelMap.AllLevels">
      <summary>
            Return all possible levels as a list of Level objects.
            </summary>
      <returns>all possible levels as a list of Level objects</returns>
      <remarks>
        <para>
            Return all possible levels as a list of Level objects.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LocationInfo">
      <summary>
            The internal representation of caller location information.
            </summary>
      <remarks>
        <para>
            This class uses the <c>System.Diagnostics.StackTrace</c> class to generate
            a call stack. The caller's information is then extracted from this stack.
            </para>
        <para>
            The <c>System.Diagnostics.StackTrace</c> class is not supported on the 
            .NET Compact Framework 1.0 therefore caller location information is not
            available on that framework.
            </para>
        <para>
            The <c>System.Diagnostics.StackTrace</c> class has this to say about Release builds:
            </para>
        <para>
            "StackTrace information will be most informative with Debug build configurations. 
            By default, Debug builds include debug symbols, while Release builds do not. The 
            debug symbols contain most of the file, method name, line number, and column 
            information used in constructing StackFrame and StackTrace objects. StackTrace 
            might not report as many method calls as expected, due to code transformations 
            that occur during optimization."
            </para>
        <para>
            This means that in a Release build the caller information may be incomplete or may 
            not exist at all! Therefore caller location information cannot be relied upon in a Release build.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.LocationInfo.NA">
      <summary>
            When location information is not available the constant
            <c>NA</c> is returned. Current value of this string
            constant is <b>?</b>.
            </summary>
    </member>
    <member name="M:log4net.Core.LocationInfo.#ctor(System.Type)">
      <summary>
            Constructor
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LocationInfo" />
            class based on the current thread.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LocationInfo.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="className">The fully qualified class name.</param>
      <param name="methodName">The method name.</param>
      <param name="fileName">The file name.</param>
      <param name="lineNumber">The line number of the method within the file.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LocationInfo" />
            class with the specified data.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LocationInfo.ClassName">
      <summary>
            Gets the fully qualified class name of the caller making the logging 
            request.
            </summary>
      <value>
            The fully qualified class name of the caller making the logging 
            request.
            </value>
      <remarks>
        <para>
            Gets the fully qualified class name of the caller making the logging 
            request.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LocationInfo.FileName">
      <summary>
            Gets the file name of the caller.
            </summary>
      <value>
            The file name of the caller.
            </value>
      <remarks>
        <para>
            Gets the file name of the caller.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LocationInfo.LineNumber">
      <summary>
            Gets the line number of the caller.
            </summary>
      <value>
            The line number of the caller.
            </value>
      <remarks>
        <para>
            Gets the line number of the caller.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LocationInfo.MethodName">
      <summary>
            Gets the method name of the caller.
            </summary>
      <value>
            The method name of the caller.
            </value>
      <remarks>
        <para>
            Gets the method name of the caller.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LocationInfo.FullInfo">
      <summary>
            Gets all available caller information
            </summary>
      <value>
            All available caller information, in the format
            <c>fully.qualified.classname.of.caller.methodName(Filename:line)</c></value>
      <remarks>
        <para>
            Gets all available caller information, in the format
            <c>fully.qualified.classname.of.caller.methodName(Filename:line)</c></para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LoggerManager">
      <summary>
            Static manager that controls the creation of repositories
            </summary>
      <remarks>
        <para>
            Static manager that controls the creation of repositories
            </para>
        <para>
            This class is used by the wrapper managers (e.g. <see cref="T:log4net.LogManager" />)
            to provide access to the <see cref="T:log4net.Core.ILogger" /> objects.
            </para>
        <para>
            This manager also holds the <see cref="T:log4net.Core.IRepositorySelector" /> that is used to
            lookup and create repositories. The selector can be set either programmatically using
            the <see cref="P:log4net.Core.LoggerManager.RepositorySelector" /> property, or by setting the <c>log4net.RepositorySelector</c>
            AppSetting in the applications config file to the fully qualified type name of the
            selector to use. 
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.LoggerManager.s_repositorySelector">
      <summary>
            Initialize the default repository selector
            </summary>
    </member>
    <member name="M:log4net.Core.LoggerManager.#ctor">
      <summary>
            Private constructor to prevent instances. Only static methods should be used.
            </summary>
      <remarks>
        <para>
            Private constructor to prevent instances. Only static methods should be used.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.RegisterAppDomainEvents">
      <summary>
            Register for ProcessExit and DomainUnload events on the AppDomain
            </summary>
      <remarks>
        <para>
            This needs to be in a separate method because the events make
            a LinkDemand for the ControlAppDomain SecurityPermission. Because
            this is a LinkDemand it is demanded at JIT time. Therefore we cannot
            catch the exception in the method itself, we have to catch it in the
            caller.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetLoggerRepository(System.String)">
      <summary>
            Return the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <param name="repository">the repository to lookup in</param>
      <returns>Return the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the <paramref name="repository" /> argument.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetLoggerRepository(System.Reflection.Assembly)">
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.</returns>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetRepository(System.String)">
      <summary>
            Return the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <param name="repository">the repository to lookup in</param>
      <returns>Return the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the <paramref name="repository" /> argument.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetRepository(System.Reflection.Assembly)">
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.</returns>
      <remarks>
        <para>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.Exists(System.String,System.String)">
      <summary>
            Returns the named logger if it exists.
            </summary>
      <param name="repository">The repository to lookup in.</param>
      <param name="name">The fully qualified logger name to look for.</param>
      <returns>
            The logger found, or <c>null</c> if the named logger does not exist in the
            specified repository.
            </returns>
      <remarks>
        <para>
            If the named logger exists (in the specified repository) then it
            returns a reference to the logger, otherwise it returns
            <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.Exists(System.Reflection.Assembly,System.String)">
      <summary>
            Returns the named logger if it exists.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <param name="name">The fully qualified logger name to look for.</param>
      <returns>
            The logger found, or <c>null</c> if the named logger does not exist in the
            specified assembly's repository.
            </returns>
      <remarks>
        <para>
            If the named logger exists (in the specified assembly's repository) then it
            returns a reference to the logger, otherwise it returns
            <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetCurrentLoggers(System.String)">
      <summary>
            Returns all the currently defined loggers in the specified repository.
            </summary>
      <param name="repository">The repository to lookup in.</param>
      <returns>All the defined loggers.</returns>
      <remarks>
        <para>
            The root logger is <b>not</b> included in the returned array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetCurrentLoggers(System.Reflection.Assembly)">
      <summary>
            Returns all the currently defined loggers in the specified assembly's repository.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <returns>All the defined loggers.</returns>
      <remarks>
        <para>
            The root logger is <b>not</b> included in the returned array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetLogger(System.String,System.String)">
      <summary>
            Retrieves or creates a named logger.
            </summary>
      <param name="repository">The repository to lookup in.</param>
      <param name="name">The name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
      <remarks>
        <para>
            Retrieves a logger named as the <paramref name="name" />
            parameter. If the named logger already exists, then the
            existing instance will be returned. Otherwise, a new instance is
            created.
            </para>
        <para>
            By default, loggers do not have a set level but inherit
            it from the hierarchy. This is one of the central features of
            log4net.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetLogger(System.Reflection.Assembly,System.String)">
      <summary>
            Retrieves or creates a named logger.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <param name="name">The name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
      <remarks>
        <para>
            Retrieves a logger named as the <paramref name="name" />
            parameter. If the named logger already exists, then the
            existing instance will be returned. Otherwise, a new instance is
            created.
            </para>
        <para>
            By default, loggers do not have a set level but inherit
            it from the hierarchy. This is one of the central features of
            log4net.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetLogger(System.String,System.Type)">
      <summary>
            Shorthand for <see cref="M:log4net.LogManager.GetLogger(System.String)" />.
            </summary>
      <param name="repository">The repository to lookup in.</param>
      <param name="type">The <paramref name="type" /> of which the fullname will be used as the name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
      <remarks>
        <para>
            Gets the logger for the fully qualified name of the type specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetLogger(System.Reflection.Assembly,System.Type)">
      <summary>
            Shorthand for <see cref="M:log4net.LogManager.GetLogger(System.String)" />.
            </summary>
      <param name="repositoryAssembly">the assembly to use to lookup the repository</param>
      <param name="type">The <paramref name="type" /> of which the fullname will be used as the name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
      <remarks>
        <para>
            Gets the logger for the fully qualified name of the type specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.Shutdown">
      <summary>
            Shuts down the log4net system.
            </summary>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in all the
            default repositories.
            </para>
        <para>
            Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>
            The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.ShutdownRepository(System.String)">
      <summary>
            Shuts down the repository for the repository specified.
            </summary>
      <param name="repository">The repository to shutdown.</param>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in the
            repository for the <paramref name="repository" /> specified.
            </para>
        <para>
            Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>
            The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.ShutdownRepository(System.Reflection.Assembly)">
      <summary>
            Shuts down the repository for the repository specified.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in the
            repository for the repository. The repository is looked up using
            the <paramref name="repositoryAssembly" /> specified.
            </para>
        <para>
            Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>
            The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.ResetConfiguration(System.String)">
      <summary>
            Resets all values contained in this repository instance to their defaults.
            </summary>
      <param name="repository">The repository to reset.</param>
      <remarks>
        <para>
            Resets all values contained in the repository instance to their
            defaults.  This removes all appenders from all loggers, sets
            the level of all non-root loggers to <c>null</c>,
            sets their additivity flag to <c>true</c> and sets the level
            of the root logger to <see cref="F:log4net.Core.Level.Debug" />. Moreover,
            message disabling is set its default "off" value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.ResetConfiguration(System.Reflection.Assembly)">
      <summary>
            Resets all values contained in this repository instance to their defaults.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository to reset.</param>
      <remarks>
        <para>
            Resets all values contained in the repository instance to their
            defaults.  This removes all appenders from all loggers, sets
            the level of all non-root loggers to <c>null</c>,
            sets their additivity flag to <c>true</c> and sets the level
            of the root logger to <see cref="F:log4net.Core.Level.Debug" />. Moreover,
            message disabling is set its default "off" value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.CreateDomain(System.String)">
      <summary>
            Creates a repository with the specified name.
            </summary>
      <param name="repository">The name of the repository, this must be unique amongst repositories.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            Creates the default type of <see cref="T:log4net.Repository.ILoggerRepository" /> which is a
            <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> object.
            </para>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An <see cref="T:System.Exception" /> will be thrown if the repository already exists.
            </para>
      </remarks>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.Core.LoggerManager.CreateRepository(System.String)">
      <summary>
            Creates a repository with the specified name.
            </summary>
      <param name="repository">The name of the repository, this must be unique amongst repositories.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
            Creates the default type of <see cref="T:log4net.Repository.ILoggerRepository" /> which is a
            <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> object.
            </para>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An <see cref="T:System.Exception" /> will be thrown if the repository already exists.
            </para>
      </remarks>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.Core.LoggerManager.CreateDomain(System.String,System.Type)">
      <summary>
            Creates a repository with the specified name and repository type.
            </summary>
      <param name="repository">The name of the repository, this must be unique to the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An Exception will be thrown if the repository already exists.
            </para>
      </remarks>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.Core.LoggerManager.CreateRepository(System.String,System.Type)">
      <summary>
            Creates a repository with the specified name and repository type.
            </summary>
      <param name="repository">The name of the repository, this must be unique to the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An Exception will be thrown if the repository already exists.
            </para>
      </remarks>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.Core.LoggerManager.CreateDomain(System.Reflection.Assembly,System.Type)">
      <summary>
            Creates a repository for the specified assembly and repository type.
            </summary>
      <param name="repositoryAssembly">The assembly to use to get the name of the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:log4net.Core.LoggerManager.GetRepository(System.Reflection.Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.CreateRepository(System.Reflection.Assembly,System.Type)">
      <summary>
            Creates a repository for the specified assembly and repository type.
            </summary>
      <param name="repositoryAssembly">The assembly to use to get the name of the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:log4net.Core.LoggerManager.GetRepository(System.Reflection.Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetAllRepositories">
      <summary>
            Gets an array of all currently defined repositories.
            </summary>
      <returns>An array of all the known <see cref="T:log4net.Repository.ILoggerRepository" /> objects.</returns>
      <remarks>
        <para>
            Gets an array of all currently defined repositories.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.GetVersionInfo">
      <summary>
            Internal method to get pertinent version info.
            </summary>
      <returns>A string of version info.</returns>
    </member>
    <member name="M:log4net.Core.LoggerManager.OnDomainUnload(System.Object,System.EventArgs)">
      <summary>
            Called when the <see cref="E:System.AppDomain.DomainUnload" /> event fires
            </summary>
      <param name="sender">the <see cref="T:System.AppDomain" /> that is exiting</param>
      <param name="e">null</param>
      <remarks>
        <para>
            Called when the <see cref="E:System.AppDomain.DomainUnload" /> event fires.
            </para>
        <para>
            When the event is triggered the log4net system is <see cref="M:log4net.Core.LoggerManager.Shutdown" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggerManager.OnProcessExit(System.Object,System.EventArgs)">
      <summary>
            Called when the <see cref="E:System.AppDomain.ProcessExit" /> event fires
            </summary>
      <param name="sender">the <see cref="T:System.AppDomain" /> that is exiting</param>
      <param name="e">null</param>
      <remarks>
        <para>
            Called when the <see cref="E:System.AppDomain.ProcessExit" /> event fires.
            </para>
        <para>
            When the event is triggered the log4net system is <see cref="M:log4net.Core.LoggerManager.Shutdown" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggerManager.RepositorySelector">
      <summary>
            Gets or sets the repository selector used by the <see cref="T:log4net.LogManager" />.
            </summary>
      <value>
            The repository selector used by the <see cref="T:log4net.LogManager" />.
            </value>
      <remarks>
        <para>
            The repository selector (<see cref="T:log4net.Core.IRepositorySelector" />) is used by 
            the <see cref="T:log4net.LogManager" /> to create and select repositories 
            (<see cref="T:log4net.Repository.ILoggerRepository" />).
            </para>
        <para>
            The caller to <see cref="T:log4net.LogManager" /> supplies either a string name 
            or an assembly (if not supplied the assembly is inferred using 
            <see cref="M:System.Reflection.Assembly.GetCallingAssembly" />).
            </para>
        <para>
            This context is used by the selector to lookup a specific repository.
            </para>
        <para>
            For the full .NET Framework, the default repository is <c>DefaultRepositorySelector</c>;
            for the .NET Compact Framework <c>CompactRepositorySelector</c> is the default
            repository.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LoggerWrapperImpl">
      <summary>
            Implementation of the <see cref="T:log4net.Core.ILoggerWrapper" /> interface.
            </summary>
      <remarks>
        <para>
            This class should be used as the base for all wrapper implementations.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.LoggerWrapperImpl.m_logger">
      <summary>
            The logger that this object is wrapping
            </summary>
    </member>
    <member name="M:log4net.Core.LoggerWrapperImpl.#ctor(log4net.Core.ILogger)">
      <summary>
            Constructs a new wrapper for the specified logger.
            </summary>
      <param name="logger">The logger to wrap.</param>
      <remarks>
        <para>
            Constructs a new wrapper for the specified logger.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggerWrapperImpl.Logger">
      <summary>
            Gets the implementation behind this wrapper object.
            </summary>
      <value>
            The <see cref="T:log4net.Core.ILogger" /> object that this object is implementing.
            </value>
      <remarks>
        <para>
            The <c>Logger</c> object may not be the same object as this object 
            because of logger decorators.
            </para>
        <para>
            This gets the actual underlying objects that is used to process
            the log events.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.LoggingEventData">
      <summary>
            Portable data structure used by <see cref="T:log4net.Core.LoggingEvent" /></summary>
      <remarks>
        <para>
            Portable data structure used by <see cref="T:log4net.Core.LoggingEvent" /></para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.LoggingEventData.LoggerName">
      <summary>
            The logger name.
            </summary>
      <remarks>
        <para>
            The logger name.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.Level">
      <summary>
            Level of logging event.
            </summary>
      <remarks>
        <para>
            Level of logging event. Level cannot be Serializable
            because it is a flyweight.  Due to its special serialization it
            cannot be declared final either.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.Message">
      <summary>
            The application supplied message.
            </summary>
      <remarks>
        <para>
            The application supplied message of logging event.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.ThreadName">
      <summary>
            The name of thread
            </summary>
      <remarks>
        <para>
            The name of thread in which this logging event was generated
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.TimeStamp">
      <summary>
            The time the event was logged
            </summary>
      <remarks>
        <para>
            The TimeStamp is stored in the local time zone for this computer.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.LocationInfo">
      <summary>
            Location information for the caller.
            </summary>
      <remarks>
        <para>
            Location information for the caller.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.UserName">
      <summary>
            String representation of the user
            </summary>
      <remarks>
        <para>
            String representation of the user's windows name,
            like DOMAIN\username
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.Identity">
      <summary>
            String representation of the identity.
            </summary>
      <remarks>
        <para>
            String representation of the current thread's principal identity.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.ExceptionString">
      <summary>
            The string representation of the exception
            </summary>
      <remarks>
        <para>
            The string representation of the exception
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.Domain">
      <summary>
            String representation of the AppDomain.
            </summary>
      <remarks>
        <para>
            String representation of the AppDomain.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEventData.Properties">
      <summary>
            Additional event specific properties
            </summary>
      <remarks>
        <para>
            A logger or an appender may attach additional
            properties to specific events. These properties
            have a string key and an object value.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.FixFlags">
      <summary>
            Flags passed to the <see cref="P:log4net.Core.LoggingEvent.Fix" /> property
            </summary>
      <remarks>
        <para>
            Flags passed to the <see cref="P:log4net.Core.LoggingEvent.Fix" /> property
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.FixFlags.Mdc">
      <summary>
            Fix the MDC
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.Ndc">
      <summary>
            Fix the NDC
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.Message">
      <summary>
            Fix the rendered message
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.ThreadName">
      <summary>
            Fix the thread name
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.LocationInfo">
      <summary>
            Fix the callers location information
            </summary>
      <remarks>
            CAUTION: Very slow to generate
            </remarks>
    </member>
    <member name="F:log4net.Core.FixFlags.UserName">
      <summary>
            Fix the callers windows user name
            </summary>
      <remarks>
            CAUTION: Slow to generate
            </remarks>
    </member>
    <member name="F:log4net.Core.FixFlags.Domain">
      <summary>
            Fix the domain friendly name
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.Identity">
      <summary>
            Fix the callers principal name
            </summary>
      <remarks>
            CAUTION: May be slow to generate
            </remarks>
    </member>
    <member name="F:log4net.Core.FixFlags.Exception">
      <summary>
            Fix the exception text
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.Properties">
      <summary>
            Fix the event properties
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.None">
      <summary>
            No fields fixed
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.All">
      <summary>
            All fields fixed
            </summary>
    </member>
    <member name="F:log4net.Core.FixFlags.Partial">
      <summary>
            Partial fields fixed
            </summary>
      <remarks>
        <para>
            This set of partial fields gives good performance. The following fields are fixed:
            </para>
        <list type="bullet">
          <item>
            <description>
              <see cref="F:log4net.Core.FixFlags.Message" />
            </description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.FixFlags.ThreadName" />
            </description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.FixFlags.Exception" />
            </description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.FixFlags.Domain" />
            </description>
          </item>
          <item>
            <description>
              <see cref="F:log4net.Core.FixFlags.Properties" />
            </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="T:log4net.Core.LoggingEvent">
      <summary>
            The internal representation of logging events. 
            </summary>
      <remarks>
        <para>
            When an affirmative decision is made to log then a 
            <see cref="T:log4net.Core.LoggingEvent" /> instance is created. This instance 
            is passed around to the different log4net components.
            </para>
        <para>
            This class is of concern to those wishing to extend log4net.
            </para>
        <para>
            Some of the values in instances of <see cref="T:log4net.Core.LoggingEvent" />
            are considered volatile, that is the values are correct at the
            time the event is delivered to appenders, but will not be consistent
            at any time afterwards. If an event is to be stored and then processed
            at a later time these volatile values must be fixed by calling
            <see cref="M:log4net.Core.LoggingEvent.FixVolatileData" />. There is a performance penalty
            for incurred by calling <see cref="M:log4net.Core.LoggingEvent.FixVolatileData" /> but it
            is essential to maintaining data consistency.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Douglas de la Torre</author>
      <author>Daniel Cazzulino</author>
    </member>
    <member name="F:log4net.Core.LoggingEvent.HostNameProperty">
      <summary>
            The key into the Properties map for the host name value.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.IdentityProperty">
      <summary>
            The key into the Properties map for the thread identity value.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.UserNameProperty">
      <summary>
            The key into the Properties map for the user name value.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_data">
      <summary>
            The internal logging event data.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_compositeProperties">
      <summary>
            The internal logging event data.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_eventProperties">
      <summary>
            The internal logging event data.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_callerStackBoundaryDeclaringType">
      <summary>
            The fully qualified Type of the calling 
            logger class in the stack frame (i.e. the declaring type of the method).
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_message">
      <summary>
            The application supplied message of logging event.
            </summary>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_thrownException">
      <summary>
            The exception that was thrown.
            </summary>
      <remarks>
            This is not serialized. The string representation
            is serialized instead.
            </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_repository">
      <summary>
            The repository that generated the logging event
            </summary>
      <remarks>
            This is not serialized.
            </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_fixFlags">
      <summary>
            The fix state for this event
            </summary>
      <remarks>
            These flags indicate which fields have been fixed.
            Not serialized.
            </remarks>
    </member>
    <member name="F:log4net.Core.LoggingEvent.m_cacheUpdatable">
      <summary>
            Indicated that the internal cache is updateable (ie not fixed)
            </summary>
      <remarks>
            This is a seperate flag to m_fixFlags as it allows incrementel fixing and simpler
            changes in the caching strategy.
            </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.#ctor(System.Type,log4net.Repository.ILoggerRepository,System.String,log4net.Core.Level,System.Object,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Core.LoggingEvent" /> class
            from the supplied parameters.
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <param name="repository">The repository this event is logged in.</param>
      <param name="loggerName">The name of the logger of this event.</param>
      <param name="level">The level of this event.</param>
      <param name="message">The message of this event.</param>
      <param name="exception">The exception for this event.</param>
      <remarks>
        <para>
            Except <see cref="P:log4net.Core.LoggingEvent.TimeStamp" />, <see cref="P:log4net.Core.LoggingEvent.Level" /> and <see cref="P:log4net.Core.LoggingEvent.LoggerName" />, 
            all fields of <c>LoggingEvent</c> are filled when actually needed. Call
            <see cref="M:log4net.Core.LoggingEvent.FixVolatileData" /> to cache all data locally
            to prevent inconsistencies.
            </para>
        <para>This method is called by the log4net framework
            to create a logging event.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.#ctor(System.Type,log4net.Repository.ILoggerRepository,log4net.Core.LoggingEventData,log4net.Core.FixFlags)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Core.LoggingEvent" /> class 
            using specific data.
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <param name="repository">The repository this event is logged in.</param>
      <param name="data">Data used to initialize the logging event.</param>
      <param name="fixedData">The fields in the <paranref name="data" /> struct that have already been fixed.</param>
      <remarks>
        <para>
            This constructor is provided to allow a <see cref="T:log4net.Core.LoggingEvent" />
            to be created independently of the log4net framework. This can
            be useful if you require a custom serialization scheme.
            </para>
        <para>
            Use the <see cref="M:log4net.Core.LoggingEvent.GetLoggingEventData(log4net.Core.FixFlags)" /> method to obtain an 
            instance of the <see cref="T:log4net.Core.LoggingEventData" /> class.
            </para>
        <para>
            The <paramref name="fixedData" /> parameter should be used to specify which fields in the
            <paramref name="data" /> struct have been preset. Fields not specified in the <paramref name="fixedData" />
            will be captured from the environment if requested or fixed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.#ctor(System.Type,log4net.Repository.ILoggerRepository,log4net.Core.LoggingEventData)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Core.LoggingEvent" /> class 
            using specific data.
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <param name="repository">The repository this event is logged in.</param>
      <param name="data">Data used to initialize the logging event.</param>
      <remarks>
        <para>
            This constructor is provided to allow a <see cref="T:log4net.Core.LoggingEvent" />
            to be created independently of the log4net framework. This can
            be useful if you require a custom serialization scheme.
            </para>
        <para>
            Use the <see cref="M:log4net.Core.LoggingEvent.GetLoggingEventData(log4net.Core.FixFlags)" /> method to obtain an 
            instance of the <see cref="T:log4net.Core.LoggingEventData" /> class.
            </para>
        <para>
            This constructor sets this objects <see cref="P:log4net.Core.LoggingEvent.Fix" /> flags to <see cref="F:log4net.Core.FixFlags.All" />,
            this assumes that all the data relating to this event is passed in via the <paramref name="data" />
            parameter and no other data should be captured from the environment.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.#ctor(log4net.Core.LoggingEventData)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Core.LoggingEvent" /> class 
            using specific data.
            </summary>
      <param name="data">Data used to initialize the logging event.</param>
      <remarks>
        <para>
            This constructor is provided to allow a <see cref="T:log4net.Core.LoggingEvent" />
            to be created independently of the log4net framework. This can
            be useful if you require a custom serialization scheme.
            </para>
        <para>
            Use the <see cref="M:log4net.Core.LoggingEvent.GetLoggingEventData(log4net.Core.FixFlags)" /> method to obtain an 
            instance of the <see cref="T:log4net.Core.LoggingEventData" /> class.
            </para>
        <para>
            This constructor sets this objects <see cref="P:log4net.Core.LoggingEvent.Fix" /> flags to <see cref="F:log4net.Core.FixFlags.All" />,
            this assumes that all the data relating to this event is passed in via the <paramref name="data" />
            parameter and no other data should be captured from the environment.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serialization constructor
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.LoggingEvent" /> class 
            with serialized data.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.EnsureRepository(log4net.Repository.ILoggerRepository)">
      <summary>
            Ensure that the repository is set.
            </summary>
      <param name="repository">the value for the repository</param>
    </member>
    <member name="M:log4net.Core.LoggingEvent.WriteRenderedMessage(System.IO.TextWriter)">
      <summary>
            Write the rendered message to a TextWriter
            </summary>
      <param name="writer">the writer to write the message to</param>
      <remarks>
        <para>
            Unlike the <see cref="P:log4net.Core.LoggingEvent.RenderedMessage" /> property this method
            does store the message data in the internal cache. Therefore 
            if called only once this method should be faster than the
            <see cref="P:log4net.Core.LoggingEvent.RenderedMessage" /> property, however if the message is
            to be accessed multiple times then the property will be more efficient.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serializes this object into the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> provided.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
      <param name="context">The destination for this serialization.</param>
      <remarks>
        <para>
            The data in this event must be fixed before it can be serialized.
            </para>
        <para>
            The <see cref="M:log4net.Core.LoggingEvent.FixVolatileData" /> method must be called during the
            <see cref="M:log4net.Appender.IAppender.DoAppend(log4net.Core.LoggingEvent)" /> method call if this event 
            is to be used outside that method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.GetLoggingEventData">
      <summary>
            Gets the portable data for this <see cref="T:log4net.Core.LoggingEvent" />.
            </summary>
      <returns>The <see cref="T:log4net.Core.LoggingEventData" /> for this event.</returns>
      <remarks>
        <para>
            A new <see cref="T:log4net.Core.LoggingEvent" /> can be constructed using a
            <see cref="T:log4net.Core.LoggingEventData" /> instance.
            </para>
        <para>
            Does a <see cref="F:log4net.Core.FixFlags.Partial" /> fix of the data
            in the logging event before returning the event data.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.GetLoggingEventData(log4net.Core.FixFlags)">
      <summary>
            Gets the portable data for this <see cref="T:log4net.Core.LoggingEvent" />.
            </summary>
      <param name="fixFlags">The set of data to ensure is fixed in the LoggingEventData</param>
      <returns>The <see cref="T:log4net.Core.LoggingEventData" /> for this event.</returns>
      <remarks>
        <para>
            A new <see cref="T:log4net.Core.LoggingEvent" /> can be constructed using a
            <see cref="T:log4net.Core.LoggingEventData" /> instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.GetExceptionStrRep">
      <summary>
            Returns this event's exception's rendered using the 
            <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </summary>
      <returns>
            This event's exception's rendered using the <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </returns>
      <remarks>
        <para>
          <b>Obsolete. Use <see cref="M:log4net.Core.LoggingEvent.GetExceptionString" /> instead.</b>
        </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.GetExceptionString">
      <summary>
            Returns this event's exception's rendered using the 
            <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </summary>
      <returns>
            This event's exception's rendered using the <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </returns>
      <remarks>
        <para>
            Returns this event's exception's rendered using the 
            <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.FixVolatileData">
      <summary>
            Fix instance fields that hold volatile data.
            </summary>
      <remarks>
        <para>
            Some of the values in instances of <see cref="T:log4net.Core.LoggingEvent" />
            are considered volatile, that is the values are correct at the
            time the event is delivered to appenders, but will not be consistent
            at any time afterwards. If an event is to be stored and then processed
            at a later time these volatile values must be fixed by calling
            <see cref="M:log4net.Core.LoggingEvent.FixVolatileData" />. There is a performance penalty
            incurred by calling <see cref="M:log4net.Core.LoggingEvent.FixVolatileData" /> but it
            is essential to maintaining data consistency.
            </para>
        <para>
            Calling <see cref="M:log4net.Core.LoggingEvent.FixVolatileData" /> is equivalent to
            calling <see cref="M:log4net.Core.LoggingEvent.FixVolatileData(System.Boolean)" /> passing the parameter
            <c>false</c>.
            </para>
        <para>
            See <see cref="M:log4net.Core.LoggingEvent.FixVolatileData(System.Boolean)" /> for more
            information.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.FixVolatileData(System.Boolean)">
      <summary>
            Fixes instance fields that hold volatile data.
            </summary>
      <param name="fastButLoose">Set to <c>true</c> to not fix data that takes a long time to fix.</param>
      <remarks>
        <para>
            Some of the values in instances of <see cref="T:log4net.Core.LoggingEvent" />
            are considered volatile, that is the values are correct at the
            time the event is delivered to appenders, but will not be consistent
            at any time afterwards. If an event is to be stored and then processed
            at a later time these volatile values must be fixed by calling
            <see cref="M:log4net.Core.LoggingEvent.FixVolatileData" />. There is a performance penalty
            for incurred by calling <see cref="M:log4net.Core.LoggingEvent.FixVolatileData" /> but it
            is essential to maintaining data consistency.
            </para>
        <para>
            The <paramref name="fastButLoose" /> param controls the data that
            is fixed. Some of the data that can be fixed takes a long time to 
            generate, therefore if you do not require those settings to be fixed
            they can be ignored by setting the <paramref name="fastButLoose" /> param
            to <c>true</c>. This setting will ignore the <see cref="P:log4net.Core.LoggingEvent.LocationInformation" />
            and <see cref="P:log4net.Core.LoggingEvent.UserName" /> settings.
            </para>
        <para>
            Set <paramref name="fastButLoose" /> to <c>false</c> to ensure that all 
            settings are fixed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.FixVolatileData(log4net.Core.FixFlags)">
      <summary>
            Fix the fields specified by the <see cref="T:log4net.Core.FixFlags" /> parameter
            </summary>
      <param name="flags">the fields to fix</param>
      <remarks>
        <para>
            Only fields specified in the <paramref name="flags" /> will be fixed.
            Fields will not be fixed if they have previously been fixed.
            It is not possible to 'unfix' a field.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.LookupProperty(System.String)">
      <summary>
            Lookup a composite property in this event
            </summary>
      <param name="key">the key for the property to lookup</param>
      <returns>the value for the property</returns>
      <remarks>
        <para>
            This event has composite properties that combine together properties from
            several different contexts in the following order:
            <list type="definition"><item><term>this events properties</term><description>
            		This event has <see cref="P:log4net.Core.LoggingEvent.Properties" /> that can be set. These 
            		properties are specific to this event only.
            		</description></item><item><term>the thread properties</term><description>
            		The <see cref="P:log4net.ThreadContext.Properties" /> that are set on the current
            		thread. These properties are shared by all events logged on this thread.
            		</description></item><item><term>the global properties</term><description>
            		The <see cref="P:log4net.GlobalContext.Properties" /> that are set globally. These 
            		properties are shared by all the threads in the AppDomain.
            		</description></item></list></para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LoggingEvent.GetProperties">
      <summary>
            Get all the composite properties in this event
            </summary>
      <returns>the <see cref="T:log4net.Util.PropertiesDictionary" /> containing all the properties</returns>
      <remarks>
        <para>
            See <see cref="M:log4net.Core.LoggingEvent.LookupProperty(System.String)" /> for details of the composite properties 
            stored by the event.
            </para>
        <para>
            This method returns a single <see cref="T:log4net.Util.PropertiesDictionary" /> containing all the
            properties defined for this event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.StartTime">
      <summary>
            Gets the time when the current process started.
            </summary>
      <value>
            This is the time when this process started.
            </value>
      <remarks>
        <para>
            The TimeStamp is stored in the local time zone for this computer.
            </para>
        <para>
            Tries to get the start time for the current process.
            Failing that it returns the time of the first call to
            this property.
            </para>
        <para>
            Note that AppDomains may be loaded and unloaded within the
            same process without the process terminating and therefore
            without the process start time being reset.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.Level">
      <summary>
            Gets the <see cref="P:log4net.Core.LoggingEvent.Level" /> of the logging event.
            </summary>
      <value>
            The <see cref="P:log4net.Core.LoggingEvent.Level" /> of the logging event.
            </value>
      <remarks>
        <para>
            Gets the <see cref="P:log4net.Core.LoggingEvent.Level" /> of the logging event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.TimeStamp">
      <summary>
            Gets the time of the logging event.
            </summary>
      <value>
            The time of the logging event.
            </value>
      <remarks>
        <para>
            The TimeStamp is stored in the local time zone for this computer.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.LoggerName">
      <summary>
            Gets the name of the logger that logged the event.
            </summary>
      <value>
            The name of the logger that logged the event.
            </value>
      <remarks>
        <para>
            Gets the name of the logger that logged the event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.LocationInformation">
      <summary>
            Gets the location information for this logging event.
            </summary>
      <value>
            The location information for this logging event.
            </value>
      <remarks>
        <para>
            The collected information is cached for future use.
            </para>
        <para>
            See the <see cref="T:log4net.Core.LocationInfo" /> class for more information on
            supported frameworks and the different behavior in Debug and
            Release builds.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.MessageObject">
      <summary>
            Gets the message object used to initialize this event.
            </summary>
      <value>
            The message object used to initialize this event.
            </value>
      <remarks>
        <para>
            Gets the message object used to initialize this event.
            Note that this event may not have a valid message object.
            If the event is serialized the message object will not 
            be transferred. To get the text of the message the
            <see cref="P:log4net.Core.LoggingEvent.RenderedMessage" /> property must be used 
            not this property.
            </para>
        <para>
            If there is no defined message object for this event then
            null will be returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.ExceptionObject">
      <summary>
            Gets the exception object used to initialize this event.
            </summary>
      <value>
            The exception object used to initialize this event.
            </value>
      <remarks>
        <para>
            Gets the exception object used to initialize this event.
            Note that this event may not have a valid exception object.
            If the event is serialized the exception object will not 
            be transferred. To get the text of the exception the
            <see cref="M:log4net.Core.LoggingEvent.GetExceptionString" /> method must be used 
            not this property.
            </para>
        <para>
            If there is no defined exception object for this event then
            null will be returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.Repository">
      <summary>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that this event was created in.
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that this event was created in.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.RenderedMessage">
      <summary>
            Gets the message, rendered through the <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </summary>
      <value>
            The message rendered through the <see cref="P:log4net.Repository.ILoggerRepository.RendererMap" />.
            </value>
      <remarks>
        <para>
            The collected information is cached for future use.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.ThreadName">
      <summary>
            Gets the name of the current thread.  
            </summary>
      <value>
            The name of the current thread, or the thread ID when 
            the name is not available.
            </value>
      <remarks>
        <para>
            The collected information is cached for future use.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.UserName">
      <summary>
            Gets the name of the current user.
            </summary>
      <value>
            The name of the current user, or <c>NOT AVAILABLE</c> when the 
            underlying runtime has no support for retrieving the name of the 
            current user.
            </value>
      <remarks>
        <para>
            Calls <c>WindowsIdentity.GetCurrent().Name</c> to get the name of
            the current windows user.
            </para>
        <para>
            To improve performance, we could cache the string representation of 
            the name, and reuse that as long as the identity stayed constant.  
            Once the identity changed, we would need to re-assign and re-render 
            the string.
            </para>
        <para>
            However, the <c>WindowsIdentity.GetCurrent()</c> call seems to 
            return different objects every time, so the current implementation 
            doesn't do this type of caching.
            </para>
        <para>
            Timing for these operations:
            </para>
        <list type="table">
          <listheader>
            <term>Method</term>
            <description>Results</description>
          </listheader>
          <item>
            <term>
              <c>WindowsIdentity.GetCurrent()</c>
            </term>
            <description>10000 loops, 00:00:00.2031250 seconds</description>
          </item>
          <item>
            <term>
              <c>WindowsIdentity.GetCurrent().Name</c>
            </term>
            <description>10000 loops, 00:00:08.0468750 seconds</description>
          </item>
        </list>
        <para>
            This means we could speed things up almost 40 times by caching the 
            value of the <c>WindowsIdentity.GetCurrent().Name</c> property, since 
            this takes (8.04-0.20) = 7.84375 seconds.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.Identity">
      <summary>
            Gets the identity of the current thread principal.
            </summary>
      <value>
            The string name of the identity of the current thread principal.
            </value>
      <remarks>
        <para>
            Calls <c>System.Threading.Thread.CurrentPrincipal.Identity.Name</c> to get
            the name of the current thread principal.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.Domain">
      <summary>
            Gets the AppDomain friendly name.
            </summary>
      <value>
            The AppDomain friendly name.
            </value>
      <remarks>
        <para>
            Gets the AppDomain friendly name.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.Properties">
      <summary>
            Additional event specific properties.
            </summary>
      <value>
            Additional event specific properties.
            </value>
      <remarks>
        <para>
            A logger or an appender may attach additional
            properties to specific events. These properties
            have a string key and an object value.
            </para>
        <para>
            This property is for events that have been added directly to
            this event. The aggregate properties (which include these
            event properties) can be retrieved using <see cref="M:log4net.Core.LoggingEvent.LookupProperty(System.String)" />
            and <see cref="M:log4net.Core.LoggingEvent.GetProperties" />.
            </para>
        <para>
            Once the properties have been fixed <see cref="P:log4net.Core.LoggingEvent.Fix" /> this property
            returns the combined cached properties. This ensures that updates to
            this property are always reflected in the underlying storage. When
            returning the combined properties there may be more keys in the
            Dictionary than expected.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LoggingEvent.Fix">
      <summary>
            The fixed fields in this event
            </summary>
      <value>
            The set of fields that are fixed in this event
            </value>
      <remarks>
        <para>
            Fields will not be fixed if they have previously been fixed.
            It is not possible to 'unfix' a field.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.ILog">
      <summary>
            The ILog interface is use by application to log messages into
            the log4net framework.
            </summary>
      <remarks>
        <para>
            Use the <see cref="T:log4net.LogManager" /> to obtain logger instances
            that implement this interface. The <see cref="M:log4net.LogManager.GetLogger(System.Reflection.Assembly,System.Type)" />
            static method is used to get logger instances.
            </para>
        <para>
            This class contains methods for logging at different levels and also
            has properties for determining if those logging levels are
            enabled in the current configuration.
            </para>
        <para>
            This interface can be implemented in different ways. This documentation
            specifies reasonable behavior that a caller can expect from the actual
            implementation, however different implementations reserve the right to
            do things differently.
            </para>
      </remarks>
      <example>Simple example of logging messages
            <code lang="C#">
            ILog log = LogManager.GetLogger("application-log");
            
            log.Info("Application Start");
            log.Debug("This is a debug message");
            
            if (log.IsDebugEnabled)
            {
            	log.Debug("This is another debug message");
            }
            </code></example>
      <seealso cref="T:log4net.LogManager" />
      <seealso cref="M:log4net.LogManager.GetLogger(System.Reflection.Assembly,System.Type)" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.ILog.Debug(System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Debug" /> level.</overloads>
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="message">The message object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>DEBUG</c>
            enabled by comparing the level of this logger with the 
            <see cref="F:log4net.Core.Level.Debug" /> level. If this logger is
            <c>DEBUG</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.ILog.Debug(System.Object,System.Exception)" /> form instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.Debug(System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Debug" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.ILog.Debug(System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.DebugFormat(System.String,System.Object[])">
      <overloads>Log a formatted string with the <see cref="F:log4net.Core.Level.Debug" /> level.</overloads>
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Debug(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.DebugFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Debug(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.DebugFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Debug(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.DebugFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Debug(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Debug(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="M:log4net.ILog.Info(System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Info" /> level.</overloads>
      <summary>
            Logs a message object with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <remarks>
        <para>
            This method first checks if this logger is <c>INFO</c>
            enabled by comparing the level of this logger with the 
            <see cref="F:log4net.Core.Level.Info" /> level. If this logger is
            <c>INFO</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.ILog.Info(System.Object,System.Exception)" /> form instead.
            </para>
      </remarks>
      <param name="message">The message object to log.</param>
      <seealso cref="M:log4net.ILog.Info(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.Info(System.Object,System.Exception)">
      <summary>
            Logs a message object with the <c>INFO</c> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.ILog.Info(System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.InfoFormat(System.String,System.Object[])">
      <overloads>Log a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.</overloads>
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Info(System.Object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.InfoFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Info(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.InfoFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Info(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.InfoFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Info(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Info(System.Object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsInfoEnabled" />
    </member>
    <member name="M:log4net.ILog.Warn(System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Warn" /> level.</overloads>
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <remarks>
        <para>
            This method first checks if this logger is <c>WARN</c>
            enabled by comparing the level of this logger with the 
            <see cref="F:log4net.Core.Level.Warn" /> level. If this logger is
            <c>WARN</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.ILog.Warn(System.Object,System.Exception)" /> form instead.
            </para>
      </remarks>
      <param name="message">The message object to log.</param>
      <seealso cref="M:log4net.ILog.Warn(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.Warn(System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Warn" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.ILog.Warn(System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.WarnFormat(System.String,System.Object[])">
      <overloads>Log a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.</overloads>
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Warn(System.Object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.WarnFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Warn(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.WarnFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Warn(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.WarnFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Warn(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Warn(System.Object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsWarnEnabled" />
    </member>
    <member name="M:log4net.ILog.Error(System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Error" /> level.</overloads>
      <summary>
            Logs a message object with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="message">The message object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>ERROR</c>
            enabled by comparing the level of this logger with the 
            <see cref="F:log4net.Core.Level.Error" /> level. If this logger is
            <c>ERROR</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.ILog.Error(System.Object,System.Exception)" /> form instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.Error(System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Error" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.ILog.Error(System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.ErrorFormat(System.String,System.Object[])">
      <overloads>Log a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.</overloads>
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Error(System.Object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.ErrorFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Error(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.ErrorFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Error(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.ErrorFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Error(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Error(System.Object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsErrorEnabled" />
    </member>
    <member name="M:log4net.ILog.Fatal(System.Object)">
      <overloads>Log a message object with the <see cref="F:log4net.Core.Level.Fatal" /> level.</overloads>
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <remarks>
        <para>
            This method first checks if this logger is <c>FATAL</c>
            enabled by comparing the level of this logger with the 
            <see cref="F:log4net.Core.Level.Fatal" /> level. If this logger is
            <c>FATAL</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.ILog.Fatal(System.Object,System.Exception)" /> form instead.
            </para>
      </remarks>
      <param name="message">The message object to log.</param>
      <seealso cref="M:log4net.ILog.Fatal(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.ILog.Fatal(System.Object,System.Exception)">
      <summary>
            Log a message object with the <see cref="F:log4net.Core.Level.Fatal" /> level including
            the stack trace of the <see cref="T:System.Exception" /> passed
            as a parameter.
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            See the <see cref="M:log4net.ILog.Fatal(System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.ILog.FatalFormat(System.String,System.Object[])">
      <overloads>Log a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.</overloads>
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Fatal(System.Object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.ILog.FatalFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Fatal(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.ILog.FatalFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Fatal(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.ILog.FatalFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Fatal(System.Object,System.Exception)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="M:log4net.ILog.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <c>String.Format</c> method. See
            <see cref="M:System.String.Format(System.String,System.Object[])" /> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.ILog.Fatal(System.Object)" />
            methods instead.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object,System.Exception)" />
      <seealso cref="P:log4net.ILog.IsFatalEnabled" />
    </member>
    <member name="P:log4net.ILog.IsDebugEnabled">
      <summary>
            Checks if this logger is enabled for the <see cref="F:log4net.Core.Level.Debug" /> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <see cref="F:log4net.Core.Level.Debug" /> events, <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            This function is intended to lessen the computational cost of
            disabled log debug statements.
            </para>
        <para> For some ILog interface <c>log</c>, when you write:</para>
        <code lang="C#">
            log.Debug("This is entry number: " + i );
            </code>
        <para>
            You incur the cost constructing the message, string construction and concatenation in
            this case, regardless of whether the message is logged or not.
            </para>
        <para>
            If you are worried about speed (who isn't), then you should write:
            </para>
        <code lang="C#">
            if (log.IsDebugEnabled)
            { 
                log.Debug("This is entry number: " + i );
            }
            </code>
        <para>
            This way you will not incur the cost of parameter
            construction if debugging is disabled for <c>log</c>. On
            the other hand, if the <c>log</c> is debug enabled, you
            will incur the cost of evaluating whether the logger is debug
            enabled twice. Once in <see cref="P:log4net.ILog.IsDebugEnabled" /> and once in
            the <see cref="M:log4net.ILog.Debug(System.Object)" />.  This is an insignificant overhead
            since evaluating a logger takes about 1% of the time it
            takes to actually log. This is the preferred style of logging.
            </para>
        <para>Alternatively if your logger is available statically then the is debug
            enabled state can be stored in a static variable like this:
            </para>
        <code lang="C#">
            private static readonly bool isDebugEnabled = log.IsDebugEnabled;
            </code>
        <para>
            Then when you come to log you can write:
            </para>
        <code lang="C#">
            if (isDebugEnabled)
            { 
                log.Debug("This is entry number: " + i );
            }
            </code>
        <para>
            This way the debug enabled state is only queried once
            when the class is loaded. Using a <c>private static readonly</c>
            variable is the most efficient because it is a run time constant
            and can be heavily optimized by the JIT compiler.
            </para>
        <para>
            Of course if you use a static readonly variable to
            hold the enabled state of the logger then you cannot
            change the enabled state at runtime to vary the logging
            that is produced. You have to decide if you need absolute
            speed or runtime flexibility.
            </para>
      </remarks>
      <seealso cref="M:log4net.ILog.Debug(System.Object)" />
      <seealso cref="M:log4net.ILog.DebugFormat(System.IFormatProvider,System.String,System.Object[])" />
    </member>
    <member name="P:log4net.ILog.IsInfoEnabled">
      <summary>
            Checks if this logger is enabled for the <see cref="F:log4net.Core.Level.Info" /> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <see cref="F:log4net.Core.Level.Info" /> events, <c>false</c> otherwise.
            </value>
      <remarks>
            For more information see <see cref="P:log4net.ILog.IsDebugEnabled" />.
            </remarks>
      <seealso cref="M:log4net.ILog.Info(System.Object)" />
      <seealso cref="M:log4net.ILog.InfoFormat(System.IFormatProvider,System.String,System.Object[])" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="P:log4net.ILog.IsWarnEnabled">
      <summary>
            Checks if this logger is enabled for the <see cref="F:log4net.Core.Level.Warn" /> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <see cref="F:log4net.Core.Level.Warn" /> events, <c>false</c> otherwise.
            </value>
      <remarks>
            For more information see <see cref="P:log4net.ILog.IsDebugEnabled" />.
            </remarks>
      <seealso cref="M:log4net.ILog.Warn(System.Object)" />
      <seealso cref="M:log4net.ILog.WarnFormat(System.IFormatProvider,System.String,System.Object[])" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="P:log4net.ILog.IsErrorEnabled">
      <summary>
            Checks if this logger is enabled for the <see cref="F:log4net.Core.Level.Error" /> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <see cref="F:log4net.Core.Level.Error" /> events, <c>false</c> otherwise.
            </value>
      <remarks>
            For more information see <see cref="P:log4net.ILog.IsDebugEnabled" />.
            </remarks>
      <seealso cref="M:log4net.ILog.Error(System.Object)" />
      <seealso cref="M:log4net.ILog.ErrorFormat(System.IFormatProvider,System.String,System.Object[])" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="P:log4net.ILog.IsFatalEnabled">
      <summary>
            Checks if this logger is enabled for the <see cref="F:log4net.Core.Level.Fatal" /> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <see cref="F:log4net.Core.Level.Fatal" /> events, <c>false</c> otherwise.
            </value>
      <remarks>
            For more information see <see cref="P:log4net.ILog.IsDebugEnabled" />.
            </remarks>
      <seealso cref="M:log4net.ILog.Fatal(System.Object)" />
      <seealso cref="M:log4net.ILog.FatalFormat(System.IFormatProvider,System.String,System.Object[])" />
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="T:log4net.Core.LogImpl">
      <summary>
            Implementation of <see cref="T:log4net.ILog" /> wrapper interface.
            </summary>
      <remarks>
        <para>
            This implementation of the <see cref="T:log4net.ILog" /> interface
            forwards to the <see cref="T:log4net.Core.ILogger" /> held by the base class.
            </para>
        <para>
            This logger has methods to allow the caller to log at the following
            levels:
            </para>
        <list type="definition">
          <item>
            <term>DEBUG</term>
            <description>
                The <see cref="M:log4net.Core.LogImpl.Debug(System.Object)" /> and <see cref="M:log4net.Core.LogImpl.DebugFormat(System.String,System.Object[])" /> methods log messages
                at the <c>DEBUG</c> level. That is the level with that name defined in the
                repositories <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" />. The default value
                for this level is <see cref="F:log4net.Core.Level.Debug" />. The <see cref="P:log4net.Core.LogImpl.IsDebugEnabled" />
                property tests if this level is enabled for logging.
                </description>
          </item>
          <item>
            <term>INFO</term>
            <description>
                The <see cref="M:log4net.Core.LogImpl.Info(System.Object)" /> and <see cref="M:log4net.Core.LogImpl.InfoFormat(System.String,System.Object[])" /> methods log messages
                at the <c>INFO</c> level. That is the level with that name defined in the
                repositories <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" />. The default value
                for this level is <see cref="F:log4net.Core.Level.Info" />. The <see cref="P:log4net.Core.LogImpl.IsInfoEnabled" />
                property tests if this level is enabled for logging.
                </description>
          </item>
          <item>
            <term>WARN</term>
            <description>
                The <see cref="M:log4net.Core.LogImpl.Warn(System.Object)" /> and <see cref="M:log4net.Core.LogImpl.WarnFormat(System.String,System.Object[])" /> methods log messages
                at the <c>WARN</c> level. That is the level with that name defined in the
                repositories <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" />. The default value
                for this level is <see cref="F:log4net.Core.Level.Warn" />. The <see cref="P:log4net.Core.LogImpl.IsWarnEnabled" />
                property tests if this level is enabled for logging.
                </description>
          </item>
          <item>
            <term>ERROR</term>
            <description>
                The <see cref="M:log4net.Core.LogImpl.Error(System.Object)" /> and <see cref="M:log4net.Core.LogImpl.ErrorFormat(System.String,System.Object[])" /> methods log messages
                at the <c>ERROR</c> level. That is the level with that name defined in the
                repositories <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" />. The default value
                for this level is <see cref="F:log4net.Core.Level.Error" />. The <see cref="P:log4net.Core.LogImpl.IsErrorEnabled" />
                property tests if this level is enabled for logging.
                </description>
          </item>
          <item>
            <term>FATAL</term>
            <description>
                The <see cref="M:log4net.Core.LogImpl.Fatal(System.Object)" /> and <see cref="M:log4net.Core.LogImpl.FatalFormat(System.String,System.Object[])" /> methods log messages
                at the <c>FATAL</c> level. That is the level with that name defined in the
                repositories <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" />. The default value
                for this level is <see cref="F:log4net.Core.Level.Fatal" />. The <see cref="P:log4net.Core.LogImpl.IsFatalEnabled" />
                property tests if this level is enabled for logging.
                </description>
          </item>
        </list>
        <para>
            The values for these levels and their semantic meanings can be changed by 
            configuring the <see cref="P:log4net.Repository.ILoggerRepository.LevelMap" /> for the repository.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.LogImpl.ThisDeclaringType">
      <summary>
            The fully qualified name of this declaring type not the type of any subclass.
            </summary>
    </member>
    <member name="M:log4net.Core.LogImpl.#ctor(log4net.Core.ILogger)">
      <summary>
            Construct a new wrapper for the specified logger.
            </summary>
      <param name="logger">The logger to wrap.</param>
      <remarks>
        <para>
            Construct a new wrapper for the specified logger.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.ReloadLevels(log4net.Repository.ILoggerRepository)">
      <summary>
            Virtual method called when the configuration of the repository changes
            </summary>
      <param name="repository">the repository holding the levels</param>
      <remarks>
        <para>
            Virtual method called when the configuration of the repository changes
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Debug(System.Object)">
      <summary>
            Logs a message object with the <c>DEBUG</c> level.
            </summary>
      <param name="message">The message object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>DEBUG</c>
            enabled by comparing the level of this logger with the 
            <c>DEBUG</c> level. If this logger is
            <c>DEBUG</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.Core.LogImpl.Debug(System.Object,System.Exception)" /> form instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Debug(System.Object,System.Exception)">
      <summary>
            Logs a message object with the <c>DEBUG</c> level
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Logs a message object with the <c>DEBUG</c> level including
            the stack trace of the <see cref="T:System.Exception" /><paramref name="exception" /> passed
            as a parameter.
            </para>
        <para>
            See the <see cref="M:log4net.Core.LogImpl.Debug(System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.Core.LogImpl.Debug(System.Object)" />
    </member>
    <member name="M:log4net.Core.LogImpl.DebugFormat(System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>DEBUG</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.DebugFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Debug(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.DebugFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <c>DEBUG</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.DebugFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Debug(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.DebugFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>DEBUG</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.DebugFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Debug(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.DebugFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>DEBUG</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.DebugFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Debug(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>DEBUG</c> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Debug(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Info(System.Object)">
      <summary>
            Logs a message object with the <c>INFO</c> level.
            </summary>
      <param name="message">The message object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>INFO</c>
            enabled by comparing the level of this logger with the 
            <c>INFO</c> level. If this logger is
            <c>INFO</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger 
            and also higher in the hierarchy depending on the value of 
            the additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> 
            to this method will print the name of the <see cref="T:System.Exception" /> 
            but no stack trace. To print a stack trace use the 
            <see cref="M:log4net.Core.LogImpl.Info(System.Object,System.Exception)" /> form instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Info(System.Object,System.Exception)">
      <summary>
            Logs a message object with the <c>INFO</c> level.
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Logs a message object with the <c>INFO</c> level including
            the stack trace of the <see cref="T:System.Exception" /><paramref name="exception" /> 
            passed as a parameter.
            </para>
        <para>
            See the <see cref="M:log4net.Core.LogImpl.Info(System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.Core.LogImpl.Info(System.Object)" />
    </member>
    <member name="M:log4net.Core.LogImpl.InfoFormat(System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>INFO</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.InfoFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Info(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.InfoFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <c>INFO</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.InfoFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Info(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.InfoFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>INFO</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.InfoFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Info(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.InfoFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>INFO</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.InfoFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Info(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>INFO</c> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Info(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Warn(System.Object)">
      <summary>
            Logs a message object with the <c>WARN</c> level.
            </summary>
      <param name="message">the message object to log</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>WARN</c>
            enabled by comparing the level of this logger with the 
            <c>WARN</c> level. If this logger is
            <c>WARN</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger and 
            also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> to this
            method will print the name of the <see cref="T:System.Exception" /> but no
            stack trace. To print a stack trace use the 
            <see cref="M:log4net.Core.LogImpl.Warn(System.Object,System.Exception)" /> form instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Warn(System.Object,System.Exception)">
      <summary>
            Logs a message object with the <c>WARN</c> level
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Logs a message object with the <c>WARN</c> level including
            the stack trace of the <see cref="T:System.Exception" /><paramref name="exception" /> 
            passed as a parameter.
            </para>
        <para>
            See the <see cref="M:log4net.Core.LogImpl.Warn(System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.Core.LogImpl.Warn(System.Object)" />
    </member>
    <member name="M:log4net.Core.LogImpl.WarnFormat(System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>WARN</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.WarnFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Warn(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.WarnFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <c>WARN</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.WarnFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Warn(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.WarnFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>WARN</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.WarnFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Warn(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.WarnFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>WARN</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.WarnFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Warn(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>WARN</c> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Warn(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Error(System.Object)">
      <summary>
            Logs a message object with the <c>ERROR</c> level.
            </summary>
      <param name="message">The message object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>ERROR</c>
            enabled by comparing the level of this logger with the 
            <c>ERROR</c> level. If this logger is
            <c>ERROR</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger and 
            also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> to this
            method will print the name of the <see cref="T:System.Exception" /> but no
            stack trace. To print a stack trace use the 
            <see cref="M:log4net.Core.LogImpl.Error(System.Object,System.Exception)" /> form instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Error(System.Object,System.Exception)">
      <summary>
            Logs a message object with the <c>ERROR</c> level
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Logs a message object with the <c>ERROR</c> level including
            the stack trace of the <see cref="T:System.Exception" /><paramref name="exception" /> 
            passed as a parameter.
            </para>
        <para>
            See the <see cref="M:log4net.Core.LogImpl.Error(System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.Core.LogImpl.Error(System.Object)" />
    </member>
    <member name="M:log4net.Core.LogImpl.ErrorFormat(System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>ERROR</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.ErrorFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Error(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.ErrorFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <c>ERROR</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.ErrorFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Error(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.ErrorFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>ERROR</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.ErrorFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Error(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.ErrorFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>ERROR</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.ErrorFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Error(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>ERROR</c> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Error(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Fatal(System.Object)">
      <summary>
            Logs a message object with the <c>FATAL</c> level.
            </summary>
      <param name="message">The message object to log.</param>
      <remarks>
        <para>
            This method first checks if this logger is <c>FATAL</c>
            enabled by comparing the level of this logger with the 
            <c>FATAL</c> level. If this logger is
            <c>FATAL</c> enabled, then it converts the message object
            (passed as parameter) to a string by invoking the appropriate
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />. It then 
            proceeds to call all the registered appenders in this logger and 
            also higher in the hierarchy depending on the value of the 
            additivity flag.
            </para>
        <para>
          <b>WARNING</b> Note that passing an <see cref="T:System.Exception" /> to this
            method will print the name of the <see cref="T:System.Exception" /> but no
            stack trace. To print a stack trace use the 
            <see cref="M:log4net.Core.LogImpl.Fatal(System.Object,System.Exception)" /> form instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.Fatal(System.Object,System.Exception)">
      <summary>
            Logs a message object with the <c>FATAL</c> level
            </summary>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Logs a message object with the <c>FATAL</c> level including
            the stack trace of the <see cref="T:System.Exception" /><paramref name="exception" /> 
            passed as a parameter.
            </para>
        <para>
            See the <see cref="M:log4net.Core.LogImpl.Fatal(System.Object)" /> form for more detailed information.
            </para>
      </remarks>
      <seealso cref="M:log4net.Core.LogImpl.Fatal(System.Object)" />
    </member>
    <member name="M:log4net.Core.LogImpl.FatalFormat(System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>FATAL</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.FatalFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Fatal(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.FatalFormat(System.String,System.Object)">
      <summary>
            Logs a formatted message string with the <c>FATAL</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.FatalFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Fatal(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.FatalFormat(System.String,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>FATAL</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.FatalFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Fatal(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.FatalFormat(System.String,System.Object,System.Object,System.Object)">
      <summary>
            Logs a formatted message string with the <c>FATAL</c> level.
            </summary>
      <param name="format">A String containing zero or more format items</param>
      <param name="arg0">An Object to format</param>
      <param name="arg1">An Object to format</param>
      <param name="arg2">An Object to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            The string is formatted using the <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />
            format provider. To specify a localized provider use the
            <see cref="M:log4net.Core.LogImpl.FatalFormat(System.IFormatProvider,System.String,System.Object[])" /> method.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Fatal(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Logs a formatted message string with the <c>FATAL</c> level.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information</param>
      <param name="format">A String containing zero or more format items</param>
      <param name="args">An Object array containing zero or more objects to format</param>
      <remarks>
        <para>
            The message is formatted using the <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" /> method. See
            <c>String.Format</c> for details of the syntax of the format string and the behavior
            of the formatting.
            </para>
        <para>
            This method does not take an <see cref="T:System.Exception" /> object to include in the
            log event. To pass an <see cref="T:System.Exception" /> use one of the <see cref="M:log4net.Core.LogImpl.Fatal(System.Object)" />
            methods instead.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.LogImpl.LoggerRepositoryConfigurationChanged(System.Object,System.EventArgs)">
      <summary>
            Event handler for the <see cref="E:log4net.Repository.ILoggerRepository.ConfigurationChanged" /> event
            </summary>
      <param name="sender">the repository</param>
      <param name="e">Empty</param>
    </member>
    <member name="P:log4net.Core.LogImpl.IsDebugEnabled">
      <summary>
            Checks if this logger is enabled for the <c>DEBUG</c>
            level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <c>DEBUG</c> events,
            <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            This function is intended to lessen the computational cost of
            disabled log debug statements.
            </para>
        <para>
            For some <c>log</c> Logger object, when you write:
            </para>
        <code lang="C#">
            log.Debug("This is entry number: " + i );
            </code>
        <para>
            You incur the cost constructing the message, concatenation in
            this case, regardless of whether the message is logged or not.
            </para>
        <para>
            If you are worried about speed, then you should write:
            </para>
        <code lang="C#">
            if (log.IsDebugEnabled())
            { 
             log.Debug("This is entry number: " + i );
            }
            </code>
        <para>
            This way you will not incur the cost of parameter
            construction if debugging is disabled for <c>log</c>. On
            the other hand, if the <c>log</c> is debug enabled, you
            will incur the cost of evaluating whether the logger is debug
            enabled twice. Once in <c>IsDebugEnabled</c> and once in
            the <c>Debug</c>.  This is an insignificant overhead
            since evaluating a logger takes about 1% of the time it
            takes to actually log.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.LogImpl.IsInfoEnabled">
      <summary>
            Checks if this logger is enabled for the <c>INFO</c> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <c>INFO</c> events,
            <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            See <see cref="P:log4net.Core.LogImpl.IsDebugEnabled" /> for more information and examples 
            of using this method.
            </para>
      </remarks>
      <seealso cref="P:log4net.Core.LogImpl.IsDebugEnabled" />
    </member>
    <member name="P:log4net.Core.LogImpl.IsWarnEnabled">
      <summary>
            Checks if this logger is enabled for the <c>WARN</c> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <c>WARN</c> events,
            <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            See <see cref="P:log4net.Core.LogImpl.IsDebugEnabled" /> for more information and examples 
            of using this method.
            </para>
      </remarks>
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="P:log4net.Core.LogImpl.IsErrorEnabled">
      <summary>
            Checks if this logger is enabled for the <c>ERROR</c> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <c>ERROR</c> events,
            <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            See <see cref="P:log4net.Core.LogImpl.IsDebugEnabled" /> for more information and examples of using this method.
            </para>
      </remarks>
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="P:log4net.Core.LogImpl.IsFatalEnabled">
      <summary>
            Checks if this logger is enabled for the <c>FATAL</c> level.
            </summary>
      <value>
        <c>true</c> if this logger is enabled for <c>FATAL</c> events,
            <c>false</c> otherwise.
            </value>
      <remarks>
        <para>
            See <see cref="P:log4net.Core.LogImpl.IsDebugEnabled" /> for more information and examples of using this method.
            </para>
      </remarks>
      <seealso cref="P:log4net.ILog.IsDebugEnabled" />
    </member>
    <member name="T:log4net.Core.SecurityContext">
      <summary>
            A SecurityContext used by log4net when interacting with protected resources
            </summary>
      <remarks>
        <para>
            A SecurityContext used by log4net when interacting with protected resources
            for example with operating system services. This can be used to impersonate
            a principal that has been granted privileges on the system resources.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Core.SecurityContext.Impersonate(System.Object)">
      <summary>
            Impersonate this SecurityContext
            </summary>
      <param name="state">State supplied by the caller</param>
      <returns>An <see cref="T:System.IDisposable" /> instance that will
            revoke the impersonation of this SecurityContext, or <c>null</c></returns>
      <remarks>
        <para>
            Impersonate this security context. Further calls on the current
            thread should now be made in the security context provided
            by this object. When the <see cref="T:System.IDisposable" /> result 
            <see cref="M:System.IDisposable.Dispose" /> method is called the security
            context of the thread should be reverted to the state it was in
            before <see cref="M:log4net.Core.SecurityContext.Impersonate(System.Object)" /> was called.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.SecurityContextProvider">
      <summary>
            The <see cref="T:log4net.Core.SecurityContextProvider" /> providers default <see cref="T:log4net.Core.SecurityContext" /> instances.
            </summary>
      <remarks>
        <para>
            A configured component that interacts with potentially protected system
            resources uses a <see cref="T:log4net.Core.SecurityContext" /> to provide the elevated
            privileges required. If the <see cref="T:log4net.Core.SecurityContext" /> object has
            been not been explicitly provided to the component then the component
            will request one from this <see cref="T:log4net.Core.SecurityContextProvider" />.
            </para>
        <para>
            By default the <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> is
            an instance of <see cref="T:log4net.Core.SecurityContextProvider" /> which returns only
            <see cref="T:log4net.Util.NullSecurityContext" /> objects. This is a reasonable default
            where the privileges required are not know by the system.
            </para>
        <para>
            This default behavior can be overridden by subclassing the <see cref="T:log4net.Core.SecurityContextProvider" />
            and overriding the <see cref="M:log4net.Core.SecurityContextProvider.CreateSecurityContext(System.Object)" /> method to return
            the desired <see cref="T:log4net.Core.SecurityContext" /> objects. The default provider
            can be replaced by programmatically setting the value of the 
            <see cref="P:log4net.Core.SecurityContextProvider.DefaultProvider" /> property.
            </para>
        <para>
            An alternative is to use the <c>log4net.Config.SecurityContextProviderAttribute</c>
            This attribute can be applied to an assembly in the same way as the
            <c>log4net.Config.XmlConfiguratorAttribute"</c>. The attribute takes
            the type to use as the <see cref="T:log4net.Core.SecurityContextProvider" /> as an argument.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Core.SecurityContextProvider.s_defaultProvider">
      <summary>
            The default provider
            </summary>
    </member>
    <member name="M:log4net.Core.SecurityContextProvider.#ctor">
      <summary>
            Protected default constructor to allow subclassing
            </summary>
      <remarks>
        <para>
            Protected default constructor to allow subclassing
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.SecurityContextProvider.CreateSecurityContext(System.Object)">
      <summary>
            Create a SecurityContext for a consumer
            </summary>
      <param name="consumer">The consumer requesting the SecurityContext</param>
      <returns>An impersonation context</returns>
      <remarks>
        <para>
            The default implementation is to return a <see cref="T:log4net.Util.NullSecurityContext" />.
            </para>
        <para>
            Subclasses should override this method to provide their own
            behavior.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Core.SecurityContextProvider.DefaultProvider">
      <summary>
            Gets or sets the default SecurityContextProvider
            </summary>
      <value>
            The default SecurityContextProvider
            </value>
      <remarks>
        <para>
            The default provider is used by configured components that
            require a <see cref="T:log4net.Core.SecurityContext" /> and have not had one
            given to them.
            </para>
        <para>
            By default this is an instance of <see cref="T:log4net.Core.SecurityContextProvider" />
            that returns <see cref="T:log4net.Util.NullSecurityContext" /> objects.
            </para>
        <para>
            The default provider can be set programmatically by setting
            the value of this property to a sub class of <see cref="T:log4net.Core.SecurityContextProvider" />
            that has the desired behavior.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.WrapperCreationHandler">
      <summary>
            Delegate used to handle creation of new wrappers.
            </summary>
      <param name="logger">The logger to wrap in a wrapper.</param>
      <remarks>
        <para>
            Delegate used to handle creation of new wrappers. This delegate
            is called from the <see cref="M:log4net.Core.WrapperMap.CreateNewWrapperObject(log4net.Core.ILogger)" />
            method to construct the wrapper for the specified logger.
            </para>
        <para>
            The delegate to use is supplied to the <see cref="T:log4net.Core.WrapperMap" />
            constructor.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Core.WrapperMap">
      <summary>
            Maps between logger objects and wrapper objects.
            </summary>
      <remarks>
        <para>
            This class maintains a mapping between <see cref="T:log4net.Core.ILogger" /> objects and
            <see cref="T:log4net.Core.ILoggerWrapper" /> objects. Use the <see cref="M:log4net.Core.WrapperMap.GetWrapper(log4net.Core.ILogger)" /> method to 
            lookup the <see cref="T:log4net.Core.ILoggerWrapper" /> for the specified <see cref="T:log4net.Core.ILogger" />.
            </para>
        <para>
            New wrapper instances are created by the <see cref="M:log4net.Core.WrapperMap.CreateNewWrapperObject(log4net.Core.ILogger)" />
            method. The default behavior is for this method to delegate construction
            of the wrapper to the <see cref="T:log4net.Core.WrapperCreationHandler" /> delegate supplied
            to the constructor. This allows specialization of the behavior without
            requiring subclassing of this type.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Core.WrapperMap.m_repositories">
      <summary>
            Map of logger repositories to hashtables of ILogger to ILoggerWrapper mappings
            </summary>
    </member>
    <member name="F:log4net.Core.WrapperMap.m_createWrapperHandler">
      <summary>
            The handler to use to create the extension wrapper objects.
            </summary>
    </member>
    <member name="F:log4net.Core.WrapperMap.m_shutdownHandler">
      <summary>
            Internal reference to the delegate used to register for repository shutdown events.
            </summary>
    </member>
    <member name="M:log4net.Core.WrapperMap.#ctor(log4net.Core.WrapperCreationHandler)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Core.WrapperMap" /></summary>
      <param name="createWrapperHandler">The handler to use to create the wrapper objects.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Core.WrapperMap" /> class with 
            the specified handler to create the wrapper objects.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.WrapperMap.GetWrapper(log4net.Core.ILogger)">
      <summary>
            Gets the wrapper object for the specified logger.
            </summary>
      <returns>The wrapper object for the specified logger</returns>
      <remarks>
        <para>
            If the logger is null then the corresponding wrapper is null.
            </para>
        <para>
            Looks up the wrapper it it has previously been requested and
            returns it. If the wrapper has never been requested before then
            the <see cref="M:log4net.Core.WrapperMap.CreateNewWrapperObject(log4net.Core.ILogger)" /> virtual method is
            called.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.WrapperMap.CreateNewWrapperObject(log4net.Core.ILogger)">
      <summary>
            Creates the wrapper object for the specified logger.
            </summary>
      <param name="logger">The logger to wrap in a wrapper.</param>
      <returns>The wrapper object for the logger.</returns>
      <remarks>
        <para>
            This implementation uses the <see cref="T:log4net.Core.WrapperCreationHandler" />
            passed to the constructor to create the wrapper. This method
            can be overridden in a subclass.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.WrapperMap.RepositoryShutdown(log4net.Repository.ILoggerRepository)">
      <summary>
            Called when a monitored repository shutdown event is received.
            </summary>
      <param name="repository">The <see cref="T:log4net.Repository.ILoggerRepository" /> that is shutting down</param>
      <remarks>
        <para>
            This method is called when a <see cref="T:log4net.Repository.ILoggerRepository" /> that this
            <see cref="T:log4net.Core.WrapperMap" /> is holding loggers for has signaled its shutdown
            event <see cref="E:log4net.Repository.ILoggerRepository.ShutdownEvent" />. The default
            behavior of this method is to release the references to the loggers
            and their wrappers generated for this repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Core.WrapperMap.ILoggerRepository_Shutdown(System.Object,System.EventArgs)">
      <summary>
            Event handler for repository shutdown event.
            </summary>
      <param name="sender">The sender of the event.</param>
      <param name="e">The event args.</param>
    </member>
    <member name="P:log4net.Core.WrapperMap.Repositories">
      <summary>
            Gets the map of logger repositories.
            </summary>
      <value>
            Map of logger repositories.
            </value>
      <remarks>
        <para>
            Gets the hashtable that is keyed on <see cref="T:log4net.Repository.ILoggerRepository" />. The
            values are hashtables keyed on <see cref="T:log4net.Core.ILogger" /> with the
            value being the corresponding <see cref="T:log4net.Core.ILoggerWrapper" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.DateFormatter.IDateFormatter">
      <summary>
            Render a <see cref="T:System.DateTime" /> as a string.
            </summary>
      <remarks>
        <para>
            Interface to abstract the rendering of a <see cref="T:System.DateTime" />
            instance into a string.
            </para>
        <para>
            The <see cref="M:log4net.DateFormatter.IDateFormatter.FormatDate(System.DateTime,System.IO.TextWriter)" /> method is used to render the
            date to a text writer.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.DateFormatter.IDateFormatter.FormatDate(System.DateTime,System.IO.TextWriter)">
      <summary>
            Formats the specified date as a string.
            </summary>
      <param name="dateToFormat">The date to format.</param>
      <param name="writer">The writer to write to.</param>
      <remarks>
        <para>
            Format the <see cref="T:System.DateTime" /> as a string and write it
            to the <see cref="T:System.IO.TextWriter" /> provided.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.DateFormatter.AbsoluteTimeDateFormatter">
      <summary>
            Formats a <see cref="T:System.DateTime" /> as <c>"HH:mm:ss,fff"</c>.
            </summary>
      <remarks>
        <para>
            Formats a <see cref="T:System.DateTime" /> in the format <c>"HH:mm:ss,fff"</c> for example, <c>"15:49:37,459"</c>.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.DateFormatter.AbsoluteTimeDateFormatter.AbsoluteTimeDateFormat">
      <summary>
            String constant used to specify AbsoluteTimeDateFormat in layouts. Current value is <b>ABSOLUTE</b>.
            </summary>
    </member>
    <member name="F:log4net.DateFormatter.AbsoluteTimeDateFormatter.DateAndTimeDateFormat">
      <summary>
            String constant used to specify DateTimeDateFormat in layouts.  Current value is <b>DATE</b>.
            </summary>
    </member>
    <member name="F:log4net.DateFormatter.AbsoluteTimeDateFormatter.Iso8601TimeDateFormat">
      <summary>
            String constant used to specify ISO8601DateFormat in layouts. Current value is <b>ISO8601</b>.
            </summary>
    </member>
    <member name="F:log4net.DateFormatter.AbsoluteTimeDateFormatter.s_lastTimeToTheSecond">
      <summary>
            Last stored time with precision up to the second.
            </summary>
    </member>
    <member name="F:log4net.DateFormatter.AbsoluteTimeDateFormatter.s_lastTimeBuf">
      <summary>
            Last stored time with precision up to the second, formatted
            as a string.
            </summary>
    </member>
    <member name="F:log4net.DateFormatter.AbsoluteTimeDateFormatter.s_lastTimeString">
      <summary>
            Last stored time with precision up to the second, formatted
            as a string.
            </summary>
    </member>
    <member name="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)">
      <summary>
            Renders the date into a string. Format is <c>"HH:mm:ss"</c>.
            </summary>
      <param name="dateToFormat">The date to render into a string.</param>
      <param name="buffer">The string builder to write to.</param>
      <remarks>
        <para>
            Subclasses should override this method to render the date
            into a string using a precision up to the second. This method
            will be called at most once per second and the result will be
            reused if it is needed again during the same second.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDate(System.DateTime,System.IO.TextWriter)">
      <summary>
            Renders the date into a string. Format is "HH:mm:ss,fff".
            </summary>
      <param name="dateToFormat">The date to render into a string.</param>
      <param name="writer">The writer to write to.</param>
      <remarks>
        <para>
            Uses the <see cref="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)" /> method to generate the
            time string up to the seconds and then appends the current
            milliseconds. The results from <see cref="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)" /> are
            cached and <see cref="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)" /> is called at most once
            per second.
            </para>
        <para>
            Sub classes should override <see cref="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)" />
            rather than <see cref="M:log4net.DateFormatter.AbsoluteTimeDateFormatter.FormatDate(System.DateTime,System.IO.TextWriter)" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.DateFormatter.DateTimeDateFormatter">
      <summary>
            Formats a <see cref="T:System.DateTime" /> as <c>"dd MMM yyyy HH:mm:ss,fff"</c></summary>
      <remarks>
        <para>
            Formats a <see cref="T:System.DateTime" /> in the format 
            <c>"dd MMM yyyy HH:mm:ss,fff"</c> for example, 
            <c>"06 Nov 1994 15:49:37,459"</c>.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Angelika Schnagl</author>
    </member>
    <member name="F:log4net.DateFormatter.DateTimeDateFormatter.m_dateTimeFormatInfo">
      <summary>
            The format info for the invariant culture.
            </summary>
    </member>
    <member name="M:log4net.DateFormatter.DateTimeDateFormatter.#ctor">
      <summary>
            Default constructor.
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.DateFormatter.DateTimeDateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)">
      <summary>
            Formats the date without the milliseconds part
            </summary>
      <param name="dateToFormat">The date to format.</param>
      <param name="buffer">The string builder to write to.</param>
      <remarks>
        <para>
            Formats a DateTime in the format <c>"dd MMM yyyy HH:mm:ss"</c>
            for example, <c>"06 Nov 1994 15:49:37"</c>.
            </para>
        <para>
            The base class will append the <c>",fff"</c> milliseconds section.
            This method will only be called at most once per second.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.DateFormatter.Iso8601DateFormatter">
      <summary>
            Formats the <see cref="T:System.DateTime" /> as <c>"yyyy-MM-dd HH:mm:ss,fff"</c>.
            </summary>
      <remarks>
        <para>
            Formats the <see cref="T:System.DateTime" /> specified as a string: <c>"yyyy-MM-dd HH:mm:ss,fff"</c>.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.DateFormatter.Iso8601DateFormatter.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.DateFormatter.Iso8601DateFormatter" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.DateFormatter.Iso8601DateFormatter.FormatDateWithoutMillis(System.DateTime,System.Text.StringBuilder)">
      <summary>
            Formats the date without the milliseconds part
            </summary>
      <param name="dateToFormat">The date to format.</param>
      <param name="buffer">The string builder to write to.</param>
      <remarks>
        <para>
            Formats the date specified as a string: <c>"yyyy-MM-dd HH:mm:ss"</c>.
            </para>
        <para>
            The base class will append the <c>",fff"</c> milliseconds section.
            This method will only be called at most once per second.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.DateFormatter.SimpleDateFormatter">
      <summary>
            Formats the <see cref="T:System.DateTime" /> using the <see cref="M:System.DateTime.ToString(System.String,System.IFormatProvider)" /> method.
            </summary>
      <remarks>
        <para>
            Formats the <see cref="T:System.DateTime" /> using the <see cref="T:System.DateTime" /><see cref="M:System.DateTime.ToString(System.String,System.IFormatProvider)" /> method.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.DateFormatter.SimpleDateFormatter.m_formatString">
      <summary>
            The format string used to format the <see cref="T:System.DateTime" />.
            </summary>
      <remarks>
        <para>
            The format string must be compatible with the options
            that can be supplied to <see cref="M:System.DateTime.ToString(System.String,System.IFormatProvider)" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.DateFormatter.SimpleDateFormatter.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="format">The format string.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.DateFormatter.SimpleDateFormatter" /> class 
            with the specified format string.
            </para>
        <para>
            The format string must be compatible with the options
            that can be supplied to <see cref="M:System.DateTime.ToString(System.String,System.IFormatProvider)" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.DateFormatter.SimpleDateFormatter.FormatDate(System.DateTime,System.IO.TextWriter)">
      <summary>
            Formats the date using <see cref="M:System.DateTime.ToString(System.String,System.IFormatProvider)" />.
            </summary>
      <param name="dateToFormat">The date to convert to a string.</param>
      <param name="writer">The writer to write to.</param>
      <remarks>
        <para>
            Uses the date format string supplied to the constructor to call
            the <see cref="M:System.DateTime.ToString(System.String,System.IFormatProvider)" /> method to format the date.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.IFilter">
      <summary>
            Implement this interface to provide customized logging event filtering
            </summary>
      <remarks>
        <para>
            Users should implement this interface to implement customized logging
            event filtering. Note that <see cref="T:log4net.Repository.Hierarchy.Logger" /> and 
            <see cref="T:log4net.Appender.AppenderSkeleton" />, the parent class of all standard
            appenders, have built-in filtering rules. It is suggested that you
            first use and understand the built-in rules before rushing to write
            your own custom filters.
            </para>
        <para>
            This abstract class assumes and also imposes that filters be
            organized in a linear chain. The <see cref="M:log4net.Filter.IFilter.Decide(log4net.Core.LoggingEvent)" />
            method of each filter is called sequentially, in the order of their 
            addition to the chain.
            </para>
        <para>
            The <see cref="M:log4net.Filter.IFilter.Decide(log4net.Core.LoggingEvent)" /> method must return one
            of the integer constants <see cref="F:log4net.Filter.FilterDecision.Deny" />, 
            <see cref="F:log4net.Filter.FilterDecision.Neutral" /> or <see cref="F:log4net.Filter.FilterDecision.Accept" />.
            </para>
        <para>
            If the value <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned, then the log event is dropped 
            immediately without consulting with the remaining filters.
            </para>
        <para>
            If the value <see cref="F:log4net.Filter.FilterDecision.Neutral" /> is returned, then the next filter
            in the chain is consulted. If there are no more filters in the
            chain, then the log event is logged. Thus, in the presence of no
            filters, the default behavior is to log all logging events.
            </para>
        <para>
            If the value <see cref="F:log4net.Filter.FilterDecision.Accept" /> is returned, then the log
            event is logged without consulting the remaining filters.
            </para>
        <para>
            The philosophy of log4net filters is largely inspired from the
            Linux ipchains.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Filter.IFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Decide if the logging event should be logged through an appender.
            </summary>
      <param name="loggingEvent">The LoggingEvent to decide upon</param>
      <returns>The decision of the filter</returns>
      <remarks>
        <para>
            If the decision is <see cref="F:log4net.Filter.FilterDecision.Deny" />, then the event will be
            dropped. If the decision is <see cref="F:log4net.Filter.FilterDecision.Neutral" />, then the next
            filter, if any, will be invoked. If the decision is <see cref="F:log4net.Filter.FilterDecision.Accept" /> then
            the event will be logged without consulting with other filters in
            the chain.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.IFilter.Next">
      <summary>
            Property to get and set the next filter
            </summary>
      <value>
            The next filter in the chain
            </value>
      <remarks>
        <para>
            Filters are typically composed into chains. This property allows the next filter in 
            the chain to be accessed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.FilterSkeleton">
      <summary>
            Subclass this type to implement customized logging event filtering
            </summary>
      <remarks>
        <para>
            Users should extend this class to implement customized logging
            event filtering. Note that <see cref="T:log4net.Repository.Hierarchy.Logger" /> and 
            <see cref="T:log4net.Appender.AppenderSkeleton" />, the parent class of all standard
            appenders, have built-in filtering rules. It is suggested that you
            first use and understand the built-in rules before rushing to write
            your own custom filters.
            </para>
        <para>
            This abstract class assumes and also imposes that filters be
            organized in a linear chain. The <see cref="M:log4net.Filter.FilterSkeleton.Decide(log4net.Core.LoggingEvent)" />
            method of each filter is called sequentially, in the order of their 
            addition to the chain.
            </para>
        <para>
            The <see cref="M:log4net.Filter.FilterSkeleton.Decide(log4net.Core.LoggingEvent)" /> method must return one
            of the integer constants <see cref="F:log4net.Filter.FilterDecision.Deny" />, 
            <see cref="F:log4net.Filter.FilterDecision.Neutral" /> or <see cref="F:log4net.Filter.FilterDecision.Accept" />.
            </para>
        <para>
            If the value <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned, then the log event is dropped 
            immediately without consulting with the remaining filters.
            </para>
        <para>
            If the value <see cref="F:log4net.Filter.FilterDecision.Neutral" /> is returned, then the next filter
            in the chain is consulted. If there are no more filters in the
            chain, then the log event is logged. Thus, in the presence of no
            filters, the default behavior is to log all logging events.
            </para>
        <para>
            If the value <see cref="F:log4net.Filter.FilterDecision.Accept" /> is returned, then the log
            event is logged without consulting the remaining filters.
            </para>
        <para>
            The philosophy of log4net filters is largely inspired from the
            Linux ipchains.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Filter.FilterSkeleton.m_next">
      <summary>
            Points to the next filter in the filter chain.
            </summary>
      <remarks>
        <para>
            See <see cref="P:log4net.Filter.FilterSkeleton.Next" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Filter.FilterSkeleton.ActivateOptions">
      <summary>
            Initialize the filter with the options set
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Filter.FilterSkeleton.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Filter.FilterSkeleton.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Filter.FilterSkeleton.ActivateOptions" /> must be called again.
            </para>
        <para>
            Typically filter's options become active immediately on set, 
            however this method must still be called. 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Filter.FilterSkeleton.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Decide if the <see cref="T:log4net.Core.LoggingEvent" /> should be logged through an appender.
            </summary>
      <param name="loggingEvent">The <see cref="T:log4net.Core.LoggingEvent" /> to decide upon</param>
      <returns>The decision of the filter</returns>
      <remarks>
        <para>
            If the decision is <see cref="F:log4net.Filter.FilterDecision.Deny" />, then the event will be
            dropped. If the decision is <see cref="F:log4net.Filter.FilterDecision.Neutral" />, then the next
            filter, if any, will be invoked. If the decision is <see cref="F:log4net.Filter.FilterDecision.Accept" /> then
            the event will be logged without consulting with other filters in
            the chain.
            </para>
        <para>
            This method is marked <c>abstract</c> and must be implemented
            in a subclass.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.FilterSkeleton.Next">
      <summary>
            Property to get and set the next filter
            </summary>
      <value>
            The next filter in the chain
            </value>
      <remarks>
        <para>
            Filters are typically composed into chains. This property allows the next filter in 
            the chain to be accessed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.DenyAllFilter">
      <summary>
            This filter drops all <see cref="T:log4net.Core.LoggingEvent" />. 
            </summary>
      <remarks>
        <para>
            You can add this filter to the end of a filter chain to
            switch from the default "accept all unless instructed otherwise"
            filtering behavior to a "deny all unless instructed otherwise"
            behavior.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Filter.DenyAllFilter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Filter.DenyAllFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Always returns the integer constant <see cref="F:log4net.Filter.FilterDecision.Deny" /></summary>
      <param name="loggingEvent">the LoggingEvent to filter</param>
      <returns>Always returns <see cref="F:log4net.Filter.FilterDecision.Deny" /></returns>
      <remarks>
        <para>
            Ignores the event being logged and just returns
            <see cref="F:log4net.Filter.FilterDecision.Deny" />. This can be used to change the default filter
            chain behavior from <see cref="F:log4net.Filter.FilterDecision.Accept" /> to <see cref="F:log4net.Filter.FilterDecision.Deny" />. This filter
            should only be used as the last filter in the chain
            as any further filters will be ignored!
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.FilterDecision">
      <summary>
            The return result from <see cref="M:log4net.Filter.IFilter.Decide(log4net.Core.LoggingEvent)" /></summary>
      <remarks>
        <para>
            The return result from <see cref="M:log4net.Filter.IFilter.Decide(log4net.Core.LoggingEvent)" /></para>
      </remarks>
    </member>
    <member name="F:log4net.Filter.FilterDecision.Deny">
      <summary>
            The log event must be dropped immediately without 
            consulting with the remaining filters, if any, in the chain.
            </summary>
    </member>
    <member name="F:log4net.Filter.FilterDecision.Neutral">
      <summary>
            This filter is neutral with respect to the log event. 
            The remaining filters, if any, should be consulted for a final decision.
            </summary>
    </member>
    <member name="F:log4net.Filter.FilterDecision.Accept">
      <summary>
            The log event must be logged immediately without 
            consulting with the remaining filters, if any, in the chain.
            </summary>
    </member>
    <member name="T:log4net.Filter.LevelMatchFilter">
      <summary>
            This is a very simple filter based on <see cref="T:log4net.Core.Level" /> matching.
            </summary>
      <remarks>
        <para>
            The filter admits two options <see cref="P:log4net.Filter.LevelMatchFilter.LevelToMatch" /> and
            <see cref="P:log4net.Filter.LevelMatchFilter.AcceptOnMatch" />. If there is an exact match between the value
            of the <see cref="P:log4net.Filter.LevelMatchFilter.LevelToMatch" /> option and the <see cref="T:log4net.Core.Level" /> of the 
            <see cref="T:log4net.Core.LoggingEvent" />, then the <see cref="M:log4net.Filter.LevelMatchFilter.Decide(log4net.Core.LoggingEvent)" /> method returns <see cref="F:log4net.Filter.FilterDecision.Accept" /> in 
            case the <see cref="P:log4net.Filter.LevelMatchFilter.AcceptOnMatch" /> option value is set
            to <c>true</c>, if it is <c>false</c> then 
            <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned. If the <see cref="T:log4net.Core.Level" /> does not match then
            the result will be <see cref="F:log4net.Filter.FilterDecision.Neutral" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Filter.LevelMatchFilter.m_acceptOnMatch">
      <summary>
            flag to indicate if the filter should <see cref="F:log4net.Filter.FilterDecision.Accept" /> on a match
            </summary>
    </member>
    <member name="F:log4net.Filter.LevelMatchFilter.m_levelToMatch">
      <summary>
            the <see cref="T:log4net.Core.Level" /> to match against
            </summary>
    </member>
    <member name="M:log4net.Filter.LevelMatchFilter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Filter.LevelMatchFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Tests if the <see cref="T:log4net.Core.Level" /> of the logging event matches that of the filter
            </summary>
      <param name="loggingEvent">the event to filter</param>
      <returns>see remarks</returns>
      <remarks>
        <para>
            If the <see cref="T:log4net.Core.Level" /> of the event matches the level of the
            filter then the result of the function depends on the
            value of <see cref="P:log4net.Filter.LevelMatchFilter.AcceptOnMatch" />. If it is true then
            the function will return <see cref="F:log4net.Filter.FilterDecision.Accept" />, it it is false then it
            will return <see cref="F:log4net.Filter.FilterDecision.Deny" />. If the <see cref="T:log4net.Core.Level" /> does not match then
            the result will be <see cref="F:log4net.Filter.FilterDecision.Neutral" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LevelMatchFilter.AcceptOnMatch">
      <summary>
        <see cref="F:log4net.Filter.FilterDecision.Accept" /> when matching <see cref="P:log4net.Filter.LevelMatchFilter.LevelToMatch" /></summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Filter.LevelMatchFilter.AcceptOnMatch" /> property is a flag that determines
            the behavior when a matching <see cref="T:log4net.Core.Level" /> is found. If the
            flag is set to true then the filter will <see cref="F:log4net.Filter.FilterDecision.Accept" /> the 
            logging event, otherwise it will <see cref="F:log4net.Filter.FilterDecision.Deny" /> the event.
            </para>
        <para>
            The default is <c>true</c> i.e. to <see cref="F:log4net.Filter.FilterDecision.Accept" /> the event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LevelMatchFilter.LevelToMatch">
      <summary>
            The <see cref="T:log4net.Core.Level" /> that the filter will match
            </summary>
      <remarks>
        <para>
            The level that this filter will attempt to match against the 
            <see cref="T:log4net.Core.LoggingEvent" /> level. If a match is found then
            the result depends on the value of <see cref="P:log4net.Filter.LevelMatchFilter.AcceptOnMatch" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.LevelRangeFilter">
      <summary>
            This is a simple filter based on <see cref="T:log4net.Core.Level" /> matching.
            </summary>
      <remarks>
        <para>
            The filter admits three options <see cref="P:log4net.Filter.LevelRangeFilter.LevelMin" /> and <see cref="P:log4net.Filter.LevelRangeFilter.LevelMax" />
            that determine the range of priorities that are matched, and
            <see cref="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch" />. If there is a match between the range
            of priorities and the <see cref="T:log4net.Core.Level" /> of the <see cref="T:log4net.Core.LoggingEvent" />, then the 
            <see cref="M:log4net.Filter.LevelRangeFilter.Decide(log4net.Core.LoggingEvent)" /> method returns <see cref="F:log4net.Filter.FilterDecision.Accept" /> in case the <see cref="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch" /> 
            option value is set to <c>true</c>, if it is <c>false</c>
            then <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned. If there is no match, <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Filter.LevelRangeFilter.m_acceptOnMatch">
      <summary>
            Flag to indicate the behavior when matching a <see cref="T:log4net.Core.Level" /></summary>
    </member>
    <member name="F:log4net.Filter.LevelRangeFilter.m_levelMin">
      <summary>
            the minimum <see cref="T:log4net.Core.Level" /> value to match
            </summary>
    </member>
    <member name="F:log4net.Filter.LevelRangeFilter.m_levelMax">
      <summary>
            the maximum <see cref="T:log4net.Core.Level" /> value to match
            </summary>
    </member>
    <member name="M:log4net.Filter.LevelRangeFilter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Filter.LevelRangeFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Check if the event should be logged.
            </summary>
      <param name="loggingEvent">the logging event to check</param>
      <returns>see remarks</returns>
      <remarks>
        <para>
            If the <see cref="T:log4net.Core.Level" /> of the logging event is outside the range
            matched by this filter then <see cref="F:log4net.Filter.FilterDecision.Deny" />
            is returned. If the <see cref="T:log4net.Core.Level" /> is matched then the value of
            <see cref="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch" /> is checked. If it is true then
            <see cref="F:log4net.Filter.FilterDecision.Accept" /> is returned, otherwise
            <see cref="F:log4net.Filter.FilterDecision.Neutral" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch">
      <summary>
        <see cref="F:log4net.Filter.FilterDecision.Accept" /> when matching <see cref="P:log4net.Filter.LevelRangeFilter.LevelMin" /> and <see cref="P:log4net.Filter.LevelRangeFilter.LevelMax" /></summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch" /> property is a flag that determines
            the behavior when a matching <see cref="T:log4net.Core.Level" /> is found. If the
            flag is set to true then the filter will <see cref="F:log4net.Filter.FilterDecision.Accept" /> the 
            logging event, otherwise it will <see cref="F:log4net.Filter.FilterDecision.Neutral" /> the event.
            </para>
        <para>
            The default is <c>true</c> i.e. to <see cref="F:log4net.Filter.FilterDecision.Accept" /> the event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LevelRangeFilter.LevelMin">
      <summary>
            Set the minimum matched <see cref="T:log4net.Core.Level" /></summary>
      <remarks>
        <para>
            The minimum level that this filter will attempt to match against the 
            <see cref="T:log4net.Core.LoggingEvent" /> level. If a match is found then
            the result depends on the value of <see cref="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LevelRangeFilter.LevelMax">
      <summary>
            Sets the maximum matched <see cref="T:log4net.Core.Level" /></summary>
      <remarks>
        <para>
            The maximum level that this filter will attempt to match against the 
            <see cref="T:log4net.Core.LoggingEvent" /> level. If a match is found then
            the result depends on the value of <see cref="P:log4net.Filter.LevelRangeFilter.AcceptOnMatch" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.LoggerMatchFilter">
      <summary>
            Simple filter to match a string in the event's logger name.
            </summary>
      <remarks>
        <para>
            The works very similar to the <see cref="T:log4net.Filter.LevelMatchFilter" />. It admits two 
            options <see cref="P:log4net.Filter.LoggerMatchFilter.LoggerToMatch" /> and <see cref="P:log4net.Filter.LoggerMatchFilter.AcceptOnMatch" />. If the 
            <see cref="P:log4net.Core.LoggingEvent.LoggerName" /> of the <see cref="T:log4net.Core.LoggingEvent" /> starts 
            with the value of the <see cref="P:log4net.Filter.LoggerMatchFilter.LoggerToMatch" /> option, then the 
            <see cref="M:log4net.Filter.LoggerMatchFilter.Decide(log4net.Core.LoggingEvent)" /> method returns <see cref="F:log4net.Filter.FilterDecision.Accept" /> in 
            case the <see cref="P:log4net.Filter.LoggerMatchFilter.AcceptOnMatch" /> option value is set to <c>true</c>, 
            if it is <c>false</c> then <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned.
            </para>
      </remarks>
      <author>Daniel Cazzulino</author>
    </member>
    <member name="F:log4net.Filter.LoggerMatchFilter.m_acceptOnMatch">
      <summary>
            Flag to indicate the behavior when we have a match
            </summary>
    </member>
    <member name="F:log4net.Filter.LoggerMatchFilter.m_loggerToMatch">
      <summary>
            The logger name string to substring match against the event
            </summary>
    </member>
    <member name="M:log4net.Filter.LoggerMatchFilter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Filter.LoggerMatchFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Check if this filter should allow the event to be logged
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <returns>see remarks</returns>
      <remarks>
        <para>
            The rendered message is matched against the <see cref="P:log4net.Filter.LoggerMatchFilter.LoggerToMatch" />.
            If the <see cref="P:log4net.Filter.LoggerMatchFilter.LoggerToMatch" /> equals the beginning of 
            the incoming <see cref="P:log4net.Core.LoggingEvent.LoggerName" /> (<see cref="M:System.String.StartsWith(System.String)" />)
            then a match will have occurred. If no match occurs
            this function will return <see cref="F:log4net.Filter.FilterDecision.Neutral" />
            allowing other filters to check the event. If a match occurs then
            the value of <see cref="P:log4net.Filter.LoggerMatchFilter.AcceptOnMatch" /> is checked. If it is
            true then <see cref="F:log4net.Filter.FilterDecision.Accept" /> is returned otherwise
            <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LoggerMatchFilter.AcceptOnMatch">
      <summary>
        <see cref="F:log4net.Filter.FilterDecision.Accept" /> when matching <see cref="P:log4net.Filter.LoggerMatchFilter.LoggerToMatch" /></summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Filter.LoggerMatchFilter.AcceptOnMatch" /> property is a flag that determines
            the behavior when a matching <see cref="T:log4net.Core.Level" /> is found. If the
            flag is set to true then the filter will <see cref="F:log4net.Filter.FilterDecision.Accept" /> the 
            logging event, otherwise it will <see cref="F:log4net.Filter.FilterDecision.Deny" /> the event.
            </para>
        <para>
            The default is <c>true</c> i.e. to <see cref="F:log4net.Filter.FilterDecision.Accept" /> the event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.LoggerMatchFilter.LoggerToMatch">
      <summary>
            The <see cref="P:log4net.Core.LoggingEvent.LoggerName" /> that the filter will match
            </summary>
      <remarks>
        <para>
            This filter will attempt to match this value against logger name in
            the following way. The match will be done against the beginning of the
            logger name (using <see cref="M:System.String.StartsWith(System.String)" />). The match is
            case sensitive. If a match is found then
            the result depends on the value of <see cref="P:log4net.Filter.LoggerMatchFilter.AcceptOnMatch" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.StringMatchFilter">
      <summary>
            Simple filter to match a string in the rendered message
            </summary>
      <remarks>
        <para>
            Simple filter to match a string in the rendered message
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Filter.StringMatchFilter.m_acceptOnMatch">
      <summary>
            Flag to indicate the behavior when we have a match
            </summary>
    </member>
    <member name="F:log4net.Filter.StringMatchFilter.m_stringToMatch">
      <summary>
            The string to substring match against the message
            </summary>
    </member>
    <member name="F:log4net.Filter.StringMatchFilter.m_stringRegexToMatch">
      <summary>
            A string regex to match
            </summary>
    </member>
    <member name="F:log4net.Filter.StringMatchFilter.m_regexToMatch">
      <summary>
            A regex object to match (generated from m_stringRegexToMatch)
            </summary>
    </member>
    <member name="M:log4net.Filter.StringMatchFilter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Filter.StringMatchFilter.ActivateOptions">
      <summary>
            Initialize and precompile the Regex if required
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Filter.StringMatchFilter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Filter.StringMatchFilter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Filter.StringMatchFilter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Filter.StringMatchFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Check if this filter should allow the event to be logged
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <returns>see remarks</returns>
      <remarks>
        <para>
            The rendered message is matched against the <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" />.
            If the <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" /> occurs as a substring within
            the message then a match will have occurred. If no match occurs
            this function will return <see cref="F:log4net.Filter.FilterDecision.Neutral" />
            allowing other filters to check the event. If a match occurs then
            the value of <see cref="P:log4net.Filter.StringMatchFilter.AcceptOnMatch" /> is checked. If it is
            true then <see cref="F:log4net.Filter.FilterDecision.Accept" /> is returned otherwise
            <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.StringMatchFilter.AcceptOnMatch">
      <summary>
        <see cref="F:log4net.Filter.FilterDecision.Accept" /> when matching <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" /> or <see cref="P:log4net.Filter.StringMatchFilter.RegexToMatch" /></summary>
      <remarks>
        <para>
            The <see cref="P:log4net.Filter.StringMatchFilter.AcceptOnMatch" /> property is a flag that determines
            the behavior when a matching <see cref="T:log4net.Core.Level" /> is found. If the
            flag is set to true then the filter will <see cref="F:log4net.Filter.FilterDecision.Accept" /> the 
            logging event, otherwise it will <see cref="F:log4net.Filter.FilterDecision.Neutral" /> the event.
            </para>
        <para>
            The default is <c>true</c> i.e. to <see cref="F:log4net.Filter.FilterDecision.Accept" /> the event.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.StringMatchFilter.StringToMatch">
      <summary>
            Sets the static string to match
            </summary>
      <remarks>
        <para>
            The string that will be substring matched against
            the rendered message. If the message contains this
            string then the filter will match. If a match is found then
            the result depends on the value of <see cref="P:log4net.Filter.StringMatchFilter.AcceptOnMatch" />.
            </para>
        <para>
            One of <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" /> or <see cref="P:log4net.Filter.StringMatchFilter.RegexToMatch" />
            must be specified.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.StringMatchFilter.RegexToMatch">
      <summary>
            Sets the regular expression to match
            </summary>
      <remarks>
        <para>
            The regular expression pattern that will be matched against
            the rendered message. If the message matches this
            pattern then the filter will match. If a match is found then
            the result depends on the value of <see cref="P:log4net.Filter.StringMatchFilter.AcceptOnMatch" />.
            </para>
        <para>
            One of <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" /> or <see cref="P:log4net.Filter.StringMatchFilter.RegexToMatch" />
            must be specified.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.PropertyFilter">
      <summary>
            Simple filter to match a string an event property
            </summary>
      <remarks>
        <para>
            Simple filter to match a string in the value for a
            specific event property
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Filter.PropertyFilter.m_key">
      <summary>
            The key to use to lookup the string from the event properties
            </summary>
    </member>
    <member name="M:log4net.Filter.PropertyFilter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Filter.PropertyFilter.Decide(log4net.Core.LoggingEvent)">
      <summary>
            Check if this filter should allow the event to be logged
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <returns>see remarks</returns>
      <remarks>
        <para>
            The event property for the <see cref="P:log4net.Filter.PropertyFilter.Key" /> is matched against 
            the <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" />.
            If the <see cref="P:log4net.Filter.StringMatchFilter.StringToMatch" /> occurs as a substring within
            the property value then a match will have occurred. If no match occurs
            this function will return <see cref="F:log4net.Filter.FilterDecision.Neutral" />
            allowing other filters to check the event. If a match occurs then
            the value of <see cref="P:log4net.Filter.StringMatchFilter.AcceptOnMatch" /> is checked. If it is
            true then <see cref="F:log4net.Filter.FilterDecision.Accept" /> is returned otherwise
            <see cref="F:log4net.Filter.FilterDecision.Deny" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Filter.PropertyFilter.Key">
      <summary>
            The key to lookup in the event properties and then match against.
            </summary>
      <remarks>
        <para>
            The key name to use to lookup in the properties map of the
            <see cref="T:log4net.Core.LoggingEvent" />. The match will be performed against 
            the value of this property if it exists.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Filter.MdcFilter">
      <summary>
            Simple filter to match a keyed string in the <see cref="T:log4net.MDC" /></summary>
      <remarks>
        <para>
            Simple filter to match a keyed string in the <see cref="T:log4net.MDC" /></para>
        <para>
            As the MDC has been replaced with layered properties the
            <see cref="T:log4net.Filter.PropertyFilter" /> should be used instead.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Filter.NdcFilter">
      <summary>
            Simple filter to match a string in the <see cref="T:log4net.NDC" /></summary>
      <remarks>
        <para>
            Simple filter to match a string in the <see cref="T:log4net.NDC" /></para>
        <para>
            As the MDC has been replaced with named stacks stored in the
            properties collections the <see cref="T:log4net.Filter.PropertyFilter" /> should 
            be used instead.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Filter.NdcFilter.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Sets the <see cref="P:log4net.Filter.PropertyFilter.Key" /> to <c>"NDC"</c>.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternConverter">
      <summary>
            Abstract class that provides the formatting functionality that 
            derived classes need.
            </summary>
      <remarks>
        <para>
            Conversion specifiers in a conversion patterns are parsed to
            individual PatternConverters. Each of which is responsible for
            converting a logging event in a converter specific manner.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.PatternConverter.c_renderBufferSize">
      <summary>
            Initial buffer size
            </summary>
    </member>
    <member name="F:log4net.Util.PatternConverter.c_renderBufferMaxCapacity">
      <summary>
            Maximum buffer size before it is recycled
            </summary>
    </member>
    <member name="F:log4net.Util.PatternConverter.m_option">
      <summary>
            The option string to the converter
            </summary>
    </member>
    <member name="M:log4net.Util.PatternConverter.#ctor">
      <summary>
            Protected constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.PatternConverter" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Evaluate this pattern converter and write the output to a writer.
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">The state object on which the pattern converter should be executed.</param>
      <remarks>
        <para>
            Derived pattern converters must override this method in order to
            convert conversion specifiers in the appropriate way.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.SetNext(log4net.Util.PatternConverter)">
      <summary>
            Set the next pattern converter in the chains
            </summary>
      <param name="patternConverter">the pattern converter that should follow this converter in the chain</param>
      <returns>the next converter</returns>
      <remarks>
        <para>
            The PatternConverter can merge with its neighbor during this method (or a sub class).
            Therefore the return value may or may not be the value of the argument passed in.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.Format(System.IO.TextWriter,System.Object)">
      <summary>
            Write the pattern converter to the writer with appropriate formatting
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">The state object on which the pattern converter should be executed.</param>
      <remarks>
        <para>
            This method calls <see cref="M:log4net.Util.PatternConverter.Convert(System.IO.TextWriter,System.Object)" /> to allow the subclass to perform
            appropriate conversion of the pattern converter. If formatting options have
            been specified via the <see cref="P:log4net.Util.PatternConverter.FormattingInfo" /> then this method will
            apply those formattings before writing the output.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.SpacePad(System.IO.TextWriter,System.Int32)">
      <summary>
            Fast space padding method.
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> to which the spaces will be appended.</param>
      <param name="length">The number of spaces to be padded.</param>
      <remarks>
        <para>
            Fast space padding method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.WriteDictionary(System.IO.TextWriter,log4net.Repository.ILoggerRepository,System.Collections.IDictionary)">
      <summary>
            Write an dictionary to a <see cref="T:System.IO.TextWriter" /></summary>
      <param name="writer">the writer to write to</param>
      <param name="repository">a <see cref="T:log4net.Repository.ILoggerRepository" /> to use for object conversion</param>
      <param name="value">the value to write to the writer</param>
      <remarks>
        <para>
            Writes the <see cref="T:System.Collections.IDictionary" /> to a writer in the form:
            </para>
        <code>
            {key1=value1, key2=value2, key3=value3}
            </code>
        <para>
            If the <see cref="T:log4net.Repository.ILoggerRepository" /> specified
            is not null then it is used to render the key and value to text, otherwise
            the object's ToString method is called.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternConverter.WriteObject(System.IO.TextWriter,log4net.Repository.ILoggerRepository,System.Object)">
      <summary>
            Write an object to a <see cref="T:System.IO.TextWriter" /></summary>
      <param name="writer">the writer to write to</param>
      <param name="repository">a <see cref="T:log4net.Repository.ILoggerRepository" /> to use for object conversion</param>
      <param name="value">the value to write to the writer</param>
      <remarks>
        <para>
            Writes the Object to a writer. If the <see cref="T:log4net.Repository.ILoggerRepository" /> specified
            is not null then it is used to render the object to text, otherwise
            the object's ToString method is called.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PatternConverter.Next">
      <summary>
            Get the next pattern converter in the chain
            </summary>
      <value>
            the next pattern converter in the chain
            </value>
      <remarks>
        <para>
            Get the next pattern converter in the chain
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PatternConverter.FormattingInfo">
      <summary>
            Gets or sets the formatting info for this converter
            </summary>
      <value>
            The formatting info for this converter
            </value>
      <remarks>
        <para>
            Gets or sets the formatting info for this converter
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PatternConverter.Option">
      <summary>
            Gets or sets the option value for this converter
            </summary>
      <summary>
            The option for this converter
            </summary>
      <remarks>
        <para>
            Gets or sets the option value for this converter
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.PatternLayoutConverter">
      <summary>
            Abstract class that provides the formatting functionality that 
            derived classes need.
            </summary>
      <remarks>
            Conversion specifiers in a conversion patterns are parsed to
            individual PatternConverters. Each of which is responsible for
            converting a logging event in a converter specific manner.
            </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Layout.Pattern.PatternLayoutConverter.m_ignoresException">
      <summary>
            Flag indicating if this converter handles exceptions
            </summary>
      <remarks>
        <c>false</c> if this converter handles exceptions
            </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.PatternLayoutConverter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Layout.Pattern.PatternLayoutConverter" /> class.
            </summary>
    </member>
    <member name="M:log4net.Layout.Pattern.PatternLayoutConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Derived pattern converters must override this method in order to
            convert conversion specifiers in the correct way.
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">The <see cref="T:log4net.Core.LoggingEvent" /> on which the pattern converter should be executed.</param>
    </member>
    <member name="M:log4net.Layout.Pattern.PatternLayoutConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Derived pattern converters must override this method in order to
            convert conversion specifiers in the correct way.
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">The state object on which the pattern converter should be executed.</param>
    </member>
    <member name="P:log4net.Layout.Pattern.PatternLayoutConverter.IgnoresException">
      <summary>
            Flag indicating if this converter handles the logging event exception
            </summary>
      <value>
        <c>false</c> if this converter handles the logging event exception</value>
      <remarks>
        <para>
            If this converter handles the exception object contained within
            <see cref="T:log4net.Core.LoggingEvent" />, then this property should be set to
            <c>false</c>. Otherwise, if the layout ignores the exception
            object, then the property should be set to <c>true</c>.
            </para>
        <para>
            Set this value to override a this default setting. The default
            value is <c>true</c>, this converter does not handle the exception.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.AppDomainPatternConverter">
      <summary>
            Write the event appdomain name to the output
            </summary>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LoggingEvent.Domain" /> to the output writer.
            </para>
      </remarks>
      <author>Daniel Cazzulino</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.AppDomainPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the event appdomain name to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LoggingEvent.Domain" /> to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.DatePatternConverter">
      <summary>
            Date pattern converter, uses a <see cref="T:log4net.DateFormatter.IDateFormatter" /> to format 
            the date of a <see cref="T:log4net.Core.LoggingEvent" />.
            </summary>
      <remarks>
        <para>
            Render the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> to the writer as a string.
            </para>
        <para>
            The value of the <see cref="P:log4net.Util.PatternConverter.Option" /> determines 
            the formatting of the date. The following values are allowed:
            <list type="definition"><listheader><term>Option value</term><description>Output</description></listheader><item><term>ISO8601</term><description>
            		Uses the <see cref="T:log4net.DateFormatter.Iso8601DateFormatter" /> formatter. 
            		Formats using the <c>"yyyy-MM-dd HH:mm:ss,fff"</c> pattern.
            		</description></item><item><term>DATE</term><description>
            		Uses the <see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> formatter. 
            		Formats using the <c>"dd MMM yyyy HH:mm:ss,fff"</c> for example, <c>"06 Nov 1994 15:49:37,459"</c>.
            		</description></item><item><term>ABSOLUTE</term><description>
            		Uses the <see cref="T:log4net.DateFormatter.AbsoluteTimeDateFormatter" /> formatter. 
            		Formats using the <c>"HH:mm:ss,yyyy"</c> for example, <c>"15:49:37,459"</c>.
            		</description></item><item><term>other</term><description>
            		Any other pattern string uses the <see cref="T:log4net.DateFormatter.SimpleDateFormatter" /> formatter. 
            		This formatter passes the pattern string to the <see cref="T:System.DateTime" /><see cref="M:System.DateTime.ToString(System.String)" /> method.
            		For details on valid patterns see 
            		<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemglobalizationdatetimeformatinfoclasstopic.asp">DateTimeFormatInfo Class</a>.
            		</description></item></list></para>
        <para>
            The <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> is in the local time zone and is rendered in that zone.
            To output the time in Universal time see <see cref="T:log4net.Layout.Pattern.UtcDatePatternConverter" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Layout.Pattern.DatePatternConverter.m_dateFormatter">
      <summary>
            The <see cref="T:log4net.DateFormatter.IDateFormatter" /> used to render the date to a string
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.DateFormatter.IDateFormatter" /> used to render the date to a string
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.DatePatternConverter.ActivateOptions">
      <summary>
            Initialize the converter pattern based on the <see cref="P:log4net.Util.PatternConverter.Option" /> property.
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.Pattern.DatePatternConverter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.Pattern.DatePatternConverter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.Pattern.DatePatternConverter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.DatePatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Convert the pattern into the rendered message
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Pass the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> to the <see cref="T:log4net.DateFormatter.IDateFormatter" />
            for it to render it to the writer.
            </para>
        <para>
            The <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> passed is in the local time zone.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.ExceptionPatternConverter">
      <summary>
            Write the exception text to the output
            </summary>
      <remarks>
        <para>
            If an exception object is stored in the logging event
            it will be rendered into the pattern output with a
            trailing newline.
            </para>
        <para>
            If there is no exception then nothing will be output
            and no trailing newline will be appended.
            It is typical to put a newline before the exception
            and to have the exception as the last data in the pattern.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.ExceptionPatternConverter.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:log4net.Layout.Pattern.ExceptionPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the exception text to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            If an exception object is stored in the logging event
            it will be rendered into the pattern output with a
            trailing newline.
            </para>
        <para>
            If there is no exception then nothing will be output
            and no trailing newline will be appended.
            It is typical to put a newline before the exception
            and to have the exception as the last data in the pattern.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.FileLocationPatternConverter">
      <summary>
            Writes the caller location file name to the output
            </summary>
      <remarks>
        <para>
            Writes the value of the <see cref="P:log4net.Core.LocationInfo.FileName" /> for
            the event to the output writer.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.FileLocationPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the caller location file name to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the value of the <see cref="P:log4net.Core.LocationInfo.FileName" /> for
            the <paramref name="loggingEvent" /> to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.FullLocationPatternConverter">
      <summary>
            Write the caller location info to the output
            </summary>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LocationInfo.FullInfo" /> to the output writer.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.FullLocationPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the caller location info to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LocationInfo.FullInfo" /> to the output writer.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.IdentityPatternConverter">
      <summary>
            Writes the event identity to the output
            </summary>
      <remarks>
        <para>
            Writes the value of the <see cref="P:log4net.Core.LoggingEvent.Identity" /> to
            the output writer.
            </para>
      </remarks>
      <author>Daniel Cazzulino</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.IdentityPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Writes the event identity to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the value of the <paramref name="loggingEvent" /><see cref="P:log4net.Core.LoggingEvent.Identity" /> to
            the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.LevelPatternConverter">
      <summary>
            Write the event level to the output
            </summary>
      <remarks>
        <para>
            Writes the display name of the event <see cref="P:log4net.Core.LoggingEvent.Level" />
            to the writer.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.LevelPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the event level to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.Level.DisplayName" /> of the <paramref name="loggingEvent" /><see cref="P:log4net.Core.LoggingEvent.Level" />
            to the <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.LineLocationPatternConverter">
      <summary>
            Write the caller location line number to the output
            </summary>
      <remarks>
        <para>
            Writes the value of the <see cref="P:log4net.Core.LocationInfo.LineNumber" /> for
            the event to the output writer.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.LineLocationPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the caller location line number to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the value of the <see cref="P:log4net.Core.LocationInfo.LineNumber" /> for
            the <paramref name="loggingEvent" /> to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.NamedPatternConverter">
      <summary>
            Converter to output and truncate <c>'.'</c> separated strings
            </summary>
      <remarks>
        <para>
            This abstract class supports truncating a <c>'.'</c> separated string
            to show a specified number of elements from the right hand side.
            This is used to truncate class names that are fully qualified.
            </para>
        <para>
            Subclasses should override the <see cref="M:log4net.Layout.Pattern.NamedPatternConverter.GetFullyQualifiedName(log4net.Core.LoggingEvent)" /> method to
            return the fully qualified string.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.NamedPatternConverter.ActivateOptions">
      <summary>
            Initialize the converter 
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.Pattern.NamedPatternConverter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.Pattern.NamedPatternConverter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.Pattern.NamedPatternConverter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.NamedPatternConverter.GetFullyQualifiedName(log4net.Core.LoggingEvent)">
      <summary>
            Get the fully qualified string data
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <returns>the fully qualified name</returns>
      <remarks>
        <para>
            Overridden by subclasses to get the fully qualified name before the
            precision is applied to it.
            </para>
        <para>
            Return the fully qualified <c>'.'</c> (dot/period) separated string.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.NamedPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Convert the pattern to the rendered message
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
            Render the <see cref="M:log4net.Layout.Pattern.NamedPatternConverter.GetFullyQualifiedName(log4net.Core.LoggingEvent)" /> to the precision
            specified by the <see cref="P:log4net.Util.PatternConverter.Option" /> property.
            </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.LoggerPatternConverter">
      <summary>
            Converter for logger name
            </summary>
      <remarks>
        <para>
            Outputs the <see cref="P:log4net.Core.LoggingEvent.LoggerName" /> of the event.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.LoggerPatternConverter.GetFullyQualifiedName(log4net.Core.LoggingEvent)">
      <summary>
            Gets the fully qualified name of the logger
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <returns>The fully qualified logger name</returns>
      <remarks>
        <para>
            Returns the <see cref="P:log4net.Core.LoggingEvent.LoggerName" /> of the <paramref name="loggingEvent" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.MessagePatternConverter">
      <summary>
            Writes the event message to the output
            </summary>
      <remarks>
        <para>
            Uses the <see cref="M:log4net.Core.LoggingEvent.WriteRenderedMessage(System.IO.TextWriter)" /> method
            to write out the event message.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.MessagePatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Writes the event message to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Uses the <see cref="M:log4net.Core.LoggingEvent.WriteRenderedMessage(System.IO.TextWriter)" /> method
            to write out the event message.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.MethodLocationPatternConverter">
      <summary>
            Write the method name to the output
            </summary>
      <remarks>
        <para>
            Writes the caller location <see cref="P:log4net.Core.LocationInfo.MethodName" /> to
            the output.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.MethodLocationPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the method name to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the caller location <see cref="P:log4net.Core.LocationInfo.MethodName" /> to
            the output.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.NdcPatternConverter">
      <summary>
            Converter to include event NDC
            </summary>
      <remarks>
        <para>
            Outputs the value of the event property named <c>NDC</c>.
            </para>
        <para>
            The <see cref="T:log4net.Layout.Pattern.PropertyPatternConverter" /> should be used instead.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.NdcPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the event NDC to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            As the thread context stacks are now stored in named event properties
            this converter simply looks up the value of the <c>NDC</c> property.
            </para>
        <para>
            The <see cref="T:log4net.Layout.Pattern.PropertyPatternConverter" /> should be used instead.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.PropertyPatternConverter">
      <summary>
            Property pattern converter
            </summary>
      <remarks>
        <para>
            Writes out the value of a named property. The property name
            should be set in the <see cref="P:log4net.Util.PatternConverter.Option" />
            property.
            </para>
        <para>
            If the <see cref="P:log4net.Util.PatternConverter.Option" /> is set to <c>null</c>
            then all the properties are written as key value pairs.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.PropertyPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the property value to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes out the value of a named property. The property name
            should be set in the <see cref="P:log4net.Util.PatternConverter.Option" />
            property.
            </para>
        <para>
            If the <see cref="P:log4net.Util.PatternConverter.Option" /> is set to <c>null</c>
            then all the properties are written as key value pairs.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.RelativeTimePatternConverter">
      <summary>
            Converter to output the relative time of the event
            </summary>
      <remarks>
        <para>
            Converter to output the time of the event relative to the start of the program.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.RelativeTimePatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the relative time to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes out the relative time of the event in milliseconds.
            That is the number of milliseconds between the event <see cref="P:log4net.Core.LoggingEvent.TimeStamp" />
            and the <see cref="P:log4net.Core.LoggingEvent.StartTime" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Pattern.RelativeTimePatternConverter.TimeDifferenceInMillis(System.DateTime,System.DateTime)">
      <summary>
            Helper method to get the time difference between two DateTime objects
            </summary>
      <param name="start">start time (in the current local time zone)</param>
      <param name="end">end time (in the current local time zone)</param>
      <returns>the time difference in milliseconds</returns>
    </member>
    <member name="T:log4net.Layout.Pattern.ThreadPatternConverter">
      <summary>
            Converter to include event thread name
            </summary>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LoggingEvent.ThreadName" /> to the output.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.ThreadPatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the ThreadName to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Writes the <see cref="P:log4net.Core.LoggingEvent.ThreadName" /> to the <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.TypeNamePatternConverter">
      <summary>
            Pattern converter for the class name
            </summary>
      <remarks>
        <para>
            Outputs the <see cref="P:log4net.Core.LocationInfo.ClassName" /> of the event.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.TypeNamePatternConverter.GetFullyQualifiedName(log4net.Core.LoggingEvent)">
      <summary>
            Gets the fully qualified name of the class
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <returns>The fully qualified type name for the caller location</returns>
      <remarks>
        <para>
            Returns the <see cref="P:log4net.Core.LocationInfo.ClassName" /> of the <paramref name="loggingEvent" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Pattern.UserNamePatternConverter">
      <summary>
            Converter to include event user name
            </summary>
      <author>Douglas de la Torre</author>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.UserNamePatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Convert the pattern to the rendered message
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
    </member>
    <member name="T:log4net.Layout.Pattern.UtcDatePatternConverter">
      <summary>
            Write the TimeStamp to the output
            </summary>
      <remarks>
        <para>
            Date pattern converter, uses a <see cref="T:log4net.DateFormatter.IDateFormatter" /> to format 
            the date of a <see cref="T:log4net.Core.LoggingEvent" />.
            </para>
        <para>
            Uses a <see cref="T:log4net.DateFormatter.IDateFormatter" /> to format the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> 
            in Universal time.
            </para>
        <para>
            See the <see cref="T:log4net.Layout.Pattern.DatePatternConverter" /> for details on the date pattern syntax.
            </para>
      </remarks>
      <seealso cref="T:log4net.Layout.Pattern.DatePatternConverter" />
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.Pattern.UtcDatePatternConverter.Convert(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Write the TimeStamp to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Pass the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> to the <see cref="T:log4net.DateFormatter.IDateFormatter" />
            for it to render it to the writer.
            </para>
        <para>
            The <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> passed is in the local time zone, this is converted
            to Universal time before it is rendered.
            </para>
      </remarks>
      <seealso cref="T:log4net.Layout.Pattern.DatePatternConverter" />
    </member>
    <member name="T:log4net.Layout.ILayout">
      <summary>
            Interface implemented by layout objects
            </summary>
      <remarks>
        <para>
            An <see cref="T:log4net.Layout.ILayout" /> object is used to format a <see cref="T:log4net.Core.LoggingEvent" />
            as text. The <see cref="M:log4net.Layout.ILayout.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)" /> method is called by an
            appender to transform the <see cref="T:log4net.Core.LoggingEvent" /> into a string.
            </para>
        <para>
            The layout can also supply <see cref="P:log4net.Layout.ILayout.Header" /> and <see cref="P:log4net.Layout.ILayout.Footer" />
            text that is appender before any events and after all the events respectively.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.ILayout.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Implement this method to create your own layout format.
            </summary>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <param name="loggingEvent">The event to format</param>
      <remarks>
        <para>
            This method is called by an appender to format
            the <paramref name="loggingEvent" /> as text and output to a writer.
            </para>
        <para>
            If the caller does not have a <see cref="T:System.IO.TextWriter" /> and prefers the
            event to be formatted as a <see cref="T:System.String" /> then the following
            code can be used to format the event into a <see cref="T:System.IO.StringWriter" />.
            </para>
        <code lang="C#">
            StringWriter writer = new StringWriter();
            Layout.Format(writer, loggingEvent);
            string formattedEvent = writer.ToString();
            </code>
      </remarks>
    </member>
    <member name="P:log4net.Layout.ILayout.ContentType">
      <summary>
            The content type output by this layout. 
            </summary>
      <value>The content type</value>
      <remarks>
        <para>
            The content type output by this layout.
            </para>
        <para>
            This is a MIME type e.g. <c>"text/plain"</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.ILayout.Header">
      <summary>
            The header for the layout format.
            </summary>
      <value>the layout header</value>
      <remarks>
        <para>
            The Header text will be appended before any logging events
            are formatted and appended.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.ILayout.Footer">
      <summary>
            The footer for the layout format.
            </summary>
      <value>the layout footer</value>
      <remarks>
        <para>
            The Footer text will be appended after all the logging events
            have been formatted and appended.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.ILayout.IgnoresException">
      <summary>
            Flag indicating if this layout handle exceptions
            </summary>
      <value>
        <c>false</c> if this layout handles exceptions</value>
      <remarks>
        <para>
            If this layout handles the exception object contained within
            <see cref="T:log4net.Core.LoggingEvent" />, then the layout should return
            <c>false</c>. Otherwise, if the layout ignores the exception
            object, then the layout should return <c>true</c>.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.LayoutSkeleton">
      <summary>
            Extend this abstract class to create your own log layout format.
            </summary>
      <remarks>
        <para>
            This is the base implementation of the <see cref="T:log4net.Layout.ILayout" />
            interface. Most layout objects should extend this class.
            </para>
      </remarks>
      <remarks>
        <note type="inheritinfo">
          <para>
            Subclasses must implement the <see cref="M:log4net.Layout.LayoutSkeleton.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)" />
            method.
            </para>
          <para>
            Subclasses should set the <see cref="P:log4net.Layout.LayoutSkeleton.IgnoresException" /> in their default
            constructor.
            </para>
        </note>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Layout.LayoutSkeleton.m_header">
      <summary>
            The header text
            </summary>
      <remarks>
        <para>
            See <see cref="P:log4net.Layout.LayoutSkeleton.Header" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Layout.LayoutSkeleton.m_footer">
      <summary>
            The footer text
            </summary>
      <remarks>
        <para>
            See <see cref="P:log4net.Layout.LayoutSkeleton.Footer" /> for more information.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Layout.LayoutSkeleton.m_ignoresException">
      <summary>
            Flag indicating if this layout handles exceptions
            </summary>
      <remarks>
        <para>
          <c>false</c> if this layout handles exceptions
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.LayoutSkeleton.#ctor">
      <summary>
            Empty default constructor
            </summary>
      <remarks>
        <para>
            Empty default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.LayoutSkeleton.ActivateOptions">
      <summary>
            Activate component options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.LayoutSkeleton.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.LayoutSkeleton.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.LayoutSkeleton.ActivateOptions" /> must be called again.
            </para>
        <para>
            This method must be implemented by the subclass.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.LayoutSkeleton.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Implement this method to create your own layout format.
            </summary>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <param name="loggingEvent">The event to format</param>
      <remarks>
        <para>
            This method is called by an appender to format
            the <paramref name="loggingEvent" /> as text.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.LayoutSkeleton.ContentType">
      <summary>
            The content type output by this layout. 
            </summary>
      <value>The content type is <c>"text/plain"</c></value>
      <remarks>
        <para>
            The content type output by this layout.
            </para>
        <para>
            This base class uses the value <c>"text/plain"</c>.
            To change this value a subclass must override this
            property.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.LayoutSkeleton.Header">
      <summary>
            The header for the layout format.
            </summary>
      <value>the layout header</value>
      <remarks>
        <para>
            The Header text will be appended before any logging events
            are formatted and appended.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.LayoutSkeleton.Footer">
      <summary>
            The footer for the layout format.
            </summary>
      <value>the layout footer</value>
      <remarks>
        <para>
            The Footer text will be appended after all the logging events
            have been formatted and appended.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.LayoutSkeleton.IgnoresException">
      <summary>
            Flag indicating if this layout handles exceptions
            </summary>
      <value>
        <c>false</c> if this layout handles exceptions</value>
      <remarks>
        <para>
            If this layout handles the exception object contained within
            <see cref="T:log4net.Core.LoggingEvent" />, then the layout should return
            <c>false</c>. Otherwise, if the layout ignores the exception
            object, then the layout should return <c>true</c>.
            </para>
        <para>
            Set this value to override a this default setting. The default
            value is <c>true</c>, this layout does not handle the exception.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.ExceptionLayout">
      <summary>
            A Layout that renders only the Exception text from the logging event
            </summary>
      <remarks>
        <para>
            A Layout that renders only the Exception text from the logging event.
            </para>
        <para>
            This Layout should only be used with appenders that utilize multiple
            layouts (e.g. <see cref="T:log4net.Appender.AdoNetAppender" />).
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.ExceptionLayout.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Constructs a ExceptionLayout
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.ExceptionLayout.ActivateOptions">
      <summary>
            Activate component options
            </summary>
      <remarks>
        <para>
            Part of the <see cref="T:log4net.Core.IOptionHandler" /> component activation
            framework.
            </para>
        <para>
            This method does nothing as options become effective immediately.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.ExceptionLayout.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Gets the exception text from the logging event
            </summary>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <param name="loggingEvent">the event being logged</param>
      <remarks>
        <para>
            Write the exception string to the <see cref="T:System.IO.TextWriter" />.
            The exception string is retrieved from <see cref="M:log4net.Core.LoggingEvent.GetExceptionString" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.IRawLayout">
      <summary>
            Interface for raw layout objects
            </summary>
      <remarks>
        <para>
            Interface used to format a <see cref="T:log4net.Core.LoggingEvent" />
            to an object.
            </para>
        <para>
            This interface should not be confused with the
            <see cref="T:log4net.Layout.ILayout" /> interface. This interface is used in
            only certain specialized situations where a raw object is
            required rather than a formatted string. The <see cref="T:log4net.Layout.ILayout" />
            is not generally useful than this interface.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.IRawLayout.Format(log4net.Core.LoggingEvent)">
      <summary>
            Implement this method to create your own layout format.
            </summary>
      <param name="loggingEvent">The event to format</param>
      <returns>returns the formatted event</returns>
      <remarks>
        <para>
            Implement this method to create your own layout format.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.Layout2RawLayoutAdapter">
      <summary>
            Adapts any <see cref="T:log4net.Layout.ILayout" /> to a <see cref="T:log4net.Layout.IRawLayout" /></summary>
      <remarks>
        <para>
            Where an <see cref="T:log4net.Layout.IRawLayout" /> is required this adapter
            allows a <see cref="T:log4net.Layout.ILayout" /> to be specified.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Layout.Layout2RawLayoutAdapter.m_layout">
      <summary>
            The layout to adapt
            </summary>
    </member>
    <member name="M:log4net.Layout.Layout2RawLayoutAdapter.#ctor(log4net.Layout.ILayout)">
      <summary>
            Construct a new adapter
            </summary>
      <param name="layout">the layout to adapt</param>
      <remarks>
        <para>
            Create the adapter for the specified <paramref name="layout" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.Layout2RawLayoutAdapter.Format(log4net.Core.LoggingEvent)">
      <summary>
            Format the logging event as an object.
            </summary>
      <param name="loggingEvent">The event to format</param>
      <returns>returns the formatted event</returns>
      <remarks>
        <para>
            Format the logging event as an object.
            </para>
        <para>
            Uses the <see cref="T:log4net.Layout.ILayout" /> object supplied to 
            the constructor to perform the formatting.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.PatternLayout">
      <summary>
            A flexible layout configurable with pattern string.
            </summary>
      <remarks>
        <para>
            The goal of this class is to <see cref="M:log4net.Layout.PatternLayout.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)" /> a 
            <see cref="T:log4net.Core.LoggingEvent" /> as a string. The results
            depend on the <i>conversion pattern</i>.
            </para>
        <para>
            The conversion pattern is closely related to the conversion
            pattern of the printf function in C. A conversion pattern is
            composed of literal text and format control expressions called
            <i>conversion specifiers</i>.
            </para>
        <para>
          <i>You are free to insert any literal text within the conversion
            pattern.</i>
        </para>
        <para>
            Each conversion specifier starts with a percent sign (%) and is
            followed by optional <i>format modifiers</i> and a <i>conversion
            pattern name</i>. The conversion pattern name specifies the type of
            data, e.g. logger, level, date, thread name. The format
            modifiers control such things as field width, padding, left and
            right justification. The following is a simple example.
            </para>
        <para>
            Let the conversion pattern be <b>"%-5level [%thread]: %message%newline"</b> and assume
            that the log4net environment was set to use a PatternLayout. Then the
            statements
            </para>
        <code lang="C#">
            ILog log = LogManager.GetLogger(typeof(TestApp));
            log.Debug("Message 1");
            log.Warn("Message 2");   
            </code>
        <para>would yield the output</para>
        <code>
            DEBUG [main]: Message 1
            WARN  [main]: Message 2  
            </code>
        <para>
            Note that there is no explicit separator between text and
            conversion specifiers. The pattern parser knows when it has reached
            the end of a conversion specifier when it reads a conversion
            character. In the example above the conversion specifier
            <b>%-5level</b> means the level of the logging event should be left
            justified to a width of five characters.
            </para>
        <para>
            The recognized conversion pattern names are:
            </para>
        <list type="table">
          <listheader>
            <term>Conversion Pattern Name</term>
            <description>Effect</description>
          </listheader>
          <item>
            <term>a</term>
            <description>Equivalent to <b>appdomain</b></description>
          </item>
          <item>
            <term>appdomain</term>
            <description>
            			Used to output the friendly name of the AppDomain where the 
            			logging event was generated. 
                    </description>
          </item>
          <item>
            <term>c</term>
            <description>Equivalent to <b>logger</b></description>
          </item>
          <item>
            <term>C</term>
            <description>Equivalent to <b>type</b></description>
          </item>
          <item>
            <term>class</term>
            <description>Equivalent to <b>type</b></description>
          </item>
          <item>
            <term>d</term>
            <description>Equivalent to <b>date</b></description>
          </item>
          <item>
            <term>date</term>
            <description>
              <para>
            			Used to output the date of the logging event in the local time zone. 
            			To output the date in universal time use the <c>%utcdate</c> pattern.
            			The date conversion 
            			specifier may be followed by a <i>date format specifier</i> enclosed 
            			between braces. For example, <b>%date{HH:mm:ss,fff}</b> or
            			<b>%date{dd MMM yyyy HH:mm:ss,fff}</b>.  If no date format specifier is 
            			given then ISO8601 format is
            			assumed (<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />).
            			</para>
              <para>
            			The date format specifier admits the same syntax as the
            			time pattern string of the <see cref="M:System.DateTime.ToString(System.String)" />.
            			</para>
              <para>
            			For better results it is recommended to use the log4net date
            			formatters. These can be specified using one of the strings
            			"ABSOLUTE", "DATE" and "ISO8601" for specifying 
            			<see cref="T:log4net.DateFormatter.AbsoluteTimeDateFormatter" />, 
            			<see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> and respectively 
            			<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />. For example, 
            			<b>%date{ISO8601}</b> or <b>%date{ABSOLUTE}</b>.
            			</para>
              <para>
            			These dedicated date formatters perform significantly
            			better than <see cref="M:System.DateTime.ToString(System.String)" />.
            			</para>
            </description>
          </item>
          <item>
            <term>exception</term>
            <description>
              <para>
            			Used to output the exception passed in with the log message.
            			</para>
              <para>
            			If an exception object is stored in the logging event
            			it will be rendered into the pattern output with a
            			trailing newline.
            			If there is no exception then nothing will be output
            			and no trailing newline will be appended.
            			It is typical to put a newline before the exception
            			and to have the exception as the last data in the pattern.
            			</para>
            </description>
          </item>
          <item>
            <term>F</term>
            <description>Equivalent to <b>file</b></description>
          </item>
          <item>
            <term>file</term>
            <description>
              <para>
            			Used to output the file name where the logging request was
            			issued.
            			</para>
              <para>
                <b>WARNING</b> Generating caller location information is
            			extremely slow. Its use should be avoided unless execution speed
            			is not an issue.
            			</para>
              <para>
            			See the note below on the availability of caller location information.
            			</para>
            </description>
          </item>
          <item>
            <term>identity</term>
            <description>
              <para>
            			Used to output the user name for the currently active user
            			(Principal.Identity.Name).
            			</para>
              <para>
                <b>WARNING</b> Generating caller information is
            			extremely slow. Its use should be avoided unless execution speed
            			is not an issue.
            			</para>
            </description>
          </item>
          <item>
            <term>l</term>
            <description>Equivalent to <b>location</b></description>
          </item>
          <item>
            <term>L</term>
            <description>Equivalent to <b>line</b></description>
          </item>
          <item>
            <term>location</term>
            <description>
              <para>
            			Used to output location information of the caller which generated
            			the logging event.
            			</para>
              <para>
            			The location information depends on the CLI implementation but
            			usually consists of the fully qualified name of the calling
            			method followed by the callers source the file name and line
            			number between parentheses.
            			</para>
              <para>
            			The location information can be very useful. However, its
            			generation is <b>extremely</b> slow. Its use should be avoided
            			unless execution speed is not an issue.
            			</para>
              <para>
            			See the note below on the availability of caller location information.
            			</para>
            </description>
          </item>
          <item>
            <term>level</term>
            <description>
              <para>
            			Used to output the level of the logging event.
            			</para>
            </description>
          </item>
          <item>
            <term>line</term>
            <description>
              <para>
            			Used to output the line number from where the logging request
            			was issued.
            			</para>
              <para>
                <b>WARNING</b> Generating caller location information is
            			extremely slow. Its use should be avoided unless execution speed
            			is not an issue.
            			</para>
              <para>
            			See the note below on the availability of caller location information.
            			</para>
            </description>
          </item>
          <item>
            <term>logger</term>
            <description>
              <para>
            			Used to output the logger of the logging event. The
            			logger conversion specifier can be optionally followed by
            			<i>precision specifier</i>, that is a decimal constant in
            			brackets.
                        </para>
              <para>
            			If a precision specifier is given, then only the corresponding
            			number of right most components of the logger name will be
            			printed. By default the logger name is printed in full.
            			</para>
              <para>
            			For example, for the logger name "a.b.c" the pattern
            			<b>%logger{2}</b> will output "b.c".
            			</para>
            </description>
          </item>
          <item>
            <term>m</term>
            <description>Equivalent to <b>message</b></description>
          </item>
          <item>
            <term>M</term>
            <description>Equivalent to <b>method</b></description>
          </item>
          <item>
            <term>message</term>
            <description>
              <para>
            			Used to output the application supplied message associated with 
            			the logging event.
            			</para>
            </description>
          </item>
          <item>
            <term>mdc</term>
            <description>
              <para>
            			The MDC (old name for the ThreadContext.Properties) is now part of the
            			combined event properties. This pattern is supported for compatibility
            			but is equivalent to <b>property</b>.
            			</para>
            </description>
          </item>
          <item>
            <term>method</term>
            <description>
              <para>
            			Used to output the method name where the logging request was
            			issued.
            			</para>
              <para>
                <b>WARNING</b> Generating caller location information is
            			extremely slow. Its use should be avoided unless execution speed
            			is not an issue.
            			</para>
              <para>
            			See the note below on the availability of caller location information.
            			</para>
            </description>
          </item>
          <item>
            <term>n</term>
            <description>Equivalent to <b>newline</b></description>
          </item>
          <item>
            <term>newline</term>
            <description>
              <para>
            			Outputs the platform dependent line separator character or
            			characters.
            			</para>
              <para>
            			This conversion pattern offers the same performance as using 
            			non-portable line separator strings such as	"\n", or "\r\n". 
            			Thus, it is the preferred way of specifying a line separator.
            			</para>
            </description>
          </item>
          <item>
            <term>ndc</term>
            <description>
              <para>
            			Used to output the NDC (nested diagnostic context) associated
            			with the thread that generated the logging event.
            			</para>
            </description>
          </item>
          <item>
            <term>p</term>
            <description>Equivalent to <b>level</b></description>
          </item>
          <item>
            <term>P</term>
            <description>Equivalent to <b>property</b></description>
          </item>
          <item>
            <term>properties</term>
            <description>Equivalent to <b>property</b></description>
          </item>
          <item>
            <term>property</term>
            <description>
              <para>
            			Used to output the an event specific property. The key to 
            			lookup must be specified within braces and directly following the
            			pattern specifier, e.g. <b>%property{user}</b> would include the value
            			from the property that is keyed by the string 'user'. Each property value
            			that is to be included in the log must be specified separately.
            			Properties are added to events by loggers or appenders. By default 
            			the <c>log4net:HostName</c> property is set to the name of machine on 
            			which the event was originally logged.
            			</para>
              <para>
            			If no key is specified, e.g. <b>%property</b> then all the keys and their
            			values are printed in a comma separated list.
            			</para>
              <para>
            			The properties of an event are combined from a number of different
            			contexts. These are listed below in the order in which they are searched.
            			</para>
              <list type="definition">
                <item>
                  <term>the event properties</term>
                  <description>
            					The event has <see cref="P:log4net.Core.LoggingEvent.Properties" /> that can be set. These 
            					properties are specific to this event only.
            					</description>
                </item>
                <item>
                  <term>the thread properties</term>
                  <description>
            					The <see cref="P:log4net.ThreadContext.Properties" /> that are set on the current
            					thread. These properties are shared by all events logged on this thread.
            					</description>
                </item>
                <item>
                  <term>the global properties</term>
                  <description>
            					The <see cref="P:log4net.GlobalContext.Properties" /> that are set globally. These 
            					properties are shared by all the threads in the AppDomain.
            					</description>
                </item>
              </list>
            </description>
          </item>
          <item>
            <term>r</term>
            <description>Equivalent to <b>timestamp</b></description>
          </item>
          <item>
            <term>t</term>
            <description>Equivalent to <b>thread</b></description>
          </item>
          <item>
            <term>timestamp</term>
            <description>
              <para>
            			Used to output the number of milliseconds elapsed since the start
            			of the application until the creation of the logging event.
            			</para>
            </description>
          </item>
          <item>
            <term>thread</term>
            <description>
              <para>
            			Used to output the name of the thread that generated the
            			logging event. Uses the thread number if no name is available.
            			</para>
            </description>
          </item>
          <item>
            <term>type</term>
            <description>
              <para>
            			Used to output the fully qualified type name of the caller
            			issuing the logging request. This conversion specifier
            			can be optionally followed by <i>precision specifier</i>, that
            			is a decimal constant in brackets.
            			</para>
              <para>
            			If a precision specifier is given, then only the corresponding
            			number of right most components of the class name will be
            			printed. By default the class name is output in fully qualified form.
            			</para>
              <para>
            			For example, for the class name "log4net.Layout.PatternLayout", the
            			pattern <b>%type{1}</b> will output "PatternLayout".
            			</para>
              <para>
                <b>WARNING</b> Generating the caller class information is
            			slow. Thus, its use should be avoided unless execution speed is
            			not an issue.
            			</para>
              <para>
            			See the note below on the availability of caller location information.
            			</para>
            </description>
          </item>
          <item>
            <term>u</term>
            <description>Equivalent to <b>identity</b></description>
          </item>
          <item>
            <term>username</term>
            <description>
              <para>
            			Used to output the WindowsIdentity for the currently
            			active user.
            			</para>
              <para>
                <b>WARNING</b> Generating caller WindowsIdentity information is
            			extremely slow. Its use should be avoided unless execution speed
            			is not an issue.
            			</para>
            </description>
          </item>
          <item>
            <term>utcdate</term>
            <description>
              <para>
            			Used to output the date of the logging event in universal time. 
            			The date conversion 
            			specifier may be followed by a <i>date format specifier</i> enclosed 
            			between braces. For example, <b>%utcdate{HH:mm:ss,fff}</b> or
            			<b>%utcdate{dd MMM yyyy HH:mm:ss,fff}</b>.  If no date format specifier is 
            			given then ISO8601 format is
            			assumed (<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />).
            			</para>
              <para>
            			The date format specifier admits the same syntax as the
            			time pattern string of the <see cref="M:System.DateTime.ToString(System.String)" />.
            			</para>
              <para>
            			For better results it is recommended to use the log4net date
            			formatters. These can be specified using one of the strings
            			"ABSOLUTE", "DATE" and "ISO8601" for specifying 
            			<see cref="T:log4net.DateFormatter.AbsoluteTimeDateFormatter" />, 
            			<see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> and respectively 
            			<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />. For example, 
            			<b>%utcdate{ISO8601}</b> or <b>%utcdate{ABSOLUTE}</b>.
            			</para>
              <para>
            			These dedicated date formatters perform significantly
            			better than <see cref="M:System.DateTime.ToString(System.String)" />.
            			</para>
            </description>
          </item>
          <item>
            <term>w</term>
            <description>Equivalent to <b>username</b></description>
          </item>
          <item>
            <term>x</term>
            <description>Equivalent to <b>ndc</b></description>
          </item>
          <item>
            <term>X</term>
            <description>Equivalent to <b>mdc</b></description>
          </item>
          <item>
            <term>%</term>
            <description>
              <para>
            			The sequence %% outputs a single percent sign.
            			</para>
            </description>
          </item>
        </list>
        <para>
            The single letter patterns are deprecated in favor of the 
            longer more descriptive pattern names.
            </para>
        <para>
            By default the relevant information is output as is. However,
            with the aid of format modifiers it is possible to change the
            minimum field width, the maximum field width and justification.
            </para>
        <para>
            The optional format modifier is placed between the percent sign
            and the conversion pattern name.
            </para>
        <para>
            The first optional format modifier is the <i>left justification
            flag</i> which is just the minus (-) character. Then comes the
            optional <i>minimum field width</i> modifier. This is a decimal
            constant that represents the minimum number of characters to
            output. If the data item requires fewer characters, it is padded on
            either the left or the right until the minimum width is
            reached. The default is to pad on the left (right justify) but you
            can specify right padding with the left justification flag. The
            padding character is space. If the data item is larger than the
            minimum field width, the field is expanded to accommodate the
            data. The value is never truncated.
            </para>
        <para>
            This behavior can be changed using the <i>maximum field
            width</i> modifier which is designated by a period followed by a
            decimal constant. If the data item is longer than the maximum
            field, then the extra characters are removed from the
            <i>beginning</i> of the data item and not from the end. For
            example, it the maximum field width is eight and the data item is
            ten characters long, then the first two characters of the data item
            are dropped. This behavior deviates from the printf function in C
            where truncation is done from the end.
            </para>
        <para>
            Below are various format modifier examples for the logger
            conversion specifier.
            </para>
        <div class="tablediv">
          <table class="dtTABLE" cellspacing="0">
            <tr>
              <th>Format modifier</th>
              <th>left justify</th>
              <th>minimum width</th>
              <th>maximum width</th>
              <th>comment</th>
            </tr>
            <tr>
              <td align="center">%20logger</td>
              <td align="center">false</td>
              <td align="center">20</td>
              <td align="center">none</td>
              <td>
                <para>
            				Left pad with spaces if the logger name is less than 20
            				characters long.
            				</para>
              </td>
            </tr>
            <tr>
              <td align="center">%-20logger</td>
              <td align="center">true</td>
              <td align="center">20</td>
              <td align="center">none</td>
              <td>
                <para>
            				Right pad with spaces if the logger 
            				name is less than 20 characters long.
            				</para>
              </td>
            </tr>
            <tr>
              <td align="center">%.30logger</td>
              <td align="center">NA</td>
              <td align="center">none</td>
              <td align="center">30</td>
              <td>
                <para>
            				Truncate from the beginning if the logger 
            				name is longer than 30 characters.
            				</para>
              </td>
            </tr>
            <tr>
              <td align="center">
                <nobr>%20.30logger</nobr>
              </td>
              <td align="center">false</td>
              <td align="center">20</td>
              <td align="center">30</td>
              <td>
                <para>
            				Left pad with spaces if the logger name is shorter than 20
            				characters. However, if logger name is longer than 30 characters,
            				then truncate from the beginning.
            				</para>
              </td>
            </tr>
            <tr>
              <td align="center">%-20.30logger</td>
              <td align="center">true</td>
              <td align="center">20</td>
              <td align="center">30</td>
              <td>
                <para>
            				Right pad with spaces if the logger name is shorter than 20
            				characters. However, if logger name is longer than 30 characters,
            				then truncate from the beginning.
            				</para>
              </td>
            </tr>
          </table>
        </div>
        <para>
          <b>Note about caller location information.</b>
          <br />
            The following patterns <c>%type %file %line %method %location %class %C %F %L %l %M</c> 
            all generate caller location information.
            Location information uses the <c>System.Diagnostics.StackTrace</c> class to generate
            a call stack. The caller's information is then extracted from this stack.
            </para>
        <note type="caution">
          <para>
            The <c>System.Diagnostics.StackTrace</c> class is not supported on the 
            .NET Compact Framework 1.0 therefore caller location information is not
            available on that framework.
            </para>
        </note>
        <note type="caution">
          <para>
            The <c>System.Diagnostics.StackTrace</c> class has this to say about Release builds:
            </para>
          <para>
            "StackTrace information will be most informative with Debug build configurations. 
            By default, Debug builds include debug symbols, while Release builds do not. The 
            debug symbols contain most of the file, method name, line number, and column 
            information used in constructing StackFrame and StackTrace objects. StackTrace 
            might not report as many method calls as expected, due to code transformations 
            that occur during optimization."
            </para>
          <para>
            This means that in a Release build the caller information may be incomplete or may 
            not exist at all! Therefore caller location information cannot be relied upon in a Release build.
            </para>
        </note>
        <para>
            Additional pattern converters may be registered with a specific <see cref="T:log4net.Layout.PatternLayout" />
            instance using the <see cref="M:log4net.Layout.PatternLayout.AddConverter(System.String,System.Type)" /> method.
            </para>
      </remarks>
      <example>
            This is a more detailed pattern.
            <code><b>%timestamp [%thread] %level %logger %ndc - %message%newline</b></code></example>
      <example>
            A similar pattern except that the relative time is
            right padded if less than 6 digits, thread name is right padded if
            less than 15 characters and truncated if longer and the logger
            name is left padded if shorter than 30 characters and truncated if
            longer.
            <code><b>%-6timestamp [%15.15thread] %-5level %30.30logger %ndc - %message%newline</b></code></example>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Douglas de la Torre</author>
      <author>Daniel Cazzulino</author>
    </member>
    <member name="T:log4net.Layout.PatternLayout.ConverterInfo">
      <summary>
            Wrapper class used to map converter names to converter types
            </summary>
      <remarks>
        <para>
            Pattern converter info class used during configuration to
            pass to the <see cref="M:log4net.Layout.PatternLayout.AddConverter(log4net.Layout.PatternLayout.ConverterInfo)" />
            method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.ConverterInfo.#ctor">
      <summary>
            default constructor
            </summary>
    </member>
    <member name="P:log4net.Layout.PatternLayout.ConverterInfo.Name">
      <summary>
            Gets or sets the name of the conversion pattern
            </summary>
      <remarks>
        <para>
            The name of the pattern in the format string
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.PatternLayout.ConverterInfo.Type">
      <summary>
            Gets or sets the type of the converter
            </summary>
      <remarks>
        <para>
            The value specified must extend the 
            <see cref="T:log4net.Util.PatternConverter" /> type.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Layout.PatternLayout.DefaultConversionPattern">
      <summary>
            Default pattern string for log output. 
            </summary>
      <remarks>
        <para>
            Default pattern string for log output. 
            Currently set to the string <b>"%message%newline"</b> 
            which just prints the application supplied message. 
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Layout.PatternLayout.DetailConversionPattern">
      <summary>
            A detailed conversion pattern
            </summary>
      <remarks>
        <para>
            A conversion pattern which includes Time, Thread, Logger, and Nested Context.
            Current value is <b>%timestamp [%thread] %level %logger %ndc - %message%newline</b>.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Layout.PatternLayout.s_globalRulesRegistry">
      <summary>
            Internal map of converter identifiers to converter types.
            </summary>
      <remarks>
        <para>
            This static map is overridden by the m_converterRegistry instance map
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Layout.PatternLayout.m_pattern">
      <summary>
            the pattern
            </summary>
    </member>
    <member name="F:log4net.Layout.PatternLayout.m_head">
      <summary>
            the head of the pattern converter chain
            </summary>
    </member>
    <member name="F:log4net.Layout.PatternLayout.m_instanceRulesRegistry">
      <summary>
            patterns defined on this PatternLayout only
            </summary>
    </member>
    <member name="M:log4net.Layout.PatternLayout.#ctor">
      <summary>
            Constructs a PatternLayout using the DefaultConversionPattern
            </summary>
      <remarks>
        <para>
            The default pattern just produces the application supplied message.
            </para>
        <para>
            Note to Inheritors: This constructor calls the virtual method
            <see cref="M:log4net.Layout.PatternLayout.CreatePatternParser(System.String)" />. If you override this method be
            aware that it will be called before your is called constructor.
            </para>
        <para>
            As per the <see cref="T:log4net.Core.IOptionHandler" /> contract the <see cref="M:log4net.Layout.PatternLayout.ActivateOptions" />
            method must be called after the properties on this object have been
            configured.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.#ctor(System.String)">
      <summary>
            Constructs a PatternLayout using the supplied conversion pattern
            </summary>
      <param name="pattern">the pattern to use</param>
      <remarks>
        <para>
            Note to Inheritors: This constructor calls the virtual method
            <see cref="M:log4net.Layout.PatternLayout.CreatePatternParser(System.String)" />. If you override this method be
            aware that it will be called before your is called constructor.
            </para>
        <para>
            When using this constructor the <see cref="M:log4net.Layout.PatternLayout.ActivateOptions" /> method 
            need not be called. This may not be the case when using a subclass.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.CreatePatternParser(System.String)">
      <summary>
            Create the pattern parser instance
            </summary>
      <param name="pattern">the pattern to parse</param>
      <returns>The <see cref="T:log4net.Util.PatternParser" /> that will format the event</returns>
      <remarks>
        <para>
            Creates the <see cref="T:log4net.Util.PatternParser" /> used to parse the conversion string. Sets the
            global and instance rules on the <see cref="T:log4net.Util.PatternParser" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.ActivateOptions">
      <summary>
            Initialize layout options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.PatternLayout.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.PatternLayout.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.PatternLayout.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Produces a formatted string as specified by the conversion pattern.
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <remarks>
        <para>
            Parse the <see cref="T:log4net.Core.LoggingEvent" /> using the patter format
            specified in the <see cref="P:log4net.Layout.PatternLayout.ConversionPattern" /> property.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.AddConverter(log4net.Layout.PatternLayout.ConverterInfo)">
      <summary>
            Add a converter to this PatternLayout
            </summary>
      <param name="converterInfo">the converter info</param>
      <remarks>
        <para>
            This version of the method is used by the configurator.
            Programmatic users should use the alternative <see cref="M:log4net.Layout.PatternLayout.AddConverter(System.String,System.Type)" /> method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.PatternLayout.AddConverter(System.String,System.Type)">
      <summary>
            Add a converter to this PatternLayout
            </summary>
      <param name="name">the name of the conversion pattern for this converter</param>
      <param name="type">the type of the converter</param>
      <remarks>
        <para>
            Add a named pattern converter to this instance. This
            converter will be used in the formatting of the event.
            This method must be called before <see cref="M:log4net.Layout.PatternLayout.ActivateOptions" />.
            </para>
        <para>
            The <paramref name="type" /> specified must extend the 
            <see cref="T:log4net.Util.PatternConverter" /> type.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.PatternLayout.ConversionPattern">
      <summary>
            The pattern formatting string
            </summary>
      <remarks>
        <para>
            The <b>ConversionPattern</b> option. This is the string which
            controls formatting and consists of a mix of literal content and
            conversion specifiers.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.TypeConverters.IConvertFrom">
      <summary>
            Interface supported by type converters
            </summary>
      <remarks>
        <para>
            This interface supports conversion from arbitrary types
            to a single target type. See <see cref="T:log4net.Util.TypeConverters.TypeConverterAttribute" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.IConvertFrom.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Test if the <paramref name="sourceType" /> can be converted to the
            type supported by this converter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.IConvertFrom.ConvertFrom(System.Object)">
      <summary>
            Convert the source object to the type supported by this object
            </summary>
      <param name="source">the object to convert</param>
      <returns>the converted object</returns>
      <remarks>
        <para>
            Converts the <paramref name="source" /> to the type supported
            by this converter.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.RawLayoutConverter">
      <summary>
            Type converter for the <see cref="T:log4net.Layout.IRawLayout" /> interface
            </summary>
      <remarks>
        <para>
            Used to convert objects to the <see cref="T:log4net.Layout.IRawLayout" /> interface.
            Supports converting from the <see cref="T:log4net.Layout.ILayout" /> interface to
            the <see cref="T:log4net.Layout.IRawLayout" /> interface using the <see cref="T:log4net.Layout.Layout2RawLayoutAdapter" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.RawLayoutConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the sourceType be converted to an <see cref="T:log4net.Layout.IRawLayout" /></summary>
      <param name="sourceType">the source to be to be converted</param>
      <returns>
        <c>true</c> if the source type can be converted to <see cref="T:log4net.Layout.IRawLayout" /></returns>
      <remarks>
        <para>
            Test if the <paramref name="sourceType" /> can be converted to a
            <see cref="T:log4net.Layout.IRawLayout" />. Only <see cref="T:log4net.Layout.ILayout" /> is supported
            as the <paramref name="sourceType" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.RawLayoutConverter.ConvertFrom(System.Object)">
      <summary>
            Convert the value to a <see cref="T:log4net.Layout.IRawLayout" /> object
            </summary>
      <param name="source">the value to convert</param>
      <returns>the <see cref="T:log4net.Layout.IRawLayout" /> object</returns>
      <remarks>
        <para>
            Convert the <paramref name="source" /> object to a 
            <see cref="T:log4net.Layout.IRawLayout" /> object. If the <paramref name="source" /> object
            is a <see cref="T:log4net.Layout.ILayout" /> then the <see cref="T:log4net.Layout.Layout2RawLayoutAdapter" />
            is used to adapt between the two interfaces, otherwise an
            exception is thrown.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.RawPropertyLayout">
      <summary>
            Extract the value of a property from the <see cref="T:log4net.Core.LoggingEvent" /></summary>
      <remarks>
        <para>
            Extract the value of a property from the <see cref="T:log4net.Core.LoggingEvent" /></para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Layout.RawPropertyLayout.#ctor">
      <summary>
            Constructs a RawPropertyLayout
            </summary>
    </member>
    <member name="M:log4net.Layout.RawPropertyLayout.Format(log4net.Core.LoggingEvent)">
      <summary>
            Lookup the property for <see cref="P:log4net.Layout.RawPropertyLayout.Key" /></summary>
      <param name="loggingEvent">The event to format</param>
      <returns>returns property value</returns>
      <remarks>
        <para>
            Looks up and returns the object value of the property
            named <see cref="P:log4net.Layout.RawPropertyLayout.Key" />. If there is no property defined
            with than name then <c>null</c> will be returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.RawPropertyLayout.Key">
      <summary>
            The name of the value to lookup in the LoggingEvent Properties collection.
            </summary>
      <value>
            Value to lookup in the LoggingEvent Properties collection
            </value>
      <remarks>
        <para>
            String name of the property to lookup in the <see cref="T:log4net.Core.LoggingEvent" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.RawTimeStampLayout">
      <summary>
            Extract the date from the <see cref="T:log4net.Core.LoggingEvent" /></summary>
      <remarks>
        <para>
            Extract the date from the <see cref="T:log4net.Core.LoggingEvent" /></para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.RawTimeStampLayout.#ctor">
      <summary>
            Constructs a RawTimeStampLayout
            </summary>
    </member>
    <member name="M:log4net.Layout.RawTimeStampLayout.Format(log4net.Core.LoggingEvent)">
      <summary>
            Gets the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> as a <see cref="T:System.DateTime" />.
            </summary>
      <param name="loggingEvent">The event to format</param>
      <returns>returns the time stamp</returns>
      <remarks>
        <para>
            Gets the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> as a <see cref="T:System.DateTime" />.
            </para>
        <para>
            The time stamp is in local time. To format the time stamp
            in universal time use <see cref="T:log4net.Layout.RawUtcTimeStampLayout" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.RawUtcTimeStampLayout">
      <summary>
            Extract the date from the <see cref="T:log4net.Core.LoggingEvent" /></summary>
      <remarks>
        <para>
            Extract the date from the <see cref="T:log4net.Core.LoggingEvent" /></para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.RawUtcTimeStampLayout.#ctor">
      <summary>
            Constructs a RawUtcTimeStampLayout
            </summary>
    </member>
    <member name="M:log4net.Layout.RawUtcTimeStampLayout.Format(log4net.Core.LoggingEvent)">
      <summary>
            Gets the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> as a <see cref="T:System.DateTime" />.
            </summary>
      <param name="loggingEvent">The event to format</param>
      <returns>returns the time stamp</returns>
      <remarks>
        <para>
            Gets the <see cref="P:log4net.Core.LoggingEvent.TimeStamp" /> as a <see cref="T:System.DateTime" />.
            </para>
        <para>
            The time stamp is in universal time. To format the time stamp
            in local time use <see cref="T:log4net.Layout.RawTimeStampLayout" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.SimpleLayout">
      <summary>
            A very simple layout
            </summary>
      <remarks>
        <para>
            SimpleLayout consists of the level of the log statement,
            followed by " - " and then the log message itself. For example,
            <code>
            DEBUG - Hello world
            </code></para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Layout.SimpleLayout.#ctor">
      <summary>
            Constructs a SimpleLayout
            </summary>
    </member>
    <member name="M:log4net.Layout.SimpleLayout.ActivateOptions">
      <summary>
            Initialize layout options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.SimpleLayout.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.SimpleLayout.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.SimpleLayout.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.SimpleLayout.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Produces a simple formatted output.
            </summary>
      <param name="loggingEvent">the event being logged</param>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <remarks>
        <para>
            Formats the event as the level of the even,
            followed by " - " and then the log message itself. The
            output is terminated by a newline.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.XmlLayoutBase">
      <summary>
            Layout that formats the log events as XML elements.
            </summary>
      <remarks>
        <para>
            This is an abstract class that must be subclassed by an implementation 
            to conform to a specific schema.
            </para>
        <para>
            Deriving classes must implement the <see cref="M:log4net.Layout.XmlLayoutBase.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)" /> method.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Layout.XmlLayoutBase.m_locationInfo">
      <summary>
            Flag to indicate if location information should be included in
            the XML events.
            </summary>
    </member>
    <member name="F:log4net.Layout.XmlLayoutBase.m_protectCloseTextWriter">
      <summary>
            Writer adapter that ignores Close
            </summary>
    </member>
    <member name="F:log4net.Layout.XmlLayoutBase.m_invalidCharReplacement">
      <summary>
            The string to replace invalid chars with
            </summary>
    </member>
    <member name="M:log4net.Layout.XmlLayoutBase.#ctor">
      <summary>
            Protected constructor to support subclasses
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Layout.XmlLayoutBase" /> class
            with no location info.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayoutBase.#ctor(System.Boolean)">
      <summary>
            Protected constructor to support subclasses
            </summary>
      <remarks>
        <para>
            The <paramref name="locationInfo" /> parameter determines whether 
            location information will be output by the layout. If 
            <paramref name="locationInfo" /> is set to <c>true</c>, then the 
            file name and line number of the statement at the origin of the log 
            statement will be output. 
            </para>
        <para>
            If you are embedding this layout within an SMTPAppender
            then make sure to set the <b>LocationInfo</b> option of that 
            appender as well.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayoutBase.ActivateOptions">
      <summary>
            Initialize layout options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.XmlLayoutBase.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.XmlLayoutBase.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.XmlLayoutBase.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayoutBase.Format(System.IO.TextWriter,log4net.Core.LoggingEvent)">
      <summary>
            Produces a formatted string.
            </summary>
      <param name="loggingEvent">The event being logged.</param>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <remarks>
        <para>
            Format the <see cref="T:log4net.Core.LoggingEvent" /> and write it to the <see cref="T:System.IO.TextWriter" />.
            </para>
        <para>
            This method creates an <see cref="T:System.Xml.XmlTextWriter" /> that writes to the
            <paramref name="writer" />. The <see cref="T:System.Xml.XmlTextWriter" /> is passed 
            to the <see cref="M:log4net.Layout.XmlLayoutBase.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)" /> method. Subclasses should override the
            <see cref="M:log4net.Layout.XmlLayoutBase.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)" /> method rather than this method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayoutBase.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)">
      <summary>
            Does the actual writing of the XML.
            </summary>
      <param name="writer">The writer to use to output the event to.</param>
      <param name="loggingEvent">The event to write.</param>
      <remarks>
        <para>
            Subclasses should override this method to format
            the <see cref="T:log4net.Core.LoggingEvent" /> as XML.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.XmlLayoutBase.LocationInfo">
      <summary>
            Gets a value indicating whether to include location information in 
            the XML events.
            </summary>
      <value>
        <c>true</c> if location information should be included in the XML 
            events; otherwise, <c>false</c>.
            </value>
      <remarks>
        <para>
            If <see cref="P:log4net.Layout.XmlLayoutBase.LocationInfo" /> is set to <c>true</c>, then the file 
            name and line number of the statement at the origin of the log 
            statement will be output. 
            </para>
        <para>
            If you are embedding this layout within an <c>SMTPAppender</c>
            then make sure to set the <b>LocationInfo</b> option of that 
            appender as well.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.XmlLayoutBase.InvalidCharReplacement">
      <summary>
            The string to replace characters that can not be expressed in XML with.
            <remarks><para>
            Not all characters may be expressed in XML. This property contains the
            string to replace those that can not with. This defaults to a ?. Set it
            to the empty string to simply remove offending characters. For more
            details on the allowed character ranges see http://www.w3.org/TR/REC-xml/#charsets
            Character replacement will occur in  the log message, the property names 
            and the property values.
            </para></remarks></summary>
    </member>
    <member name="P:log4net.Layout.XmlLayoutBase.ContentType">
      <summary>
            Gets the content type output by this layout. 
            </summary>
      <value>
            As this is the XML layout, the value is always <c>"text/xml"</c>.
            </value>
      <remarks>
        <para>
            As this is the XML layout, the value is always <c>"text/xml"</c>.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.XmlLayout">
      <summary>
             Layout that formats the log events as XML elements.
             </summary>
      <remarks>
        <para>
             The output of the <see cref="T:log4net.Layout.XmlLayout" /> consists of a series of 
             log4net:event elements. It does not output a complete well-formed XML 
             file. The output is designed to be included as an <em>external entity</em>
             in a separate file to form a correct XML file.
             </para>
        <para>
             For example, if <c>abc</c> is the name of the file where
             the <see cref="T:log4net.Layout.XmlLayout" /> output goes, then a well-formed XML file would 
             be:
             </para>
        <code lang="XML">
             &lt;?xml version="1.0" ?&gt;
             
             &lt;!DOCTYPE log4net:events SYSTEM "log4net-events.dtd" [&lt;!ENTITY data SYSTEM "abc"&gt;]&gt;
            
             &lt;log4net:events version="1.2" xmlns:log4net="http://logging.apache.org/log4net/schemas/log4net-events-1.2&gt;
                 &amp;data;
             &lt;/log4net:events&gt;
             </code>
        <para>
             This approach enforces the independence of the <see cref="T:log4net.Layout.XmlLayout" /> 
             and the appender where it is embedded.
             </para>
        <para>
             The <c>version</c> attribute helps components to correctly
             interpret output generated by <see cref="T:log4net.Layout.XmlLayout" />. The value of 
             this attribute should be "1.2" for release 1.2 and later.
             </para>
        <para>
             Alternatively the <c>Header</c> and <c>Footer</c> properties can be
             configured to output the correct XML header, open tag and close tag.
             When setting the <c>Header</c> and <c>Footer</c> properties it is essential
             that the underlying data store not be appendable otherwise the data
             will become invalid XML.
             </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Layout.XmlLayout.m_prefix">
      <summary>
            The prefix to use for all generated element names
            </summary>
    </member>
    <member name="M:log4net.Layout.XmlLayout.#ctor">
      <summary>
            Constructs an XmlLayout
            </summary>
    </member>
    <member name="M:log4net.Layout.XmlLayout.#ctor(System.Boolean)">
      <summary>
            Constructs an XmlLayout.
            </summary>
      <remarks>
        <para>
            The <b>LocationInfo</b> option takes a boolean value. By
            default, it is set to false which means there will be no location
            information output by this layout. If the the option is set to
            true, then the file name and line number of the statement
            at the origin of the log statement will be output. 
            </para>
        <para>
            If you are embedding this layout within an SmtpAppender
            then make sure to set the <b>LocationInfo</b> option of that 
            appender as well.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayout.ActivateOptions">
      <summary>
            Initialize layout options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Layout.XmlLayout.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Layout.XmlLayout.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Layout.XmlLayout.ActivateOptions" /> must be called again.
            </para>
        <para>
            Builds a cache of the element names
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayout.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)">
      <summary>
            Does the actual writing of the XML.
            </summary>
      <param name="writer">The writer to use to output the event to.</param>
      <param name="loggingEvent">The event to write.</param>
      <remarks>
        <para>
            Override the base class <see cref="M:log4net.Layout.XmlLayoutBase.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)" /> method
            to write the <see cref="T:log4net.Core.LoggingEvent" /> to the <see cref="T:System.Xml.XmlWriter" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.XmlLayout.Prefix">
      <summary>
            The prefix to use for all element names
            </summary>
      <remarks>
        <para>
            The default prefix is <b>log4net</b>. Set this property
            to change the prefix. If the prefix is set to an empty string
            then no prefix will be written.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.XmlLayout.Base64EncodeMessage">
      <summary>
            Set whether or not to base64 encode the message.
            </summary>
      <remarks>
        <para>
            By default the log message will be written as text to the xml
            output. This can cause problems when the message contains binary
            data. By setting this to true the contents of the message will be
            base64 encoded. If this is set then invalid character replacement
            (see <see cref="P:log4net.Layout.XmlLayoutBase.InvalidCharReplacement" />) will not be performed
            on the log message.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.XmlLayout.Base64EncodeProperties">
      <summary>
            Set whether or not to base64 encode the property values.
            </summary>
      <remarks>
        <para>
            By default the properties will be written as text to the xml
            output. This can cause problems when one or more properties contain
            binary data. By setting this to true the values of the properties
            will be base64 encoded. If this is set then invalid character replacement
            (see <see cref="P:log4net.Layout.XmlLayoutBase.InvalidCharReplacement" />) will not be performed
            on the property values.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Layout.XmlLayoutSchemaLog4j">
      <summary>
            Layout that formats the log events as XML elements compatible with the log4j schema
            </summary>
      <remarks>
        <para>
            Formats the log events according to the http://logging.apache.org/log4j schema.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Layout.XmlLayoutSchemaLog4j.s_date1970">
      <summary>
            The 1st of January 1970 in UTC
            </summary>
    </member>
    <member name="M:log4net.Layout.XmlLayoutSchemaLog4j.#ctor">
      <summary>
            Constructs an XMLLayoutSchemaLog4j
            </summary>
    </member>
    <member name="M:log4net.Layout.XmlLayoutSchemaLog4j.#ctor(System.Boolean)">
      <summary>
            Constructs an XMLLayoutSchemaLog4j.
            </summary>
      <remarks>
        <para>
            The <b>LocationInfo</b> option takes a boolean value. By
            default, it is set to false which means there will be no location
            information output by this layout. If the the option is set to
            true, then the file name and line number of the statement
            at the origin of the log statement will be output. 
            </para>
        <para>
            If you are embedding this layout within an SMTPAppender
            then make sure to set the <b>LocationInfo</b> option of that 
            appender as well.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Layout.XmlLayoutSchemaLog4j.FormatXml(System.Xml.XmlWriter,log4net.Core.LoggingEvent)">
      <summary>
            Actually do the writing of the xml
            </summary>
      <param name="writer">the writer to use</param>
      <param name="loggingEvent">the event to write</param>
      <remarks>
        <para>
            Generate XML that is compatible with the log4j schema.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Layout.XmlLayoutSchemaLog4j.Version">
      <summary>
            The version of the log4j schema to use.
            </summary>
      <remarks>
        <para>
            Only version 1.2 of the log4j schema is supported.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.ObjectRenderer.IObjectRenderer">
      <summary>
            Implement this interface in order to render objects as strings
            </summary>
      <remarks>
        <para>
            Certain types require special case conversion to
            string form. This conversion is done by an object renderer.
            Object renderers implement the <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />
            interface.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.ObjectRenderer.IObjectRenderer.RenderObject(log4net.ObjectRenderer.RendererMap,System.Object,System.IO.TextWriter)">
      <summary>
            Render the object <paramref name="obj" /> to a string
            </summary>
      <param name="rendererMap">The map used to lookup renderers</param>
      <param name="obj">The object to render</param>
      <param name="writer">The writer to render to</param>
      <remarks>
        <para>
            Render the object <paramref name="obj" /> to a 
            string.
            </para>
        <para>
            The <paramref name="rendererMap" /> parameter is
            provided to lookup and render other objects. This is
            very useful where <paramref name="obj" /> contains
            nested objects of unknown type. The <see cref="M:log4net.ObjectRenderer.RendererMap.FindAndRender(System.Object,System.IO.TextWriter)" />
            method can be used to render these objects.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.ObjectRenderer.DefaultRenderer">
      <summary>
            The default object Renderer.
            </summary>
      <remarks>
        <para>
            The default renderer supports rendering objects and collections to strings.
            </para>
        <para>
            See the <see cref="M:log4net.ObjectRenderer.DefaultRenderer.RenderObject(log4net.ObjectRenderer.RendererMap,System.Object,System.IO.TextWriter)" /> method for details of the output.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.ObjectRenderer.DefaultRenderer.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.DefaultRenderer.RenderObject(log4net.ObjectRenderer.RendererMap,System.Object,System.IO.TextWriter)">
      <summary>
            Render the object <paramref name="obj" /> to a string
            </summary>
      <param name="rendererMap">The map used to lookup renderers</param>
      <param name="obj">The object to render</param>
      <param name="writer">The writer to render to</param>
      <remarks>
        <para>
            Render the object <paramref name="obj" /> to a string.
            </para>
        <para>
            The <paramref name="rendererMap" /> parameter is
            provided to lookup and render other objects. This is
            very useful where <paramref name="obj" /> contains
            nested objects of unknown type. The <see cref="M:log4net.ObjectRenderer.RendererMap.FindAndRender(System.Object)" />
            method can be used to render these objects.
            </para>
        <para>
            The default renderer supports rendering objects to strings as follows:
            </para>
        <list type="table">
          <listheader>
            <term>Value</term>
            <description>Rendered String</description>
          </listheader>
          <item>
            <term>
              <c>null</c>
            </term>
            <description>
              <para>"(null)"</para>
            </description>
          </item>
          <item>
            <term>
              <see cref="T:System.Array" />
            </term>
            <description>
              <para>
            		For a one dimensional array this is the
            		array type name, an open brace, followed by a comma
            		separated list of the elements (using the appropriate
            		renderer), followed by a close brace. 
            		</para>
              <para>
            		For example: <c>int[] {1, 2, 3}</c>.
            		</para>
              <para>
            		If the array is not one dimensional the 
            		<c>Array.ToString()</c> is returned.
            		</para>
            </description>
          </item>
          <item>
            <term>
              <see cref="T:System.Collections.IEnumerable" />, <see cref="T:System.Collections.ICollection" /> &amp; <see cref="T:System.Collections.IEnumerator" /></term>
            <description>
              <para>
            		Rendered as an open brace, followed by a comma
            		separated list of the elements (using the appropriate
            		renderer), followed by a close brace.
            		</para>
              <para>
            		For example: <c>{a, b, c}</c>.
            		</para>
              <para>
            		All collection classes that implement <see cref="T:System.Collections.ICollection" /> its subclasses, 
            		or generic equivalents all implement the <see cref="T:System.Collections.IEnumerable" /> interface.
            		</para>
            </description>
          </item>
          <item>
            <term>
              <see cref="T:System.Collections.DictionaryEntry" />
            </term>
            <description>
              <para>
            		Rendered as the key, an equals sign ('='), and the value (using the appropriate
            		renderer). 
            		</para>
              <para>
            		For example: <c>key=value</c>.
            		</para>
            </description>
          </item>
          <item>
            <term>other</term>
            <description>
              <para>
                <c>Object.ToString()</c>
              </para>
            </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.DefaultRenderer.RenderArray(log4net.ObjectRenderer.RendererMap,System.Array,System.IO.TextWriter)">
      <summary>
            Render the array argument into a string
            </summary>
      <param name="rendererMap">The map used to lookup renderers</param>
      <param name="array">the array to render</param>
      <param name="writer">The writer to render to</param>
      <remarks>
        <para>
            For a one dimensional array this is the
            array type name, an open brace, followed by a comma
            separated list of the elements (using the appropriate
            renderer), followed by a close brace. For example:
            <c>int[] {1, 2, 3}</c>.
            </para>
        <para>
            If the array is not one dimensional the 
            <c>Array.ToString()</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.DefaultRenderer.RenderEnumerator(log4net.ObjectRenderer.RendererMap,System.Collections.IEnumerator,System.IO.TextWriter)">
      <summary>
            Render the enumerator argument into a string
            </summary>
      <param name="rendererMap">The map used to lookup renderers</param>
      <param name="enumerator">the enumerator to render</param>
      <param name="writer">The writer to render to</param>
      <remarks>
        <para>
            Rendered as an open brace, followed by a comma
            separated list of the elements (using the appropriate
            renderer), followed by a close brace. For example:
            <c>{a, b, c}</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.DefaultRenderer.RenderDictionaryEntry(log4net.ObjectRenderer.RendererMap,System.Collections.DictionaryEntry,System.IO.TextWriter)">
      <summary>
            Render the DictionaryEntry argument into a string
            </summary>
      <param name="rendererMap">The map used to lookup renderers</param>
      <param name="entry">the DictionaryEntry to render</param>
      <param name="writer">The writer to render to</param>
      <remarks>
        <para>
            Render the key, an equals sign ('='), and the value (using the appropriate
            renderer). For example: <c>key=value</c>.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.ObjectRenderer.RendererMap">
      <summary>
            Map class objects to an <see cref="T:log4net.ObjectRenderer.IObjectRenderer" />.
            </summary>
      <remarks>
        <para>
            Maintains a mapping between types that require special
            rendering and the <see cref="T:log4net.ObjectRenderer.IObjectRenderer" /> that
            is used to render them.
            </para>
        <para>
            The <see cref="M:log4net.ObjectRenderer.RendererMap.FindAndRender(System.Object)" /> method is used to render an
            <c>object</c> using the appropriate renderers defined in this map.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.#ctor">
      <summary>
            Default Constructor
            </summary>
      <remarks>
        <para>
            Default constructor.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.FindAndRender(System.Object)">
      <summary>
            Render <paramref name="obj" /> using the appropriate renderer.
            </summary>
      <param name="obj">the object to render to a string</param>
      <returns>the object rendered as a string</returns>
      <remarks>
        <para>
            This is a convenience method used to render an object to a string.
            The alternative method <see cref="M:log4net.ObjectRenderer.RendererMap.FindAndRender(System.Object,System.IO.TextWriter)" />
            should be used when streaming output to a <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.FindAndRender(System.Object,System.IO.TextWriter)">
      <summary>
            Render <paramref name="obj" /> using the appropriate renderer.
            </summary>
      <param name="obj">the object to render to a string</param>
      <param name="writer">The writer to render to</param>
      <remarks>
        <para>
            Find the appropriate renderer for the type of the
            <paramref name="obj" /> parameter. This is accomplished by calling the
            <see cref="M:log4net.ObjectRenderer.RendererMap.Get(System.Type)" /> method. Once a renderer is found, it is
            applied on the object <paramref name="obj" /> and the result is returned
            as a <see cref="T:System.String" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.Get(System.Object)">
      <summary>
            Gets the renderer for the specified object type
            </summary>
      <param name="obj">the object to lookup the renderer for</param>
      <returns>the renderer for <paramref name="obj" /></returns>
      <remarks>
        <param>
            Gets the renderer for the specified object type.
            </param>
        <param>
            Syntactic sugar method that calls <see cref="M:log4net.ObjectRenderer.RendererMap.Get(System.Type)" /> 
            with the type of the object parameter.
            </param>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.Get(System.Type)">
      <summary>
            Gets the renderer for the specified type
            </summary>
      <param name="type">the type to lookup the renderer for</param>
      <returns>the renderer for the specified type</returns>
      <remarks>
        <para>
            Returns the renderer for the specified type.
            If no specific renderer has been defined the
            <see cref="P:log4net.ObjectRenderer.RendererMap.DefaultRenderer" /> will be returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.SearchTypeAndInterfaces(System.Type)">
      <summary>
            Internal function to recursively search interfaces
            </summary>
      <param name="type">the type to lookup the renderer for</param>
      <returns>the renderer for the specified type</returns>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.Clear">
      <summary>
            Clear the map of renderers
            </summary>
      <remarks>
        <para>
            Clear the custom renderers defined by using
            <see cref="M:log4net.ObjectRenderer.RendererMap.Put(System.Type,log4net.ObjectRenderer.IObjectRenderer)" />. The <see cref="P:log4net.ObjectRenderer.RendererMap.DefaultRenderer" />
            cannot be removed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.ObjectRenderer.RendererMap.Put(System.Type,log4net.ObjectRenderer.IObjectRenderer)">
      <summary>
            Register an <see cref="T:log4net.ObjectRenderer.IObjectRenderer" /> for <paramref name="typeToRender" />. 
            </summary>
      <param name="typeToRender">the type that will be rendered by <paramref name="renderer" /></param>
      <param name="renderer">the renderer for <paramref name="typeToRender" /></param>
      <remarks>
        <para>
            Register an object renderer for a specific source type.
            This renderer will be returned from a call to <see cref="M:log4net.ObjectRenderer.RendererMap.Get(System.Type)" />
            specifying the same <paramref name="typeToRender" /> as an argument.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.ObjectRenderer.RendererMap.DefaultRenderer">
      <summary>
            Get the default renderer instance
            </summary>
      <value>the default renderer</value>
      <remarks>
        <para>
            Get the default renderer
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Plugin.IPlugin">
      <summary>
            Interface implemented by logger repository plugins.
            </summary>
      <remarks>
        <para>
            Plugins define additional behavior that can be associated
            with a <see cref="T:log4net.Repository.ILoggerRepository" />.
            The <see cref="T:log4net.Plugin.PluginMap" /> held by the <see cref="P:log4net.Repository.ILoggerRepository.PluginMap" />
            property is used to store the plugins for a repository.
            </para>
        <para>
            The <c>log4net.Config.PluginAttribute</c> can be used to
            attach plugins to repositories created using configuration
            attributes.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Plugin.IPlugin.Attach(log4net.Repository.ILoggerRepository)">
      <summary>
            Attaches the plugin to the specified <see cref="T:log4net.Repository.ILoggerRepository" />.
            </summary>
      <param name="repository">The <see cref="T:log4net.Repository.ILoggerRepository" /> that this plugin should be attached to.</param>
      <remarks>
        <para>
            A plugin may only be attached to a single repository.
            </para>
        <para>
            This method is called when the plugin is attached to the repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.IPlugin.Shutdown">
      <summary>
            Is called when the plugin is to shutdown.
            </summary>
      <remarks>
        <para>
            This method is called to notify the plugin that 
            it should stop operating and should detach from
            the repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Plugin.IPlugin.Name">
      <summary>
            Gets the name of the plugin.
            </summary>
      <value>
            The name of the plugin.
            </value>
      <remarks>
        <para>
            Plugins are stored in the <see cref="T:log4net.Plugin.PluginMap" />
            keyed by name. Each plugin instance attached to a
            repository must be a unique name.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Plugin.PluginCollection">
      <summary>
            A strongly-typed collection of <see cref="T:log4net.Plugin.IPlugin" /> objects.
            </summary>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Plugin.PluginCollection.IPluginCollectionEnumerator">
      <summary>
            Supports type-safe iteration over a <see cref="T:log4net.Plugin.PluginCollection" />.
            </summary>
      <exclude />
    </member>
    <member name="M:log4net.Plugin.PluginCollection.IPluginCollectionEnumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element in the collection.
            </summary>
      <returns>
        <c>true</c> if the enumerator was successfully advanced to the next element; 
            <c>false</c> if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.IPluginCollectionEnumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.IPluginCollectionEnumerator.Current">
      <summary>
            Gets the current element in the collection.
            </summary>
    </member>
    <member name="T:log4net.Plugin.PluginCollection.Tag">
      <summary>
            Type visible only to our subclasses
            Used to access protected constructor
            </summary>
      <exclude />
    </member>
    <member name="T:log4net.Plugin.PluginCollection.Enumerator">
      <summary>
            Supports simple iteration over a <see cref="T:log4net.Plugin.PluginCollection" />.
            </summary>
      <exclude />
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Enumerator.#ctor(log4net.Plugin.PluginCollection)">
      <summary>
            Initializes a new instance of the <c>Enumerator</c> class.
            </summary>
      <param name="tc">
      </param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Enumerator.MoveNext">
      <summary>
            Advances the enumerator to the next element in the collection.
            </summary>
      <returns>
        <c>true</c> if the enumerator was successfully advanced to the next element; 
            <c>false</c> if the enumerator has passed the end of the collection.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created.
            </exception>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Enumerator.Reset">
      <summary>
            Sets the enumerator to its initial position, before the first element in the collection.
            </summary>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.Enumerator.Current">
      <summary>
            Gets the current element in the collection.
            </summary>
      <value>
            The current element in the collection.
            </value>
    </member>
    <member name="T:log4net.Plugin.PluginCollection.ReadOnlyPluginCollection">
      <exclude />
    </member>
    <member name="M:log4net.Plugin.PluginCollection.ReadOnly(log4net.Plugin.PluginCollection)">
      <summary>
            Creates a read-only wrapper for a <c>PluginCollection</c> instance.
            </summary>
      <param name="list">list to create a readonly wrapper arround</param>
      <returns>
            A <c>PluginCollection</c> wrapper that is read-only.
            </returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.#ctor">
      <summary>
            Initializes a new instance of the <c>PluginCollection</c> class
            that is empty and has the default initial capacity.
            </summary>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <c>PluginCollection</c> class
            that has the specified initial capacity.
            </summary>
      <param name="capacity">
            The number of elements that the new <c>PluginCollection</c> is initially capable of storing.
            </param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.#ctor(log4net.Plugin.PluginCollection)">
      <summary>
            Initializes a new instance of the <c>PluginCollection</c> class
            that contains elements copied from the specified <c>PluginCollection</c>.
            </summary>
      <param name="c">The <c>PluginCollection</c> whose elements are copied to the new collection.</param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.#ctor(log4net.Plugin.IPlugin[])">
      <summary>
            Initializes a new instance of the <c>PluginCollection</c> class
            that contains elements copied from the specified <see cref="T:log4net.Plugin.IPlugin" /> array.
            </summary>
      <param name="a">The <see cref="T:log4net.Plugin.IPlugin" /> array whose elements are copied to the new list.</param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.#ctor(System.Collections.ICollection)">
      <summary>
            Initializes a new instance of the <c>PluginCollection</c> class
            that contains elements copied from the specified <see cref="T:log4net.Plugin.IPlugin" /> collection.
            </summary>
      <param name="col">The <see cref="T:log4net.Plugin.IPlugin" /> collection whose elements are copied to the new list.</param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.#ctor(log4net.Plugin.PluginCollection.Tag)">
      <summary>
            Allow subclasses to avoid our default constructors
            </summary>
      <param name="tag">
      </param>
      <exclude />
    </member>
    <member name="M:log4net.Plugin.PluginCollection.CopyTo(log4net.Plugin.IPlugin[])">
      <summary>
            Copies the entire <c>PluginCollection</c> to a one-dimensional
            <see cref="T:log4net.Plugin.IPlugin" /> array.
            </summary>
      <param name="array">The one-dimensional <see cref="T:log4net.Plugin.IPlugin" /> array to copy to.</param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.CopyTo(log4net.Plugin.IPlugin[],System.Int32)">
      <summary>
            Copies the entire <c>PluginCollection</c> to a one-dimensional
            <see cref="T:log4net.Plugin.IPlugin" /> array, starting at the specified index of the target array.
            </summary>
      <param name="array">The one-dimensional <see cref="T:log4net.Plugin.IPlugin" /> array to copy to.</param>
      <param name="start">The zero-based index in <paramref name="array" /> at which copying begins.</param>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Add(log4net.Plugin.IPlugin)">
      <summary>
            Adds a <see cref="T:log4net.Plugin.IPlugin" /> to the end of the <c>PluginCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Plugin.IPlugin" /> to be added to the end of the <c>PluginCollection</c>.</param>
      <returns>The index at which the value has been added.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Clear">
      <summary>
            Removes all elements from the <c>PluginCollection</c>.
            </summary>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Clone">
      <summary>
            Creates a shallow copy of the <see cref="T:log4net.Plugin.PluginCollection" />.
            </summary>
      <returns>A new <see cref="T:log4net.Plugin.PluginCollection" /> with a shallow copy of the collection data.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Contains(log4net.Plugin.IPlugin)">
      <summary>
            Determines whether a given <see cref="T:log4net.Plugin.IPlugin" /> is in the <c>PluginCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Plugin.IPlugin" /> to check for.</param>
      <returns>
        <c>true</c> if <paramref name="item" /> is found in the <c>PluginCollection</c>; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.IndexOf(log4net.Plugin.IPlugin)">
      <summary>
            Returns the zero-based index of the first occurrence of a <see cref="T:log4net.Plugin.IPlugin" />
            in the <c>PluginCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Plugin.IPlugin" /> to locate in the <c>PluginCollection</c>.</param>
      <returns>
            The zero-based index of the first occurrence of <paramref name="item" /> 
            in the entire <c>PluginCollection</c>, if found; otherwise, -1.
            </returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Insert(System.Int32,log4net.Plugin.IPlugin)">
      <summary>
            Inserts an element into the <c>PluginCollection</c> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
      <param name="item">The <see cref="T:log4net.Plugin.IPlugin" /> to insert.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Plugin.PluginCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.Remove(log4net.Plugin.IPlugin)">
      <summary>
            Removes the first occurrence of a specific <see cref="T:log4net.Plugin.IPlugin" /> from the <c>PluginCollection</c>.
            </summary>
      <param name="item">The <see cref="T:log4net.Plugin.IPlugin" /> to remove from the <c>PluginCollection</c>.</param>
      <exception cref="T:System.ArgumentException">
            The specified <see cref="T:log4net.Plugin.IPlugin" /> was not found in the <c>PluginCollection</c>.
            </exception>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.RemoveAt(System.Int32)">
      <summary>
            Removes the element at the specified index of the <c>PluginCollection</c>.
            </summary>
      <param name="index">The zero-based index of the element to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero.</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Plugin.PluginCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through the <c>PluginCollection</c>.
            </summary>
      <returns>An <see cref="T:log4net.Plugin.PluginCollection.Enumerator" /> for the entire <c>PluginCollection</c>.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.AddRange(log4net.Plugin.PluginCollection)">
      <summary>
            Adds the elements of another <c>PluginCollection</c> to the current <c>PluginCollection</c>.
            </summary>
      <param name="x">The <c>PluginCollection</c> whose elements should be added to the end of the current <c>PluginCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Plugin.PluginCollection.Count" /> of the <c>PluginCollection</c>.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.AddRange(log4net.Plugin.IPlugin[])">
      <summary>
            Adds the elements of a <see cref="T:log4net.Plugin.IPlugin" /> array to the current <c>PluginCollection</c>.
            </summary>
      <param name="x">The <see cref="T:log4net.Plugin.IPlugin" /> array whose elements should be added to the end of the <c>PluginCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Plugin.PluginCollection.Count" /> of the <c>PluginCollection</c>.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.AddRange(System.Collections.ICollection)">
      <summary>
            Adds the elements of a <see cref="T:log4net.Plugin.IPlugin" /> collection to the current <c>PluginCollection</c>.
            </summary>
      <param name="col">The <see cref="T:log4net.Plugin.IPlugin" /> collection whose elements should be added to the end of the <c>PluginCollection</c>.</param>
      <returns>The new <see cref="P:log4net.Plugin.PluginCollection.Count" /> of the <c>PluginCollection</c>.</returns>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.TrimToSize">
      <summary>
            Sets the capacity to the actual number of elements.
            </summary>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.ValidateIndex(System.Int32)">
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero.</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Plugin.PluginCollection.Count" />.</para>
      </exception>
    </member>
    <member name="M:log4net.Plugin.PluginCollection.ValidateIndex(System.Int32,System.Boolean)">
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero.</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Plugin.PluginCollection.Count" />.</para>
      </exception>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.Count">
      <summary>
            Gets the number of elements actually contained in the <c>PluginCollection</c>.
            </summary>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the collection is synchronized (thread-safe).
            </summary>
      <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the collection.
            </summary>
      <value>
            An object that can be used to synchronize access to the collection.
            </value>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="T:log4net.Plugin.IPlugin" /> at the specified index.
            </summary>
      <value>
            The <see cref="T:log4net.Plugin.IPlugin" /> at the specified index.
            </value>
      <param name="index">The zero-based index of the element to get or set.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="index" /> is less than zero.</para>
        <para>-or-</para>
        <para>
          <paramref name="index" /> is equal to or greater than <see cref="P:log4net.Plugin.PluginCollection.Count" />.</para>
      </exception>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.IsFixedSize">
      <summary>
            Gets a value indicating whether the collection has a fixed size.
            </summary>
      <value>
        <c>true</c> if the collection has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.IsReadOnly">
      <summary>
            Gets a value indicating whether the IList is read-only.
            </summary>
      <value>
        <c>true</c> if the collection is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
    </member>
    <member name="P:log4net.Plugin.PluginCollection.Capacity">
      <summary>
            Gets or sets the number of elements the <c>PluginCollection</c> can contain.
            </summary>
      <value>
            The number of elements the <c>PluginCollection</c> can contain.
            </value>
    </member>
    <member name="T:log4net.Plugin.PluginMap">
      <summary>
            Map of repository plugins.
            </summary>
      <remarks>
        <para>
            This class is a name keyed map of the plugins that are
            attached to a repository.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Plugin.PluginMap.#ctor(log4net.Repository.ILoggerRepository)">
      <summary>
            Constructor
            </summary>
      <param name="repository">The repository that the plugins should be attached to.</param>
      <remarks>
        <para>
            Initialize a new instance of the <see cref="T:log4net.Plugin.PluginMap" /> class with a 
            repository that the plugins should be attached to.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.PluginMap.Add(log4net.Plugin.IPlugin)">
      <summary>
            Adds a <see cref="T:log4net.Plugin.IPlugin" /> to the map.
            </summary>
      <param name="plugin">The <see cref="T:log4net.Plugin.IPlugin" /> to add to the map.</param>
      <remarks>
        <para>
            The <see cref="T:log4net.Plugin.IPlugin" /> will be attached to the repository when added.
            </para>
        <para>
            If there already exists a plugin with the same name 
            attached to the repository then the old plugin will
            be <see cref="M:log4net.Plugin.IPlugin.Shutdown" /> and replaced with
            the new plugin.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.PluginMap.Remove(log4net.Plugin.IPlugin)">
      <summary>
            Removes a <see cref="T:log4net.Plugin.IPlugin" /> from the map.
            </summary>
      <param name="plugin">The <see cref="T:log4net.Plugin.IPlugin" /> to remove from the map.</param>
      <remarks>
        <para>
            Remove a specific plugin from this map.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Plugin.PluginMap.Item(System.String)">
      <summary>
            Gets a <see cref="T:log4net.Plugin.IPlugin" /> by name.
            </summary>
      <param name="name">The name of the <see cref="T:log4net.Plugin.IPlugin" /> to lookup.</param>
      <returns>
            The <see cref="T:log4net.Plugin.IPlugin" /> from the map with the name specified, or 
            <c>null</c> if no plugin is found.
            </returns>
      <remarks>
        <para>
            Lookup a plugin by name. If the plugin is not found <c>null</c>
            will be returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Plugin.PluginMap.AllPlugins">
      <summary>
            Gets all possible plugins as a list of <see cref="T:log4net.Plugin.IPlugin" /> objects.
            </summary>
      <value>All possible plugins as a list of <see cref="T:log4net.Plugin.IPlugin" /> objects.</value>
      <remarks>
        <para>
            Get a collection of all the plugins defined in this map.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Plugin.PluginSkeleton">
      <summary>
            Base implementation of <see cref="T:log4net.Plugin.IPlugin" /></summary>
      <remarks>
        <para>
            Default abstract implementation of the <see cref="T:log4net.Plugin.IPlugin" />
            interface. This base class can be used by implementors
            of the <see cref="T:log4net.Plugin.IPlugin" /> interface.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Plugin.PluginSkeleton.m_name">
      <summary>
            The name of this plugin.
            </summary>
    </member>
    <member name="F:log4net.Plugin.PluginSkeleton.m_repository">
      <summary>
            The repository this plugin is attached to.
            </summary>
    </member>
    <member name="M:log4net.Plugin.PluginSkeleton.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="name">the name of the plugin</param>
      <remarks>
            Initializes a new Plugin with the specified name.
            </remarks>
    </member>
    <member name="M:log4net.Plugin.PluginSkeleton.Attach(log4net.Repository.ILoggerRepository)">
      <summary>
            Attaches this plugin to a <see cref="T:log4net.Repository.ILoggerRepository" />.
            </summary>
      <param name="repository">The <see cref="T:log4net.Repository.ILoggerRepository" /> that this plugin should be attached to.</param>
      <remarks>
        <para>
            A plugin may only be attached to a single repository.
            </para>
        <para>
            This method is called when the plugin is attached to the repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.PluginSkeleton.Shutdown">
      <summary>
            Is called when the plugin is to shutdown.
            </summary>
      <remarks>
        <para>
            This method is called to notify the plugin that 
            it should stop operating and should detach from
            the repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Plugin.PluginSkeleton.Name">
      <summary>
            Gets or sets the name of the plugin.
            </summary>
      <value>
            The name of the plugin.
            </value>
      <remarks>
        <para>
            Plugins are stored in the <see cref="T:log4net.Plugin.PluginMap" />
            keyed by name. Each plugin instance attached to a
            repository must be a unique name.
            </para>
        <para>
            The name of the plugin must not change one the 
            plugin has been attached to a repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Plugin.PluginSkeleton.LoggerRepository">
      <summary>
            The repository for this plugin
            </summary>
      <value>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that this plugin is attached to.
            </value>
      <remarks>
        <para>
            Gets or sets the <see cref="T:log4net.Repository.ILoggerRepository" /> that this plugin is 
            attached to.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Plugin.RemoteLoggingServerPlugin">
      <summary>
            Plugin that listens for events from the <see cref="T:log4net.Appender.RemotingAppender" /></summary>
      <remarks>
        <para>
            This plugin publishes an instance of <see cref="T:log4net.Appender.RemotingAppender.IRemoteLoggingSink" /> 
            on a specified <see cref="P:log4net.Plugin.RemoteLoggingServerPlugin.SinkUri" />. This listens for logging events delivered from
            a remote <see cref="T:log4net.Appender.RemotingAppender" />.
            </para>
        <para>
            When an event is received it is relogged within the attached repository
            as if it had been raised locally.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Plugin.RemoteLoggingServerPlugin.RemoteLoggingSinkImpl">
      <summary>
            Delivers <see cref="T:log4net.Core.LoggingEvent" /> objects to a remote sink.
            </summary>
      <remarks>
        <para>
            Internal class used to listen for logging events
            and deliver them to the local repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.RemoteLoggingSinkImpl.#ctor(log4net.Repository.ILoggerRepository)">
      <summary>
            Constructor
            </summary>
      <param name="repository">The repository to log to.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Plugin.RemoteLoggingServerPlugin.RemoteLoggingSinkImpl" /> for the
            specified <see cref="T:log4net.Repository.ILoggerRepository" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.RemoteLoggingSinkImpl.LogEvents(log4net.Core.LoggingEvent[])">
      <summary>
            Logs the events to the repository.
            </summary>
      <param name="events">The events to log.</param>
      <remarks>
        <para>
            The events passed are logged to the <see cref="T:log4net.Repository.ILoggerRepository" /></para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.RemoteLoggingSinkImpl.InitializeLifetimeService">
      <summary>
            Obtains a lifetime service object to control the lifetime 
            policy for this instance.
            </summary>
      <returns>
        <c>null</c> to indicate that this instance should live forever.</returns>
      <remarks>
        <para>
            Obtains a lifetime service object to control the lifetime 
            policy for this instance. This object should live forever
            therefore this implementation returns <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Plugin.RemoteLoggingServerPlugin" /> class.
            </para>
        <para>
            The <see cref="P:log4net.Plugin.RemoteLoggingServerPlugin.SinkUri" /> property must be set.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.#ctor(System.String)">
      <summary>
            Construct with sink Uri.
            </summary>
      <param name="sinkUri">The name to publish the sink under in the remoting infrastructure. 
            See <see cref="P:log4net.Plugin.RemoteLoggingServerPlugin.SinkUri" /> for more details.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Plugin.RemoteLoggingServerPlugin" /> class
            with specified name.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.Attach(log4net.Repository.ILoggerRepository)">
      <summary>
            Attaches this plugin to a <see cref="T:log4net.Repository.ILoggerRepository" />.
            </summary>
      <param name="repository">The <see cref="T:log4net.Repository.ILoggerRepository" /> that this plugin should be attached to.</param>
      <remarks>
        <para>
            A plugin may only be attached to a single repository.
            </para>
        <para>
            This method is called when the plugin is attached to the repository.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Plugin.RemoteLoggingServerPlugin.Shutdown">
      <summary>
            Is called when the plugin is to shutdown.
            </summary>
      <remarks>
        <para>
            When the plugin is shutdown the remote logging
            sink is disconnected.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Plugin.RemoteLoggingServerPlugin.SinkUri">
      <summary>
            Gets or sets the URI of this sink.
            </summary>
      <value>
            The URI of this sink.
            </value>
      <remarks>
        <para>
            This is the name under which the object is marshaled.
            <see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" /></para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.ILoggerFactory">
      <summary>
            Interface abstracts creation of <see cref="T:log4net.Repository.Hierarchy.Logger" /> instances
            </summary>
      <remarks>
        <para>
            This interface is used by the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> to 
            create new <see cref="T:log4net.Repository.Hierarchy.Logger" /> objects.
            </para>
        <para>
            The <see cref="M:log4net.Repository.Hierarchy.ILoggerFactory.CreateLogger(System.String)" /> method is called
            to create a named <see cref="T:log4net.Repository.Hierarchy.Logger" />.
            </para>
        <para>
            Implement this interface to create new subclasses of <see cref="T:log4net.Repository.Hierarchy.Logger" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.Hierarchy.ILoggerFactory.CreateLogger(System.String)">
      <summary>
            Create a new <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance
            </summary>
      <param name="name">The name of the <see cref="T:log4net.Repository.Hierarchy.Logger" />.</param>
      <returns>The <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance for the specified name.</returns>
      <remarks>
        <para>
            Create a new <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance with the 
            specified name.
            </para>
        <para>
            Called by the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> to create
            new named <see cref="T:log4net.Repository.Hierarchy.Logger" /> instances.
            </para>
        <para>
            If the <paramref name="name" /> is <c>null</c> then the root logger
            must be returned.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.DefaultLoggerFactory">
      <summary>
            Default implementation of <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" /></summary>
      <remarks>
        <para>
            This default implementation of the <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" />
            interface is used to create the default subclass
            of the <see cref="T:log4net.Repository.Hierarchy.Logger" /> object.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Repository.Hierarchy.DefaultLoggerFactory.LoggerImpl">
      <summary>
            Default internal subclass of <see cref="T:log4net.Repository.Hierarchy.Logger" /></summary>
      <remarks>
        <para>
            This subclass has no additional behavior over the
            <see cref="T:log4net.Repository.Hierarchy.Logger" /> class but does allow instances
            to be created.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.DefaultLoggerFactory.LoggerImpl.#ctor(System.String)">
      <summary>
            Construct a new Logger
            </summary>
      <param name="name">the name of the logger</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.DefaultLoggerFactory.LoggerImpl" /> class
            with the specified name. 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.DefaultLoggerFactory.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.DefaultLoggerFactory" /> class. 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.DefaultLoggerFactory.CreateLogger(System.String)">
      <summary>
            Create a new <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance
            </summary>
      <param name="name">The name of the <see cref="T:log4net.Repository.Hierarchy.Logger" />.</param>
      <returns>The <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance for the specified name.</returns>
      <remarks>
        <para>
            Create a new <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance with the 
            specified name.
            </para>
        <para>
            Called by the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> to create
            new named <see cref="T:log4net.Repository.Hierarchy.Logger" /> instances.
            </para>
        <para>
            If the <paramref name="name" /> is <c>null</c> then the root logger
            must be returned.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.Logger">
      <summary>
            Implementation of <see cref="T:log4net.Core.ILogger" /> used by <see cref="P:log4net.Repository.Hierarchy.Logger.Hierarchy" /></summary>
      <remarks>
        <para>
            Internal class used to provide implementation of <see cref="T:log4net.Core.ILogger" />
            interface. Applications should use <see cref="T:log4net.LogManager" /> to get
            logger instances.
            </para>
        <para>
            This is one of the central classes in the log4net implementation. One of the
            distinctive features of log4net are hierarchical loggers and their
            evaluation. The <see cref="P:log4net.Repository.Hierarchy.Logger.Hierarchy" /> organizes the <see cref="T:log4net.Repository.Hierarchy.Logger" />
            instances into a rooted tree hierarchy.
            </para>
        <para>
            The <see cref="T:log4net.Repository.Hierarchy.Logger" /> class is abstract. Only concrete subclasses of
            <see cref="T:log4net.Repository.Hierarchy.Logger" /> can be created. The <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" />
            is used to create instances of this type for the <see cref="P:log4net.Repository.Hierarchy.Logger.Hierarchy" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Aspi Havewala</author>
      <author>Douglas de la Torre</author>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.ThisDeclaringType">
      <summary>
            The fully qualified type of the Logger class.
            </summary>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_name">
      <summary>
            The name of this logger.
            </summary>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_level">
      <summary>
            The assigned level of this logger. 
            </summary>
      <remarks>
        <para>
            The <c>level</c> variable need not be 
            assigned a value in which case it is inherited 
            form the hierarchy.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_parent">
      <summary>
            The parent of this logger.
            </summary>
      <remarks>
        <para>
            The parent of this logger. 
            All loggers have at least one ancestor which is the root logger.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_hierarchy">
      <summary>
            Loggers need to know what Hierarchy they are in.
            </summary>
      <remarks>
        <para>
            Loggers need to know what Hierarchy they are in.
            The hierarchy that this logger is a member of is stored
            here.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_appenderAttachedImpl">
      <summary>
            Helper implementation of the <see cref="T:log4net.Core.IAppenderAttachable" /> interface
            </summary>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_additive">
      <summary>
            Flag indicating if child loggers inherit their parents appenders
            </summary>
      <remarks>
        <para>
            Additivity is set to true by default, that is children inherit
            the appenders of their ancestors by default. If this variable is
            set to <c>false</c> then the appenders found in the
            ancestors of this logger are not used. However, the children
            of this logger will inherit its appenders, unless the children
            have their additivity flag set to <c>false</c> too. See
            the user manual for more details.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Repository.Hierarchy.Logger.m_appenderLock">
      <summary>
            Lock to protect AppenderAttachedImpl variable m_appenderAttachedImpl
            </summary>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.#ctor(System.String)">
      <summary>
            This constructor created a new <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance and
            sets its name.
            </summary>
      <param name="name">The name of the <see cref="T:log4net.Repository.Hierarchy.Logger" />.</param>
      <remarks>
        <para>
            This constructor is protected and designed to be used by
            a subclass that is not abstract.
            </para>
        <para>
            Loggers are constructed by <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" /> 
            objects. See <see cref="T:log4net.Repository.Hierarchy.DefaultLoggerFactory" /> for the default
            logger creator.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.AddAppender(log4net.Appender.IAppender)">
      <summary>
            Add <paramref name="newAppender" /> to the list of appenders of this
            Logger instance.
            </summary>
      <param name="newAppender">An appender to add to this logger</param>
      <remarks>
        <para>
            Add <paramref name="newAppender" /> to the list of appenders of this
            Logger instance.
            </para>
        <para>
            If <paramref name="newAppender" /> is already in the list of
            appenders, then it won't be added again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.GetAppender(System.String)">
      <summary>
            Look for the appender named as <c>name</c></summary>
      <param name="name">The name of the appender to lookup</param>
      <returns>The appender with the name specified, or <c>null</c>.</returns>
      <remarks>
        <para>
            Returns the named appender, or null if the appender is not found.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.RemoveAllAppenders">
      <summary>
            Remove all previously added appenders from this Logger instance.
            </summary>
      <remarks>
        <para>
            Remove all previously added appenders from this Logger instance.
            </para>
        <para>
            This is useful when re-reading configuration information.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.RemoveAppender(log4net.Appender.IAppender)">
      <summary>
            Remove the appender passed as parameter form the list of appenders.
            </summary>
      <param name="appender">The appender to remove</param>
      <returns>The appender removed from the list</returns>
      <remarks>
        <para>
            Remove the appender passed as parameter form the list of appenders.
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.RemoveAppender(System.String)">
      <summary>
            Remove the appender passed as parameter form the list of appenders.
            </summary>
      <param name="name">The name of the appender to remove</param>
      <returns>The appender removed from the list</returns>
      <remarks>
        <para>
            Remove the named appender passed as parameter form the list of appenders.
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.Log(System.Type,log4net.Core.Level,System.Object,System.Exception)">
      <summary>
            This generic form is intended to be used by wrappers.
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <param name="level">The level of the message to be logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Generate a logging event for the specified <paramref name="level" /> using
            the <paramref name="message" /> and <paramref name="exception" />.
            </para>
        <para>
            This method must not throw any exception to the caller.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.Log(log4net.Core.LoggingEvent)">
      <summary>
            This is the most generic printing method that is intended to be used 
            by wrappers.
            </summary>
      <param name="logEvent">The event being logged.</param>
      <remarks>
        <para>
            Logs the specified logging event through this logger.
            </para>
        <para>
            This method must not throw any exception to the caller.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.IsEnabledFor(log4net.Core.Level)">
      <summary>
            Checks if this logger is enabled for a given <see cref="P:log4net.Repository.Hierarchy.Logger.Level" /> passed as parameter.
            </summary>
      <param name="level">The level to check.</param>
      <returns>
        <c>true</c> if this logger is enabled for <c>level</c>, otherwise <c>false</c>.
            </returns>
      <remarks>
        <para>
            Test if this logger is going to log events of the specified <paramref name="level" />.
            </para>
        <para>
            This method must not throw any exception to the caller.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.CallAppenders(log4net.Core.LoggingEvent)">
      <summary>
            Deliver the <see cref="T:log4net.Core.LoggingEvent" /> to the attached appenders.
            </summary>
      <param name="loggingEvent">The event to log.</param>
      <remarks>
        <para>
            Call the appenders in the hierarchy starting at
            <c>this</c>. If no appenders could be found, emit a
            warning.
            </para>
        <para>
            This method calls all the appenders inherited from the
            hierarchy circumventing any evaluation of whether to log or not
            to log the particular log request.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.CloseNestedAppenders">
      <summary>
            Closes all attached appenders implementing the <see cref="T:log4net.Core.IAppenderAttachable" /> interface.
            </summary>
      <remarks>
        <para>
            Used to ensure that the appenders are correctly shutdown.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.Log(log4net.Core.Level,System.Object,System.Exception)">
      <summary>
            This is the most generic printing method. This generic form is intended to be used by wrappers
            </summary>
      <param name="level">The level of the message to be logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Generate a logging event for the specified <paramref name="level" /> using
            the <paramref name="message" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.ForcedLog(System.Type,log4net.Core.Level,System.Object,System.Exception)">
      <summary>
            Creates a new logging event and logs the event without further checks.
            </summary>
      <param name="callerStackBoundaryDeclaringType">The declaring type of the method that is
            the stack boundary into the logging system for this call.</param>
      <param name="level">The level of the message to be logged.</param>
      <param name="message">The message object to log.</param>
      <param name="exception">The exception to log, including its stack trace.</param>
      <remarks>
        <para>
            Generates a logging event and delivers it to the attached
            appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Logger.ForcedLog(log4net.Core.LoggingEvent)">
      <summary>
            Creates a new logging event and logs the event without further checks.
            </summary>
      <param name="logEvent">The event being logged.</param>
      <remarks>
        <para>
            Delivers the logging event to the attached appenders.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Parent">
      <summary>
            Gets or sets the parent logger in the hierarchy.
            </summary>
      <value>
            The parent logger in the hierarchy.
            </value>
      <remarks>
        <para>
            Part of the Composite pattern that makes the hierarchy.
            The hierarchy is parent linked rather than child linked.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Additivity">
      <summary>
            Gets or sets a value indicating if child loggers inherit their parent's appenders.
            </summary>
      <value>
        <c>true</c> if child loggers inherit their parent's appenders.
            </value>
      <remarks>
        <para>
            Additivity is set to <c>true</c> by default, that is children inherit
            the appenders of their ancestors by default. If this variable is
            set to <c>false</c> then the appenders found in the
            ancestors of this logger are not used. However, the children
            of this logger will inherit its appenders, unless the children
            have their additivity flag set to <c>false</c> too. See
            the user manual for more details.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.EffectiveLevel">
      <summary>
            Gets the effective level for this logger.
            </summary>
      <returns>The nearest level in the logger hierarchy.</returns>
      <remarks>
        <para>
            Starting from this logger, searches the logger hierarchy for a
            non-null level and returns it. Otherwise, returns the level of the
            root logger.
            </para>
        <para>The Logger class is designed so that this method executes as
            quickly as possible.</para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Hierarchy">
      <summary>
            Gets or sets the <see cref="P:log4net.Repository.Hierarchy.Logger.Hierarchy" /> where this 
            <c>Logger</c> instance is attached to.
            </summary>
      <value>The hierarchy that this logger belongs to.</value>
      <remarks>
        <para>
            This logger must be attached to a single <see cref="P:log4net.Repository.Hierarchy.Logger.Hierarchy" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Level">
      <summary>
            Gets or sets the assigned <see cref="P:log4net.Repository.Hierarchy.Logger.Level" />, if any, for this Logger.  
            </summary>
      <value>
            The <see cref="P:log4net.Repository.Hierarchy.Logger.Level" /> of this logger.
            </value>
      <remarks>
        <para>
            The assigned <see cref="P:log4net.Repository.Hierarchy.Logger.Level" /> can be <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Appenders">
      <summary>
            Get the appenders contained in this logger as an 
            <see cref="T:System.Collections.ICollection" />.
            </summary>
      <returns>A collection of the appenders in this logger</returns>
      <remarks>
        <para>
            Get the appenders contained in this logger as an 
            <see cref="T:System.Collections.ICollection" />. If no appenders 
            can be found, then a <see cref="T:log4net.Util.EmptyCollection" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Name">
      <summary>
            Gets the logger name.
            </summary>
      <value>
            The name of the logger.
            </value>
      <remarks>
        <para>
            The name of this logger
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Logger.Repository">
      <summary>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> where this 
            <c>Logger</c> instance is attached to.
            </summary>
      <value>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> that this logger belongs to.
            </value>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> where this 
            <c>Logger</c> instance is attached to.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.LoggerCreationEventHandler">
      <summary>
            Delegate used to handle logger creation event notifications.
            </summary>
      <param name="sender">The <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> in which the <see cref="T:log4net.Repository.Hierarchy.Logger" /> has been created.</param>
      <param name="e">The <see cref="T:log4net.Repository.Hierarchy.LoggerCreationEventArgs" /> event args that hold the <see cref="T:log4net.Repository.Hierarchy.Logger" /> instance that has been created.</param>
      <remarks>
        <para>
            Delegate used to handle logger creation event notifications.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.LoggerCreationEventArgs">
      <summary>
            Provides data for the <see cref="E:log4net.Repository.Hierarchy.Hierarchy.LoggerCreatedEvent" /> event.
            </summary>
      <remarks>
        <para>
            A <see cref="E:log4net.Repository.Hierarchy.Hierarchy.LoggerCreatedEvent" /> event is raised every time a
            <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" /> is created.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Repository.Hierarchy.LoggerCreationEventArgs.m_log">
      <summary>
            The <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" /> created
            </summary>
    </member>
    <member name="M:log4net.Repository.Hierarchy.LoggerCreationEventArgs.#ctor(log4net.Repository.Hierarchy.Logger)">
      <summary>
            Constructor
            </summary>
      <param name="log">The <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" /> that has been created.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.LoggerCreationEventArgs" /> event argument 
            class,with the specified <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger">
      <summary>
            Gets the <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" /> that has been created.
            </summary>
      <value>
            The <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" /> that has been created.
            </value>
      <remarks>
        <para>
            The <see cref="P:log4net.Repository.Hierarchy.LoggerCreationEventArgs.Logger" /> that has been created.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.ILoggerRepository">
      <summary>
            Interface implemented by logger repositories.
            </summary>
      <remarks>
        <para>
            This interface is implemented by logger repositories. e.g. 
            <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />.
            </para>
        <para>
            This interface is used by the <see cref="T:log4net.LogManager" />
            to obtain <see cref="T:log4net.ILog" /> interfaces.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.Exists(System.String)">
      <summary>
            Check if the named logger exists in the repository. If so return
            its reference, otherwise returns <c>null</c>.
            </summary>
      <param name="name">The name of the logger to lookup</param>
      <returns>The Logger object with the name specified</returns>
      <remarks>
        <para>
            If the names logger exists it is returned, otherwise
            <c>null</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.GetCurrentLoggers">
      <summary>
            Returns all the currently defined loggers as an Array.
            </summary>
      <returns>All the defined loggers</returns>
      <remarks>
        <para>
            Returns all the currently defined loggers as an Array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.GetLogger(System.String)">
      <summary>
            Returns a named logger instance
            </summary>
      <param name="name">The name of the logger to retrieve</param>
      <returns>The logger object with the name specified</returns>
      <remarks>
        <para>
            Returns a named logger instance.
            </para>
        <para>
            If a logger of that name already exists, then it will be
            returned.  Otherwise, a new logger will be instantiated and
            then linked with its existing ancestors as well as children.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.Shutdown">
      <summary>Shutdown the repository</summary>
      <remarks>
        <para>
            Shutting down a repository will <i>safely</i> close and remove
            all appenders in all loggers including the root logger.
            </para>
        <para>
            Some appenders need to be closed before the
            application exists. Otherwise, pending logging events might be
            lost.
            </para>
        <para>
            The <see cref="M:log4net.Repository.ILoggerRepository.Shutdown" /> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.ResetConfiguration">
      <summary>
            Reset the repositories configuration to a default state
            </summary>
      <remarks>
        <para>
            Reset all values contained in this instance to their
            default state.
            </para>
        <para>
            Existing loggers are not removed. They are just reset.
            </para>
        <para>
            This method should be used sparingly and with care as it will
            block all logging until it is completed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.Log(log4net.Core.LoggingEvent)">
      <summary>
            Log the <see cref="T:log4net.Core.LoggingEvent" /> through this repository.
            </summary>
      <param name="logEvent">the event to log</param>
      <remarks>
        <para>
            This method should not normally be used to log.
            The <see cref="T:log4net.ILog" /> interface should be used 
            for routine logging. This interface can be obtained
            using the <see cref="M:log4net.LogManager.GetLogger(System.String)" /> method.
            </para>
        <para>
            The <c>logEvent</c> is delivered to the appropriate logger and
            that logger is then responsible for logging the event.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.ILoggerRepository.GetAppenders">
      <summary>
            Returns all the Appenders that are configured as an Array.
            </summary>
      <returns>All the Appenders</returns>
      <remarks>
        <para>
            Returns all the Appenders that are configured as an Array.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.Name">
      <summary>
            The name of the repository
            </summary>
      <value>
            The name of the repository
            </value>
      <remarks>
        <para>
            The name of the repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.RendererMap">
      <summary>
            RendererMap accesses the object renderer map for this repository.
            </summary>
      <value>
            RendererMap accesses the object renderer map for this repository.
            </value>
      <remarks>
        <para>
            RendererMap accesses the object renderer map for this repository.
            </para>
        <para>
            The RendererMap holds a mapping between types and
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" /> objects.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.PluginMap">
      <summary>
            The plugin map for this repository.
            </summary>
      <value>
            The plugin map for this repository.
            </value>
      <remarks>
        <para>
            The plugin map holds the <see cref="T:log4net.Plugin.IPlugin" /> instances
            that have been attached to this repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.LevelMap">
      <summary>
            Get the level map for the Repository.
            </summary>
      <remarks>
        <para>
            Get the level map for the Repository.
            </para>
        <para>
            The level map defines the mappings between
            level names and <see cref="T:log4net.Core.Level" /> objects in
            this repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.Threshold">
      <summary>
            The threshold for all events in this repository
            </summary>
      <value>
            The threshold for all events in this repository
            </value>
      <remarks>
        <para>
            The threshold for all events in this repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.Configured">
      <summary>
            Flag indicates if this repository has been configured.
            </summary>
      <value>
            Flag indicates if this repository has been configured.
            </value>
      <remarks>
        <para>
            Flag indicates if this repository has been configured.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.ILoggerRepository.Properties">
      <summary>
            Repository specific properties
            </summary>
      <value>
            Repository specific properties
            </value>
      <remarks>
        <para>
            These properties can be specified on a repository specific basis.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Repository.ILoggerRepository.ShutdownEvent">
      <summary>
            Event to notify that the repository has been shutdown.
            </summary>
      <value>
            Event to notify that the repository has been shutdown.
            </value>
      <remarks>
        <para>
            Event raised when the repository has been shutdown.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Repository.ILoggerRepository.ConfigurationReset">
      <summary>
            Event to notify that the repository has had its configuration reset.
            </summary>
      <value>
            Event to notify that the repository has had its configuration reset.
            </value>
      <remarks>
        <para>
            Event raised when the repository's configuration has been
            reset to default.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Repository.ILoggerRepository.ConfigurationChanged">
      <summary>
            Event to notify that the repository has had its configuration changed.
            </summary>
      <value>
            Event to notify that the repository has had its configuration changed.
            </value>
      <remarks>
        <para>
            Event raised when the repository's configuration has been changed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.LoggerRepositorySkeleton">
      <summary>
            Base implementation of <see cref="T:log4net.Repository.ILoggerRepository" /></summary>
      <remarks>
        <para>
            Default abstract implementation of the <see cref="T:log4net.Repository.ILoggerRepository" /> interface.
            </para>
        <para>
            Skeleton implementation of the <see cref="T:log4net.Repository.ILoggerRepository" /> interface.
            All <see cref="T:log4net.Repository.ILoggerRepository" /> types can extend this type.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.#ctor">
      <summary>
            Default Constructor
            </summary>
      <remarks>
        <para>
            Initializes the repository with default (empty) properties.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.#ctor(log4net.Util.PropertiesDictionary)">
      <summary>
            Construct the repository using specific properties
            </summary>
      <param name="properties">the properties to set for this repository</param>
      <remarks>
        <para>
            Initializes the repository with specified properties.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.Exists(System.String)">
      <summary>
            Test if logger exists
            </summary>
      <param name="name">The name of the logger to lookup</param>
      <returns>The Logger object with the name specified</returns>
      <remarks>
        <para>
            Check if the named logger exists in the repository. If so return
            its reference, otherwise returns <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.GetCurrentLoggers">
      <summary>
            Returns all the currently defined loggers in the repository
            </summary>
      <returns>All the defined loggers</returns>
      <remarks>
        <para>
            Returns all the currently defined loggers in the repository as an Array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.GetLogger(System.String)">
      <summary>
            Return a new logger instance
            </summary>
      <param name="name">The name of the logger to retrieve</param>
      <returns>The logger object with the name specified</returns>
      <remarks>
        <para>
            Return a new logger instance.
            </para>
        <para>
            If a logger of that name already exists, then it will be
            returned. Otherwise, a new logger will be instantiated and
            then linked with its existing ancestors as well as children.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.Shutdown">
      <summary>
            Shutdown the repository
            </summary>
      <remarks>
        <para>
            Shutdown the repository. Can be overridden in a subclass.
            This base class implementation notifies the <see cref="E:log4net.Repository.LoggerRepositorySkeleton.ShutdownEvent" />
            listeners and all attached plugins of the shutdown event.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.ResetConfiguration">
      <summary>
            Reset the repositories configuration to a default state
            </summary>
      <remarks>
        <para>
            Reset all values contained in this instance to their
            default state.
            </para>
        <para>
            Existing loggers are not removed. They are just reset.
            </para>
        <para>
            This method should be used sparingly and with care as it will
            block all logging until it is completed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.Log(log4net.Core.LoggingEvent)">
      <summary>
            Log the logEvent through this repository.
            </summary>
      <param name="logEvent">the event to log</param>
      <remarks>
        <para>
            This method should not normally be used to log.
            The <see cref="T:log4net.ILog" /> interface should be used 
            for routine logging. This interface can be obtained
            using the <see cref="M:log4net.LogManager.GetLogger(System.String)" /> method.
            </para>
        <para>
            The <c>logEvent</c> is delivered to the appropriate logger and
            that logger is then responsible for logging the event.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.GetAppenders">
      <summary>
            Returns all the Appenders that are configured as an Array.
            </summary>
      <returns>All the Appenders</returns>
      <remarks>
        <para>
            Returns all the Appenders that are configured as an Array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.AddRenderer(System.Type,log4net.ObjectRenderer.IObjectRenderer)">
      <summary>
            Adds an object renderer for a specific class. 
            </summary>
      <param name="typeToRender">The type that will be rendered by the renderer supplied.</param>
      <param name="rendererInstance">The object renderer used to render the object.</param>
      <remarks>
        <para>
            Adds an object renderer for a specific class. 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.OnShutdown(System.EventArgs)">
      <summary>
            Notify the registered listeners that the repository is shutting down
            </summary>
      <param name="e">Empty EventArgs</param>
      <remarks>
        <para>
            Notify any listeners that this repository is shutting down.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.OnConfigurationReset(System.EventArgs)">
      <summary>
            Notify the registered listeners that the repository has had its configuration reset
            </summary>
      <param name="e">Empty EventArgs</param>
      <remarks>
        <para>
            Notify any listeners that this repository's configuration has been reset.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.OnConfigurationChanged(System.EventArgs)">
      <summary>
            Notify the registered listeners that the repository has had its configuration changed
            </summary>
      <param name="e">Empty EventArgs</param>
      <remarks>
        <para>
            Notify any listeners that this repository's configuration has changed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.LoggerRepositorySkeleton.RaiseConfigurationChanged(System.EventArgs)">
      <summary>
            Raise a configuration changed event on this repository
            </summary>
      <param name="e">EventArgs.Empty</param>
      <remarks>
        <para>
            Applications that programmatically change the configuration of the repository should
            raise this event notification to notify listeners.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.Name">
      <summary>
            The name of the repository
            </summary>
      <value>
            The string name of the repository
            </value>
      <remarks>
        <para>
            The name of this repository. The name is
            used to store and lookup the repositories 
            stored by the <see cref="T:log4net.Core.IRepositorySelector" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.Threshold">
      <summary>
            The threshold for all events in this repository
            </summary>
      <value>
            The threshold for all events in this repository
            </value>
      <remarks>
        <para>
            The threshold for all events in this repository
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.RendererMap">
      <summary>
            RendererMap accesses the object renderer map for this repository.
            </summary>
      <value>
            RendererMap accesses the object renderer map for this repository.
            </value>
      <remarks>
        <para>
            RendererMap accesses the object renderer map for this repository.
            </para>
        <para>
            The RendererMap holds a mapping between types and
            <see cref="T:log4net.ObjectRenderer.IObjectRenderer" /> objects.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.PluginMap">
      <summary>
            The plugin map for this repository.
            </summary>
      <value>
            The plugin map for this repository.
            </value>
      <remarks>
        <para>
            The plugin map holds the <see cref="T:log4net.Plugin.IPlugin" /> instances
            that have been attached to this repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.LevelMap">
      <summary>
            Get the level map for the Repository.
            </summary>
      <remarks>
        <para>
            Get the level map for the Repository.
            </para>
        <para>
            The level map defines the mappings between
            level names and <see cref="T:log4net.Core.Level" /> objects in
            this repository.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.Configured">
      <summary>
            Flag indicates if this repository has been configured.
            </summary>
      <value>
            Flag indicates if this repository has been configured.
            </value>
      <remarks>
        <para>
            Flag indicates if this repository has been configured.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.LoggerRepositorySkeleton.Properties">
      <summary>
            Repository specific properties
            </summary>
      <value>
            Repository specific properties
            </value>
      <remarks>
            These properties can be specified on a repository specific basis
            </remarks>
    </member>
    <member name="E:log4net.Repository.LoggerRepositorySkeleton.ShutdownEvent">
      <summary>
            Event to notify that the repository has been shutdown.
            </summary>
      <value>
            Event to notify that the repository has been shutdown.
            </value>
      <remarks>
        <para>
            Event raised when the repository has been shutdown.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Repository.LoggerRepositorySkeleton.ConfigurationReset">
      <summary>
            Event to notify that the repository has had its configuration reset.
            </summary>
      <value>
            Event to notify that the repository has had its configuration reset.
            </value>
      <remarks>
        <para>
            Event raised when the repository's configuration has been
            reset to default.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Repository.LoggerRepositorySkeleton.ConfigurationChanged">
      <summary>
            Event to notify that the repository has had its configuration changed.
            </summary>
      <value>
            Event to notify that the repository has had its configuration changed.
            </value>
      <remarks>
        <para>
            Event raised when the repository's configuration has been changed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.IBasicRepositoryConfigurator">
      <summary>
            Basic Configurator interface for repositories
            </summary>
      <remarks>
        <para>
            Interface used by basic configurator to configure a <see cref="T:log4net.Repository.ILoggerRepository" />
            with a default <see cref="T:log4net.Appender.IAppender" />.
            </para>
        <para>
            A <see cref="T:log4net.Repository.ILoggerRepository" /> should implement this interface to support
            configuration by the <see cref="T:log4net.Config.BasicConfigurator" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.IBasicRepositoryConfigurator.Configure(log4net.Appender.IAppender)">
      <summary>
            Initialize the repository using the specified appender
            </summary>
      <param name="appender">the appender to use to log all logging events</param>
      <remarks>
        <para>
            Configure the repository to route all logging events to the
            specified appender.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.IXmlRepositoryConfigurator">
      <summary>
            Configure repository using XML
            </summary>
      <remarks>
        <para>
            Interface used by Xml configurator to configure a <see cref="T:log4net.Repository.ILoggerRepository" />.
            </para>
        <para>
            A <see cref="T:log4net.Repository.ILoggerRepository" /> should implement this interface to support
            configuration by the <see cref="T:log4net.Config.XmlConfigurator" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.IXmlRepositoryConfigurator.Configure(System.Xml.XmlElement)">
      <summary>
            Initialize the repository using the specified config
            </summary>
      <param name="element">the element containing the root of the config</param>
      <remarks>
        <para>
            The schema for the XML configuration data is defined by
            the implementation.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.Hierarchy">
      <summary>
            Hierarchical organization of loggers
            </summary>
      <remarks>
        <para>
          <i>The casual user should not have to deal with this class
            directly.</i>
        </para>
        <para>
            This class is specialized in retrieving loggers by name and
            also maintaining the logger hierarchy. Implements the 
            <see cref="T:log4net.Repository.ILoggerRepository" /> interface.
            </para>
        <para>
            The structure of the logger hierarchy is maintained by the
            <see cref="M:log4net.Repository.Hierarchy.Hierarchy.GetLogger(System.String)" /> method. The hierarchy is such that children
            link to their parent but parents do not have any references to their
            children. Moreover, loggers can be instantiated in any order, in
            particular descendant before ancestor.
            </para>
        <para>
            In case a descendant is created before a particular ancestor,
            then it creates a provision node for the ancestor and adds itself
            to the provision node. Other descendants of the same ancestor add
            themselves to the previously created provision node.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Repository.Hierarchy.Hierarchy.LevelEntry">
      <summary>
            A class to hold the value, name and display name for a level
            </summary>
      <remarks>
        <para>
            A class to hold the value, name and display name for a level
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.LevelEntry.ToString">
      <summary>
            Override <c>Object.ToString</c> to return sensible debug info
            </summary>
      <returns>string info about this object</returns>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.LevelEntry.Value">
      <summary>
            Value of the level
            </summary>
      <remarks>
        <para>
            If the value is not set (defaults to -1) the value will be looked
            up for the current level with the same name.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.LevelEntry.Name">
      <summary>
            Name of the level
            </summary>
      <value>
            The name of the level
            </value>
      <remarks>
        <para>
            The name of the level.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.LevelEntry.DisplayName">
      <summary>
            Display name for the level
            </summary>
      <value>
            The display name of the level
            </value>
      <remarks>
        <para>
            The display name of the level.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.Hierarchy.PropertyEntry">
      <summary>
            A class to hold the key and data for a property set in the config file
            </summary>
      <remarks>
        <para>
            A class to hold the key and data for a property set in the config file
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.PropertyEntry.ToString">
      <summary>
            Override <c>Object.ToString</c> to return sensible debug info
            </summary>
      <returns>string info about this object</returns>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.PropertyEntry.Key">
      <summary>
            Property Key
            </summary>
      <value>
            Property Key
            </value>
      <remarks>
        <para>
            Property Key.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.PropertyEntry.Value">
      <summary>
            Property Value
            </summary>
      <value>
            Property Value
            </value>
      <remarks>
        <para>
            Property Value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.#ctor(log4net.Util.PropertiesDictionary)">
      <summary>
            Construct with properties
            </summary>
      <param name="properties">The properties to pass to this repository.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.#ctor(log4net.Repository.Hierarchy.ILoggerFactory)">
      <summary>
            Construct with a logger factory
            </summary>
      <param name="loggerFactory">The factory to use to create new logger instances.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> class with 
            the specified <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.#ctor(log4net.Util.PropertiesDictionary,log4net.Repository.Hierarchy.ILoggerFactory)">
      <summary>
            Construct with properties and a logger factory
            </summary>
      <param name="properties">The properties to pass to this repository.</param>
      <param name="loggerFactory">The factory to use to create new logger instances.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> class with 
            the specified <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.Exists(System.String)">
      <summary>
            Test if a logger exists
            </summary>
      <param name="name">The name of the logger to lookup</param>
      <returns>The Logger object with the name specified</returns>
      <remarks>
        <para>
            Check if the named logger exists in the hierarchy. If so return
            its reference, otherwise returns <c>null</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.GetCurrentLoggers">
      <summary>
            Returns all the currently defined loggers in the hierarchy as an Array
            </summary>
      <returns>All the defined loggers</returns>
      <remarks>
        <para>
            Returns all the currently defined loggers in the hierarchy as an Array.
            The root logger is <b>not</b> included in the returned
            enumeration.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.GetLogger(System.String)">
      <summary>
            Return a new logger instance named as the first parameter using
            the default factory.
            </summary>
      <remarks>
        <para>
            Return a new logger instance named as the first parameter using
            the default factory.
            </para>
        <para>
            If a logger of that name already exists, then it will be
            returned.  Otherwise, a new logger will be instantiated and
            then linked with its existing ancestors as well as children.
            </para>
      </remarks>
      <param name="name">The name of the logger to retrieve</param>
      <returns>The logger object with the name specified</returns>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.Shutdown">
      <summary>
            Shutting down a hierarchy will <i>safely</i> close and remove
            all appenders in all loggers including the root logger.
            </summary>
      <remarks>
        <para>
            Shutting down a hierarchy will <i>safely</i> close and remove
            all appenders in all loggers including the root logger.
            </para>
        <para>
            Some appenders need to be closed before the
            application exists. Otherwise, pending logging events might be
            lost.
            </para>
        <para>
            The <c>Shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.ResetConfiguration">
      <summary>
            Reset all values contained in this hierarchy instance to their default.
            </summary>
      <remarks>
        <para>
            Reset all values contained in this hierarchy instance to their
            default.  This removes all appenders from all loggers, sets
            the level of all non-root loggers to <c>null</c>,
            sets their additivity flag to <c>true</c> and sets the level
            of the root logger to <see cref="F:log4net.Core.Level.Debug" />. Moreover,
            message disabling is set its default "off" value.
            </para>
        <para>
            Existing loggers are not removed. They are just reset.
            </para>
        <para>
            This method should be used sparingly and with care as it will
            block all logging until it is completed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.Log(log4net.Core.LoggingEvent)">
      <summary>
            Log the logEvent through this hierarchy.
            </summary>
      <param name="logEvent">the event to log</param>
      <remarks>
        <para>
            This method should not normally be used to log.
            The <see cref="T:log4net.ILog" /> interface should be used 
            for routine logging. This interface can be obtained
            using the <see cref="M:log4net.LogManager.GetLogger(System.String)" /> method.
            </para>
        <para>
            The <c>logEvent</c> is delivered to the appropriate logger and
            that logger is then responsible for logging the event.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.GetAppenders">
      <summary>
            Returns all the Appenders that are currently configured
            </summary>
      <returns>An array containing all the currently configured appenders</returns>
      <remarks>
        <para>
            Returns all the <see cref="T:log4net.Appender.IAppender" /> instances that are currently configured.
            All the loggers are searched for appenders. The appenders may also be containers
            for appenders and these are also searched for additional loggers.
            </para>
        <para>
            The list returned is unordered but does not contain duplicates.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.CollectAppender(System.Collections.ArrayList,log4net.Appender.IAppender)">
      <summary>
            Collect the appenders from an <see cref="T:log4net.Core.IAppenderAttachable" />.
            The appender may also be a container.
            </summary>
      <param name="appenderList">
      </param>
      <param name="appender">
      </param>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.CollectAppenders(System.Collections.ArrayList,log4net.Core.IAppenderAttachable)">
      <summary>
            Collect the appenders from an <see cref="T:log4net.Core.IAppenderAttachable" /> container
            </summary>
      <param name="appenderList">
      </param>
      <param name="container">
      </param>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.BasicRepositoryConfigure(log4net.Appender.IAppender)">
      <summary>
            Initialize the log4net system using the specified appender
            </summary>
      <param name="appender">the appender to use to log all logging events</param>
      <remarks>
        <para>
            This method provides the same functionality as the 
            <see cref="M:log4net.Repository.IBasicRepositoryConfigurator.Configure(log4net.Appender.IAppender)" /> method implemented
            on this object, but it is protected and therefore can be called by subclasses.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.XmlRepositoryConfigure(System.Xml.XmlElement)">
      <summary>
            Initialize the log4net system using the specified config
            </summary>
      <param name="element">the element containing the root of the config</param>
      <remarks>
        <para>
            This method provides the same functionality as the 
            <see cref="M:log4net.Repository.IBasicRepositoryConfigurator.Configure(log4net.Appender.IAppender)" /> method implemented
            on this object, but it is protected and therefore can be called by subclasses.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.IsDisabled(log4net.Core.Level)">
      <summary>
            Test if this hierarchy is disabled for the specified <see cref="T:log4net.Core.Level" />.
            </summary>
      <param name="level">The level to check against.</param>
      <returns>
        <c>true</c> if the repository is disabled for the level argument, <c>false</c> otherwise.
            </returns>
      <remarks>
        <para>
            If this hierarchy has not been configured then this method will
            always return <c>true</c>.
            </para>
        <para>
            This method will return <c>true</c> if this repository is
            disabled for <c>level</c> object passed as parameter and
            <c>false</c> otherwise.
            </para>
        <para>
            See also the <see cref="P:log4net.Repository.ILoggerRepository.Threshold" /> property.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.Clear">
      <summary>
            Clear all logger definitions from the internal hashtable
            </summary>
      <remarks>
        <para>
            This call will clear all logger definitions from the internal
            hashtable. Invoking this method will irrevocably mess up the
            logger hierarchy.
            </para>
        <para>
            You should <b>really</b> know what you are doing before
            invoking this method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.GetLogger(System.String,log4net.Repository.Hierarchy.ILoggerFactory)">
      <summary>
            Return a new logger instance named as the first parameter using
            <paramref name="factory" />.
            </summary>
      <param name="name">The name of the logger to retrieve</param>
      <param name="factory">The factory that will make the new logger instance</param>
      <returns>The logger object with the name specified</returns>
      <remarks>
        <para>
            If a logger of that name already exists, then it will be
            returned. Otherwise, a new logger will be instantiated by the
            <paramref name="factory" /> parameter and linked with its existing
            ancestors as well as children.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.OnLoggerCreationEvent(log4net.Repository.Hierarchy.Logger)">
      <summary>
            Sends a logger creation event to all registered listeners
            </summary>
      <param name="logger">The newly created logger</param>
      <remarks>
            Raises the logger creation event.
            </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.UpdateParents(log4net.Repository.Hierarchy.Logger)">
      <summary>
            Updates all the parents of the specified logger
            </summary>
      <param name="log">The logger to update the parents for</param>
      <remarks>
        <para>
            This method loops through all the <i>potential</i> parents of
            <paramref name="log" />. There 3 possible cases:
            </para>
        <list type="number">
          <item>
            <term>No entry for the potential parent of <paramref name="log" /> exists</term>
            <description>
            		We create a ProvisionNode for this potential 
            		parent and insert <paramref name="log" /> in that provision node.
            		</description>
          </item>
          <item>
            <term>The entry is of type Logger for the potential parent.</term>
            <description>
            		The entry is <paramref name="log" />'s nearest existing parent. We 
            		update <paramref name="log" />'s parent field with this entry. We also break from 
            		he loop because updating our parent's parent is our parent's 
            		responsibility.
            		</description>
          </item>
          <item>
            <term>The entry is of type ProvisionNode for this potential parent.</term>
            <description>
            		We add <paramref name="log" /> to the list of children for this 
            		potential parent.
            		</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.UpdateChildren(log4net.Repository.Hierarchy.ProvisionNode,log4net.Repository.Hierarchy.Logger)">
      <summary>
            Replace a <see cref="T:log4net.Repository.Hierarchy.ProvisionNode" /> with a <see cref="T:log4net.Repository.Hierarchy.Logger" /> in the hierarchy.
            </summary>
      <param name="pn">
      </param>
      <param name="log">
      </param>
      <remarks>
        <para>
            We update the links for all the children that placed themselves
            in the provision node 'pn'. The second argument 'log' is a
            reference for the newly created Logger, parent of all the
            children in 'pn'.
            </para>
        <para>
            We loop on all the children 'c' in 'pn'.
            </para>
        <para>
            If the child 'c' has been already linked to a child of
            'log' then there is no need to update 'c'.
            </para>
        <para>
            Otherwise, we set log's parent field to c's parent and set
            c's parent field to log.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.AddLevel(log4net.Repository.Hierarchy.Hierarchy.LevelEntry)">
      <summary>
            Define or redefine a Level using the values in the <see cref="T:log4net.Repository.Hierarchy.Hierarchy.LevelEntry" /> argument
            </summary>
      <param name="levelEntry">the level values</param>
      <remarks>
        <para>
            Define or redefine a Level using the values in the <see cref="T:log4net.Repository.Hierarchy.Hierarchy.LevelEntry" /> argument
            </para>
        <para>
            Supports setting levels via the configuration file.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.Hierarchy.AddProperty(log4net.Repository.Hierarchy.Hierarchy.PropertyEntry)">
      <summary>
            Set a Property using the values in the <see cref="T:log4net.Repository.Hierarchy.Hierarchy.LevelEntry" /> argument
            </summary>
      <param name="propertyEntry">the property value</param>
      <remarks>
        <para>
            Set a Property using the values in the <see cref="T:log4net.Repository.Hierarchy.Hierarchy.LevelEntry" /> argument.
            </para>
        <para>
            Supports setting property values via the configuration file.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.EmittedNoAppenderWarning">
      <summary>
            Has no appender warning been emitted
            </summary>
      <remarks>
        <para>
            Flag to indicate if we have already issued a warning
            about not having an appender warning.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.Root">
      <summary>
            Get the root of this hierarchy
            </summary>
      <remarks>
        <para>
            Get the root of this hierarchy.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.Hierarchy.LoggerFactory">
      <summary>
            Gets or sets the default <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" /> instance.
            </summary>
      <value>The default <see cref="T:log4net.Repository.Hierarchy.ILoggerFactory" /></value>
      <remarks>
        <para>
            The logger factory is used to create logger instances.
            </para>
      </remarks>
    </member>
    <member name="E:log4net.Repository.Hierarchy.Hierarchy.LoggerCreatedEvent">
      <summary>
            Event used to notify that a logger has been created.
            </summary>
      <remarks>
        <para>
            Event raised when a logger is created.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.LoggerKey">
      <summary>
            Used internally to accelerate hash table searches.
            </summary>
      <remarks>
        <para>
            Internal class used to improve performance of 
            string keyed hashtables.
            </para>
        <para>
            The hashcode of the string is cached for reuse.
            The string is stored as an interned value.
            When comparing two <see cref="T:log4net.Repository.Hierarchy.LoggerKey" /> objects for equality 
            the reference equality of the interned strings is compared.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.Hierarchy.LoggerKey.#ctor(System.String)">
      <summary>
            Construct key with string name
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.LoggerKey" /> class 
            with the specified name.
            </para>
        <para>
            Stores the hashcode of the string and interns
            the string key to optimize comparisons.
            </para>
        <note>
            The Compact Framework 1.0 the <see cref="M:System.String.Intern(System.String)" />
            method does not work. On the Compact Framework
            the string keys are not interned nor are they
            compared by reference.
            </note>
      </remarks>
      <param name="name">The name of the logger.</param>
    </member>
    <member name="M:log4net.Repository.Hierarchy.LoggerKey.GetHashCode">
      <summary>
            Returns a hash code for the current instance.
            </summary>
      <returns>A hash code for the current instance.</returns>
      <remarks>
        <para>
            Returns the cached hashcode.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.LoggerKey.Equals(System.Object)">
      <summary>
            Determines whether two <see cref="T:log4net.Repository.Hierarchy.LoggerKey" /> instances 
            are equal.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:log4net.Repository.Hierarchy.LoggerKey" />.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:log4net.Repository.Hierarchy.LoggerKey" />; otherwise, <c>false</c>.
            </returns>
      <remarks>
        <para>
            Compares the references of the interned strings.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.ProvisionNode">
      <summary>
            Provision nodes are used where no logger instance has been specified
            </summary>
      <remarks>
        <para>
          <see cref="T:log4net.Repository.Hierarchy.ProvisionNode" /> instances are used in the 
            <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> when there is no specified 
            <see cref="T:log4net.Repository.Hierarchy.Logger" /> for that node.
            </para>
        <para>
            A provision node holds a list of child loggers on behalf of
            a logger that does not exist.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.Hierarchy.ProvisionNode.#ctor(log4net.Repository.Hierarchy.Logger)">
      <summary>
            Create a new provision node with child node
            </summary>
      <param name="log">A child logger to add to this node.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.ProvisionNode" /> class 
            with the specified child logger.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.RootLogger">
      <summary>
            The <see cref="T:log4net.Repository.Hierarchy.RootLogger" /> sits at the root of the logger hierarchy tree. 
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.Hierarchy.RootLogger" /> is a regular <see cref="T:log4net.Repository.Hierarchy.Logger" /> except 
            that it provides several guarantees.
            </para>
        <para>
            First, it cannot be assigned a <c>null</c>
            level. Second, since the root logger cannot have a parent, the
            <see cref="P:log4net.Repository.Hierarchy.RootLogger.EffectiveLevel" /> property always returns the value of the
            level field without walking the hierarchy.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Repository.Hierarchy.RootLogger.#ctor(log4net.Core.Level)">
      <summary>
            Construct a <see cref="T:log4net.Repository.Hierarchy.RootLogger" /></summary>
      <param name="level">The level to assign to the root logger.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.RootLogger" /> class with
            the specified logging level.
            </para>
        <para>
            The root logger names itself as "root". However, the root
            logger cannot be retrieved by name.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.RootLogger.EffectiveLevel">
      <summary>
            Gets the assigned level value without walking the logger hierarchy.
            </summary>
      <value>The assigned level value without walking the logger hierarchy.</value>
      <remarks>
        <para>
            Because the root logger cannot have a parent and its level
            must not be <c>null</c> this property just returns the
            value of <see cref="P:log4net.Repository.Hierarchy.Logger.Level" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Repository.Hierarchy.RootLogger.Level">
      <summary>
            Gets or sets the assigned <see cref="P:log4net.Repository.Hierarchy.RootLogger.Level" /> for the root logger.  
            </summary>
      <value>
            The <see cref="P:log4net.Repository.Hierarchy.RootLogger.Level" /> of the root logger.
            </value>
      <remarks>
        <para>
            Setting the level of the root logger to a <c>null</c> reference
            may have catastrophic results. We prevent this here.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.Hierarchy.XmlHierarchyConfigurator">
      <summary>
            Initializes the log4net environment using an XML DOM.
            </summary>
      <remarks>
        <para>
            Configures a <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> using an XML DOM.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.m_appenderBag">
      <summary>
            key: appenderName, value: appender.
            </summary>
    </member>
    <member name="F:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.m_hierarchy">
      <summary>
            The Hierarchy being configured.
            </summary>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.#ctor(log4net.Repository.Hierarchy.Hierarchy)">
      <summary>
            Construct the configurator for a hierarchy
            </summary>
      <param name="hierarchy">The hierarchy to build.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Repository.Hierarchy.XmlHierarchyConfigurator" /> class
            with the specified <see cref="T:log4net.Repository.Hierarchy.Hierarchy" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.Configure(System.Xml.XmlElement)">
      <summary>
            Configure the hierarchy by parsing a DOM tree of XML elements.
            </summary>
      <param name="element">The root element to parse.</param>
      <remarks>
        <para>
            Configure the hierarchy by parsing a DOM tree of XML elements.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.FindAppenderByReference(System.Xml.XmlElement)">
      <summary>
            Parse appenders by IDREF.
            </summary>
      <param name="appenderRef">The appender ref element.</param>
      <returns>The instance of the appender that the ref refers to.</returns>
      <remarks>
        <para>
            Parse an XML element that represents an appender and return 
            the appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ParseAppender(System.Xml.XmlElement)">
      <summary>
            Parses an appender element.
            </summary>
      <param name="appenderElement">The appender element.</param>
      <returns>The appender instance or <c>null</c> when parsing failed.</returns>
      <remarks>
        <para>
            Parse an XML element that represents an appender and return
            the appender instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ParseLogger(System.Xml.XmlElement)">
      <summary>
            Parses a logger element.
            </summary>
      <param name="loggerElement">The logger element.</param>
      <remarks>
        <para>
            Parse an XML element that represents a logger.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ParseRoot(System.Xml.XmlElement)">
      <summary>
            Parses the root logger element.
            </summary>
      <param name="rootElement">The root element.</param>
      <remarks>
        <para>
            Parse an XML element that represents the root logger.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ParseChildrenOfLoggerElement(System.Xml.XmlElement,log4net.Repository.Hierarchy.Logger,System.Boolean)">
      <summary>
            Parses the children of a logger element.
            </summary>
      <param name="catElement">The category element.</param>
      <param name="log">The logger instance.</param>
      <param name="isRoot">Flag to indicate if the logger is the root logger.</param>
      <remarks>
        <para>
            Parse the child elements of a &lt;logger&gt; element.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ParseRenderer(System.Xml.XmlElement)">
      <summary>
            Parses an object renderer.
            </summary>
      <param name="element">The renderer element.</param>
      <remarks>
        <para>
            Parse an XML element that represents a renderer.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ParseLevel(System.Xml.XmlElement,log4net.Repository.Hierarchy.Logger,System.Boolean)">
      <summary>
            Parses a level element.
            </summary>
      <param name="element">The level element.</param>
      <param name="log">The logger object to set the level on.</param>
      <param name="isRoot">Flag to indicate if the logger is the root logger.</param>
      <remarks>
        <para>
            Parse an XML element that represents a level.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.SetParameter(System.Xml.XmlElement,System.Object)">
      <summary>
            Sets a parameter on an object.
            </summary>
      <param name="element">The parameter element.</param>
      <param name="target">The object to set the parameter on.</param>
      <remarks>
            The parameter name must correspond to a writable property
            on the object. The value of the parameter is a string,
            therefore this function will attempt to set a string
            property first. If unable to set a string property it
            will inspect the property and its argument type. It will
            attempt to call a static method called <c>Parse</c> on the
            type of the property. This method will take a single
            string argument and return a value that can be used to
            set the property.
            </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.HasAttributesOrElements(System.Xml.XmlElement)">
      <summary>
            Test if an element has no attributes or child elements
            </summary>
      <param name="element">the element to inspect</param>
      <returns>
        <c>true</c> if the element has any attributes or child elements, <c>false</c> otherwise</returns>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.IsTypeConstructible(System.Type)">
      <summary>
            Test if a <see cref="T:System.Type" /> is constructible with <c>Activator.CreateInstance</c>.
            </summary>
      <param name="type">the type to inspect</param>
      <returns>
        <c>true</c> if the type is creatable using a default constructor, <c>false</c> otherwise</returns>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.FindMethodInfo(System.Type,System.String)">
      <summary>
            Look for a method on the <paramref name="targetType" /> that matches the <paramref name="name" /> supplied
            </summary>
      <param name="targetType">the type that has the method</param>
      <param name="name">the name of the method</param>
      <returns>the method info found</returns>
      <remarks>
        <para>
            The method must be a public instance method on the <paramref name="targetType" />.
            The method must be named <paramref name="name" /> or "Add" followed by <paramref name="name" />.
            The method must take a single parameter.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.ConvertStringTo(System.Type,System.String)">
      <summary>
            Converts a string value to a target type.
            </summary>
      <param name="type">The type of object to convert the string to.</param>
      <param name="value">The string value to use as the value of the object.</param>
      <returns>
        <para>
            An object of type <paramref name="type" /> with value <paramref name="value" /> or 
            <c>null</c> when the conversion could not be performed.
            </para>
      </returns>
    </member>
    <member name="M:log4net.Repository.Hierarchy.XmlHierarchyConfigurator.CreateObjectFromXml(System.Xml.XmlElement,System.Type,System.Type)">
      <summary>
            Creates an object as specified in XML.
            </summary>
      <param name="element">The XML element that contains the definition of the object.</param>
      <param name="defaultTargetType">The object type to use if not explicitly specified.</param>
      <param name="typeConstraint">The type that the returned object must be or must inherit from.</param>
      <returns>The object or <c>null</c></returns>
      <remarks>
        <para>
            Parse an XML element and create an object instance based on the configuration
            data.
            </para>
        <para>
            The type of the instance may be specified in the XML. If not
            specified then the <paramref name="defaultTargetType" /> is used
            as the type. However the type is specified it must support the
            <paramref name="typeConstraint" /> type.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.LoggerRepositoryShutdownEventHandler">
      <summary>
            Delegate used to handle logger repository shutdown event notifications
            </summary>
      <param name="sender">The <see cref="T:log4net.Repository.ILoggerRepository" /> that is shutting down.</param>
      <param name="e">Empty event args</param>
      <remarks>
        <para>
            Delegate used to handle logger repository shutdown event notifications.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.LoggerRepositoryConfigurationResetEventHandler">
      <summary>
            Delegate used to handle logger repository configuration reset event notifications
            </summary>
      <param name="sender">The <see cref="T:log4net.Repository.ILoggerRepository" /> that has had its configuration reset.</param>
      <param name="e">Empty event args</param>
      <remarks>
        <para>
            Delegate used to handle logger repository configuration reset event notifications.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Repository.LoggerRepositoryConfigurationChangedEventHandler">
      <summary>
            Delegate used to handle event notifications for logger repository configuration changes.
            </summary>
      <param name="sender">The <see cref="T:log4net.Repository.ILoggerRepository" /> that has had its configuration changed.</param>
      <param name="e">Empty event arguments.</param>
      <remarks>
        <para>
            Delegate used to handle event notifications for logger repository configuration changes.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.AppDomainPatternConverter">
      <summary>
            Write the name of the current AppDomain to the output
            </summary>
      <remarks>
        <para>
            Write the name of the current AppDomain to the output writer
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.AppDomainPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the name of the current AppDomain to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Writes name of the current AppDomain to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.DatePatternConverter">
      <summary>
            Write the current date to the output
            </summary>
      <remarks>
        <para>
            Date pattern converter, uses a <see cref="T:log4net.DateFormatter.IDateFormatter" /> to format 
            the current date and time to the writer as a string.
            </para>
        <para>
            The value of the <see cref="P:log4net.Util.PatternConverter.Option" /> determines 
            the formatting of the date. The following values are allowed:
            <list type="definition"><listheader><term>Option value</term><description>Output</description></listheader><item><term>ISO8601</term><description>
            		Uses the <see cref="T:log4net.DateFormatter.Iso8601DateFormatter" /> formatter. 
            		Formats using the <c>"yyyy-MM-dd HH:mm:ss,fff"</c> pattern.
            		</description></item><item><term>DATE</term><description>
            		Uses the <see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> formatter. 
            		Formats using the <c>"dd MMM yyyy HH:mm:ss,fff"</c> for example, <c>"06 Nov 1994 15:49:37,459"</c>.
            		</description></item><item><term>ABSOLUTE</term><description>
            		Uses the <see cref="T:log4net.DateFormatter.AbsoluteTimeDateFormatter" /> formatter. 
            		Formats using the <c>"HH:mm:ss,fff"</c> for example, <c>"15:49:37,459"</c>.
            		</description></item><item><term>other</term><description>
            		Any other pattern string uses the <see cref="T:log4net.DateFormatter.SimpleDateFormatter" /> formatter. 
            		This formatter passes the pattern string to the <see cref="T:System.DateTime" /><see cref="M:System.DateTime.ToString(System.String)" /> method.
            		For details on valid patterns see 
            		<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemglobalizationdatetimeformatinfoclasstopic.asp">DateTimeFormatInfo Class</a>.
            		</description></item></list></para>
        <para>
            The date and time is in the local time zone and is rendered in that zone.
            To output the time in Universal time see <see cref="T:log4net.Util.PatternStringConverters.UtcDatePatternConverter" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.DatePatternConverter.m_dateFormatter">
      <summary>
            The <see cref="T:log4net.DateFormatter.IDateFormatter" /> used to render the date to a string
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.DateFormatter.IDateFormatter" /> used to render the date to a string
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.DatePatternConverter.ActivateOptions">
      <summary>
            Initialize the converter options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Util.PatternStringConverters.DatePatternConverter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Util.PatternStringConverters.DatePatternConverter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Util.PatternStringConverters.DatePatternConverter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.DatePatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the current date to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Pass the current date and time to the <see cref="T:log4net.DateFormatter.IDateFormatter" />
            for it to render it to the writer.
            </para>
        <para>
            The date and time passed is in the local time zone.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.EnvironmentPatternConverter">
      <summary>
            Write an environment variable to the output
            </summary>
      <remarks>
        <para>
            Write an environment variable to the output writer.
            The value of the <see cref="P:log4net.Util.PatternConverter.Option" /> determines 
            the name of the variable to output.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.EnvironmentPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write an environment variable to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Writes the environment variable to the output <paramref name="writer" />.
            The name of the environment variable to output must be set
            using the <see cref="P:log4net.Util.PatternConverter.Option" />
            property.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.IdentityPatternConverter">
      <summary>
            Write the current thread identity to the output
            </summary>
      <remarks>
        <para>
            Write the current thread identity to the output writer
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.IdentityPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the current thread identity to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Writes the current thread identity to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.LiteralPatternConverter">
      <summary>
            Pattern converter for literal string instances in the pattern
            </summary>
      <remarks>
        <para>
            Writes the literal string value specified in the 
            <see cref="P:log4net.Util.PatternConverter.Option" /> property to 
            the output.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.LiteralPatternConverter.SetNext(log4net.Util.PatternConverter)">
      <summary>
            Set the next converter in the chain
            </summary>
      <param name="pc">The next pattern converter in the chain</param>
      <returns>The next pattern converter</returns>
      <remarks>
        <para>
            Special case the building of the pattern converter chain
            for <see cref="T:log4net.Util.PatternStringConverters.LiteralPatternConverter" /> instances. Two adjacent
            literals in the pattern can be represented by a single combined
            pattern converter. This implementation detects when a 
            <see cref="T:log4net.Util.PatternStringConverters.LiteralPatternConverter" /> is added to the chain
            after this converter and combines its value with this converter's
            literal value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.LiteralPatternConverter.Format(System.IO.TextWriter,System.Object)">
      <summary>
            Write the literal to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, not set</param>
      <remarks>
        <para>
            Override the formatting behavior to ignore the FormattingInfo
            because we have a literal instead.
            </para>
        <para>
            Writes the value of <see cref="P:log4net.Util.PatternConverter.Option" />
            to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.LiteralPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Convert this pattern into the rendered message
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">null, not set</param>
      <remarks>
        <para>
            This method is not used.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.NewLinePatternConverter">
      <summary>
            Writes a newline to the output
            </summary>
      <remarks>
        <para>
            Writes the system dependent line terminator to the output.
            This behavior can be overridden by setting the <see cref="P:log4net.Util.PatternConverter.Option" />:
            </para>
        <list type="definition">
          <listheader>
            <term>Option Value</term>
            <description>Output</description>
          </listheader>
          <item>
            <term>DOS</term>
            <description>DOS or Windows line terminator <c>"\r\n"</c></description>
          </item>
          <item>
            <term>UNIX</term>
            <description>UNIX line terminator <c>"\n"</c></description>
          </item>
        </list>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.NewLinePatternConverter.ActivateOptions">
      <summary>
            Initialize the converter
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Util.PatternStringConverters.NewLinePatternConverter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Util.PatternStringConverters.NewLinePatternConverter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Util.PatternStringConverters.NewLinePatternConverter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.ProcessIdPatternConverter">
      <summary>
            Write the current process ID to the output
            </summary>
      <remarks>
        <para>
            Write the current process ID to the output writer
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.ProcessIdPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the current process ID to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Write the current process ID to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.PropertyPatternConverter">
      <summary>
            Property pattern converter
            </summary>
      <remarks>
        <para>
            This pattern converter reads the thread and global properties.
            The thread properties take priority over global properties.
            See <see cref="P:log4net.ThreadContext.Properties" /> for details of the 
            thread properties. See <see cref="P:log4net.GlobalContext.Properties" /> for
            details of the global properties.
            </para>
        <para>
            If the <see cref="P:log4net.Util.PatternConverter.Option" /> is specified then that will be used to
            lookup a single property. If no <see cref="P:log4net.Util.PatternConverter.Option" /> is specified
            then all properties will be dumped as a list of key value pairs.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.PropertyPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the property value to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Writes out the value of a named property. The property name
            should be set in the <see cref="P:log4net.Util.PatternConverter.Option" />
            property.
            </para>
        <para>
            If the <see cref="P:log4net.Util.PatternConverter.Option" /> is set to <c>null</c>
            then all the properties are written as key value pairs.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.RandomStringPatternConverter">
      <summary>
            A Pattern converter that generates a string of random characters
            </summary>
      <remarks>
        <para>
            The converter generates a string of random characters. By default
            the string is length 4. This can be changed by setting the <see cref="P:log4net.Util.PatternConverter.Option" />
            to the string value of the length required.
            </para>
        <para>
            The random characters in the string are limited to uppercase letters
            and numbers only.
            </para>
        <para>
            The random number generator used by this class is not cryptographically secure.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.RandomStringPatternConverter.s_random">
      <summary>
            Shared random number generator
            </summary>
    </member>
    <member name="F:log4net.Util.PatternStringConverters.RandomStringPatternConverter.m_length">
      <summary>
            Length of random string to generate. Default length 4.
            </summary>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.RandomStringPatternConverter.ActivateOptions">
      <summary>
            Initialize the converter options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Util.PatternStringConverters.RandomStringPatternConverter.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Util.PatternStringConverters.RandomStringPatternConverter.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Util.PatternStringConverters.RandomStringPatternConverter.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.RandomStringPatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write a randoim string to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Write a randoim string to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.UserNamePatternConverter">
      <summary>
            Write the current threads username to the output
            </summary>
      <remarks>
        <para>
            Write the current threads username to the output writer
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.UserNamePatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the current threads username to the output
            </summary>
      <param name="writer">the writer to write to</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Write the current threads username to the output <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternStringConverters.UtcDatePatternConverter">
      <summary>
            Write the UTC date time to the output
            </summary>
      <remarks>
        <para>
            Date pattern converter, uses a <see cref="T:log4net.DateFormatter.IDateFormatter" /> to format 
            the current date and time in Universal time.
            </para>
        <para>
            See the <see cref="T:log4net.Util.PatternStringConverters.DatePatternConverter" /> for details on the date pattern syntax.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.PatternStringConverters.DatePatternConverter" />
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.PatternStringConverters.UtcDatePatternConverter.Convert(System.IO.TextWriter,System.Object)">
      <summary>
            Write the current date and time to the output
            </summary>
      <param name="writer">
        <see cref="T:System.IO.TextWriter" /> that will receive the formatted result.</param>
      <param name="state">null, state is not set</param>
      <remarks>
        <para>
            Pass the current date and time to the <see cref="T:log4net.DateFormatter.IDateFormatter" />
            for it to render it to the writer.
            </para>
        <para>
            The date is in Universal time when it is rendered.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.PatternStringConverters.DatePatternConverter" />
    </member>
    <member name="T:log4net.Util.TypeConverters.BooleanConverter">
      <summary>
            Type converter for Boolean.
            </summary>
      <remarks>
        <para>
            Supports conversion from string to <c>bool</c> type.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.ConverterRegistry" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertTo" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.BooleanConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="sourceType" /> is
            the <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.BooleanConverter.ConvertFrom(System.Object)">
      <summary>
            Convert the source object to the type supported by this object
            </summary>
      <param name="source">the object to convert</param>
      <returns>the converted object</returns>
      <remarks>
        <para>
            Uses the <see cref="M:System.Boolean.Parse(System.String)" /> method to convert the
            <see cref="T:System.String" /> argument to a <see cref="T:System.Boolean" />.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            target type. To check for this condition use the <see cref="M:log4net.Util.TypeConverters.BooleanConverter.CanConvertFrom(System.Type)" />
            method.
            </exception>
    </member>
    <member name="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
      <summary>
            Exception base type for conversion errors.
            </summary>
      <remarks>
        <para>
            This type extends <see cref="T:System.ApplicationException" />. It
            does not add any new functionality but does differentiate the
            type of exception being thrown.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConversionNotSupportedException.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConversionNotSupportedException.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="message">A message to include with the exception.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class
            with the specified message.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConversionNotSupportedException.#ctor(System.String,System.Exception)">
      <summary>
            Constructor
            </summary>
      <param name="message">A message to include with the exception.</param>
      <param name="innerException">A nested exception to include.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class
            with the specified message and inner exception.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConversionNotSupportedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serialization constructor
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class 
            with serialized data.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConversionNotSupportedException.Create(System.Type,System.Object)">
      <summary>
            Creates a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class.
            </summary>
      <param name="destinationType">The conversion destination type.</param>
      <param name="sourceValue">The value to convert.</param>
      <returns>An instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" />.</returns>
      <remarks>
        <para>
            Creates a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConversionNotSupportedException.Create(System.Type,System.Object,System.Exception)">
      <summary>
            Creates a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class.
            </summary>
      <param name="destinationType">The conversion destination type.</param>
      <param name="sourceValue">The value to convert.</param>
      <param name="innerException">A nested exception to include.</param>
      <returns>An instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" />.</returns>
      <remarks>
        <para>
            Creates a new instance of the <see cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException" /> class.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.TypeConverters.ConverterRegistry">
      <summary>
            Register of type converters for specific types.
            </summary>
      <remarks>
        <para>
            Maintains a registry of type converters used to convert between
            types.
            </para>
        <para>
            Use the <see cref="M:log4net.Util.TypeConverters.ConverterRegistry.AddConverter(System.Type,System.Object)" /> and 
            <see cref="M:log4net.Util.TypeConverters.ConverterRegistry.AddConverter(System.Type,System.Type)" /> methods to register new converters.
            The <see cref="M:log4net.Util.TypeConverters.ConverterRegistry.GetConvertTo(System.Type,System.Type)" /> and <see cref="M:log4net.Util.TypeConverters.ConverterRegistry.GetConvertFrom(System.Type)" /> methods
            lookup appropriate converters to use.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertTo" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.TypeConverters.ConverterRegistry.s_type2converter">
      <summary>
            Mapping from <see cref="T:System.Type" /> to type converter.
            </summary>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.#ctor">
      <summary>
            Private constructor
            </summary>
      <remarks>
            Initializes a new instance of the <see cref="T:log4net.Util.TypeConverters.ConverterRegistry" /> class.
            </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.AddConverter(System.Type,System.Object)">
      <summary>
            Adds a converter for a specific type.
            </summary>
      <param name="destinationType">The type being converted to.</param>
      <param name="converter">The type converter to use to convert to the destination type.</param>
      <remarks>
        <para>
            Adds a converter instance for a specific type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.AddConverter(System.Type,System.Type)">
      <summary>
            Adds a converter for a specific type.
            </summary>
      <param name="destinationType">The type being converted to.</param>
      <param name="converterType">The type of the type converter to use to convert to the destination type.</param>
      <remarks>
        <para>
            Adds a converter <see cref="T:System.Type" /> for a specific type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.GetConvertTo(System.Type,System.Type)">
      <summary>
            Gets the type converter to use to convert values to the destination type.
            </summary>
      <param name="sourceType">The type being converted from.</param>
      <param name="destinationType">The type being converted to.</param>
      <returns>
            The type converter instance to use for type conversions or <c>null</c> 
            if no type converter is found.
            </returns>
      <remarks>
        <para>
            Gets the type converter to use to convert values to the destination type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.GetConvertFrom(System.Type)">
      <summary>
            Gets the type converter to use to convert values to the destination type.
            </summary>
      <param name="destinationType">The type being converted to.</param>
      <returns>
            The type converter instance to use for type conversions or <c>null</c> 
            if no type converter is found.
            </returns>
      <remarks>
        <para>
            Gets the type converter to use to convert values to the destination type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.GetConverterFromAttribute(System.Type)">
      <summary>
            Lookups the type converter to use as specified by the attributes on the 
            destination type.
            </summary>
      <param name="destinationType">The type being converted to.</param>
      <returns>
            The type converter instance to use for type conversions or <c>null</c> 
            if no type converter is found.
            </returns>
    </member>
    <member name="M:log4net.Util.TypeConverters.ConverterRegistry.CreateConverterInstance(System.Type)">
      <summary>
            Creates the instance of the type converter.
            </summary>
      <param name="converterType">The type of the type converter.</param>
      <returns>
            The type converter instance to use for type conversions or <c>null</c> 
            if no type converter is found.
            </returns>
      <remarks>
        <para>
            The type specified for the type converter must implement 
            the <see cref="T:log4net.Util.TypeConverters.IConvertFrom" /> or <see cref="T:log4net.Util.TypeConverters.IConvertTo" /> interfaces 
            and must have a public default (no argument) constructor.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.TypeConverters.EncodingConverter">
      <summary>
            Supports conversion from string to <see cref="T:System.Text.Encoding" /> type.
            </summary>
      <remarks>
        <para>
            Supports conversion from string to <see cref="T:System.Text.Encoding" /> type.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.ConverterRegistry" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertTo" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.EncodingConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="sourceType" /> is
            the <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.EncodingConverter.ConvertFrom(System.Object)">
      <summary>
            Overrides the ConvertFrom method of IConvertFrom.
            </summary>
      <param name="source">the object to convert to an encoding</param>
      <returns>the encoding</returns>
      <remarks>
        <para>
            Uses the <see cref="M:System.Text.Encoding.GetEncoding(System.String)" /> method to 
            convert the <see cref="T:System.String" /> argument to an <see cref="T:System.Text.Encoding" />.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            target type. To check for this condition use the <see cref="M:log4net.Util.TypeConverters.EncodingConverter.CanConvertFrom(System.Type)" />
            method.
            </exception>
    </member>
    <member name="T:log4net.Util.TypeConverters.IConvertTo">
      <summary>
            Interface supported by type converters
            </summary>
      <remarks>
        <para>
            This interface supports conversion from a single type to arbitrary types.
            See <see cref="T:log4net.Util.TypeConverters.TypeConverterAttribute" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.IConvertTo.CanConvertTo(System.Type)">
      <summary>
            Returns whether this converter can convert the object to the specified type
            </summary>
      <param name="targetType">A Type that represents the type you want to convert to</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Test if the type supported by this converter can be converted to the
            <paramref name="targetType" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.IConvertTo.ConvertTo(System.Object,System.Type)">
      <summary>
            Converts the given value object to the specified type, using the arguments
            </summary>
      <param name="source">the object to convert</param>
      <param name="targetType">The Type to convert the value parameter to</param>
      <returns>the converted object</returns>
      <remarks>
        <para>
            Converts the <paramref name="source" /> (which must be of the type supported
            by this converter) to the <paramref name="targetType" /> specified..
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.TypeConverters.IPAddressConverter">
      <summary>
            Supports conversion from string to <see cref="T:System.Net.IPAddress" /> type.
            </summary>
      <remarks>
        <para>
            Supports conversion from string to <see cref="T:System.Net.IPAddress" /> type.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.ConverterRegistry" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.TypeConverters.IPAddressConverter.validIpAddressChars">
      <summary>
            Valid characters in an IPv4 or IPv6 address string. (Does not support subnets)
            </summary>
    </member>
    <member name="M:log4net.Util.TypeConverters.IPAddressConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="sourceType" /> is
            the <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.IPAddressConverter.ConvertFrom(System.Object)">
      <summary>
            Overrides the ConvertFrom method of IConvertFrom.
            </summary>
      <param name="source">the object to convert to an IPAddress</param>
      <returns>the IPAddress</returns>
      <remarks>
        <para>
            Uses the <see cref="M:System.Net.IPAddress.Parse(System.String)" /> method to convert the
            <see cref="T:System.String" /> argument to an <see cref="T:System.Net.IPAddress" />.
            If that fails then the string is resolved as a DNS hostname.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            target type. To check for this condition use the <see cref="M:log4net.Util.TypeConverters.IPAddressConverter.CanConvertFrom(System.Type)" />
            method.
            </exception>
    </member>
    <member name="T:log4net.Util.TypeConverters.PatternLayoutConverter">
      <summary>
            Supports conversion from string to <see cref="T:log4net.Layout.PatternLayout" /> type.
            </summary>
      <remarks>
        <para>
            Supports conversion from string to <see cref="T:log4net.Layout.PatternLayout" /> type.
            </para>
        <para>
            The string is used as the <see cref="P:log4net.Layout.PatternLayout.ConversionPattern" /> 
            of the <see cref="T:log4net.Layout.PatternLayout" />.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.ConverterRegistry" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertTo" />
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.PatternLayoutConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="sourceType" /> is
            the <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.PatternLayoutConverter.ConvertFrom(System.Object)">
      <summary>
            Overrides the ConvertFrom method of IConvertFrom.
            </summary>
      <param name="source">the object to convert to a PatternLayout</param>
      <returns>the PatternLayout</returns>
      <remarks>
        <para>
            Creates and returns a new <see cref="T:log4net.Layout.PatternLayout" /> using
            the <paramref name="source" /><see cref="T:System.String" /> as the
            <see cref="P:log4net.Layout.PatternLayout.ConversionPattern" />.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            target type. To check for this condition use the <see cref="M:log4net.Util.TypeConverters.PatternLayoutConverter.CanConvertFrom(System.Type)" />
            method.
            </exception>
    </member>
    <member name="T:log4net.Util.TypeConverters.PatternStringConverter">
      <summary>
            Convert between string and <see cref="T:log4net.Util.PatternString" /></summary>
      <remarks>
        <para>
            Supports conversion from string to <see cref="T:log4net.Util.PatternString" /> type, 
            and from a <see cref="T:log4net.Util.PatternString" /> type to a string.
            </para>
        <para>
            The string is used as the <see cref="P:log4net.Util.PatternString.ConversionPattern" /> 
            of the <see cref="T:log4net.Util.PatternString" />.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.ConverterRegistry" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertTo" />
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.PatternStringConverter.CanConvertTo(System.Type)">
      <summary>
            Can the target type be converted to the type supported by this object
            </summary>
      <param name="targetType">A <see cref="T:System.Type" /> that represents the type you want to convert to</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="targetType" /> is
            assignable from a <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.PatternStringConverter.ConvertTo(System.Object,System.Type)">
      <summary>
            Converts the given value object to the specified type, using the arguments
            </summary>
      <param name="source">the object to convert</param>
      <param name="targetType">The Type to convert the value parameter to</param>
      <returns>the converted object</returns>
      <remarks>
        <para>
            Uses the <see cref="M:log4net.Util.PatternString.Format" /> method to convert the
            <see cref="T:log4net.Util.PatternString" /> argument to a <see cref="T:System.String" />.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            <paramref name="targetType" />. To check for this condition use the 
            <see cref="M:log4net.Util.TypeConverters.PatternStringConverter.CanConvertTo(System.Type)" /> method.
            </exception>
    </member>
    <member name="M:log4net.Util.TypeConverters.PatternStringConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="sourceType" /> is
            the <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.PatternStringConverter.ConvertFrom(System.Object)">
      <summary>
            Overrides the ConvertFrom method of IConvertFrom.
            </summary>
      <param name="source">the object to convert to a PatternString</param>
      <returns>the PatternString</returns>
      <remarks>
        <para>
            Creates and returns a new <see cref="T:log4net.Util.PatternString" /> using
            the <paramref name="source" /><see cref="T:System.String" /> as the
            <see cref="P:log4net.Util.PatternString.ConversionPattern" />.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            target type. To check for this condition use the <see cref="M:log4net.Util.TypeConverters.PatternStringConverter.CanConvertFrom(System.Type)" />
            method.
            </exception>
    </member>
    <member name="T:log4net.Util.TypeConverters.TypeConverter">
      <summary>
            Supports conversion from string to <see cref="T:System.Type" /> type.
            </summary>
      <remarks>
        <para>
            Supports conversion from string to <see cref="T:System.Type" /> type.
            </para>
      </remarks>
      <seealso cref="T:log4net.Util.TypeConverters.ConverterRegistry" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertFrom" />
      <seealso cref="T:log4net.Util.TypeConverters.IConvertTo" />
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.TypeConverters.TypeConverter.CanConvertFrom(System.Type)">
      <summary>
            Can the source type be converted to the type supported by this object
            </summary>
      <param name="sourceType">the type to convert</param>
      <returns>true if the conversion is possible</returns>
      <remarks>
        <para>
            Returns <c>true</c> if the <paramref name="sourceType" /> is
            the <see cref="T:System.String" /> type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.TypeConverter.ConvertFrom(System.Object)">
      <summary>
            Overrides the ConvertFrom method of IConvertFrom.
            </summary>
      <param name="source">the object to convert to a Type</param>
      <returns>the Type</returns>
      <remarks>
        <para>
            Uses the <see cref="M:System.Type.GetType(System.String,System.Boolean)" /> method to convert the
            <see cref="T:System.String" /> argument to a <see cref="T:System.Type" />.
            Additional effort is made to locate partially specified types
            by searching the loaded assemblies.
            </para>
      </remarks>
      <exception cref="T:log4net.Util.TypeConverters.ConversionNotSupportedException">
            The <paramref name="source" /> object cannot be converted to the
            target type. To check for this condition use the <see cref="M:log4net.Util.TypeConverters.TypeConverter.CanConvertFrom(System.Type)" />
            method.
            </exception>
    </member>
    <member name="T:log4net.Util.TypeConverters.TypeConverterAttribute">
      <summary>
            Attribute used to associate a type converter
            </summary>
      <remarks>
        <para>
            Class and Interface level attribute that specifies a type converter
            to use with the associated type.
            </para>
        <para>
            To associate a type converter with a target type apply a
            <c>TypeConverterAttribute</c> to the target type. Specify the
            type of the type converter on the attribute.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.TypeConverters.TypeConverterAttribute.m_typeName">
      <summary>
            The string type name of the type converter
            </summary>
    </member>
    <member name="M:log4net.Util.TypeConverters.TypeConverterAttribute.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.TypeConverterAttribute.#ctor(System.String)">
      <summary>
            Create a new type converter attribute for the specified type name
            </summary>
      <param name="typeName">The string type name of the type converter</param>
      <remarks>
        <para>
            The type specified must implement the <see cref="T:log4net.Util.TypeConverters.IConvertFrom" /> 
            or the <see cref="T:log4net.Util.TypeConverters.IConvertTo" /> interfaces.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TypeConverters.TypeConverterAttribute.#ctor(System.Type)">
      <summary>
            Create a new type converter attribute for the specified type
            </summary>
      <param name="converterType">The type of the type converter</param>
      <remarks>
        <para>
            The type specified must implement the <see cref="T:log4net.Util.TypeConverters.IConvertFrom" /> 
            or the <see cref="T:log4net.Util.TypeConverters.IConvertTo" /> interfaces.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.TypeConverters.TypeConverterAttribute.ConverterTypeName">
      <summary>
            The string type name of the type converter 
            </summary>
      <value>
            The string type name of the type converter 
            </value>
      <remarks>
        <para>
            The type specified must implement the <see cref="T:log4net.Util.TypeConverters.IConvertFrom" /> 
            or the <see cref="T:log4net.Util.TypeConverters.IConvertTo" /> interfaces.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.AppenderAttachedImpl">
      <summary>
            A straightforward implementation of the <see cref="T:log4net.Core.IAppenderAttachable" /> interface.
            </summary>
      <remarks>
        <para>
            This is the default implementation of the <see cref="T:log4net.Core.IAppenderAttachable" />
            interface. Implementors of the <see cref="T:log4net.Core.IAppenderAttachable" /> interface
            should aggregate an instance of this type.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.AppenderAttachedImpl.m_appenderList">
      <summary>
            List of appenders
            </summary>
    </member>
    <member name="F:log4net.Util.AppenderAttachedImpl.m_appenderArray">
      <summary>
            Array of appenders, used to cache the m_appenderList
            </summary>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.AppenderAttachedImpl" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.AppendLoopOnAppenders(log4net.Core.LoggingEvent)">
      <summary>
            Append on on all attached appenders.
            </summary>
      <param name="loggingEvent">The event being logged.</param>
      <returns>The number of appenders called.</returns>
      <remarks>
        <para>
            Calls the <see cref="M:log4net.Appender.IAppender.DoAppend(log4net.Core.LoggingEvent)" /> method on all 
            attached appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.AppendLoopOnAppenders(log4net.Core.LoggingEvent[])">
      <summary>
            Append on on all attached appenders.
            </summary>
      <param name="loggingEvents">The array of events being logged.</param>
      <returns>The number of appenders called.</returns>
      <remarks>
        <para>
            Calls the <see cref="M:log4net.Appender.IAppender.DoAppend(log4net.Core.LoggingEvent)" /> method on all 
            attached appenders.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.CallAppend(log4net.Appender.IAppender,log4net.Core.LoggingEvent[])">
      <summary>
            Calls the DoAppende method on the <see cref="T:log4net.Appender.IAppender" /> with 
            the <see cref="T:log4net.Core.LoggingEvent" /> objects supplied.
            </summary>
      <param name="appender">The appender</param>
      <param name="loggingEvents">The events</param>
      <remarks>
        <para>
            If the <paramref name="appender" /> supports the <see cref="T:log4net.Appender.IBulkAppender" />
            interface then the <paramref name="loggingEvents" /> will be passed 
            through using that interface. Otherwise the <see cref="T:log4net.Core.LoggingEvent" />
            objects in the array will be passed one at a time.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.AddAppender(log4net.Appender.IAppender)">
      <summary>
            Attaches an appender.
            </summary>
      <param name="newAppender">The appender to add.</param>
      <remarks>
        <para>
            If the appender is already in the list it won't be added again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.GetAppender(System.String)">
      <summary>
            Gets an attached appender with the specified name.
            </summary>
      <param name="name">The name of the appender to get.</param>
      <returns>
            The appender with the name specified, or <c>null</c> if no appender with the
            specified name is found.
            </returns>
      <remarks>
        <para>
            Lookup an attached appender by name.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.RemoveAllAppenders">
      <summary>
            Removes all attached appenders.
            </summary>
      <remarks>
        <para>
            Removes and closes all attached appenders
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.RemoveAppender(log4net.Appender.IAppender)">
      <summary>
            Removes the specified appender from the list of attached appenders.
            </summary>
      <param name="appender">The appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
        <para>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.AppenderAttachedImpl.RemoveAppender(System.String)">
      <summary>
            Removes the appender with the specified name from the list of appenders.
            </summary>
      <param name="name">The name of the appender to remove.</param>
      <returns>The appender removed from the list</returns>
      <remarks>
        <para>
            The appender removed is not closed.
            If you are discarding the appender you must call
            <see cref="M:log4net.Appender.IAppender.Close" /> on the appender removed.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.AppenderAttachedImpl.Appenders">
      <summary>
            Gets all attached appenders.
            </summary>
      <returns>
            A collection of attached appenders, or <c>null</c> if there
            are no attached appenders.
            </returns>
      <remarks>
        <para>
            The read only collection of all currently attached appenders.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.CompositeProperties">
      <summary>
            This class aggregates several PropertiesDictionary collections together.
            </summary>
      <remarks>
        <para>
            Provides a dictionary style lookup over an ordered list of
            <see cref="T:log4net.Util.PropertiesDictionary" /> collections.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.CompositeProperties.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.CompositeProperties" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CompositeProperties.Add(log4net.Util.ReadOnlyPropertiesDictionary)">
      <summary>
            Add a Properties Dictionary to this composite collection
            </summary>
      <param name="properties">the properties to add</param>
      <remarks>
        <para>
            Properties dictionaries added first take precedence over dictionaries added
            later.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CompositeProperties.Flatten">
      <summary>
            Flatten this composite collection into a single properties dictionary
            </summary>
      <returns>the flattened dictionary</returns>
      <remarks>
        <para>
            Reduces the collection of ordered dictionaries to a single dictionary
            containing the resultant values for the keys.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.CompositeProperties.Item(System.String)">
      <summary>
            Gets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Looks up the value for the <paramref name="key" /> specified.
            The <see cref="T:log4net.Util.PropertiesDictionary" /> collections are searched
            in the order in which they were added to this collection. The value
            returned is the value held by the first collection that contains
            the specified key.
            </para>
        <para>
            If none of the collections contain the specified key then
            <c>null</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ContextPropertiesBase">
      <summary>
            Base class for Context Properties implementations
            </summary>
      <remarks>
        <para>
            This class defines a basic property get set accessor
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="P:log4net.Util.ContextPropertiesBase.Item(System.String)">
      <summary>
            Gets or sets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Gets or sets the value of a property
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.TextWriterAdapter">
      <summary>
            Adapter that extends <see cref="T:System.IO.TextWriter" /> and forwards all
            messages to an instance of <see cref="T:System.IO.TextWriter" />.
            </summary>
      <remarks>
        <para>
            Adapter that extends <see cref="T:System.IO.TextWriter" /> and forwards all
            messages to an instance of <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.TextWriterAdapter.m_writer">
      <summary>
            The writer to forward messages to
            </summary>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.#ctor(System.IO.TextWriter)">
      <summary>
            Create an instance of <see cref="T:log4net.Util.TextWriterAdapter" /> that forwards all
            messages to a <see cref="T:System.IO.TextWriter" />.
            </summary>
      <param name="writer">The <see cref="T:System.IO.TextWriter" /> to forward to</param>
      <remarks>
        <para>
            Create an instance of <see cref="T:log4net.Util.TextWriterAdapter" /> that forwards all
            messages to a <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.Close">
      <summary>
            Closes the writer and releases any system resources associated with the writer
            </summary>
      <remarks>
        <para>
        </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.Dispose(System.Boolean)">
      <summary>
            Dispose this writer
            </summary>
      <param name="disposing">flag indicating if we are being disposed</param>
      <remarks>
        <para>
            Dispose this writer
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.Flush">
      <summary>
            Flushes any buffered output
            </summary>
      <remarks>
        <para>
            Clears all buffers for the writer and causes any buffered data to be written 
            to the underlying device
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.Write(System.Char)">
      <summary>
            Writes a character to the wrapped TextWriter
            </summary>
      <param name="value">the value to write to the TextWriter</param>
      <remarks>
        <para>
            Writes a character to the wrapped TextWriter
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.Write(System.Char[],System.Int32,System.Int32)">
      <summary>
            Writes a character buffer to the wrapped TextWriter
            </summary>
      <param name="buffer">the data buffer</param>
      <param name="index">the start index</param>
      <param name="count">the number of characters to write</param>
      <remarks>
        <para>
            Writes a character buffer to the wrapped TextWriter
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.TextWriterAdapter.Write(System.String)">
      <summary>
            Writes a string to the wrapped TextWriter
            </summary>
      <param name="value">the value to write to the TextWriter</param>
      <remarks>
        <para>
            Writes a string to the wrapped TextWriter
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.TextWriterAdapter.Writer">
      <summary>
            Gets or sets the underlying <see cref="T:System.IO.TextWriter" />.
            </summary>
      <value>
            The underlying <see cref="T:System.IO.TextWriter" />.
            </value>
      <remarks>
        <para>
            Gets or sets the underlying <see cref="T:System.IO.TextWriter" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.TextWriterAdapter.Encoding">
      <summary>
            The Encoding in which the output is written
            </summary>
      <value>
            The <see cref="P:log4net.Util.TextWriterAdapter.Encoding" /></value>
      <remarks>
        <para>
            The Encoding in which the output is written
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.TextWriterAdapter.FormatProvider">
      <summary>
            Gets an object that controls formatting
            </summary>
      <value>
            The format provider
            </value>
      <remarks>
        <para>
            Gets an object that controls formatting
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.TextWriterAdapter.NewLine">
      <summary>
            Gets or sets the line terminator string used by the TextWriter
            </summary>
      <value>
            The line terminator to use
            </value>
      <remarks>
        <para>
            Gets or sets the line terminator string used by the TextWriter
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.QuietTextWriter">
      <summary>
        <see cref="T:System.IO.TextWriter" /> that does not leak exceptions
            </summary>
      <remarks>
        <para>
          <see cref="T:log4net.Util.QuietTextWriter" /> does not throw exceptions when things go wrong. 
            Instead, it delegates error handling to its <see cref="T:log4net.Core.IErrorHandler" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.QuietTextWriter.m_errorHandler">
      <summary>
            The error handler instance to pass all errors to
            </summary>
    </member>
    <member name="F:log4net.Util.QuietTextWriter.m_closed">
      <summary>
            Flag to indicate if this writer is closed
            </summary>
    </member>
    <member name="M:log4net.Util.QuietTextWriter.#ctor(System.IO.TextWriter,log4net.Core.IErrorHandler)">
      <summary>
            Constructor
            </summary>
      <param name="writer">the writer to actually write to</param>
      <param name="errorHandler">the error handler to report error to</param>
      <remarks>
        <para>
            Create a new QuietTextWriter using a writer and error handler
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.QuietTextWriter.Write(System.Char)">
      <summary>
            Writes a character to the underlying writer
            </summary>
      <param name="value">the char to write</param>
      <remarks>
        <para>
            Writes a character to the underlying writer
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.QuietTextWriter.Write(System.Char[],System.Int32,System.Int32)">
      <summary>
            Writes a buffer to the underlying writer
            </summary>
      <param name="buffer">the buffer to write</param>
      <param name="index">the start index to write from</param>
      <param name="count">the number of characters to write</param>
      <remarks>
        <para>
            Writes a buffer to the underlying writer
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.QuietTextWriter.Write(System.String)">
      <summary>
            Writes a string to the output.
            </summary>
      <param name="value">The string data to write to the output.</param>
      <remarks>
        <para>
            Writes a string to the output.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.QuietTextWriter.Close">
      <summary>
            Closes the underlying output writer.
            </summary>
      <remarks>
        <para>
            Closes the underlying output writer.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.QuietTextWriter.ErrorHandler">
      <summary>
            Gets or sets the error handler that all errors are passed to.
            </summary>
      <value>
            The error handler that all errors are passed to.
            </value>
      <remarks>
        <para>
            Gets or sets the error handler that all errors are passed to.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.QuietTextWriter.Closed">
      <summary>
            Gets a value indicating whether this writer is closed.
            </summary>
      <value>
        <c>true</c> if this writer is closed, otherwise <c>false</c>.
            </value>
      <remarks>
        <para>
            Gets a value indicating whether this writer is closed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.CountingQuietTextWriter">
      <summary>
            Subclass of <see cref="T:log4net.Util.QuietTextWriter" /> that maintains a count of 
            the number of bytes written.
            </summary>
      <remarks>
        <para>
            This writer counts the number of bytes written.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.CountingQuietTextWriter.m_countBytes">
      <summary>
            Total number of bytes written.
            </summary>
    </member>
    <member name="M:log4net.Util.CountingQuietTextWriter.#ctor(System.IO.TextWriter,log4net.Core.IErrorHandler)">
      <summary>
            Constructor
            </summary>
      <param name="writer">The <see cref="T:System.IO.TextWriter" /> to actually write to.</param>
      <param name="errorHandler">The <see cref="T:log4net.Core.IErrorHandler" /> to report errors to.</param>
      <remarks>
        <para>
            Creates a new instance of the <see cref="T:log4net.Util.CountingQuietTextWriter" /> class 
            with the specified <see cref="T:System.IO.TextWriter" /> and <see cref="T:log4net.Core.IErrorHandler" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CountingQuietTextWriter.Write(System.Char)">
      <summary>
            Writes a character to the underlying writer and counts the number of bytes written.
            </summary>
      <param name="value">the char to write</param>
      <remarks>
        <para>
            Overrides implementation of <see cref="T:log4net.Util.QuietTextWriter" />. Counts
            the number of bytes written.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CountingQuietTextWriter.Write(System.Char[],System.Int32,System.Int32)">
      <summary>
            Writes a buffer to the underlying writer and counts the number of bytes written.
            </summary>
      <param name="buffer">the buffer to write</param>
      <param name="index">the start index to write from</param>
      <param name="count">the number of characters to write</param>
      <remarks>
        <para>
            Overrides implementation of <see cref="T:log4net.Util.QuietTextWriter" />. Counts
            the number of bytes written.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CountingQuietTextWriter.Write(System.String)">
      <summary>
            Writes a string to the output and counts the number of bytes written.
            </summary>
      <param name="str">The string data to write to the output.</param>
      <remarks>
        <para>
            Overrides implementation of <see cref="T:log4net.Util.QuietTextWriter" />. Counts
            the number of bytes written.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.CountingQuietTextWriter.Count">
      <summary>
            Gets or sets the total number of bytes written.
            </summary>
      <value>
            The total number of bytes written.
            </value>
      <remarks>
        <para>
            Gets or sets the total number of bytes written.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.CyclicBuffer">
      <summary>
            A fixed size rolling buffer of logging events.
            </summary>
      <remarks>
        <para>
            An array backed fixed size leaky bucket.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.CyclicBuffer.#ctor(System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="maxSize">The maximum number of logging events in the buffer.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.CyclicBuffer" /> class with 
            the specified maximum number of buffered logging events.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="maxSize" /> argument is not a positive integer.</exception>
    </member>
    <member name="M:log4net.Util.CyclicBuffer.Append(log4net.Core.LoggingEvent)">
      <summary>
            Appends a <paramref name="loggingEvent" /> to the buffer.
            </summary>
      <param name="loggingEvent">The event to append to the buffer.</param>
      <returns>The event discarded from the buffer, if the buffer is full, otherwise <c>null</c>.</returns>
      <remarks>
        <para>
            Append an event to the buffer. If the buffer still contains free space then
            <c>null</c> is returned. If the buffer is full then an event will be dropped
            to make space for the new event, the event dropped is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CyclicBuffer.PopOldest">
      <summary>
            Get and remove the oldest event in the buffer.
            </summary>
      <returns>The oldest logging event in the buffer</returns>
      <remarks>
        <para>
            Gets the oldest (first) logging event in the buffer and removes it 
            from the buffer.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CyclicBuffer.PopAll">
      <summary>
            Pops all the logging events from the buffer into an array.
            </summary>
      <returns>An array of all the logging events in the buffer.</returns>
      <remarks>
        <para>
            Get all the events in the buffer and clear the buffer.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.CyclicBuffer.Clear">
      <summary>
            Clear the buffer
            </summary>
      <remarks>
        <para>
            Clear the buffer of all events. The events in the buffer are lost.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.CyclicBuffer.Item(System.Int32)">
      <summary>
            Gets the <paramref name="i" />th oldest event currently in the buffer.
            </summary>
      <value>The <paramref name="i" />th oldest event currently in the buffer.</value>
      <remarks>
        <para>
            If <paramref name="i" /> is outside the range 0 to the number of events
            currently in the buffer, then <c>null</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.CyclicBuffer.MaxSize">
      <summary>
            Gets the maximum size of the buffer.
            </summary>
      <value>The maximum size of the buffer.</value>
      <remarks>
        <para>
            Gets the maximum size of the buffer
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.CyclicBuffer.Length">
      <summary>
            Gets the number of logging events in the buffer.
            </summary>
      <value>The number of logging events in the buffer.</value>
      <remarks>
        <para>
            This number is guaranteed to be in the range 0 to <see cref="P:log4net.Util.CyclicBuffer.MaxSize" />
            (inclusive).
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.EmptyCollection">
      <summary>
            An always empty <see cref="T:System.Collections.ICollection" />.
            </summary>
      <remarks>
        <para>
            A singleton implementation of the <see cref="T:System.Collections.ICollection" />
            interface that always represents an empty collection.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.EmptyCollection.s_instance">
      <summary>
            The singleton instance of the empty collection.
            </summary>
    </member>
    <member name="M:log4net.Util.EmptyCollection.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.EmptyCollection" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to enforce the singleton pattern.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.EmptyCollection.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an 
            <see cref="T:System.Array" />, starting at a particular Array index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> 
            that is the destination of the elements copied from 
            <see cref="T:System.Collections.ICollection" />. The Array must have zero-based 
            indexing.</param>
      <param name="index">The zero-based index in array at which 
            copying begins.</param>
      <remarks>
        <para>
            As the collection is empty no values are copied into the array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.EmptyCollection.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> that can be used to 
            iterate through the collection.
            </returns>
      <remarks>
        <para>
            As the collection is empty a <see cref="T:log4net.Util.NullEnumerator" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyCollection.Instance">
      <summary>
            Gets the singleton instance of the empty collection.
            </summary>
      <returns>The singleton instance of the empty collection.</returns>
      <remarks>
        <para>
            Gets the singleton instance of the empty collection.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyCollection.IsSynchronized">
      <summary>
            Gets a value indicating if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread-safe).
            </summary>
      <value>
        <b>true</b> if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread-safe); otherwise, <b>false</b>.
            </value>
      <remarks>
        <para>
            For the <see cref="T:log4net.Util.EmptyCollection" /> this property is always <c>true</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyCollection.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
            The number of elements contained in the <see cref="T:System.Collections.ICollection" />.
            </value>
      <remarks>
        <para>
            As the collection is empty the <see cref="P:log4net.Util.EmptyCollection.Count" /> is always <c>0</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyCollection.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
            An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </value>
      <remarks>
        <para>
            As the collection is empty and thread safe and synchronized this instance is also
            the <see cref="P:log4net.Util.EmptyCollection.SyncRoot" /> object.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.EmptyDictionary">
      <summary>
            An always empty <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <remarks>
        <para>
            A singleton implementation of the <see cref="T:System.Collections.IDictionary" />
            interface that always represents an empty collection.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.EmptyDictionary.s_instance">
      <summary>
            The singleton instance of the empty dictionary.
            </summary>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.EmptyDictionary" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to enforce the singleton pattern.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.CopyTo(System.Array,System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an 
            <see cref="T:System.Array" />, starting at a particular Array index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> 
            that is the destination of the elements copied from 
            <see cref="T:System.Collections.ICollection" />. The Array must have zero-based 
            indexing.</param>
      <param name="index">The zero-based index in array at which 
            copying begins.</param>
      <remarks>
        <para>
            As the collection is empty no values are copied into the array.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.Add(System.Object,System.Object)">
      <summary>
            Adds an element with the provided key and value to the 
            <see cref="T:log4net.Util.EmptyDictionary" />.
            </summary>
      <param name="key">The <see cref="T:System.Object" /> to use as the key of the element to add.</param>
      <param name="value">The <see cref="T:System.Object" /> to use as the value of the element to add.</param>
      <remarks>
        <para>
            As the collection is empty no new values can be added. A <see cref="T:System.InvalidOperationException" />
            is thrown if this method is called.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">This dictionary is always empty and cannot be modified.</exception>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.Clear">
      <summary>
            Removes all elements from the <see cref="T:log4net.Util.EmptyDictionary" />.
            </summary>
      <remarks>
        <para>
            As the collection is empty no values can be removed. A <see cref="T:System.InvalidOperationException" />
            is thrown if this method is called.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">This dictionary is always empty and cannot be modified.</exception>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.Contains(System.Object)">
      <summary>
            Determines whether the <see cref="T:log4net.Util.EmptyDictionary" /> contains an element 
            with the specified key.
            </summary>
      <param name="key">The key to locate in the <see cref="T:log4net.Util.EmptyDictionary" />.</param>
      <returns>
        <c>false</c>
      </returns>
      <remarks>
        <para>
            As the collection is empty the <see cref="M:log4net.Util.EmptyDictionary.Contains(System.Object)" /> method always returns <c>false</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> that can be used to 
            iterate through the collection.
            </returns>
      <remarks>
        <para>
            As the collection is empty a <see cref="T:log4net.Util.NullEnumerator" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.EmptyDictionary.Remove(System.Object)">
      <summary>
            Removes the element with the specified key from the <see cref="T:log4net.Util.EmptyDictionary" />.
            </summary>
      <param name="key">The key of the element to remove.</param>
      <remarks>
        <para>
            As the collection is empty no values can be removed. A <see cref="T:System.InvalidOperationException" />
            is thrown if this method is called.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">This dictionary is always empty and cannot be modified.</exception>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.Instance">
      <summary>
            Gets the singleton instance of the <see cref="T:log4net.Util.EmptyDictionary" />.
            </summary>
      <returns>The singleton instance of the <see cref="T:log4net.Util.EmptyDictionary" />.</returns>
      <remarks>
        <para>
            Gets the singleton instance of the <see cref="T:log4net.Util.EmptyDictionary" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.IsSynchronized">
      <summary>
            Gets a value indicating if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread-safe).
            </summary>
      <value>
        <b>true</b> if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread-safe); otherwise, <b>false</b>.
            </value>
      <remarks>
        <para>
            For the <see cref="T:log4net.Util.EmptyCollection" /> this property is always <b>true</b>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection" /></summary>
      <value>
            The number of elements contained in the <see cref="T:System.Collections.ICollection" />.
            </value>
      <remarks>
        <para>
            As the collection is empty the <see cref="P:log4net.Util.EmptyDictionary.Count" /> is always <c>0</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </summary>
      <value>
            An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.
            </value>
      <remarks>
        <para>
            As the collection is empty and thread safe and synchronized this instance is also
            the <see cref="P:log4net.Util.EmptyDictionary.SyncRoot" /> object.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.IsFixedSize">
      <summary>
            Gets a value indicating whether the <see cref="T:log4net.Util.EmptyDictionary" /> has a fixed size.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            As the collection is empty <see cref="P:log4net.Util.EmptyDictionary.IsFixedSize" /> always returns <c>true</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:log4net.Util.EmptyDictionary" /> is read-only.
            </summary>
      <value>
        <c>true</c>
      </value>
      <remarks>
        <para>
            As the collection is empty <see cref="P:log4net.Util.EmptyDictionary.IsReadOnly" /> always returns <c>true</c>.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.Keys">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> containing the keys of the <see cref="T:log4net.Util.EmptyDictionary" />.
            </summary>
      <value>An <see cref="T:System.Collections.ICollection" /> containing the keys of the <see cref="T:log4net.Util.EmptyDictionary" />.</value>
      <remarks>
        <para>
            As the collection is empty a <see cref="T:log4net.Util.EmptyCollection" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.Values">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> containing the values of the <see cref="T:log4net.Util.EmptyDictionary" />.
            </summary>
      <value>An <see cref="T:System.Collections.ICollection" /> containing the values of the <see cref="T:log4net.Util.EmptyDictionary" />.</value>
      <remarks>
        <para>
            As the collection is empty a <see cref="T:log4net.Util.EmptyCollection" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.EmptyDictionary.Item(System.Object)">
      <summary>
            Gets or sets the element with the specified key.
            </summary>
      <param name="key">The key of the element to get or set.</param>
      <value>
        <c>null</c>
      </value>
      <remarks>
        <para>
            As the collection is empty no values can be looked up or stored. 
            If the index getter is called then <c>null</c> is returned.
            A <see cref="T:System.InvalidOperationException" /> is thrown if the setter is called.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">This dictionary is always empty and cannot be modified.</exception>
    </member>
    <member name="T:log4net.Util.FormattingInfo">
      <summary>
            Contain the information obtained when parsing formatting modifiers 
            in conversion modifiers.
            </summary>
      <remarks>
        <para>
            Holds the formatting information extracted from the format string by
            the <see cref="T:log4net.Util.PatternParser" />. This is used by the <see cref="T:log4net.Util.PatternConverter" />
            objects when rendering the output.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.FormattingInfo.#ctor">
      <summary>
            Defaut Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.FormattingInfo" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.FormattingInfo.#ctor(System.Int32,System.Int32,System.Boolean)">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.FormattingInfo" /> class
            with the specified parameters.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.FormattingInfo.Min">
      <summary>
            Gets or sets the minimum value.
            </summary>
      <value>
            The minimum value.
            </value>
      <remarks>
        <para>
            Gets or sets the minimum value.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.FormattingInfo.Max">
      <summary>
            Gets or sets the maximum value.
            </summary>
      <value>
            The maximum value.
            </value>
      <remarks>
        <para>
            Gets or sets the maximum value.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.FormattingInfo.LeftAlign">
      <summary>
            Gets or sets a flag indicating whether left align is enabled
            or not.
            </summary>
      <value>
            A flag indicating whether left align is enabled or not.
            </value>
      <remarks>
        <para>
            Gets or sets a flag indicating whether left align is enabled or not.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.GlobalContextProperties">
      <summary>
            Implementation of Properties collection for the <see cref="T:log4net.GlobalContext" /></summary>
      <remarks>
        <para>
            This class implements a properties collection that is thread safe and supports both
            storing properties and capturing a read only copy of the current propertied.
            </para>
        <para>
            This class is optimized to the scenario where the properties are read frequently
            and are modified infrequently.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.GlobalContextProperties.m_readOnlyProperties">
      <summary>
            The read only copy of the properties.
            </summary>
      <remarks>
        <para>
            This variable is declared <c>volatile</c> to prevent the compiler and JIT from
            reordering reads and writes of this thread performed on different threads.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Util.GlobalContextProperties.m_syncRoot">
      <summary>
            Lock object used to synchronize updates within this instance
            </summary>
    </member>
    <member name="M:log4net.Util.GlobalContextProperties.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.GlobalContextProperties" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.GlobalContextProperties.Remove(System.String)">
      <summary>
            Remove a property from the global context
            </summary>
      <param name="key">the key for the entry to remove</param>
      <remarks>
        <para>
            Removing an entry from the global context properties is relatively expensive compared
            with reading a value. 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.GlobalContextProperties.Clear">
      <summary>
            Clear the global context properties
            </summary>
    </member>
    <member name="M:log4net.Util.GlobalContextProperties.GetReadOnlyProperties">
      <summary>
            Get a readonly immutable copy of the properties
            </summary>
      <returns>the current global context properties</returns>
      <remarks>
        <para>
            This implementation is fast because the GlobalContextProperties class
            stores a readonly copy of the properties.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.GlobalContextProperties.Item(System.String)">
      <summary>
            Gets or sets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Reading the value for a key is faster than setting the value.
            When the value is written a new read only copy of 
            the properties is created.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.LevelMapping">
      <summary>
            Manages a mapping from levels to <see cref="T:log4net.Util.LevelMappingEntry" /></summary>
      <remarks>
        <para>
            Manages an ordered mapping from <see cref="T:log4net.Core.Level" /> instances 
            to <see cref="T:log4net.Util.LevelMappingEntry" /> subclasses.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.LevelMapping.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Initialise a new instance of <see cref="T:log4net.Util.LevelMapping" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LevelMapping.Add(log4net.Util.LevelMappingEntry)">
      <summary>
            Add a <see cref="T:log4net.Util.LevelMappingEntry" /> to this mapping
            </summary>
      <param name="entry">the entry to add</param>
      <remarks>
        <para>
            If a <see cref="T:log4net.Util.LevelMappingEntry" /> has previously been added
            for the same <see cref="T:log4net.Core.Level" /> then that entry will be 
            overwritten.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LevelMapping.Lookup(log4net.Core.Level)">
      <summary>
            Lookup the mapping for the specified level
            </summary>
      <param name="level">the level to lookup</param>
      <returns>the <see cref="T:log4net.Util.LevelMappingEntry" /> for the level or <c>null</c> if no mapping found</returns>
      <remarks>
        <para>
            Lookup the value for the specified level. Finds the nearest
            mapping value for the level that is equal to or less than the
            <paramref name="level" /> specified.
            </para>
        <para>
            If no mapping could be found then <c>null</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LevelMapping.ActivateOptions">
      <summary>
            Initialize options
            </summary>
      <remarks>
        <para>
            Caches the sorted list of <see cref="T:log4net.Util.LevelMappingEntry" /> in an array
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.LogicalThreadContextProperties">
      <summary>
            Implementation of Properties collection for the <see cref="T:log4net.LogicalThreadContext" /></summary>
      <remarks>
        <para>
            Class implements a collection of properties that is specific to each thread.
            The class is not synchronized as each thread has its own <see cref="T:log4net.Util.PropertiesDictionary" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.LogicalThreadContextProperties.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.LogicalThreadContextProperties" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogicalThreadContextProperties.Remove(System.String)">
      <summary>
            Remove a property
            </summary>
      <param name="key">the key for the entry to remove</param>
      <remarks>
        <para>
            Remove the value for the specified <paramref name="key" /> from the context.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogicalThreadContextProperties.Clear">
      <summary>
            Clear all the context properties
            </summary>
      <remarks>
        <para>
            Clear all the context properties
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogicalThreadContextProperties.GetProperties(System.Boolean)">
      <summary>
            Get the PropertiesDictionary stored in the LocalDataStoreSlot for this thread.
            </summary>
      <param name="create">create the dictionary if it does not exist, otherwise return null if is does not exist</param>
      <returns>the properties for this thread</returns>
      <remarks>
        <para>
            The collection returned is only to be used on the calling thread. If the
            caller needs to share the collection between different threads then the 
            caller must clone the collection before doings so.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.LogicalThreadContextProperties.Item(System.String)">
      <summary>
            Gets or sets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Get or set the property value for the <paramref name="key" /> specified.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.LogLog">
      <summary>
            Outputs log statements from within the log4net assembly.
            </summary>
      <remarks>
        <para>
            Log4net components cannot make log4net logging calls. However, it is
            sometimes useful for the user to learn about what log4net is
            doing.
            </para>
        <para>
            All log4net internal debug calls go to the standard output stream
            whereas internal error messages are sent to the standard error output 
            stream.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.LogLog.s_debugEnabled">
      <summary>
             Default debug level
            </summary>
    </member>
    <member name="F:log4net.Util.LogLog.s_quietMode">
      <summary>
            In quietMode not even errors generate any output.
            </summary>
    </member>
    <member name="M:log4net.Util.LogLog.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.LogLog" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to prevent instantiation of this class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.Debug(System.String)">
      <summary>
            Writes log4net internal debug messages to the 
            standard output stream.
            </summary>
      <param name="message">The message to log.</param>
      <remarks>
        <para>
            All internal debug messages are prepended with 
            the string "log4net: ".
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.Debug(System.String,System.Exception)">
      <summary>
            Writes log4net internal debug messages to the 
            standard output stream.
            </summary>
      <param name="message">The message to log.</param>
      <param name="exception">An exception to log.</param>
      <remarks>
        <para>
            All internal debug messages are prepended with 
            the string "log4net: ".
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.Warn(System.String)">
      <summary>
            Writes log4net internal warning messages to the 
            standard error stream.
            </summary>
      <param name="message">The message to log.</param>
      <remarks>
        <para>
            All internal warning messages are prepended with 
            the string "log4net:WARN ".
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.Warn(System.String,System.Exception)">
      <summary>
            Writes log4net internal warning messages to the 
            standard error stream.
            </summary>
      <param name="message">The message to log.</param>
      <param name="exception">An exception to log.</param>
      <remarks>
        <para>
            All internal warning messages are prepended with 
            the string "log4net:WARN ".
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.Error(System.String)">
      <summary>
            Writes log4net internal error messages to the 
            standard error stream.
            </summary>
      <param name="message">The message to log.</param>
      <remarks>
        <para>
            All internal error messages are prepended with 
            the string "log4net:ERROR ".
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.Error(System.String,System.Exception)">
      <summary>
            Writes log4net internal error messages to the 
            standard error stream.
            </summary>
      <param name="message">The message to log.</param>
      <param name="exception">An exception to log.</param>
      <remarks>
        <para>
            All internal debug messages are prepended with 
            the string "log4net:ERROR ".
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.EmitOutLine(System.String)">
      <summary>
            Writes output to the standard output stream.  
            </summary>
      <param name="message">The message to log.</param>
      <remarks>
        <para>
            Writes to both Console.Out and System.Diagnostics.Trace.
            Note that the System.Diagnostics.Trace is not supported
            on the Compact Framework.
            </para>
        <para>
            If the AppDomain is not configured with a config file then
            the call to System.Diagnostics.Trace may fail. This is only
            an issue if you are programmatically creating your own AppDomains.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.LogLog.EmitErrorLine(System.String)">
      <summary>
            Writes output to the standard error stream.  
            </summary>
      <param name="message">The message to log.</param>
      <remarks>
        <para>
            Writes to both Console.Error and System.Diagnostics.Trace.
            Note that the System.Diagnostics.Trace is not supported
            on the Compact Framework.
            </para>
        <para>
            If the AppDomain is not configured with a config file then
            the call to System.Diagnostics.Trace may fail. This is only
            an issue if you are programmatically creating your own AppDomains.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.LogLog.InternalDebugging">
      <summary>
            Gets or sets a value indicating whether log4net internal logging
            is enabled or disabled.
            </summary>
      <value>
        <c>true</c> if log4net internal logging is enabled, otherwise 
            <c>false</c>.
            </value>
      <remarks>
        <para>
            When set to <c>true</c>, internal debug level logging will be 
            displayed.
            </para>
        <para>
            This value can be set by setting the application setting 
            <c>log4net.Internal.Debug</c> in the application configuration
            file.
            </para>
        <para>
            The default value is <c>false</c>, i.e. debugging is
            disabled.
            </para>
      </remarks>
      <example>
        <para>
            The following example enables internal debugging using the 
            application configuration file :
            </para>
        <code lang="XML" escaped="true">
          <configuration>
            <appSettings>
              <add key="log4net.Internal.Debug" value="true" />
            </appSettings>
          </configuration>
        </code>
      </example>
    </member>
    <member name="P:log4net.Util.LogLog.QuietMode">
      <summary>
            Gets or sets a value indicating whether log4net should generate no output
            from internal logging, not even for errors. 
            </summary>
      <value>
        <c>true</c> if log4net should generate no output at all from internal 
            logging, otherwise <c>false</c>.
            </value>
      <remarks>
        <para>
            When set to <c>true</c> will cause internal logging at all levels to be 
            suppressed. This means that no warning or error reports will be logged. 
            This option overrides the <see cref="P:log4net.Util.LogLog.InternalDebugging" /> setting and 
            disables all debug also.
            </para>
        <para>This value can be set by setting the application setting
            <c>log4net.Internal.Quiet</c> in the application configuration file.
            </para>
        <para>
            The default value is <c>false</c>, i.e. internal logging is not
            disabled.
            </para>
      </remarks>
      <example>
            The following example disables internal logging using the 
            application configuration file :
            <code lang="XML" escaped="true"><configuration><appSettings><add key="log4net.Internal.Quiet" value="true" /></appSettings></configuration></code></example>
    </member>
    <member name="P:log4net.Util.LogLog.IsDebugEnabled">
      <summary>
            Test if LogLog.Debug is enabled for output.
            </summary>
      <value>
        <c>true</c> if Debug is enabled
            </value>
      <remarks>
        <para>
            Test if LogLog.Debug is enabled for output.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.LogLog.IsWarnEnabled">
      <summary>
            Test if LogLog.Warn is enabled for output.
            </summary>
      <value>
        <c>true</c> if Warn is enabled
            </value>
      <remarks>
        <para>
            Test if LogLog.Warn is enabled for output.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.LogLog.IsErrorEnabled">
      <summary>
            Test if LogLog.Error is enabled for output.
            </summary>
      <value>
        <c>true</c> if Error is enabled
            </value>
      <remarks>
        <para>
            Test if LogLog.Error is enabled for output.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.NativeError">
      <summary>
            Represents a native error code and message.
            </summary>
      <remarks>
        <para>
            Represents a Win32 platform native error.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.NativeError.#ctor(System.Int32,System.String)">
      <summary>
            Create an instance of the <see cref="T:log4net.Util.NativeError" /> class with the specified 
            error number and message.
            </summary>
      <param name="number">The number of the native error.</param>
      <param name="message">The message of the native error.</param>
      <remarks>
        <para>
            Create an instance of the <see cref="T:log4net.Util.NativeError" /> class with the specified 
            error number and message.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NativeError.GetLastError">
      <summary>
            Create a new instance of the <see cref="T:log4net.Util.NativeError" /> class for the last Windows error.
            </summary>
      <returns>
            An instance of the <see cref="T:log4net.Util.NativeError" /> class for the last windows error.
            </returns>
      <remarks>
        <para>
            The message for the <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> error number is lookup up using the 
            native Win32 <c>FormatMessage</c> function.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NativeError.GetError(System.Int32)">
      <summary>
            Create a new instance of the <see cref="T:log4net.Util.NativeError" /> class.
            </summary>
      <param name="number">the error number for the native error</param>
      <returns>
            An instance of the <see cref="T:log4net.Util.NativeError" /> class for the specified 
            error number.
            </returns>
      <remarks>
        <para>
            The message for the specified error number is lookup up using the 
            native Win32 <c>FormatMessage</c> function.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NativeError.GetErrorMessage(System.Int32)">
      <summary>
            Retrieves the message corresponding with a Win32 message identifier.
            </summary>
      <param name="messageId">Message identifier for the requested message.</param>
      <returns>
            The message corresponding with the specified message identifier.
            </returns>
      <remarks>
        <para>
            The message will be searched for in system message-table resource(s)
            using the native <c>FormatMessage</c> function.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NativeError.ToString">
      <summary>
            Return error information string
            </summary>
      <returns>error information string</returns>
      <remarks>
        <para>
            Return error information string
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NativeError.FormatMessage(System.Int32,System.IntPtr@,System.Int32,System.Int32,System.String@,System.Int32,System.IntPtr)">
      <summary>
            Formats a message string.
            </summary>
      <param name="dwFlags">Formatting options, and how to interpret the <paramref name="lpSource" /> parameter.</param>
      <param name="lpSource">Location of the message definition.</param>
      <param name="dwMessageId">Message identifier for the requested message.</param>
      <param name="dwLanguageId">Language identifier for the requested message.</param>
      <param name="lpBuffer">If <paramref name="dwFlags" /> includes FORMAT_MESSAGE_ALLOCATE_BUFFER, the function allocates a buffer using the <c>LocalAlloc</c> function, and places the pointer to the buffer at the address specified in <paramref name="lpBuffer" />.</param>
      <param name="nSize">If the FORMAT_MESSAGE_ALLOCATE_BUFFER flag is not set, this parameter specifies the maximum number of TCHARs that can be stored in the output buffer. If FORMAT_MESSAGE_ALLOCATE_BUFFER is set, this parameter specifies the minimum number of TCHARs to allocate for an output buffer.</param>
      <param name="Arguments">Pointer to an array of values that are used as insert values in the formatted message.</param>
      <remarks>
        <para>
            The function requires a message definition as input. The message definition can come from a 
            buffer passed into the function. It can come from a message table resource in an 
            already-loaded module. Or the caller can ask the function to search the system's message 
            table resource(s) for the message definition. The function finds the message definition 
            in a message table resource based on a message identifier and a language identifier. 
            The function copies the formatted message text to an output buffer, processing any embedded 
            insert sequences if requested.
            </para>
        <para>
            To prevent the usage of unsafe code, this stub does not support inserting values in the formatted message.
            </para>
      </remarks>
      <returns>
        <para>
            If the function succeeds, the return value is the number of TCHARs stored in the output 
            buffer, excluding the terminating null character.
            </para>
        <para>
            If the function fails, the return value is zero. To get extended error information, 
            call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />.
            </para>
      </returns>
    </member>
    <member name="P:log4net.Util.NativeError.Number">
      <summary>
            Gets the number of the native error.
            </summary>
      <value>
            The number of the native error.
            </value>
      <remarks>
        <para>
            Gets the number of the native error.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.NativeError.Message">
      <summary>
            Gets the message of the native error.
            </summary>
      <value>
            The message of the native error.
            </value>
      <remarks>
        <para>
        </para>
            Gets the message of the native error.
            </remarks>
    </member>
    <member name="T:log4net.Util.NullDictionaryEnumerator">
      <summary>
            An always empty <see cref="T:System.Collections.IDictionaryEnumerator" />.
            </summary>
      <remarks>
        <para>
            A singleton implementation of the <see cref="T:System.Collections.IDictionaryEnumerator" /> over a collection
            that is empty and not modifiable.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.NullDictionaryEnumerator.s_instance">
      <summary>
            The singleton instance of the <see cref="T:log4net.Util.NullDictionaryEnumerator" />.
            </summary>
    </member>
    <member name="M:log4net.Util.NullDictionaryEnumerator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.NullDictionaryEnumerator" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to enforce the singleton pattern.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NullDictionaryEnumerator.MoveNext">
      <summary>
            Test if the enumerator can advance, if so advance.
            </summary>
      <returns>
        <c>false</c> as the <see cref="T:log4net.Util.NullDictionaryEnumerator" /> cannot advance.</returns>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="M:log4net.Util.NullDictionaryEnumerator.MoveNext" />
            will always return <c>false</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NullDictionaryEnumerator.Reset">
      <summary>
            Resets the enumerator back to the start.
            </summary>
      <remarks>
        <para>
            As the enumerator is over an empty collection <see cref="M:log4net.Util.NullDictionaryEnumerator.Reset" /> does nothing.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.NullDictionaryEnumerator.Instance">
      <summary>
            Gets the singleton instance of the <see cref="T:log4net.Util.NullDictionaryEnumerator" />.
            </summary>
      <returns>The singleton instance of the <see cref="T:log4net.Util.NullDictionaryEnumerator" />.</returns>
      <remarks>
        <para>
            Gets the singleton instance of the <see cref="T:log4net.Util.NullDictionaryEnumerator" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.NullDictionaryEnumerator.Current">
      <summary>
            Gets the current object from the enumerator.
            </summary>
      <remarks>
            Throws an <see cref="T:System.InvalidOperationException" /> because the 
            <see cref="T:log4net.Util.NullDictionaryEnumerator" /> never has a current value.
            </remarks>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" />
            will throw an <see cref="T:System.InvalidOperationException" />.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The collection is empty and <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" /> 
            cannot be positioned over a valid location.</exception>
    </member>
    <member name="P:log4net.Util.NullDictionaryEnumerator.Key">
      <summary>
            Gets the current key from the enumerator.
            </summary>
      <remarks>
            Throws an exception because the <see cref="T:log4net.Util.NullDictionaryEnumerator" />
            never has a current value.
            </remarks>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="P:log4net.Util.NullDictionaryEnumerator.Key" />
            will throw an <see cref="T:System.InvalidOperationException" />.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The collection is empty and <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" /> 
            cannot be positioned over a valid location.</exception>
    </member>
    <member name="P:log4net.Util.NullDictionaryEnumerator.Value">
      <summary>
            Gets the current value from the enumerator.
            </summary>
      <value>The current value from the enumerator.</value>
      <remarks>
            Throws an <see cref="T:System.InvalidOperationException" /> because the 
            <see cref="T:log4net.Util.NullDictionaryEnumerator" /> never has a current value.
            </remarks>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="P:log4net.Util.NullDictionaryEnumerator.Value" />
            will throw an <see cref="T:System.InvalidOperationException" />.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The collection is empty and <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" /> 
            cannot be positioned over a valid location.</exception>
    </member>
    <member name="P:log4net.Util.NullDictionaryEnumerator.Entry">
      <summary>
            Gets the current entry from the enumerator.
            </summary>
      <remarks>
            Throws an <see cref="T:System.InvalidOperationException" /> because the 
            <see cref="T:log4net.Util.NullDictionaryEnumerator" /> never has a current entry.
            </remarks>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="P:log4net.Util.NullDictionaryEnumerator.Entry" />
            will throw an <see cref="T:System.InvalidOperationException" />.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The collection is empty and <see cref="P:log4net.Util.NullDictionaryEnumerator.Current" /> 
            cannot be positioned over a valid location.</exception>
    </member>
    <member name="T:log4net.Util.NullEnumerator">
      <summary>
            An always empty <see cref="T:System.Collections.IEnumerator" />.
            </summary>
      <remarks>
        <para>
            A singleton implementation of the <see cref="T:System.Collections.IEnumerator" /> over a collection
            that is empty and not modifiable.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.NullEnumerator.s_instance">
      <summary>
            The singleton instance of the <see cref="T:log4net.Util.NullEnumerator" />.
            </summary>
    </member>
    <member name="M:log4net.Util.NullEnumerator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.NullEnumerator" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to enforce the singleton pattern.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NullEnumerator.MoveNext">
      <summary>
            Test if the enumerator can advance, if so advance
            </summary>
      <returns>
        <c>false</c> as the <see cref="T:log4net.Util.NullEnumerator" /> cannot advance.</returns>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="M:log4net.Util.NullEnumerator.MoveNext" />
            will always return <c>false</c>.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NullEnumerator.Reset">
      <summary>
            Resets the enumerator back to the start.
            </summary>
      <remarks>
        <para>
            As the enumerator is over an empty collection <see cref="M:log4net.Util.NullEnumerator.Reset" /> does nothing.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.NullEnumerator.Instance">
      <summary>
            Get the singleton instance of the <see cref="T:log4net.Util.NullEnumerator" />.
            </summary>
      <returns>The singleton instance of the <see cref="T:log4net.Util.NullEnumerator" />.</returns>
      <remarks>
        <para>
            Gets the singleton instance of the <see cref="T:log4net.Util.NullEnumerator" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.NullEnumerator.Current">
      <summary>
            Gets the current object from the enumerator.
            </summary>
      <remarks>
            Throws an <see cref="T:System.InvalidOperationException" /> because the 
            <see cref="T:log4net.Util.NullDictionaryEnumerator" /> never has a current value.
            </remarks>
      <remarks>
        <para>
            As the enumerator is over an empty collection its <see cref="P:log4net.Util.NullEnumerator.Current" />
            value cannot be moved over a valid position, therefore <see cref="P:log4net.Util.NullEnumerator.Current" />
            will throw an <see cref="T:System.InvalidOperationException" />.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The collection is empty and <see cref="P:log4net.Util.NullEnumerator.Current" /> 
            cannot be positioned over a valid location.</exception>
    </member>
    <member name="T:log4net.Util.NullSecurityContext">
      <summary>
            A SecurityContext used when a SecurityContext is not required
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.Util.NullSecurityContext" /> is a no-op implementation of the
            <see cref="T:log4net.Core.SecurityContext" /> base class. It is used where a <see cref="T:log4net.Core.SecurityContext" />
            is required but one has not been provided.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.NullSecurityContext.Instance">
      <summary>
            Singleton instance of <see cref="T:log4net.Util.NullSecurityContext" /></summary>
      <remarks>
        <para>
            Singleton instance of <see cref="T:log4net.Util.NullSecurityContext" /></para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NullSecurityContext.#ctor">
      <summary>
            Private constructor
            </summary>
      <remarks>
        <para>
            Private constructor for singleton pattern.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.NullSecurityContext.Impersonate(System.Object)">
      <summary>
            Impersonate this SecurityContext
            </summary>
      <param name="state">State supplied by the caller</param>
      <returns>
        <c>null</c>
      </returns>
      <remarks>
        <para>
            No impersonation is done and <c>null</c> is always returned.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.OnlyOnceErrorHandler">
      <summary>
            Implements log4net's default error handling policy which consists 
            of emitting a message for the first error in an appender and 
            ignoring all subsequent errors.
            </summary>
      <remarks>
        <para>
            The error message is printed on the standard error output stream.
            </para>
        <para>
            This policy aims at protecting an otherwise working application
            from being flooded with error messages when logging fails.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.OnlyOnceErrorHandler.m_firstTime">
      <summary>
            Flag to indicate if it is the first error
            </summary>
    </member>
    <member name="F:log4net.Util.OnlyOnceErrorHandler.m_prefix">
      <summary>
            String to prefix each message with
            </summary>
    </member>
    <member name="M:log4net.Util.OnlyOnceErrorHandler.#ctor">
      <summary>
            Default Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.OnlyOnceErrorHandler" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OnlyOnceErrorHandler.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="prefix">The prefix to use for each message.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.OnlyOnceErrorHandler" /> class
            with the specified prefix.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OnlyOnceErrorHandler.Error(System.String,System.Exception,log4net.Core.ErrorCode)">
      <summary>
            Log an Error
            </summary>
      <param name="message">The error message.</param>
      <param name="e">The exception.</param>
      <param name="errorCode">The internal error code.</param>
      <remarks>
        <para>
            Prints the message and the stack trace of the exception on the standard
            error output stream.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OnlyOnceErrorHandler.Error(System.String,System.Exception)">
      <summary>
            Log an Error
            </summary>
      <param name="message">The error message.</param>
      <param name="e">The exception.</param>
      <remarks>
        <para>
            Prints the message and the stack trace of the exception on the standard
            error output stream.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OnlyOnceErrorHandler.Error(System.String)">
      <summary>
            Log an error
            </summary>
      <param name="message">The error message.</param>
      <remarks>
        <para>
            Print a the error message passed as parameter on the standard
            error output stream.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.OnlyOnceErrorHandler.IsEnabled">
      <summary>
            Is error logging enabled
            </summary>
      <remarks>
        <para>
            Is error logging enabled. Logging is only enabled for the
            first error delivered to the <see cref="T:log4net.Util.OnlyOnceErrorHandler" />.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.OptionConverter">
      <summary>
            A convenience class to convert property values to specific types.
            </summary>
      <remarks>
        <para>
            Utility functions for converting types and parsing values.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.OptionConverter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.OptionConverter" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to prevent instantiation of this class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.ToBoolean(System.String,System.Boolean)">
      <summary>
            Converts a string to a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="argValue">String to convert.</param>
      <param name="defaultValue">The default value.</param>
      <returns>The <see cref="T:System.Boolean" /> value of <paramref name="argValue" />.</returns>
      <remarks>
        <para>
            If <paramref name="argValue" /> is "true", then <c>true</c> is returned. 
            If <paramref name="argValue" /> is "false", then <c>false</c> is returned. 
            Otherwise, <paramref name="defaultValue" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.ToFileSize(System.String,System.Int64)">
      <summary>
            Parses a file size into a number.
            </summary>
      <param name="argValue">String to parse.</param>
      <param name="defaultValue">The default value.</param>
      <returns>The <see cref="T:System.Int64" /> value of <paramref name="argValue" />.</returns>
      <remarks>
        <para>
            Parses a file size of the form: number[KB|MB|GB] into a
            long value. It is scaled with the appropriate multiplier.
            </para>
        <para>
          <paramref name="defaultValue" /> is returned when <paramref name="argValue" />
            cannot be converted to a <see cref="T:System.Int64" /> value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.ConvertStringTo(System.Type,System.String)">
      <summary>
            Converts a string to an object.
            </summary>
      <param name="target">The target type to convert to.</param>
      <param name="txt">The string to convert to an object.</param>
      <returns>
            The object converted from a string or <c>null</c> when the 
            conversion failed.
            </returns>
      <remarks>
        <para>
            Converts a string to an object. Uses the converter registry to try
            to convert the string value into the specified target type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.CanConvertTypeTo(System.Type,System.Type)">
      <summary>
            Checks if there is an appropriate type conversion from the source type to the target type.
            </summary>
      <param name="sourceType">The type to convert from.</param>
      <param name="targetType">The type to convert to.</param>
      <returns>
        <c>true</c> if there is a conversion from the source type to the target type.</returns>
      <remarks>
            Checks if there is an appropriate type conversion from the source type to the target type.
            <para></para></remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.ConvertTypeTo(System.Object,System.Type)">
      <summary>
            Converts an object to the target type.
            </summary>
      <param name="sourceInstance">The object to convert to the target type.</param>
      <param name="targetType">The type to convert to.</param>
      <returns>The converted object.</returns>
      <remarks>
        <para>
            Converts an object to the target type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.InstantiateByClassName(System.String,System.Type,System.Object)">
      <summary>
            Instantiates an object given a class name.
            </summary>
      <param name="className">The fully qualified class name of the object to instantiate.</param>
      <param name="superClass">The class to which the new object should belong.</param>
      <param name="defaultValue">The object to return in case of non-fulfillment.</param>
      <returns>
            An instance of the <paramref name="className" /> or <paramref name="defaultValue" />
            if the object could not be instantiated.
            </returns>
      <remarks>
        <para>
            Checks that the <paramref name="className" /> is a subclass of
            <paramref name="superClass" />. If that test fails or the object could
            not be instantiated, then <paramref name="defaultValue" /> is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.SubstituteVariables(System.String,System.Collections.IDictionary)">
      <summary>
            Performs variable substitution in string <paramref name="val" /> from the 
            values of keys found in <paramref name="props" />.
            </summary>
      <param name="value">The string on which variable substitution is performed.</param>
      <param name="props">The dictionary to use to lookup variables.</param>
      <returns>The result of the substitutions.</returns>
      <remarks>
        <para>
            The variable substitution delimiters are <b>${</b> and <b>}</b>.
            </para>
        <para>
            For example, if props contains <c>key=value</c>, then the call
            </para>
        <para>
          <code lang="C#">
            string s = OptionConverter.SubstituteVariables("Value of key is ${key}.");
            </code>
        </para>
        <para>
            will set the variable <c>s</c> to "Value of key is value.".
            </para>
        <para>
            If no value could be found for the specified key, then substitution 
            defaults to an empty string.
            </para>
        <para>
            For example, if system properties contains no value for the key
            "nonExistentKey", then the call
            </para>
        <para>
          <code lang="C#">
            string s = OptionConverter.SubstituteVariables("Value of nonExistentKey is [${nonExistentKey}]");
            </code>
        </para>
        <para>
            will set <s>s</s> to "Value of nonExistentKey is []".	 
            </para>
        <para>
            An Exception is thrown if <paramref name="value" /> contains a start 
            delimiter "${" which is not balanced by a stop delimiter "}". 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.OptionConverter.ParseEnum(System.Type,System.String,System.Boolean)">
      <summary>
            Converts the string representation of the name or numeric value of one or 
            more enumerated constants to an equivalent enumerated object.
            </summary>
      <param name="enumType">The type to convert to.</param>
      <param name="value">The enum string value.</param>
      <param name="ignoreCase">If <c>true</c>, ignore case; otherwise, regard case.</param>
      <returns>An object of type <paramref name="enumType" /> whose value is represented by <paramref name="value" />.</returns>
    </member>
    <member name="T:log4net.Util.PatternParser">
      <summary>
            Most of the work of the <see cref="T:log4net.Layout.PatternLayout" /> class
            is delegated to the PatternParser class.
            </summary>
      <remarks>
        <para>
            The <c>PatternParser</c> processes a pattern string and
            returns a chain of <see cref="T:log4net.Util.PatternConverter" /> objects.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="T:log4net.Util.PatternParser.StringLengthComparer">
      <summary>
            Sort strings by length
            </summary>
      <remarks>
        <para>
          <see cref="T:System.Collections.IComparer" /> that orders strings by string length.
            The longest strings are placed first
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Util.PatternParser.m_head">
      <summary>
            The first pattern converter in the chain
            </summary>
    </member>
    <member name="F:log4net.Util.PatternParser.m_tail">
      <summary>
             the last pattern converter in the chain
            </summary>
    </member>
    <member name="F:log4net.Util.PatternParser.m_pattern">
      <summary>
            The pattern
            </summary>
    </member>
    <member name="F:log4net.Util.PatternParser.m_patternConverters">
      <summary>
            Internal map of converter identifiers to converter types
            </summary>
      <remarks>
        <para>
            This map overrides the static s_globalRulesRegistry map.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternParser.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="pattern">The pattern to parse.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.PatternParser" /> class 
            with the specified pattern string.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternParser.Parse">
      <summary>
            Parses the pattern into a chain of pattern converters.
            </summary>
      <returns>The head of a chain of pattern converters.</returns>
      <remarks>
        <para>
            Parses the pattern into a chain of pattern converters.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternParser.BuildCache">
      <summary>
            Build the unified cache of converters from the static and instance maps
            </summary>
      <returns>the list of all the converter names</returns>
      <remarks>
        <para>
            Build the unified cache of converters from the static and instance maps
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternParser.ParseInternal(System.String,System.String[])">
      <summary>
            Internal method to parse the specified pattern to find specified matches
            </summary>
      <param name="pattern">the pattern to parse</param>
      <param name="matches">the converter names to match in the pattern</param>
      <remarks>
        <para>
            The matches param must be sorted such that longer strings come before shorter ones.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternParser.ProcessLiteral(System.String)">
      <summary>
            Process a parsed literal
            </summary>
      <param name="text">the literal text</param>
    </member>
    <member name="M:log4net.Util.PatternParser.ProcessConverter(System.String,System.String,log4net.Util.FormattingInfo)">
      <summary>
            Process a parsed converter pattern
            </summary>
      <param name="converterName">the name of the converter</param>
      <param name="option">the optional option for the converter</param>
      <param name="formattingInfo">the formatting info for the converter</param>
    </member>
    <member name="M:log4net.Util.PatternParser.AddConverter(log4net.Util.PatternConverter)">
      <summary>
            Resets the internal state of the parser and adds the specified pattern converter 
            to the chain.
            </summary>
      <param name="pc">The pattern converter to add.</param>
    </member>
    <member name="P:log4net.Util.PatternParser.PatternConverters">
      <summary>
            Get the converter registry used by this parser
            </summary>
      <value>
            The converter registry used by this parser
            </value>
      <remarks>
        <para>
            Get the converter registry used by this parser
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.PatternString">
      <summary>
            This class implements a patterned string.
            </summary>
      <remarks>
        <para>
            This string has embedded patterns that are resolved and expanded
            when the string is formatted.
            </para>
        <para>
            This class functions similarly to the <see cref="T:log4net.Layout.PatternLayout" />
            in that it accepts a pattern and renders it to a string. Unlike the 
            <see cref="T:log4net.Layout.PatternLayout" /> however the <c>PatternString</c>
            does not render the properties of a specific <see cref="T:log4net.Core.LoggingEvent" /> but
            of the process in general.
            </para>
        <para>
            The recognized conversion pattern names are:
            </para>
        <list type="table">
          <listheader>
            <term>Conversion Pattern Name</term>
            <description>Effect</description>
          </listheader>
          <item>
            <term>appdomain</term>
            <description>
              <para>
                        Used to output the friendly name of the current AppDomain.
                        </para>
            </description>
          </item>
          <item>
            <term>date</term>
            <description>
              <para>
            			Used to output the date of the logging event in the local time zone. 
            			To output the date in universal time use the <c>%utcdate</c> pattern.
            			The date conversion 
            			specifier may be followed by a <i>date format specifier</i> enclosed 
            			between braces. For example, <b>%date{HH:mm:ss,fff}</b> or
            			<b>%date{dd MMM yyyy HH:mm:ss,fff}</b>.  If no date format specifier is 
            			given then ISO8601 format is
            			assumed (<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />).
            			</para>
              <para>
            			The date format specifier admits the same syntax as the
            			time pattern string of the <see cref="M:System.DateTime.ToString(System.String)" />.
            			</para>
              <para>
            			For better results it is recommended to use the log4net date
            			formatters. These can be specified using one of the strings
            			"ABSOLUTE", "DATE" and "ISO8601" for specifying 
            			<see cref="T:log4net.DateFormatter.AbsoluteTimeDateFormatter" />, 
            			<see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> and respectively 
            			<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />. For example, 
            			<b>%date{ISO8601}</b> or <b>%date{ABSOLUTE}</b>.
            			</para>
              <para>
            			These dedicated date formatters perform significantly
            			better than <see cref="M:System.DateTime.ToString(System.String)" />.
            			</para>
            </description>
          </item>
          <item>
            <term>env</term>
            <description>
              <para>
            			Used to output the a specific environment variable. The key to 
            			lookup must be specified within braces and directly following the
            			pattern specifier, e.g. <b>%env{COMPUTERNAME}</b> would include the value
            			of the <c>COMPUTERNAME</c> environment variable.
                        </para>
              <para>
                        The <c>env</c> pattern is not supported on the .NET Compact Framework.
                        </para>
            </description>
          </item>
          <item>
            <term>identity</term>
            <description>
              <para>
            			Used to output the user name for the currently active user
            			(Principal.Identity.Name).
            			</para>
            </description>
          </item>
          <item>
            <term>newline</term>
            <description>
              <para>
            			Outputs the platform dependent line separator character or
            			characters.
            			</para>
              <para>
            			This conversion pattern name offers the same performance as using 
            			non-portable line separator strings such as	"\n", or "\r\n". 
            			Thus, it is the preferred way of specifying a line separator.
            			</para>
            </description>
          </item>
          <item>
            <term>processid</term>
            <description>
              <para>
            			Used to output the system process ID for the current process.
                        </para>
            </description>
          </item>
          <item>
            <term>property</term>
            <description>
              <para>
            			Used to output a specific context property. The key to 
            			lookup must be specified within braces and directly following the
            			pattern specifier, e.g. <b>%property{user}</b> would include the value
            			from the property that is keyed by the string 'user'. Each property value
            			that is to be included in the log must be specified separately.
            			Properties are stored in logging contexts. By default 
            			the <c>log4net:HostName</c> property is set to the name of machine on 
            			which the event was originally logged.
            			</para>
              <para>
            			If no key is specified, e.g. <b>%property</b> then all the keys and their
            			values are printed in a comma separated list.
            			</para>
              <para>
            			The properties of an event are combined from a number of different
            			contexts. These are listed below in the order in which they are searched.
            			</para>
              <list type="definition">
                <item>
                  <term>the thread properties</term>
                  <description>
            					The <see cref="P:log4net.ThreadContext.Properties" /> that are set on the current
            					thread. These properties are shared by all events logged on this thread.
            					</description>
                </item>
                <item>
                  <term>the global properties</term>
                  <description>
            					The <see cref="P:log4net.GlobalContext.Properties" /> that are set globally. These 
            					properties are shared by all the threads in the AppDomain.
            					</description>
                </item>
              </list>
            </description>
          </item>
          <item>
            <term>random</term>
            <description>
              <para>
                        Used to output a random string of characters. The string is made up of
                        uppercase letters and numbers. By default the string is 4 characters long.
                        The length of the string can be specified within braces directly following the
            			pattern specifier, e.g. <b>%random{8}</b> would output an 8 character string.
                        </para>
            </description>
          </item>
          <item>
            <term>username</term>
            <description>
              <para>
            			Used to output the WindowsIdentity for the currently
            			active user.
            			</para>
            </description>
          </item>
          <item>
            <term>utcdate</term>
            <description>
              <para>
            			Used to output the date of the logging event in universal time. 
            			The date conversion 
            			specifier may be followed by a <i>date format specifier</i> enclosed 
            			between braces. For example, <b>%utcdate{HH:mm:ss,fff}</b> or
            			<b>%utcdate{dd MMM yyyy HH:mm:ss,fff}</b>.  If no date format specifier is 
            			given then ISO8601 format is
            			assumed (<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />).
            			</para>
              <para>
            			The date format specifier admits the same syntax as the
            			time pattern string of the <see cref="M:System.DateTime.ToString(System.String)" />.
            			</para>
              <para>
            			For better results it is recommended to use the log4net date
            			formatters. These can be specified using one of the strings
            			"ABSOLUTE", "DATE" and "ISO8601" for specifying 
            			<see cref="T:log4net.DateFormatter.AbsoluteTimeDateFormatter" />, 
            			<see cref="T:log4net.DateFormatter.DateTimeDateFormatter" /> and respectively 
            			<see cref="T:log4net.DateFormatter.Iso8601DateFormatter" />. For example, 
            			<b>%utcdate{ISO8601}</b> or <b>%utcdate{ABSOLUTE}</b>.
            			</para>
              <para>
            			These dedicated date formatters perform significantly
            			better than <see cref="M:System.DateTime.ToString(System.String)" />.
            			</para>
            </description>
          </item>
          <item>
            <term>%</term>
            <description>
              <para>
            			The sequence %% outputs a single percent sign.
            			</para>
            </description>
          </item>
        </list>
        <para>
            Additional pattern converters may be registered with a specific <see cref="T:log4net.Util.PatternString" />
            instance using <see cref="M:log4net.Util.PatternString.AddConverter(log4net.Util.PatternString.ConverterInfo)" /> or
            <see cref="M:log4net.Util.PatternString.AddConverter(System.String,System.Type)" />.
            </para>
        <para>
            See the <see cref="T:log4net.Layout.PatternLayout" /> for details on the 
            <i>format modifiers</i> supported by the patterns.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Util.PatternString.ConverterInfo">
      <summary>
            Wrapper class used to map converter names to converter types
            </summary>
      <remarks>
        <para>
            Wrapper class used to map converter names to converter types
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.ConverterInfo.#ctor">
      <summary>
            default constructor
            </summary>
    </member>
    <member name="P:log4net.Util.PatternString.ConverterInfo.Name">
      <summary>
            Gets or sets the name of the conversion pattern
            </summary>
      <value>
            The name of the conversion pattern
            </value>
      <remarks>
        <para>
            Gets or sets the name of the conversion pattern
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PatternString.ConverterInfo.Type">
      <summary>
            Gets or sets the type of the converter
            </summary>
      <value>
            The type of the converter
            </value>
      <remarks>
        <para>
            Gets or sets the type of the converter
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Util.PatternString.s_globalRulesRegistry">
      <summary>
            Internal map of converter identifiers to converter types.
            </summary>
    </member>
    <member name="F:log4net.Util.PatternString.m_pattern">
      <summary>
            the pattern
            </summary>
    </member>
    <member name="F:log4net.Util.PatternString.m_head">
      <summary>
            the head of the pattern converter chain
            </summary>
    </member>
    <member name="F:log4net.Util.PatternString.m_instanceRulesRegistry">
      <summary>
            patterns defined on this PatternString only
            </summary>
    </member>
    <member name="M:log4net.Util.PatternString.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Initialize a new instance of <see cref="T:log4net.Util.PatternString" /></para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.#ctor(System.String)">
      <summary>
            Constructs a PatternString
            </summary>
      <param name="pattern">The pattern to use with this PatternString</param>
      <remarks>
        <para>
            Initialize a new instance of <see cref="T:log4net.Util.PatternString" /> with the pattern specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.ActivateOptions">
      <summary>
            Initialize object options
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Util.PatternString.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Util.PatternString.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Util.PatternString.ActivateOptions" /> must be called again.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.CreatePatternParser(System.String)">
      <summary>
            Create the <see cref="T:log4net.Util.PatternParser" /> used to parse the pattern
            </summary>
      <param name="pattern">the pattern to parse</param>
      <returns>The <see cref="T:log4net.Util.PatternParser" /></returns>
      <remarks>
        <para>
            Returns PatternParser used to parse the conversion string. Subclasses
            may override this to return a subclass of PatternParser which recognize
            custom conversion pattern name.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.Format(System.IO.TextWriter)">
      <summary>
            Produces a formatted string as specified by the conversion pattern.
            </summary>
      <param name="writer">The TextWriter to write the formatted event to</param>
      <remarks>
        <para>
            Format the pattern to the <paramref name="writer" />.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.Format">
      <summary>
            Format the pattern as a string
            </summary>
      <returns>the pattern formatted as a string</returns>
      <remarks>
        <para>
            Format the pattern to a string.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.AddConverter(log4net.Util.PatternString.ConverterInfo)">
      <summary>
            Add a converter to this PatternString
            </summary>
      <param name="converterInfo">the converter info</param>
      <remarks>
        <para>
            This version of the method is used by the configurator.
            Programmatic users should use the alternative <see cref="M:log4net.Util.PatternString.AddConverter(System.String,System.Type)" /> method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PatternString.AddConverter(System.String,System.Type)">
      <summary>
            Add a converter to this PatternString
            </summary>
      <param name="name">the name of the conversion pattern for this converter</param>
      <param name="type">the type of the converter</param>
      <remarks>
        <para>
            Add a converter to this PatternString
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PatternString.ConversionPattern">
      <summary>
            Gets or sets the pattern formatting string
            </summary>
      <value>
            The pattern formatting string
            </value>
      <remarks>
        <para>
            The <b>ConversionPattern</b> option. This is the string which
            controls formatting and consists of a mix of literal content and
            conversion specifiers.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ReadOnlyPropertiesDictionary">
      <summary>
            String keyed object map that is read only.
            </summary>
      <remarks>
        <para>
            This collection is readonly and cannot be modified.
            </para>
        <para>
            While this collection is serializable only member 
            objects that are serializable will
            be serialized along with this collection.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.Util.ReadOnlyPropertiesDictionary.m_hashtable">
      <summary>
            The Hashtable used to store the properties data
            </summary>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ReadOnlyPropertiesDictionary" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.#ctor(log4net.Util.ReadOnlyPropertiesDictionary)">
      <summary>
            Copy Constructor
            </summary>
      <param name="propertiesDictionary">properties to copy</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ReadOnlyPropertiesDictionary" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Deserialization constructor
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ReadOnlyPropertiesDictionary" /> class 
            with serialized data.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.GetKeys">
      <summary>
            Gets the key names.
            </summary>
      <returns>An array of all the keys.</returns>
      <remarks>
        <para>
            Gets the key names.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.Contains(System.String)">
      <summary>
            Test if the dictionary contains a specified key
            </summary>
      <param name="key">the key to look for</param>
      <returns>true if the dictionary contains the specified key</returns>
      <remarks>
        <para>
            Test if the dictionary contains a specified key
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Serializes this object into the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> provided.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
      <param name="context">The destination for this serialization.</param>
      <remarks>
        <para>
            Serializes this object into the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> provided.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReadOnlyPropertiesDictionary.Clear">
      <summary>
            Remove all properties from the properties collection
            </summary>
    </member>
    <member name="P:log4net.Util.ReadOnlyPropertiesDictionary.Item(System.String)">
      <summary>
            Gets or sets the value of the  property with the specified key.
            </summary>
      <value>
            The value of the property with the specified key.
            </value>
      <param name="key">The key of the property to get or set.</param>
      <remarks>
        <para>
            The property value will only be serialized if it is serializable.
            If it cannot be serialized it will be silently ignored if
            a serialization operation is performed.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ReadOnlyPropertiesDictionary.InnerHashtable">
      <summary>
            The hashtable used to store the properties
            </summary>
      <value>
            The internal collection used to store the properties
            </value>
      <remarks>
        <para>
            The hashtable used to store the properties
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ReadOnlyPropertiesDictionary.Count">
      <summary>
            The number of properties in this collection
            </summary>
    </member>
    <member name="T:log4net.Util.PropertiesDictionary">
      <summary>
            String keyed object map.
            </summary>
      <remarks>
        <para>
            While this collection is serializable only member 
            objects that are serializable will
            be serialized along with this collection.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.PropertiesDictionary.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.PropertiesDictionary" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PropertiesDictionary.#ctor(log4net.Util.ReadOnlyPropertiesDictionary)">
      <summary>
            Constructor
            </summary>
      <param name="propertiesDictionary">properties to copy</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.PropertiesDictionary" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PropertiesDictionary.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.PropertiesDictionary" /> class 
            with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <remarks>
        <para>
            Because this class is sealed the serialization constructor is private.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PropertiesDictionary.Remove(System.String)">
      <summary>
            Remove the entry with the specified key from this dictionary
            </summary>
      <param name="key">the key for the entry to remove</param>
      <remarks>
        <para>
            Remove the entry with the specified key from this dictionary
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.PropertiesDictionary.Clear">
      <summary>
            Remove all properties from the properties collection
            </summary>
      <remarks>
        <para>
            Remove all properties from the properties collection
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.PropertiesDictionary.Item(System.String)">
      <summary>
            Gets or sets the value of the  property with the specified key.
            </summary>
      <value>
            The value of the property with the specified key.
            </value>
      <param name="key">The key of the property to get or set.</param>
      <remarks>
        <para>
            The property value will only be serialized if it is serializable.
            If it cannot be serialized it will be silently ignored if
            a serialization operation is performed.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ProtectCloseTextWriter">
      <summary>
            A <see cref="T:System.IO.TextWriter" /> that ignores the <see cref="M:log4net.Util.ProtectCloseTextWriter.Close" /> message
            </summary>
      <remarks>
        <para>
            This writer is used in special cases where it is necessary 
            to protect a writer from being closed by a client.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.ProtectCloseTextWriter.#ctor(System.IO.TextWriter)">
      <summary>
            Constructor
            </summary>
      <param name="writer">the writer to actually write to</param>
      <remarks>
        <para>
            Create a new ProtectCloseTextWriter using a writer
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ProtectCloseTextWriter.Attach(System.IO.TextWriter)">
      <summary>
            Attach this instance to a different underlying <see cref="T:System.IO.TextWriter" /></summary>
      <param name="writer">the writer to attach to</param>
      <remarks>
        <para>
            Attach this instance to a different underlying <see cref="T:System.IO.TextWriter" /></para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ProtectCloseTextWriter.Close">
      <summary>
            Does not close the underlying output writer.
            </summary>
      <remarks>
        <para>
            Does not close the underlying output writer.
            This method does nothing.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ReaderWriterLock">
      <summary>
            Defines a lock that supports single writers and multiple readers
            </summary>
      <remarks>
        <para>
          <c>ReaderWriterLock</c> is used to synchronize access to a resource. 
            At any given time, it allows either concurrent read access for 
            multiple threads, or write access for a single thread. In a 
            situation where a resource is changed infrequently, a 
            <c>ReaderWriterLock</c> provides better throughput than a simple 
            one-at-a-time lock, such as <see cref="T:System.Threading.Monitor" />.
            </para>
        <para>
            If a platform does not support a <c>System.Threading.ReaderWriterLock</c> 
            implementation then all readers and writers are serialized. Therefore 
            the caller must not rely on multiple simultaneous readers.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.ReaderWriterLock.#ctor">
      <summary>
            Constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ReaderWriterLock" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReaderWriterLock.AcquireReaderLock">
      <summary>
            Acquires a reader lock
            </summary>
      <remarks>
        <para>
          <see cref="M:log4net.Util.ReaderWriterLock.AcquireReaderLock" /> blocks if a different thread has the writer 
            lock, or if at least one thread is waiting for the writer lock.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReaderWriterLock.ReleaseReaderLock">
      <summary>
            Decrements the lock count
            </summary>
      <remarks>
        <para>
          <see cref="M:log4net.Util.ReaderWriterLock.ReleaseReaderLock" /> decrements the lock count. When the count 
            reaches zero, the lock is released.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReaderWriterLock.AcquireWriterLock">
      <summary>
            Acquires the writer lock
            </summary>
      <remarks>
        <para>
            This method blocks if another thread has a reader lock or writer lock.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReaderWriterLock.ReleaseWriterLock">
      <summary>
            Decrements the lock count on the writer lock
            </summary>
      <remarks>
        <para>
            ReleaseWriterLock decrements the writer lock count. 
            When the count reaches zero, the writer lock is released.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ReusableStringWriter">
      <summary>
            A <see cref="T:System.IO.StringWriter" /> that can be <see cref="M:log4net.Util.ReusableStringWriter.Reset(System.Int32,System.Int32)" /> and reused
            </summary>
      <remarks>
        <para>
            A <see cref="T:System.IO.StringWriter" /> that can be <see cref="M:log4net.Util.ReusableStringWriter.Reset(System.Int32,System.Int32)" /> and reused.
            This uses a single buffer for string operations.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.ReusableStringWriter.#ctor(System.IFormatProvider)">
      <summary>
            Create an instance of <see cref="T:log4net.Util.ReusableStringWriter" /></summary>
      <param name="formatProvider">the format provider to use</param>
      <remarks>
        <para>
            Create an instance of <see cref="T:log4net.Util.ReusableStringWriter" /></para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReusableStringWriter.Dispose(System.Boolean)">
      <summary>
            Override Dispose to prevent closing of writer
            </summary>
      <param name="disposing">flag</param>
      <remarks>
        <para>
            Override Dispose to prevent closing of writer
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ReusableStringWriter.Reset(System.Int32,System.Int32)">
      <summary>
            Reset this string writer so that it can be reused.
            </summary>
      <param name="maxCapacity">the maximum buffer capacity before it is trimmed</param>
      <param name="defaultSize">the default size to make the buffer</param>
      <remarks>
        <para>
            Reset this string writer so that it can be reused.
            The internal buffers are cleared and reset.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.SystemInfo">
      <summary>
            Utility class for system specific information.
            </summary>
      <remarks>
        <para>
            Utility class of static methods for system specific information.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
      <author>Alexey Solofnenko</author>
    </member>
    <member name="F:log4net.Util.SystemInfo.EmptyTypes">
      <summary>
            Gets an empty array of types.
            </summary>
      <remarks>
        <para>
            The <c>Type.EmptyTypes</c> field is not available on
            the .NET Compact Framework 1.0.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Util.SystemInfo.s_hostName">
      <summary>
            Cache the host name for the current machine
            </summary>
    </member>
    <member name="F:log4net.Util.SystemInfo.s_appFriendlyName">
      <summary>
            Cache the application friendly name
            </summary>
    </member>
    <member name="F:log4net.Util.SystemInfo.s_nullText">
      <summary>
            Text to output when a <c>null</c> is encountered.
            </summary>
    </member>
    <member name="F:log4net.Util.SystemInfo.s_notAvailableText">
      <summary>
            Text to output when an unsupported feature is requested.
            </summary>
    </member>
    <member name="F:log4net.Util.SystemInfo.s_processStartTime">
      <summary>
            Start time for the current process.
            </summary>
    </member>
    <member name="M:log4net.Util.SystemInfo.#ctor">
      <summary>
            Private constructor to prevent instances.
            </summary>
      <remarks>
        <para>
            Only static methods are exposed from this type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.AssemblyLocationInfo(System.Reflection.Assembly)">
      <summary>
            Gets the assembly location path for the specified assembly.
            </summary>
      <param name="myAssembly">The assembly to get the location for.</param>
      <returns>The location of the assembly.</returns>
      <remarks>
        <para>
            This method does not guarantee to return the correct path
            to the assembly. If only tries to give an indication as to
            where the assembly was loaded from.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.AssemblyQualifiedName(System.Type)">
      <summary>
            Gets the fully qualified name of the <see cref="T:System.Type" />, including 
            the name of the assembly from which the <see cref="T:System.Type" /> was 
            loaded.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to get the fully qualified name for.</param>
      <returns>The fully qualified name for the <see cref="T:System.Type" />.</returns>
      <remarks>
        <para>
            This is equivalent to the <c>Type.AssemblyQualifiedName</c> property,
            but this method works on the .NET Compact Framework 1.0 as well as
            the full .NET runtime.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.AssemblyShortName(System.Reflection.Assembly)">
      <summary>
            Gets the short name of the <see cref="T:System.Reflection.Assembly" />.
            </summary>
      <param name="myAssembly">The <see cref="T:System.Reflection.Assembly" /> to get the name for.</param>
      <returns>The short name of the <see cref="T:System.Reflection.Assembly" />.</returns>
      <remarks>
        <para>
            The short name of the assembly is the <see cref="P:System.Reflection.Assembly.FullName" /> 
            without the version, culture, or public key. i.e. it is just the 
            assembly's file name without the extension.
            </para>
        <para>
            Use this rather than <c>Assembly.GetName().Name</c> because that
            is not available on the Compact Framework.
            </para>
        <para>
            Because of a FileIOPermission security demand we cannot do
            the obvious Assembly.GetName().Name. We are allowed to get
            the <see cref="P:System.Reflection.Assembly.FullName" /> of the assembly so we 
            start from there and strip out just the assembly name.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.AssemblyFileName(System.Reflection.Assembly)">
      <summary>
            Gets the file name portion of the <see cref="T:System.Reflection.Assembly" />, including the extension.
            </summary>
      <param name="myAssembly">The <see cref="T:System.Reflection.Assembly" /> to get the file name for.</param>
      <returns>The file name of the assembly.</returns>
      <remarks>
        <para>
            Gets the file name portion of the <see cref="T:System.Reflection.Assembly" />, including the extension.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.GetTypeFromString(System.Type,System.String,System.Boolean,System.Boolean)">
      <summary>
            Loads the type specified in the type string.
            </summary>
      <param name="relativeType">A sibling type to use to load the type.</param>
      <param name="typeName">The name of the type to load.</param>
      <param name="throwOnError">Flag set to <c>true</c> to throw an exception if the type cannot be loaded.</param>
      <param name="ignoreCase">
        <c>true</c> to ignore the case of the type name; otherwise, <c>false</c></param>
      <returns>The type loaded or <c>null</c> if it could not be loaded.</returns>
      <remarks>
        <para>
            If the type name is fully qualified, i.e. if contains an assembly name in 
            the type name, the type will be loaded from the system using 
            <see cref="M:System.Type.GetType(System.String,System.Boolean)" />.
            </para>
        <para>
            If the type name is not fully qualified, it will be loaded from the assembly
            containing the specified relative type. If the type is not found in the assembly 
            then all the loaded assemblies will be searched for the type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.GetTypeFromString(System.String,System.Boolean,System.Boolean)">
      <summary>
            Loads the type specified in the type string.
            </summary>
      <param name="typeName">The name of the type to load.</param>
      <param name="throwOnError">Flag set to <c>true</c> to throw an exception if the type cannot be loaded.</param>
      <param name="ignoreCase">
        <c>true</c> to ignore the case of the type name; otherwise, <c>false</c></param>
      <returns>The type loaded or <c>null</c> if it could not be loaded.</returns>
      <remarks>
        <para>
            If the type name is fully qualified, i.e. if contains an assembly name in 
            the type name, the type will be loaded from the system using 
            <see cref="M:System.Type.GetType(System.String,System.Boolean)" />.
            </para>
        <para>
            If the type name is not fully qualified it will be loaded from the
            assembly that is directly calling this method. If the type is not found 
            in the assembly then all the loaded assemblies will be searched for the type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.GetTypeFromString(System.Reflection.Assembly,System.String,System.Boolean,System.Boolean)">
      <summary>
            Loads the type specified in the type string.
            </summary>
      <param name="relativeAssembly">An assembly to load the type from.</param>
      <param name="typeName">The name of the type to load.</param>
      <param name="throwOnError">Flag set to <c>true</c> to throw an exception if the type cannot be loaded.</param>
      <param name="ignoreCase">
        <c>true</c> to ignore the case of the type name; otherwise, <c>false</c></param>
      <returns>The type loaded or <c>null</c> if it could not be loaded.</returns>
      <remarks>
        <para>
            If the type name is fully qualified, i.e. if contains an assembly name in 
            the type name, the type will be loaded from the system using 
            <see cref="M:System.Type.GetType(System.String,System.Boolean)" />.
            </para>
        <para>
            If the type name is not fully qualified it will be loaded from the specified
            assembly. If the type is not found in the assembly then all the loaded assemblies 
            will be searched for the type.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.NewGuid">
      <summary>
            Generate a new guid
            </summary>
      <returns>A new Guid</returns>
      <remarks>
        <para>
            Generate a new guid
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.CreateArgumentOutOfRangeException(System.String,System.Object,System.String)">
      <summary>
            Create an <see cref="T:System.ArgumentOutOfRangeException" /></summary>
      <param name="parameterName">The name of the parameter that caused the exception</param>
      <param name="actualValue">The value of the argument that causes this exception</param>
      <param name="message">The message that describes the error</param>
      <returns>the ArgumentOutOfRangeException object</returns>
      <remarks>
        <para>
            Create a new instance of the <see cref="T:System.ArgumentOutOfRangeException" /> class 
            with a specified error message, the parameter name, and the value 
            of the argument.
            </para>
        <para>
            The Compact Framework does not support the 3 parameter constructor for the
            <see cref="T:System.ArgumentOutOfRangeException" /> type. This method provides an
            implementation that works for all platforms.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.TryParse(System.String,System.Int32@)">
      <summary>
            Parse a string into an <see cref="T:System.Int32" /> value
            </summary>
      <param name="s">the string to parse</param>
      <param name="val">out param where the parsed value is placed</param>
      <returns>
        <c>true</c> if the string was able to be parsed into an integer</returns>
      <remarks>
        <para>
            Attempts to parse the string into an integer. If the string cannot
            be parsed then this method returns <c>false</c>. The method does not throw an exception.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.TryParse(System.String,System.Int64@)">
      <summary>
            Parse a string into an <see cref="T:System.Int64" /> value
            </summary>
      <param name="s">the string to parse</param>
      <param name="val">out param where the parsed value is placed</param>
      <returns>
        <c>true</c> if the string was able to be parsed into an integer</returns>
      <remarks>
        <para>
            Attempts to parse the string into an integer. If the string cannot
            be parsed then this method returns <c>false</c>. The method does not throw an exception.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.GetAppSetting(System.String)">
      <summary>
            Lookup an application setting
            </summary>
      <param name="key">the application settings key to lookup</param>
      <returns>the value for the key, or <c>null</c></returns>
      <remarks>
        <para>
            Configuration APIs are not supported under the Compact Framework
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.ConvertToFullPath(System.String)">
      <summary>
            Convert a path into a fully qualified local file path.
            </summary>
      <param name="path">The path to convert.</param>
      <returns>The fully qualified path.</returns>
      <remarks>
        <para>
            Converts the path specified to a fully
            qualified path. If the path is relative it is
            taken as relative from the application base 
            directory.
            </para>
        <para>
            The path specified must be a local file path, a URI is not supported.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemInfo.CreateCaseInsensitiveHashtable">
      <summary>
            Creates a new case-insensitive instance of the <see cref="T:System.Collections.Hashtable" /> class with the default initial capacity. 
            </summary>
      <returns>A new case-insensitive instance of the <see cref="T:System.Collections.Hashtable" /> class with the default initial capacity</returns>
      <remarks>
        <para>
            The new Hashtable instance uses the default load factor, the CaseInsensitiveHashCodeProvider, and the CaseInsensitiveComparer.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.NewLine">
      <summary>
            Gets the system dependent line terminator.
            </summary>
      <value>
            The system dependent line terminator.
            </value>
      <remarks>
        <para>
            Gets the system dependent line terminator.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.ApplicationBaseDirectory">
      <summary>
            Gets the base directory for this <see cref="T:System.AppDomain" />.
            </summary>
      <value>The base directory path for the current <see cref="T:System.AppDomain" />.</value>
      <remarks>
        <para>
            Gets the base directory for this <see cref="T:System.AppDomain" />.
            </para>
        <para>
            The value returned may be either a local file path or a URI.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.ConfigurationFileLocation">
      <summary>
            Gets the path to the configuration file for the current <see cref="T:System.AppDomain" />.
            </summary>
      <value>The path to the configuration file for the current <see cref="T:System.AppDomain" />.</value>
      <remarks>
        <para>
            The .NET Compact Framework 1.0 does not have a concept of a configuration
            file. For this runtime, we use the entry assembly location as the root for
            the configuration file name.
            </para>
        <para>
            The value returned may be either a local file path or a URI.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.EntryAssemblyLocation">
      <summary>
            Gets the path to the file that first executed in the current <see cref="T:System.AppDomain" />.
            </summary>
      <value>The path to the entry assembly.</value>
      <remarks>
        <para>
            Gets the path to the file that first executed in the current <see cref="T:System.AppDomain" />.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.CurrentThreadId">
      <summary>
            Gets the ID of the current thread.
            </summary>
      <value>The ID of the current thread.</value>
      <remarks>
        <para>
            On the .NET framework, the <c>AppDomain.GetCurrentThreadId</c> method
            is used to obtain the thread ID for the current thread. This is the 
            operating system ID for the thread.
            </para>
        <para>
            On the .NET Compact Framework 1.0 it is not possible to get the 
            operating system thread ID for the current thread. The native method 
            <c>GetCurrentThreadId</c> is implemented inline in a header file
            and cannot be called.
            </para>
        <para>
            On the .NET Framework 2.0 the <c>Thread.ManagedThreadId</c> is used as this
            gives a stable id unrelated to the operating system thread ID which may 
            change if the runtime is using fibers.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.HostName">
      <summary>
            Get the host name or machine name for the current machine
            </summary>
      <value>
            The hostname or machine name
            </value>
      <remarks>
        <para>
            Get the host name or machine name for the current machine
            </para>
        <para>
            The host name (<see cref="M:System.Net.Dns.GetHostName" />) or
            the machine name (<c>Environment.MachineName</c>) for
            the current machine, or if neither of these are available
            then <c>NOT AVAILABLE</c> is returned.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.ApplicationFriendlyName">
      <summary>
            Get this application's friendly name
            </summary>
      <value>
            The friendly name of this application as a string
            </value>
      <remarks>
        <para>
            If available the name of the application is retrieved from
            the <c>AppDomain</c> using <c>AppDomain.CurrentDomain.FriendlyName</c>.
            </para>
        <para>
            Otherwise the file name of the entry assembly is used.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.ProcessStartTime">
      <summary>
            Get the start time for the current process.
            </summary>
      <remarks>
        <para>
            This is the time at which the log4net library was loaded into the
            AppDomain. Due to reports of a hang in the call to <c>System.Diagnostics.Process.StartTime</c>
            this is not the start time for the current process.
            </para>
        <para>
            The log4net library should be loaded by an application early during its
            startup, therefore this start time should be a good approximation for
            the actual start time.
            </para>
        <para>
            Note that AppDomains may be loaded and unloaded within the
            same process without the process terminating, however this start time
            will be set per AppDomain.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.NullText">
      <summary>
            Text to output when a <c>null</c> is encountered.
            </summary>
      <remarks>
        <para>
            Use this value to indicate a <c>null</c> has been encountered while
            outputting a string representation of an item.
            </para>
        <para>
            The default value is <c>(null)</c>. This value can be overridden by specifying
            a value for the <c>log4net.NullText</c> appSetting in the application's
            .config file.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.SystemInfo.NotAvailableText">
      <summary>
            Text to output when an unsupported feature is requested.
            </summary>
      <remarks>
        <para>
            Use this value when an unsupported feature is requested.
            </para>
        <para>
            The default value is <c>NOT AVAILABLE</c>. This value can be overridden by specifying
            a value for the <c>log4net.NotAvailableText</c> appSetting in the application's
            .config file.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.SystemStringFormat">
      <summary>
            Utility class that represents a format string.
            </summary>
      <remarks>
        <para>
            Utility class that represents a format string.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.SystemStringFormat.#ctor(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Initialise the <see cref="T:log4net.Util.SystemStringFormat" /></summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information.</param>
      <param name="format">A <see cref="T:System.String" /> containing zero or more format items.</param>
      <param name="args">An <see cref="T:System.Object" /> array containing zero or more objects to format.</param>
    </member>
    <member name="M:log4net.Util.SystemStringFormat.ToString">
      <summary>
            Format the string and arguments
            </summary>
      <returns>the formatted string</returns>
    </member>
    <member name="M:log4net.Util.SystemStringFormat.StringFormat(System.IFormatProvider,System.String,System.Object[])">
      <summary>
            Replaces the format item in a specified <see cref="T:System.String" /> with the text equivalent 
            of the value of a corresponding <see cref="T:System.Object" /> instance in a specified array.
            A specified parameter supplies culture-specific formatting information.
            </summary>
      <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information.</param>
      <param name="format">A <see cref="T:System.String" /> containing zero or more format items.</param>
      <param name="args">An <see cref="T:System.Object" /> array containing zero or more objects to format.</param>
      <returns>
            A copy of format in which the format items have been replaced by the <see cref="T:System.String" /> 
            equivalent of the corresponding instances of <see cref="T:System.Object" /> in args.
            </returns>
      <remarks>
        <para>
            This method does not throw exceptions. If an exception thrown while formatting the result the
            exception and arguments are returned in the result string.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.SystemStringFormat.StringFormatError(System.Exception,System.String,System.Object[])">
      <summary>
            Process an error during StringFormat
            </summary>
    </member>
    <member name="M:log4net.Util.SystemStringFormat.RenderArray(System.Array,System.Text.StringBuilder)">
      <summary>
            Dump the contents of an array into a string builder
            </summary>
    </member>
    <member name="M:log4net.Util.SystemStringFormat.RenderObject(System.Object,System.Text.StringBuilder)">
      <summary>
            Dump an object to a string
            </summary>
    </member>
    <member name="T:log4net.Util.ThreadContextProperties">
      <summary>
            Implementation of Properties collection for the <see cref="T:log4net.ThreadContext" /></summary>
      <remarks>
        <para>
            Class implements a collection of properties that is specific to each thread.
            The class is not synchronized as each thread has its own <see cref="T:log4net.Util.PropertiesDictionary" />.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.Util.ThreadContextProperties.s_threadLocalSlot">
      <summary>
            The thread local data slot to use to store a PropertiesDictionary.
            </summary>
    </member>
    <member name="M:log4net.Util.ThreadContextProperties.#ctor">
      <summary>
            Internal constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ThreadContextProperties" /> class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextProperties.Remove(System.String)">
      <summary>
            Remove a property
            </summary>
      <param name="key">the key for the entry to remove</param>
      <remarks>
        <para>
            Remove a property
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextProperties.Clear">
      <summary>
            Clear all properties
            </summary>
      <remarks>
        <para>
            Clear all properties
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextProperties.GetProperties(System.Boolean)">
      <summary>
            Get the <c>PropertiesDictionary</c> for this thread.
            </summary>
      <param name="create">create the dictionary if it does not exist, otherwise return null if is does not exist</param>
      <returns>the properties for this thread</returns>
      <remarks>
        <para>
            The collection returned is only to be used on the calling thread. If the
            caller needs to share the collection between different threads then the 
            caller must clone the collection before doing so.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ThreadContextProperties.Item(System.String)">
      <summary>
            Gets or sets the value of a property
            </summary>
      <value>
            The value for the property with the specified key
            </value>
      <remarks>
        <para>
            Gets or sets the value of a property
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ThreadContextStack">
      <summary>
            Implementation of Stack for the <see cref="T:log4net.ThreadContext" /></summary>
      <remarks>
        <para>
            Implementation of Stack for the <see cref="T:log4net.ThreadContext" /></para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="T:log4net.Util.ThreadContextStack.StackFrame">
      <summary>
            Inner class used to represent a single context frame in the stack.
            </summary>
      <remarks>
        <para>
            Inner class used to represent a single context frame in the stack.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.StackFrame.#ctor(System.String,log4net.Util.ThreadContextStack.StackFrame)">
      <summary>
            Constructor
            </summary>
      <param name="message">The message for this context.</param>
      <param name="parent">The parent context in the chain.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ThreadContextStack.StackFrame" /> class
            with the specified message and parent context.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ThreadContextStack.StackFrame.Message">
      <summary>
            Get the message.
            </summary>
      <value>The message.</value>
      <remarks>
        <para>
            Get the message.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ThreadContextStack.StackFrame.FullMessage">
      <summary>
            Gets the full text of the context down to the root level.
            </summary>
      <value>
            The full text of the context down to the root level.
            </value>
      <remarks>
        <para>
            Gets the full text of the context down to the root level.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ThreadContextStack.AutoPopStackFrame">
      <summary>
            Struct returned from the <see cref="M:log4net.Util.ThreadContextStack.Push(System.String)" /> method.
            </summary>
      <remarks>
        <para>
            This struct implements the <see cref="T:System.IDisposable" /> and is designed to be used
            with the <see langword="using" /> pattern to remove the stack frame at the end of the scope.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.AutoPopStackFrame.#ctor(System.Collections.Stack,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="frameStack">The internal stack used by the ThreadContextStack.</param>
      <param name="frameDepth">The depth to return the stack to when this object is disposed.</param>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ThreadContextStack.AutoPopStackFrame" /> class with
            the specified stack and return depth.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.AutoPopStackFrame.Dispose">
      <summary>
            Returns the stack to the correct depth.
            </summary>
      <remarks>
        <para>
            Returns the stack to the correct depth.
            </para>
      </remarks>
    </member>
    <member name="F:log4net.Util.ThreadContextStack.m_stack">
      <summary>
            The stack store.
            </summary>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.#ctor">
      <summary>
            Internal constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ThreadContextStack" /> class. 
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.Clear">
      <summary>
            Clears all the contextual information held in this stack.
            </summary>
      <remarks>
        <para>
            Clears all the contextual information held in this stack.
            Only call this if you think that this tread is being reused after
            a previous call execution which may not have completed correctly.
            You do not need to use this method if you always guarantee to call
            the <see cref="M:System.IDisposable.Dispose" /> method of the <see cref="T:System.IDisposable" />
            returned from <see cref="M:log4net.Util.ThreadContextStack.Push(System.String)" /> even in exceptional circumstances,
            for example by using the <c>using(log4net.ThreadContext.Stacks["NDC"].Push("Stack_Message"))</c> 
            syntax.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.Pop">
      <summary>
            Removes the top context from this stack.
            </summary>
      <returns>The message in the context that was removed from the top of this stack.</returns>
      <remarks>
        <para>
            Remove the top context from this stack, and return
            it to the caller. If this stack is empty then an
            empty string (not <see langword="null" />) is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.Push(System.String)">
      <summary>
            Pushes a new context message into this stack.
            </summary>
      <param name="message">The new context message.</param>
      <returns>
            An <see cref="T:System.IDisposable" /> that can be used to clean up the context stack.
            </returns>
      <remarks>
        <para>
            Pushes a new context onto this stack. An <see cref="T:System.IDisposable" />
            is returned that can be used to clean up this stack. This
            can be easily combined with the <c>using</c> keyword to scope the
            context.
            </para>
      </remarks>
      <example>Simple example of using the <c>Push</c> method with the <c>using</c> keyword.
            <code lang="C#">
            using(log4net.ThreadContext.Stacks["NDC"].Push("Stack_Message"))
            {
            	log.Warn("This should have an ThreadContext Stack message");
            }
            </code></example>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.GetFullMessage">
      <summary>
            Gets the current context information for this stack.
            </summary>
      <returns>The current context information.</returns>
    </member>
    <member name="M:log4net.Util.ThreadContextStack.ToString">
      <summary>
            Gets the current context information for this stack.
            </summary>
      <returns>Gets the current context information</returns>
      <remarks>
        <para>
            Gets the current context information for this stack.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ThreadContextStack.Count">
      <summary>
            The number of messages in the stack
            </summary>
      <value>
            The current number of messages in the stack
            </value>
      <remarks>
        <para>
            The current number of messages in the stack. That is
            the number of times <see cref="M:log4net.Util.ThreadContextStack.Push(System.String)" /> has been called
            minus the number of times <see cref="M:log4net.Util.ThreadContextStack.Pop" /> has been called.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ThreadContextStack.InternalStack">
      <summary>
            Gets and sets the internal stack used by this <see cref="T:log4net.Util.ThreadContextStack" /></summary>
      <value>The internal storage stack</value>
      <remarks>
        <para>
            This property is provided only to support backward compatability 
            of the <see cref="T:log4net.NDC" />. Tytpically the internal stack should not
            be modified.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.ThreadContextStacks">
      <summary>
            Implementation of Stacks collection for the <see cref="T:log4net.ThreadContext" /></summary>
      <remarks>
        <para>
            Implementation of Stacks collection for the <see cref="T:log4net.ThreadContext" /></para>
      </remarks>
      <author>Nicko Cadell</author>
    </member>
    <member name="M:log4net.Util.ThreadContextStacks.#ctor(log4net.Util.ContextPropertiesBase)">
      <summary>
            Internal constructor
            </summary>
      <remarks>
        <para>
            Initializes a new instance of the <see cref="T:log4net.Util.ThreadContextStacks" /> class.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.ThreadContextStacks.Item(System.String)">
      <summary>
            Gets the named thread context stack
            </summary>
      <value>
            The named stack
            </value>
      <remarks>
        <para>
            Gets the named thread context stack
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.Transform">
      <summary>
            Utility class for transforming strings.
            </summary>
      <remarks>
        <para>
            Utility class for transforming strings.
            </para>
      </remarks>
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.Util.Transform.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.Util.Transform" /> class. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to prevent instantiation of this class.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.Transform.WriteEscapedXmlString(System.Xml.XmlWriter,System.String,System.String)">
      <summary>
            Write a string to an <see cref="T:System.Xml.XmlWriter" /></summary>
      <param name="writer">the writer to write to</param>
      <param name="textData">the string to write</param>
      <param name="invalidCharReplacement">The string to replace non XML compliant chars with</param>
      <remarks>
        <para>
            The test is escaped either using XML escape entities
            or using CDATA sections.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.Transform.MaskXmlInvalidCharacters(System.String,System.String)">
      <summary>
            Replace invalid XML characters in text string
            </summary>
      <param name="textData">the XML text input string</param>
      <param name="mask">the string to use in place of invalid characters</param>
      <returns>A string that does not contain invalid XML characters.</returns>
      <remarks>
        <para>
            Certain Unicode code points are not allowed in the XML InfoSet, for
            details see: <a href="http://www.w3.org/TR/REC-xml/#charsets">http://www.w3.org/TR/REC-xml/#charsets</a>.
            </para>
        <para>
            This method replaces any illegal characters in the input string
            with the mask string specified.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.Transform.CountSubstrings(System.String,System.String)">
      <summary>
            Count the number of times that the substring occurs in the text
            </summary>
      <param name="text">the text to search</param>
      <param name="substring">the substring to find</param>
      <returns>the number of times the substring occurs in the text</returns>
      <remarks>
        <para>
            The substring is assumed to be non repeating within itself.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.WindowsSecurityContext">
      <summary>
            Impersonate a Windows Account
            </summary>
      <remarks>
        <para>
            This <see cref="T:log4net.Core.SecurityContext" /> impersonates a Windows account.
            </para>
        <para>
            How the impersonation is done depends on the value of <see cref="M:log4net.Util.WindowsSecurityContext.Impersonate(System.Object)" />.
            This allows the context to either impersonate a set of user credentials specified 
            using username, domain name and password or to revert to the process credentials.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.WindowsSecurityContext.ImpersonationMode">
      <summary>
            The impersonation modes for the <see cref="T:log4net.Util.WindowsSecurityContext" /></summary>
      <remarks>
        <para>
            See the <see cref="P:log4net.Util.WindowsSecurityContext.Credentials" /> property for
            details.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.Util.WindowsSecurityContext.DisposableImpersonationContext">
      <summary>
            Adds <see cref="T:System.IDisposable" /> to <see cref="T:System.Security.Principal.WindowsImpersonationContext" /></summary>
      <remarks>
        <para>
            Helper class to expose the <see cref="T:System.Security.Principal.WindowsImpersonationContext" />
            through the <see cref="T:System.IDisposable" /> interface.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.WindowsSecurityContext.DisposableImpersonationContext.#ctor(System.Security.Principal.WindowsImpersonationContext)">
      <summary>
            Constructor
            </summary>
      <param name="impersonationContext">the impersonation context being wrapped</param>
      <remarks>
        <para>
            Constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.WindowsSecurityContext.DisposableImpersonationContext.Dispose">
      <summary>
            Revert the impersonation
            </summary>
      <remarks>
        <para>
            Revert the impersonation
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.WindowsSecurityContext.#ctor">
      <summary>
            Default constructor
            </summary>
      <remarks>
        <para>
            Default constructor
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.WindowsSecurityContext.ActivateOptions">
      <summary>
            Initialize the SecurityContext based on the options set.
            </summary>
      <remarks>
        <para>
            This is part of the <see cref="T:log4net.Core.IOptionHandler" /> delayed object
            activation scheme. The <see cref="M:log4net.Util.WindowsSecurityContext.ActivateOptions" /> method must 
            be called on this object after the configuration properties have
            been set. Until <see cref="M:log4net.Util.WindowsSecurityContext.ActivateOptions" /> is called this
            object is in an undefined state and must not be used. 
            </para>
        <para>
            If any of the configuration properties are modified then 
            <see cref="M:log4net.Util.WindowsSecurityContext.ActivateOptions" /> must be called again.
            </para>
        <para>
            The security context will try to Logon the specified user account and
            capture a primary token for impersonation.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">The required <see cref="P:log4net.Util.WindowsSecurityContext.UserName" />, 
            <see cref="P:log4net.Util.WindowsSecurityContext.DomainName" /> or <see cref="P:log4net.Util.WindowsSecurityContext.Password" /> properties were not specified.</exception>
    </member>
    <member name="M:log4net.Util.WindowsSecurityContext.Impersonate(System.Object)">
      <summary>
            Impersonate the Windows account specified by the <see cref="P:log4net.Util.WindowsSecurityContext.UserName" /> and <see cref="P:log4net.Util.WindowsSecurityContext.DomainName" /> properties.
            </summary>
      <param name="state">caller provided state</param>
      <returns>
            An <see cref="T:System.IDisposable" /> instance that will revoke the impersonation of this SecurityContext
            </returns>
      <remarks>
        <para>
            Depending on the <see cref="P:log4net.Util.WindowsSecurityContext.Credentials" /> property either
            impersonate a user using credentials supplied or revert 
            to the process credentials.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.Util.WindowsSecurityContext.LogonUser(System.String,System.String,System.String)">
      <summary>
            Create a <see cref="T:System.Security.Principal.WindowsIdentity" /> given the userName, domainName and password.
            </summary>
      <param name="userName">the user name</param>
      <param name="domainName">the domain name</param>
      <param name="password">the password</param>
      <returns>the <see cref="T:System.Security.Principal.WindowsIdentity" /> for the account specified</returns>
      <remarks>
        <para>
            Uses the Windows API call LogonUser to get a principal token for the account. This
            token is used to initialize the WindowsIdentity.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.WindowsSecurityContext.Credentials">
      <summary>
            Gets or sets the impersonation mode for this security context
            </summary>
      <value>
            The impersonation mode for this security context
            </value>
      <remarks>
        <para>
            Impersonate either a user with user credentials or
            revert this thread to the credentials of the process.
            The value is one of the <see cref="T:log4net.Util.WindowsSecurityContext.ImpersonationMode" />
            enum.
            </para>
        <para>
            The default value is <see cref="F:log4net.Util.WindowsSecurityContext.ImpersonationMode.User" /></para>
        <para>
            When the mode is set to <see cref="F:log4net.Util.WindowsSecurityContext.ImpersonationMode.User" />
            the user's credentials are established using the
            <see cref="P:log4net.Util.WindowsSecurityContext.UserName" />, <see cref="P:log4net.Util.WindowsSecurityContext.DomainName" /> and <see cref="P:log4net.Util.WindowsSecurityContext.Password" />
            values.
            </para>
        <para>
            When the mode is set to <see cref="F:log4net.Util.WindowsSecurityContext.ImpersonationMode.Process" />
            no other properties need to be set. If the calling thread is 
            impersonating then it will be reverted back to the process credentials.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.WindowsSecurityContext.UserName">
      <summary>
            Gets or sets the Windows username for this security context
            </summary>
      <value>
            The Windows username for this security context
            </value>
      <remarks>
        <para>
            This property must be set if <see cref="P:log4net.Util.WindowsSecurityContext.Credentials" />
            is set to <see cref="F:log4net.Util.WindowsSecurityContext.ImpersonationMode.User" /> (the default setting).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.WindowsSecurityContext.DomainName">
      <summary>
            Gets or sets the Windows domain name for this security context
            </summary>
      <value>
            The Windows domain name for this security context
            </value>
      <remarks>
        <para>
            The default value for <see cref="P:log4net.Util.WindowsSecurityContext.DomainName" /> is the local machine name
            taken from the <see cref="P:System.Environment.MachineName" /> property.
            </para>
        <para>
            This property must be set if <see cref="P:log4net.Util.WindowsSecurityContext.Credentials" />
            is set to <see cref="F:log4net.Util.WindowsSecurityContext.ImpersonationMode.User" /> (the default setting).
            </para>
      </remarks>
    </member>
    <member name="P:log4net.Util.WindowsSecurityContext.Password">
      <summary>
            Sets the password for the Windows account specified by the <see cref="P:log4net.Util.WindowsSecurityContext.UserName" /> and <see cref="P:log4net.Util.WindowsSecurityContext.DomainName" /> properties.
            </summary>
      <value>
            The password for the Windows account specified by the <see cref="P:log4net.Util.WindowsSecurityContext.UserName" /> and <see cref="P:log4net.Util.WindowsSecurityContext.DomainName" /> properties.
            </value>
      <remarks>
        <para>
            This property must be set if <see cref="P:log4net.Util.WindowsSecurityContext.Credentials" />
            is set to <see cref="F:log4net.Util.WindowsSecurityContext.ImpersonationMode.User" /> (the default setting).
            </para>
      </remarks>
    </member>
    <member name="T:log4net.GlobalContext">
      <summary>
            The log4net Global Context.
            </summary>
      <remarks>
        <para>
            The <c>GlobalContext</c> provides a location for global debugging 
            information to be stored.
            </para>
        <para>
            The global context has a properties map and these properties can 
            be included in the output of log messages. The <see cref="T:log4net.Layout.PatternLayout" />
            supports selecting and outputing these properties.
            </para>
        <para>
            By default the <c>log4net:HostName</c> property is set to the name of 
            the current machine.
            </para>
      </remarks>
      <example>
        <code lang="C#">
            GlobalContext.Properties["hostname"] = Environment.MachineName;
            </code>
      </example>
      <threadsafety static="true" instance="true" />
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.GlobalContext.s_properties">
      <summary>
            The global context properties instance
            </summary>
    </member>
    <member name="M:log4net.GlobalContext.#ctor">
      <summary>
            Private Constructor. 
            </summary>
      <remarks>
            Uses a private access modifier to prevent instantiation of this class.
            </remarks>
    </member>
    <member name="P:log4net.GlobalContext.Properties">
      <summary>
            The global properties map.
            </summary>
      <value>
            The global properties map.
            </value>
      <remarks>
        <para>
            The global properties map.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.LogicalThreadContext">
      <summary>
            The log4net Logical Thread Context.
            </summary>
      <remarks>
        <para>
            The <c>LogicalThreadContext</c> provides a location for <see cref="T:System.Runtime.Remoting.Messaging.CallContext" /> specific debugging 
            information to be stored.
            The <c>LogicalThreadContext</c> properties override any <see cref="T:log4net.ThreadContext" /> or <see cref="T:log4net.GlobalContext" />
            properties with the same name.
            </para>
        <para>
            The Logical Thread Context has a properties map and a stack.
            The properties and stack can 
            be included in the output of log messages. The <see cref="T:log4net.Layout.PatternLayout" />
            supports selecting and outputting these properties.
            </para>
        <para>
            The Logical Thread Context provides a diagnostic context for the current call context. 
            This is an instrument for distinguishing interleaved log
            output from different sources. Log output is typically interleaved
            when a server handles multiple clients near-simultaneously.
            </para>
        <para>
            The Logical Thread Context is managed on a per <see cref="T:System.Runtime.Remoting.Messaging.CallContext" /> basis.
            </para>
      </remarks>
      <example>Example of using the thread context properties to store a username.
            <code lang="C#">
            LogicalThreadContext.Properties["user"] = userName;
            log.Info("This log message has a LogicalThreadContext Property called 'user'");
            </code></example>
      <example>Example of how to push a message into the context stack
            <code lang="C#">
            using(LogicalThreadContext.Stacks["LDC"].Push("my context message"))
            {
            	log.Info("This log message has a LogicalThreadContext Stack message that includes 'my context message'");
            
            } // at the end of the using block the message is automatically popped 
            </code></example>
      <threadsafety static="true" instance="true" />
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.LogicalThreadContext.s_properties">
      <summary>
            The thread context properties instance
            </summary>
    </member>
    <member name="F:log4net.LogicalThreadContext.s_stacks">
      <summary>
            The thread context stacks instance
            </summary>
    </member>
    <member name="M:log4net.LogicalThreadContext.#ctor">
      <summary>
            Private Constructor. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to prevent instantiation of this class.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.LogicalThreadContext.Properties">
      <summary>
            The thread properties map
            </summary>
      <value>
            The thread properties map
            </value>
      <remarks>
        <para>
            The <c>LogicalThreadContext</c> properties override any <see cref="T:log4net.ThreadContext" /> 
            or <see cref="T:log4net.GlobalContext" /> properties with the same name.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.LogicalThreadContext.Stacks">
      <summary>
            The thread stacks
            </summary>
      <value>
            stack map
            </value>
      <remarks>
        <para>
            The logical thread stacks.
            </para>
      </remarks>
    </member>
    <member name="T:log4net.LogManager">
      <summary>
            This class is used by client applications to request logger instances.
            </summary>
      <remarks>
        <para>
            This class has static methods that are used by a client to request
            a logger instance. The <see cref="M:log4net.LogManager.GetLogger(System.String)" /> method is 
            used to retrieve a logger.
            </para>
        <para>
            See the <see cref="T:log4net.ILog" /> interface for more details.
            </para>
      </remarks>
      <example>Simple example of logging messages
            <code lang="C#">
            ILog log = LogManager.GetLogger("application-log");
            
            log.Info("Application Start");
            log.Debug("This is a debug message");
            
            if (log.IsDebugEnabled)
            {
            	log.Debug("This is another debug message");
            }
            </code></example>
      <threadsafety static="true" instance="true" />
      <seealso cref="T:log4net.ILog" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="F:log4net.LogManager.s_wrapperMap">
      <summary>
            The wrapper map to use to hold the <see cref="T:log4net.Core.LogImpl" /> objects.
            </summary>
    </member>
    <member name="M:log4net.LogManager.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.LogManager" /> class. 
            </summary>
      <remarks>
            Uses a private access modifier to prevent instantiation of this class.
            </remarks>
    </member>
    <member name="M:log4net.LogManager.Exists(System.String)">
      <overloads>Returns the named logger if it exists.</overloads>
      <summary>
            Returns the named logger if it exists.
            </summary>
      <remarks>
        <para>
            If the named logger exists (in the default repository) then it
            returns a reference to the logger, otherwise it returns <c>null</c>.
            </para>
      </remarks>
      <param name="name">The fully qualified logger name to look for.</param>
      <returns>The logger found, or <c>null</c> if no logger could be found.</returns>
    </member>
    <member name="M:log4net.LogManager.Exists(System.String,System.String)">
      <summary>
            Returns the named logger if it exists.
            </summary>
      <remarks>
        <para>
            If the named logger exists (in the specified repository) then it
            returns a reference to the logger, otherwise it returns
            <c>null</c>.
            </para>
      </remarks>
      <param name="repository">The repository to lookup in.</param>
      <param name="name">The fully qualified logger name to look for.</param>
      <returns>
            The logger found, or <c>null</c> if the logger doesn't exist in the specified 
            repository.
            </returns>
    </member>
    <member name="M:log4net.LogManager.Exists(System.Reflection.Assembly,System.String)">
      <summary>
            Returns the named logger if it exists.
            </summary>
      <remarks>
        <para>
            If the named logger exists (in the repository for the specified assembly) then it
            returns a reference to the logger, otherwise it returns
            <c>null</c>.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <param name="name">The fully qualified logger name to look for.</param>
      <returns>
            The logger, or <c>null</c> if the logger doesn't exist in the specified
            assembly's repository.
            </returns>
    </member>
    <member name="M:log4net.LogManager.GetCurrentLoggers">
      <overloads>Get the currently defined loggers.</overloads>
      <summary>
            Returns all the currently defined loggers in the default repository.
            </summary>
      <remarks>
        <para>The root logger is <b>not</b> included in the returned array.</para>
      </remarks>
      <returns>All the defined loggers.</returns>
    </member>
    <member name="M:log4net.LogManager.GetCurrentLoggers(System.String)">
      <summary>
            Returns all the currently defined loggers in the specified repository.
            </summary>
      <param name="repository">The repository to lookup in.</param>
      <remarks>
            The root logger is <b>not</b> included in the returned array.
            </remarks>
      <returns>All the defined loggers.</returns>
    </member>
    <member name="M:log4net.LogManager.GetCurrentLoggers(System.Reflection.Assembly)">
      <summary>
            Returns all the currently defined loggers in the specified assembly's repository.
            </summary>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <remarks>
            The root logger is <b>not</b> included in the returned array.
            </remarks>
      <returns>All the defined loggers.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLogger(System.String)">
      <overloads>Get or create a logger.</overloads>
      <summary>
            Retrieves or creates a named logger.
            </summary>
      <remarks>
        <para>
            Retrieves a logger named as the <paramref name="name" />
            parameter. If the named logger already exists, then the
            existing instance will be returned. Otherwise, a new instance is
            created.
            </para>
        <para>By default, loggers do not have a set level but inherit
            it from the hierarchy. This is one of the central features of
            log4net.
            </para>
      </remarks>
      <param name="name">The name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLogger(System.String,System.String)">
      <summary>
            Retrieves or creates a named logger.
            </summary>
      <remarks>
        <para>
            Retrieve a logger named as the <paramref name="name" />
            parameter. If the named logger already exists, then the
            existing instance will be returned. Otherwise, a new instance is
            created.
            </para>
        <para>
            By default, loggers do not have a set level but inherit
            it from the hierarchy. This is one of the central features of
            log4net.
            </para>
      </remarks>
      <param name="repository">The repository to lookup in.</param>
      <param name="name">The name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLogger(System.Reflection.Assembly,System.String)">
      <summary>
            Retrieves or creates a named logger.
            </summary>
      <remarks>
        <para>
            Retrieve a logger named as the <paramref name="name" />
            parameter. If the named logger already exists, then the
            existing instance will be returned. Otherwise, a new instance is
            created.
            </para>
        <para>
            By default, loggers do not have a set level but inherit
            it from the hierarchy. This is one of the central features of
            log4net.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <param name="name">The name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLogger(System.Type)">
      <summary>
            Shorthand for <see cref="M:log4net.LogManager.GetLogger(System.String)" />.
            </summary>
      <remarks>
            Get the logger for the fully qualified name of the type specified.
            </remarks>
      <param name="type">The full name of <paramref name="type" /> will be used as the name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLogger(System.String,System.Type)">
      <summary>
            Shorthand for <see cref="M:log4net.LogManager.GetLogger(System.String)" />.
            </summary>
      <remarks>
            Gets the logger for the fully qualified name of the type specified.
            </remarks>
      <param name="repository">The repository to lookup in.</param>
      <param name="type">The full name of <paramref name="type" /> will be used as the name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLogger(System.Reflection.Assembly,System.Type)">
      <summary>
            Shorthand for <see cref="M:log4net.LogManager.GetLogger(System.String)" />.
            </summary>
      <remarks>
            Gets the logger for the fully qualified name of the type specified.
            </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
      <param name="type">The full name of <paramref name="type" /> will be used as the name of the logger to retrieve.</param>
      <returns>The logger with the name specified.</returns>
    </member>
    <member name="M:log4net.LogManager.Shutdown">
      <summary>
            Shuts down the log4net system.
            </summary>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in all the
            default repositories.
            </para>
        <para>
            Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.LogManager.ShutdownRepository">
      <overloads>Shutdown a logger repository.</overloads>
      <summary>
            Shuts down the default repository.
            </summary>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in the
            default repository.
            </para>
        <para>Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.LogManager.ShutdownRepository(System.String)">
      <summary>
            Shuts down the repository for the repository specified.
            </summary>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in the
            <paramref name="repository" /> specified.
            </para>
        <para>
            Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
      <param name="repository">The repository to shutdown.</param>
    </member>
    <member name="M:log4net.LogManager.ShutdownRepository(System.Reflection.Assembly)">
      <summary>
            Shuts down the repository specified.
            </summary>
      <remarks>
        <para>
            Calling this method will <b>safely</b> close and remove all
            appenders in all the loggers including root contained in the
            repository. The repository is looked up using
            the <paramref name="repositoryAssembly" /> specified.
            </para>
        <para>
            Some appenders need to be closed before the application exists. 
            Otherwise, pending logging events might be lost.
            </para>
        <para>
            The <c>shutdown</c> method is careful to close nested
            appenders before closing regular appenders. This is allows
            configurations where a regular appender is attached to a logger
            and again to a nested appender.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
    </member>
    <member name="M:log4net.LogManager.ResetConfiguration">
      <overloads>Reset the configuration of a repository</overloads>
      <summary>
            Resets all values contained in this repository instance to their defaults.
            </summary>
      <remarks>
        <para>
            Resets all values contained in the repository instance to their
            defaults.  This removes all appenders from all loggers, sets
            the level of all non-root loggers to <c>null</c>,
            sets their additivity flag to <c>true</c> and sets the level
            of the root logger to <see cref="F:log4net.Core.Level.Debug" />. Moreover,
            message disabling is set to its default "off" value.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.LogManager.ResetConfiguration(System.String)">
      <summary>
            Resets all values contained in this repository instance to their defaults.
            </summary>
      <remarks>
        <para>
            Reset all values contained in the repository instance to their
            defaults.  This removes all appenders from all loggers, sets
            the level of all non-root loggers to <c>null</c>,
            sets their additivity flag to <c>true</c> and sets the level
            of the root logger to <see cref="F:log4net.Core.Level.Debug" />. Moreover,
            message disabling is set to its default "off" value.
            </para>
      </remarks>
      <param name="repository">The repository to reset.</param>
    </member>
    <member name="M:log4net.LogManager.ResetConfiguration(System.Reflection.Assembly)">
      <summary>
            Resets all values contained in this repository instance to their defaults.
            </summary>
      <remarks>
        <para>
            Reset all values contained in the repository instance to their
            defaults.  This removes all appenders from all loggers, sets
            the level of all non-root loggers to <c>null</c>,
            sets their additivity flag to <c>true</c> and sets the level
            of the root logger to <see cref="F:log4net.Core.Level.Debug" />. Moreover,
            message disabling is set to its default "off" value.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository to reset.</param>
    </member>
    <member name="M:log4net.LogManager.GetLoggerRepository">
      <overloads>Get the logger repository.</overloads>
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the callers assembly (<see cref="M:System.Reflection.Assembly.GetCallingAssembly" />).
            </para>
      </remarks>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> instance for the default repository.</returns>
    </member>
    <member name="M:log4net.LogManager.GetLoggerRepository(System.String)">
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the <paramref name="repository" /> argument.
            </para>
      </remarks>
      <param name="repository">The repository to lookup in.</param>
    </member>
    <member name="M:log4net.LogManager.GetLoggerRepository(System.Reflection.Assembly)">
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the <paramref name="repositoryAssembly" /> argument.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
    </member>
    <member name="M:log4net.LogManager.GetRepository">
      <overloads>Get a logger repository.</overloads>
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the callers assembly (<see cref="M:System.Reflection.Assembly.GetCallingAssembly" />).
            </para>
      </remarks>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> instance for the default repository.</returns>
    </member>
    <member name="M:log4net.LogManager.GetRepository(System.String)">
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the <paramref name="repository" /> argument.
            </para>
      </remarks>
      <param name="repository">The repository to lookup in.</param>
    </member>
    <member name="M:log4net.LogManager.GetRepository(System.Reflection.Assembly)">
      <summary>
            Returns the default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.
            </summary>
      <returns>The default <see cref="T:log4net.Repository.ILoggerRepository" /> instance.</returns>
      <remarks>
        <para>
            Gets the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified
            by the <paramref name="repositoryAssembly" /> argument.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to lookup the repository.</param>
    </member>
    <member name="M:log4net.LogManager.CreateDomain(System.Type)">
      <overloads>Create a domain</overloads>
      <summary>
            Creates a repository with the specified repository type.
            </summary>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:log4net.LogManager.GetRepository" /> will return 
            the same repository instance.
            </para>
      </remarks>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
    </member>
    <member name="M:log4net.LogManager.CreateRepository(System.Type)">
      <overloads>Create a logger repository.</overloads>
      <summary>
            Creates a repository with the specified repository type.
            </summary>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:log4net.LogManager.GetRepository" /> will return 
            the same repository instance.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.LogManager.CreateDomain(System.String)">
      <summary>
            Creates a repository with the specified name.
            </summary>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            Creates the default type of <see cref="T:log4net.Repository.ILoggerRepository" /> which is a
            <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> object.
            </para>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An <see cref="T:System.Exception" /> will be thrown if the repository already exists.
            </para>
      </remarks>
      <param name="repository">The name of the repository, this must be unique amongst repositories.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.LogManager.CreateRepository(System.String)">
      <summary>
            Creates a repository with the specified name.
            </summary>
      <remarks>
        <para>
            Creates the default type of <see cref="T:log4net.Repository.ILoggerRepository" /> which is a
            <see cref="T:log4net.Repository.Hierarchy.Hierarchy" /> object.
            </para>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An <see cref="T:System.Exception" /> will be thrown if the repository already exists.
            </para>
      </remarks>
      <param name="repository">The name of the repository, this must be unique amongst repositories.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.LogManager.CreateDomain(System.String,System.Type)">
      <summary>
            Creates a repository with the specified name and repository type.
            </summary>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An <see cref="T:System.Exception" /> will be thrown if the repository already exists.
            </para>
      </remarks>
      <param name="repository">The name of the repository, this must be unique to the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.LogManager.CreateRepository(System.String,System.Type)">
      <summary>
            Creates a repository with the specified name and repository type.
            </summary>
      <remarks>
        <para>
            The <paramref name="repository" /> name must be unique. Repositories cannot be redefined.
            An <see cref="T:System.Exception" /> will be thrown if the repository already exists.
            </para>
      </remarks>
      <param name="repository">The name of the repository, this must be unique to the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
      <exception cref="T:log4net.Core.LogException">The specified repository already exists.</exception>
    </member>
    <member name="M:log4net.LogManager.CreateDomain(System.Reflection.Assembly,System.Type)">
      <summary>
            Creates a repository for the specified assembly and repository type.
            </summary>
      <remarks>
        <para>
          <b>CreateDomain is obsolete. Use CreateRepository instead of CreateDomain.</b>
        </para>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:log4net.LogManager.GetRepository(System.Reflection.Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to get the name of the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
    </member>
    <member name="M:log4net.LogManager.CreateRepository(System.Reflection.Assembly,System.Type)">
      <summary>
            Creates a repository for the specified assembly and repository type.
            </summary>
      <remarks>
        <para>
            The <see cref="T:log4net.Repository.ILoggerRepository" /> created will be associated with the repository
            specified such that a call to <see cref="M:log4net.LogManager.GetRepository(System.Reflection.Assembly)" /> with the
            same assembly specified will return the same repository instance.
            </para>
      </remarks>
      <param name="repositoryAssembly">The assembly to use to get the name of the repository.</param>
      <param name="repositoryType">A <see cref="T:System.Type" /> that implements <see cref="T:log4net.Repository.ILoggerRepository" />
            and has a no arg constructor. An instance of this type will be created to act
            as the <see cref="T:log4net.Repository.ILoggerRepository" /> for the repository specified.</param>
      <returns>The <see cref="T:log4net.Repository.ILoggerRepository" /> created for the repository.</returns>
    </member>
    <member name="M:log4net.LogManager.GetAllRepositories">
      <summary>
            Gets the list of currently defined repositories.
            </summary>
      <remarks>
        <para>
            Get an array of all the <see cref="T:log4net.Repository.ILoggerRepository" /> objects that have been created.
            </para>
      </remarks>
      <returns>An array of all the known <see cref="T:log4net.Repository.ILoggerRepository" /> objects.</returns>
    </member>
    <member name="M:log4net.LogManager.WrapLogger(log4net.Core.ILogger)">
      <summary>
            Looks up the wrapper object for the logger specified.
            </summary>
      <param name="logger">The logger to get the wrapper for.</param>
      <returns>The wrapper for the logger specified.</returns>
    </member>
    <member name="M:log4net.LogManager.WrapLoggers(log4net.Core.ILogger[])">
      <summary>
            Looks up the wrapper objects for the loggers specified.
            </summary>
      <param name="loggers">The loggers to get the wrappers for.</param>
      <returns>The wrapper objects for the loggers specified.</returns>
    </member>
    <member name="M:log4net.LogManager.WrapperCreationHandler(log4net.Core.ILogger)">
      <summary>
            Create the <see cref="T:log4net.Core.ILoggerWrapper" /> objects used by
            this manager.
            </summary>
      <param name="logger">The logger to wrap.</param>
      <returns>The wrapper for the logger specified.</returns>
    </member>
    <member name="T:log4net.MDC">
      <summary>
            Implementation of Mapped Diagnostic Contexts.
            </summary>
      <remarks>
        <note>
          <para>
            The MDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Properties" />.
            The current MDC implementation forwards to the <c>ThreadContext.Properties</c>.
            </para>
        </note>
        <para>
            The MDC class is similar to the <see cref="T:log4net.NDC" /> class except that it is
            based on a map instead of a stack. It provides <i>mapped
            diagnostic contexts</i>. A <i>Mapped Diagnostic Context</i>, or
            MDC in short, is an instrument for distinguishing interleaved log
            output from different sources. Log output is typically interleaved
            when a server handles multiple clients near-simultaneously.
            </para>
        <para>
            The MDC is managed on a per thread basis.
            </para>
      </remarks>
      <threadsafety static="true" instance="true" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.MDC.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.MDC" /> class. 
            </summary>
      <remarks>
            Uses a private access modifier to prevent instantiation of this class.
            </remarks>
    </member>
    <member name="M:log4net.MDC.Get(System.String)">
      <summary>
            Gets the context value identified by the <paramref name="key" /> parameter.
            </summary>
      <param name="key">The key to lookup in the MDC.</param>
      <returns>The string value held for the key, or a <c>null</c> reference if no corresponding value is found.</returns>
      <remarks>
        <note>
          <para>
            The MDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Properties" />.
            The current MDC implementation forwards to the <c>ThreadContext.Properties</c>.
            </para>
        </note>
        <para>
            If the <paramref name="key" /> parameter does not look up to a
            previously defined context then <c>null</c> will be returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.MDC.Set(System.String,System.String)">
      <summary>
            Add an entry to the MDC
            </summary>
      <param name="key">The key to store the value under.</param>
      <param name="value">The value to store.</param>
      <remarks>
        <note>
          <para>
            The MDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Properties" />.
            The current MDC implementation forwards to the <c>ThreadContext.Properties</c>.
            </para>
        </note>
        <para>
            Puts a context value (the <paramref name="val" /> parameter) as identified
            with the <paramref name="key" /> parameter into the current thread's
            context map.
            </para>
        <para>
            If a value is already defined for the <paramref name="key" />
            specified then the value will be replaced. If the <paramref name="val" /> 
            is specified as <c>null</c> then the key value mapping will be removed.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.MDC.Remove(System.String)">
      <summary>
            Removes the key value mapping for the key specified.
            </summary>
      <param name="key">The key to remove.</param>
      <remarks>
        <note>
          <para>
            The MDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Properties" />.
            The current MDC implementation forwards to the <c>ThreadContext.Properties</c>.
            </para>
        </note>
        <para>
            Remove the specified entry from this thread's MDC
            </para>
      </remarks>
    </member>
    <member name="M:log4net.MDC.Clear">
      <summary>
            Clear all entries in the MDC
            </summary>
      <remarks>
        <note>
          <para>
            The MDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Properties" />.
            The current MDC implementation forwards to the <c>ThreadContext.Properties</c>.
            </para>
        </note>
        <para>
            Remove all the entries from this thread's MDC
            </para>
      </remarks>
    </member>
    <member name="T:log4net.NDC">
      <summary>
            Implementation of Nested Diagnostic Contexts.
            </summary>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            A Nested Diagnostic Context, or NDC in short, is an instrument
            to distinguish interleaved log output from different sources. Log
            output is typically interleaved when a server handles multiple
            clients near-simultaneously.
            </para>
        <para>
            Interleaved log output can still be meaningful if each log entry
            from different contexts had a distinctive stamp. This is where NDCs
            come into play.
            </para>
        <para>
            Note that NDCs are managed on a per thread basis. The NDC class
            is made up of static methods that operate on the context of the
            calling thread.
            </para>
      </remarks>
      <example>How to push a message into the context
            <code lang="C#">
            using(NDC.Push("my context message"))
            {
            	... all log calls will have 'my context message' included ...
            
            } // at the end of the using block the message is automatically removed 
            </code></example>
      <threadsafety static="true" instance="true" />
      <author>Nicko Cadell</author>
      <author>Gert Driesen</author>
    </member>
    <member name="M:log4net.NDC.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:log4net.NDC" /> class. 
            </summary>
      <remarks>
            Uses a private access modifier to prevent instantiation of this class.
            </remarks>
    </member>
    <member name="M:log4net.NDC.Clear">
      <summary>
            Clears all the contextual information held on the current thread.
            </summary>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            Clears the stack of NDC data held on the current thread.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.NDC.CloneStack">
      <summary>
            Creates a clone of the stack of context information.
            </summary>
      <returns>A clone of the context info for this thread.</returns>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            The results of this method can be passed to the <see cref="M:log4net.NDC.Inherit(System.Collections.Stack)" /> 
            method to allow child threads to inherit the context of their 
            parent thread.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.NDC.Inherit(System.Collections.Stack)">
      <summary>
            Inherits the contextual information from another thread.
            </summary>
      <param name="stack">The context stack to inherit.</param>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            This thread will use the context information from the stack
            supplied. This can be used to initialize child threads with
            the same contextual information as their parent threads. These
            contexts will <b>NOT</b> be shared. Any further contexts that
            are pushed onto the stack will not be visible to the other.
            Call <see cref="M:log4net.NDC.CloneStack" /> to obtain a stack to pass to
            this method.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.NDC.Pop">
      <summary>
            Removes the top context from the stack.
            </summary>
      <returns>
            The message in the context that was removed from the top 
            of the stack.
            </returns>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            Remove the top context from the stack, and return
            it to the caller. If the stack is empty then an
            empty string (not <c>null</c>) is returned.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.NDC.Push(System.String)">
      <summary>
            Pushes a new context message.
            </summary>
      <param name="message">The new context message.</param>
      <returns>
            An <see cref="T:System.IDisposable" /> that can be used to clean up 
            the context stack.
            </returns>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            Pushes a new context onto the context stack. An <see cref="T:System.IDisposable" />
            is returned that can be used to clean up the context stack. This
            can be easily combined with the <c>using</c> keyword to scope the
            context.
            </para>
      </remarks>
      <example>Simple example of using the <c>Push</c> method with the <c>using</c> keyword.
            <code lang="C#">
            using(log4net.NDC.Push("NDC_Message"))
            {
            	log.Warn("This should have an NDC message");
            }
            </code></example>
    </member>
    <member name="M:log4net.NDC.Remove">
      <summary>
            Removes the context information for this thread. It is
            not required to call this method.
            </summary>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            This method is not implemented.
            </para>
      </remarks>
    </member>
    <member name="M:log4net.NDC.SetMaxDepth(System.Int32)">
      <summary>
            Forces the stack depth to be at most <paramref name="maxDepth" />.
            </summary>
      <param name="maxDepth">The maximum depth of the stack</param>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            Forces the stack depth to be at most <paramref name="maxDepth" />.
            This may truncate the head of the stack. This only affects the 
            stack in the current thread. Also it does not prevent it from
            growing, it only sets the maximum depth at the time of the
            call. This can be used to return to a known context depth.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.NDC.Depth">
      <summary>
            Gets the current context depth.
            </summary>
      <value>The current context depth.</value>
      <remarks>
        <note>
          <para>
            The NDC is deprecated and has been replaced by the <see cref="P:log4net.ThreadContext.Stacks" />.
            The current NDC implementation forwards to the <c>ThreadContext.Stacks["NDC"]</c>.
            </para>
        </note>
        <para>
            The number of context values pushed onto the context stack.
            </para>
        <para>
            Used to record the current depth of the context. This can then 
            be restored using the <see cref="M:log4net.NDC.SetMaxDepth(System.Int32)" /> method.
            </para>
      </remarks>
      <seealso cref="M:log4net.NDC.SetMaxDepth(System.Int32)" />
    </member>
    <member name="T:log4net.ThreadContext">
      <summary>
            The log4net Thread Context.
            </summary>
      <remarks>
        <para>
            The <c>ThreadContext</c> provides a location for thread specific debugging 
            information to be stored.
            The <c>ThreadContext</c> properties override any <see cref="T:log4net.GlobalContext" />
            properties with the same name.
            </para>
        <para>
            The thread context has a properties map and a stack.
            The properties and stack can 
            be included in the output of log messages. The <see cref="T:log4net.Layout.PatternLayout" />
            supports selecting and outputting these properties.
            </para>
        <para>
            The Thread Context provides a diagnostic context for the current thread. 
            This is an instrument for distinguishing interleaved log
            output from different sources. Log output is typically interleaved
            when a server handles multiple clients near-simultaneously.
            </para>
        <para>
            The Thread Context is managed on a per thread basis.
            </para>
      </remarks>
      <example>Example of using the thread context properties to store a username.
            <code lang="C#">
            ThreadContext.Properties["user"] = userName;
            log.Info("This log message has a ThreadContext Property called 'user'");
            </code></example>
      <example>Example of how to push a message into the context stack
            <code lang="C#">
            using(ThreadContext.Stacks["NDC"].Push("my context message"))
            {
            	log.Info("This log message has a ThreadContext Stack message that includes 'my context message'");
            
            } // at the end of the using block the message is automatically popped 
            </code></example>
      <threadsafety static="true" instance="true" />
      <author>Nicko Cadell</author>
    </member>
    <member name="F:log4net.ThreadContext.s_properties">
      <summary>
            The thread context properties instance
            </summary>
    </member>
    <member name="F:log4net.ThreadContext.s_stacks">
      <summary>
            The thread context stacks instance
            </summary>
    </member>
    <member name="M:log4net.ThreadContext.#ctor">
      <summary>
            Private Constructor. 
            </summary>
      <remarks>
        <para>
            Uses a private access modifier to prevent instantiation of this class.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.ThreadContext.Properties">
      <summary>
            The thread properties map
            </summary>
      <value>
            The thread properties map
            </value>
      <remarks>
        <para>
            The <c>ThreadContext</c> properties override any <see cref="T:log4net.GlobalContext" />
            properties with the same name.
            </para>
      </remarks>
    </member>
    <member name="P:log4net.ThreadContext.Stacks">
      <summary>
            The thread stacks
            </summary>
      <value>
            stack map
            </value>
      <remarks>
        <para>
            The thread local stacks.
            </para>
      </remarks>
    </member>
    <member name="T:NHibernate.ByteCode.Castle.LazyInitializer">
      <summary>
            A <see cref="T:NHibernate.Proxy.ILazyInitializer" /> for use with the Castle Dynamic Class Generator.
            </summary>
    </member>
    <member name="M:NHibernate.ByteCode.Castle.LazyInitializer.#ctor(System.String,System.Type,System.Object,System.Reflection.MethodInfo,System.Reflection.MethodInfo,NHibernate.Type.IAbstractComponentType,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Initializes a new <see cref="T:NHibernate.ByteCode.Castle.LazyInitializer" /> object.
            </summary>
      <param name="entityName">
      </param>
      <param name="persistentClass">The Class to Proxy.</param>
      <param name="id">The Id of the Object we are Proxying.</param>
      <param name="getIdentifierMethod">
      </param>
      <param name="setIdentifierMethod">
      </param>
      <param name="componentIdType">
      </param>
      <param name="session">The ISession this Proxy is in.</param>
    </member>
    <member name="M:NHibernate.ByteCode.Castle.LazyInitializer.Intercept(Castle.Core.Interceptor.IInvocation)">
      <summary>
            Invoke the actual Property/Method using the Proxy or instantiate the actual
            object and use it when the Proxy can't handle the method. 
            </summary>
      <param name="invocation">The <see cref="T:Castle.Core.Interceptor.IInvocation" /> from the generated Castle.DynamicProxy.</param>
    </member>
    <member name="M:NHibernate.ByteCode.Castle.ProxyFactory.GetProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Build a proxy using the Castle.DynamicProxy library.
            </summary>
      <param name="id">The value for the Id.</param>
      <param name="session">The Session the proxy is in.</param>
      <returns>A fully built <c>INHibernateProxy</c>.</returns>
    </member>
    <member name="T:NHibernate.Action.IExecutable">
      <summary>
            An operation which may be scheduled for later execution.
            Usually, the operation is a database insert/update/delete,
            together with required second-level cache management.
            </summary>
    </member>
    <member name="M:NHibernate.Action.IExecutable.BeforeExecutions">
      <summary> Called before executing any actions</summary>
    </member>
    <member name="M:NHibernate.Action.IExecutable.Execute">
      <summary> Execute this action</summary>
    </member>
    <member name="M:NHibernate.Action.IExecutable.HasAfterTransactionCompletion">
      <summary> 
            Do we need to retain this instance until after the transaction completes?
            </summary>
      <returns>
            False if this class defines a no-op	has after transaction completion.
            </returns>
    </member>
    <member name="M:NHibernate.Action.IExecutable.AfterTransactionCompletion(System.Boolean)">
      <summary> Called after the transaction completes</summary>
    </member>
    <member name="P:NHibernate.Action.IExecutable.PropertySpaces">
      <summary>
            What spaces (tables) are affected by this action?
            </summary>
    </member>
    <member name="T:NHibernate.Action.BulkOperationCleanupAction">
      <summary>
            Implementation of BulkOperationCleanupAction.
            </summary>
    </member>
    <member name="M:NHibernate.Action.BulkOperationCleanupAction.#ctor(NHibernate.Engine.ISessionImplementor,Iesi.Collections.Generic.ISet{System.String})">
      <summary>
            Create an action that will evict collection and entity regions based on queryspaces (table names).  
            </summary>
    </member>
    <member name="T:NHibernate.Action.CollectionAction">
      <summary>
            Any action relating to insert/update/delete of a collection
            </summary>
    </member>
    <member name="M:NHibernate.Action.CollectionAction.#ctor(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Action.CollectionAction" />.
            </summary>
      <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> that is responsible for the persisting the Collection.</param>
      <param name="collection">The Persistent collection.</param>
      <param name="key">The identifier of the Collection.</param>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> that the Action is occurring in.</param>
    </member>
    <member name="M:NHibernate.Action.CollectionAction.BeforeExecutions">
      <summary> Called before executing any actions</summary>
    </member>
    <member name="M:NHibernate.Action.CollectionAction.Execute">
      <summary> Execute this action</summary>
    </member>
    <member name="M:NHibernate.Action.CollectionAction.HasAfterTransactionCompletion">
      <summary> 
            Do we need to retain this instance until after the transaction completes?
            </summary>
      <returns>
            False if this class defines a no-op	has after transaction completion.
            </returns>
    </member>
    <member name="M:NHibernate.Action.CollectionAction.AfterTransactionCompletion(System.Boolean)">
      <summary> Called after the transaction completes</summary>
    </member>
    <member name="M:NHibernate.Action.CollectionAction.CompareTo(NHibernate.Action.CollectionAction)">
      <summary>
            Compares the current object with another object of the same type.
            </summary>
      <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the other parameter.Zero This object is equal to other. Greater than zero This object is greater than other. 
            </returns>
      <param name="other">An object to compare with this object.</param>
    </member>
    <member name="P:NHibernate.Action.CollectionAction.PropertySpaces">
      <summary>
            What spaces (tables) are affected by this action?
            </summary>
    </member>
    <member name="M:NHibernate.Action.CollectionRecreateAction.Execute">
      <summary> Execute this action</summary>
      <remarks>
            This method is called when a new non-null collection is persisted
            or when an existing (non-null) collection is moved to a new owner
            </remarks>
    </member>
    <member name="M:NHibernate.Action.CollectionRemoveAction.#ctor(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Removes a persistent collection from its loaded owner. 
            </summary>
      <param name="collection">The collection to to remove; must be non-null </param>
      <param name="persister"> The collection's persister </param>
      <param name="id">The collection key </param>
      <param name="emptySnapshot">Indicates if the snapshot is empty </param>
      <param name="session">The session </param>
      <remarks>Use this constructor when the collection is non-null.</remarks>
    </member>
    <member name="M:NHibernate.Action.CollectionRemoveAction.#ctor(System.Object,NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Removes a persistent collection from a specified owner. 
            </summary>
      <param name="affectedOwner">The collection's owner; must be non-null </param>
      <param name="persister"> The collection's persister </param>
      <param name="id">The collection key </param>
      <param name="emptySnapshot">Indicates if the snapshot is empty </param>
      <param name="session">The session </param>
      <remarks> Use this constructor when the collection to be removed has not been loaded. </remarks>
    </member>
    <member name="T:NHibernate.Action.DelayedPostInsertIdentifier">
      <summary>
            Acts as a stand-in for an entity identifier which is supposed to be
            generated on insert (like an IDENTITY column) where the insert needed to
            be delayed because we were outside a transaction when the persist
            occurred (save currently still performs the insert).
            
            The stand-in is only used within the see cref="NHibernate.Engine.PersistenceContext"
            in order to distinguish one instance from another; it is never injected into
            the entity instance or returned to the client...
            </summary>
    </member>
    <member name="T:NHibernate.Action.EntityAction">
      <summary>
            Base class for actions relating to insert/update/delete of an entity
            instance.
            </summary>
    </member>
    <member name="M:NHibernate.Action.EntityAction.#ctor(NHibernate.Engine.ISessionImplementor,System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
      <summary>
            Instantiate an action.
            </summary>
      <param name="session">The session from which this action is coming.</param>
      <param name="id">The id of the entity</param>
      <param name="instance">The entity instance</param>
      <param name="persister">The entity persister</param>
    </member>
    <member name="P:NHibernate.Action.EntityAction.EntityName">
      <summary>
            Entity name accessor
            </summary>
    </member>
    <member name="P:NHibernate.Action.EntityAction.Id">
      <summary>
            Entity Id accessor
            </summary>
    </member>
    <member name="P:NHibernate.Action.EntityAction.Instance">
      <summary>
            Entity Instance
            </summary>
    </member>
    <member name="P:NHibernate.Action.EntityAction.Session">
      <summary>
            Session from which this action originated
            </summary>
    </member>
    <member name="P:NHibernate.Action.EntityAction.Persister">
      <summary>
            The entity persister.
            </summary>
    </member>
    <member name="M:NHibernate.AdoNet.Util.DdlFormatter.Format(System.String)">
      <summary> Format an SQL statement using simple rules:
            a) Insert newline after each comma;
            b) Indent three spaces after each inserted newline;
            If the statement contains single/double quotes return unchanged,
            it is too complex and could be broken by simple formatting.
            </summary>
    </member>
    <member name="T:NHibernate.AdoNet.Util.FormatStyle">
      <summary> Represents the the understood types or styles of formatting.  </summary>
    </member>
    <member name="T:NHibernate.AdoNet.Util.SqlStatementLogger">
      <summary> Centralize logging handling for SQL statements. </summary>
    </member>
    <member name="M:NHibernate.AdoNet.Util.SqlStatementLogger.#ctor">
      <summary> Constructs a new SqlStatementLogger instance.</summary>
    </member>
    <member name="M:NHibernate.AdoNet.Util.SqlStatementLogger.#ctor(System.Boolean,System.Boolean)">
      <summary> Constructs a new SqlStatementLogger instance. </summary>
      <param name="logToStdout">Should we log to STDOUT in addition to our internal logger. </param>
      <param name="formatSql">Should we format SQL ('prettify') prior to logging. </param>
    </member>
    <member name="M:NHibernate.AdoNet.Util.SqlStatementLogger.LogCommand(System.String,System.Data.IDbCommand,NHibernate.AdoNet.Util.FormatStyle)">
      <summary> Log a IDbCommand. </summary>
      <param name="message">Title</param>
      <param name="command">The SQL statement. </param>
      <param name="style">The requested formatting style. </param>
    </member>
    <member name="M:NHibernate.AdoNet.Util.SqlStatementLogger.LogCommand(System.Data.IDbCommand,NHibernate.AdoNet.Util.FormatStyle)">
      <summary> Log a IDbCommand. </summary>
      <param name="command">The SQL statement. </param>
      <param name="style">The requested formatting style. </param>
    </member>
    <member name="T:NHibernate.Engine.IBatcher">
      <summary>
            Manages <see cref="T:System.Data.IDbCommand" />s and <see cref="T:System.Data.IDataReader" />s 
            for an <see cref="T:NHibernate.ISession" />. 
            </summary>
      <remarks>
        <p>
            Abstracts ADO.NET batching to maintain the illusion that a single logical batch 
            exists for the whole session, even when batching is disabled.
            Provides transparent <c>IDbCommand</c> caching.
            </p>
        <p>
            This will be useful once ADO.NET gets support for batching.  Until that point
            no code exists that will do batching, but this will provide a good point to do
            error checking and making sure the correct number of rows were affected.
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.Engine.IBatcher.PrepareQueryCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])">
      <summary>
            Get an <see cref="T:System.Data.IDbCommand" /> for using in loading / querying.
            </summary>
      <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString" /> to convert to an <see cref="T:System.Data.IDbCommand" />.</param>
      <param name="commandType">The <see cref="T:System.Data.CommandType" /> of the command.</param>
      <param name="parameterTypes">The <see cref="T:NHibernate.SqlTypes.SqlType">SqlTypes</see> of parameters
            in <paramref name="sql" />.</param>
      <returns>
            An <see cref="T:System.Data.IDbCommand" /> that is ready to be executed.
            </returns>
      <remarks>
        <para>
            If not explicitly released by <see cref="M:NHibernate.Engine.IBatcher.CloseCommand(System.Data.IDbCommand,System.Data.IDataReader)" />, it will be 
            released when the session is closed or disconnected.
            </para>
        <para>
            This does NOT add anything to the batch - it only creates the IDbCommand and 
            does NOT cause the batch to execute...
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Engine.IBatcher.PrepareCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])">
      <summary>
            Get a non-batchable an <see cref="T:System.Data.IDbCommand" /> to use for inserting / deleting / updating.
            Must be explicitly released by <c>CloseCommand()</c></summary>
      <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString" /> to convert to an <see cref="T:System.Data.IDbCommand" />.</param>
      <param name="commandType">The <see cref="T:System.Data.CommandType" /> of the command.</param>
      <param name="parameterTypes">The <see cref="T:NHibernate.SqlTypes.SqlType">SqlTypes</see> of parameters
            in <paramref name="sql" />.</param>
      <returns>
            An <see cref="T:System.Data.IDbCommand" /> that is ready to have the parameter values set
            and then executed.
            </returns>
    </member>
    <member name="M:NHibernate.Engine.IBatcher.CloseCommand(System.Data.IDbCommand,System.Data.IDataReader)">
      <summary>
            Close a <see cref="T:System.Data.IDbCommand" /> opened using <c>PrepareCommand()</c></summary>
      <param name="cmd">The <see cref="T:System.Data.IDbCommand" /> to ensure is closed.</param>
      <param name="reader">The <see cref="T:System.Data.IDataReader" /> to ensure is closed.</param>
    </member>
    <member name="M:NHibernate.Engine.IBatcher.CloseReader(System.Data.IDataReader)">
      <summary>
            Close a <see cref="T:System.Data.IDataReader" /> opened using <see cref="M:NHibernate.Engine.IBatcher.ExecuteReader(System.Data.IDbCommand)" /></summary>
      <param name="reader">The <see cref="T:System.Data.IDataReader" /> to ensure is closed.</param>
    </member>
    <member name="M:NHibernate.Engine.IBatcher.PrepareBatchCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])">
      <summary>
            Get a batchable <see cref="T:System.Data.IDbCommand" /> to use for inserting / deleting / updating
            (might be called many times before a single call to <c>ExecuteBatch()</c></summary>
      <remarks>
            After setting parameters, call <c>AddToBatch()</c> - do not execute the statement
            explicitly.
            </remarks>
      <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString" /> to convert to an <see cref="T:System.Data.IDbCommand" />.</param>
      <param name="commandType">The <see cref="T:System.Data.CommandType" /> of the command.</param>
      <param name="parameterTypes">The <see cref="T:NHibernate.SqlTypes.SqlType">SqlTypes</see> of parameters
            in <paramref name="sql" />.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Engine.IBatcher.AddToBatch(NHibernate.AdoNet.IExpectation)">
      <summary>
            Add an insert / delete / update to the current batch (might be called multiple times
            for a single <c>PrepareBatchStatement()</c>)
            </summary>
      <param name="expectation">Determines whether the number of rows affected by query is correct.</param>
    </member>
    <member name="M:NHibernate.Engine.IBatcher.ExecuteBatch">
      <summary>
            Execute the batch
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IBatcher.CloseCommands">
      <summary>
            Close any query statements that were left lying around
            </summary>
      <remarks>
            Use this method instead of <c>Dispose</c> if the <see cref="T:NHibernate.Engine.IBatcher" />
            can be used again.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.IBatcher.ExecuteReader(System.Data.IDbCommand)">
      <summary>
            Gets an <see cref="T:System.Data.IDataReader" /> by calling ExecuteReader on the <see cref="T:System.Data.IDbCommand" />.
            </summary>
      <param name="cmd">The <see cref="T:System.Data.IDbCommand" /> to execute to get the <see cref="T:System.Data.IDataReader" />.</param>
      <returns>The <see cref="T:System.Data.IDataReader" /> from the <see cref="T:System.Data.IDbCommand" />.</returns>
      <remarks>
            The Batcher is responsible for ensuring that all of the Drivers rules for how many open
            <see cref="T:System.Data.IDataReader" />s it can have are followed.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.IBatcher.ExecuteNonQuery(System.Data.IDbCommand)">
      <summary>
            Executes the <see cref="T:System.Data.IDbCommand" />. 
            </summary>
      <param name="cmd">The <see cref="T:System.Data.IDbCommand" /> to execute.</param>
      <returns>The number of rows affected.</returns>
      <remarks>
            The Batcher is responsible for ensuring that all of the Drivers rules for how many open
            <see cref="T:System.Data.IDataReader" />s it can have are followed.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.IBatcher.AbortBatch(System.Exception)">
      <summary>
            Must be called when an exception occurs.
            </summary>
      <param name="e">
      </param>
    </member>
    <member name="M:NHibernate.Engine.IBatcher.CancelLastQuery">
      <summary>
            Cancel the current query statement
            </summary>
    </member>
    <member name="P:NHibernate.Engine.IBatcher.HasOpenResources">
      <summary>
            Gets the value indicating whether there are any open resources
            managed by this batcher (IDbCommands or IDataReaders).
            </summary>
    </member>
    <member name="P:NHibernate.Engine.IBatcher.BatchSize">
      <summary>
            Gets or sets the size of the batch, this can change dynamically by
            calling the session's SetBatchSize.
            </summary>
      <value>The size of the batch.</value>
    </member>
    <member name="T:NHibernate.AdoNet.AbstractBatcher">
      <summary>
            Manages prepared statements and batching. Class exists to enforce separation of concerns
            </summary>
    </member>
    <member name="F:NHibernate.AdoNet.AbstractBatcher._isAlreadyDisposed">
      <summary>
            A flag to indicate if <c>Dispose()</c> has been called.
            </summary>
    </member>
    <member name="M:NHibernate.AdoNet.AbstractBatcher.#ctor(NHibernate.AdoNet.ConnectionManager,NHibernate.IInterceptor)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AdoNet.AbstractBatcher" /> class.
            </summary>
      <param name="connectionManager">The <see cref="P:NHibernate.AdoNet.AbstractBatcher.ConnectionManager" /> owning this batcher.</param>
      <param name="interceptor">
      </param>
    </member>
    <member name="M:NHibernate.AdoNet.AbstractBatcher.Prepare(System.Data.IDbCommand)">
      <summary>
            Prepares the <see cref="T:System.Data.IDbCommand" /> for execution in the database.
            </summary>
      <remarks>
            This takes care of hooking the <see cref="T:System.Data.IDbCommand" /> up to an <see cref="T:System.Data.IDbConnection" />
            and <see cref="T:System.Data.IDbTransaction" /> if one exists.  It will call <c>Prepare</c> if the Driver
            supports preparing commands.
            </remarks>
    </member>
    <member name="M:NHibernate.AdoNet.AbstractBatcher.CheckReaders">
      <summary>
            Ensures that the Driver's rules for Multiple Open DataReaders are being followed.
            </summary>
    </member>
    <member name="M:NHibernate.AdoNet.AbstractBatcher.ExecuteBatch">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.AdoNet.AbstractBatcher.DoExecuteBatch(System.Data.IDbCommand)">
      <summary>
      </summary>
      <param name="ps">
      </param>
    </member>
    <member name="M:NHibernate.AdoNet.AbstractBatcher.AddToBatch(NHibernate.AdoNet.IExpectation)">
      <summary>
            Adds the expected row count into the batch.
            </summary>
      <param name="expectation">The number of rows expected to be affected by the query.</param>
      <remarks>
            If Batching is not supported, then this is when the Command should be executed.  If Batching
            is supported then it should hold of on executing the batch until explicitly told to.
            </remarks>
    </member>
    <member name="M:NHibernate.AdoNet.AbstractBatcher.Finalize">
      <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
    </member>
    <member name="M:NHibernate.AdoNet.AbstractBatcher.Dispose">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
    </member>
    <member name="M:NHibernate.AdoNet.AbstractBatcher.Dispose(System.Boolean)">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
      <param name="isDisposing">Indicates if this BatcherImpl is being Disposed of or Finalized.</param>
      <remarks>
            If this BatcherImpl is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this BatcherImpl back to life.
            </remarks>
    </member>
    <member name="P:NHibernate.AdoNet.AbstractBatcher.CurrentCommand">
      <summary>
            Gets the current <see cref="T:System.Data.IDbCommand" /> that is contained for this Batch
            </summary>
      <value>The current <see cref="T:System.Data.IDbCommand" />.</value>
    </member>
    <member name="P:NHibernate.AdoNet.AbstractBatcher.BatchSize">
      <summary>
            Gets or sets the size of the batch, this can change dynamically by
            calling the session's SetBatchSize.
            </summary>
      <value>The size of the batch.</value>
    </member>
    <member name="P:NHibernate.AdoNet.AbstractBatcher.Factory">
      <summary>
            Gets the <see cref="T:NHibernate.Engine.ISessionFactoryImplementor" /> the Batcher was
            created in.
            </summary>
      <value>
            The <see cref="T:NHibernate.Engine.ISessionFactoryImplementor" /> the Batcher was
            created in.
            </value>
    </member>
    <member name="P:NHibernate.AdoNet.AbstractBatcher.ConnectionManager">
      <summary>
            Gets the <see cref="P:NHibernate.AdoNet.AbstractBatcher.ConnectionManager" /> for this batcher.
            </summary>
    </member>
    <member name="T:NHibernate.AdoNet.ColumnNameCache">
      <summary> Implementation of ColumnNameCache. </summary>
    </member>
    <member name="T:NHibernate.AdoNet.ConnectionManager">
      <summary>
            Manages the database connection and transaction for an <see cref="T:NHibernate.ISession" />.
            </summary>
      <remarks>
            This class corresponds to ConnectionManager and JDBCContext in Hibernate,
            combined.
            </remarks>
    </member>
    <member name="P:NHibernate.AdoNet.ConnectionManager.Batcher">
      <summary> The batcher managed by this ConnectionManager. </summary>
    </member>
    <member name="P:NHibernate.AdoNet.IExpectation.ExpectedRowCount">
      <summary>
            Expected row count. Valid only for batchable expectations.
            </summary>
    </member>
    <member name="T:NHibernate.AdoNet.IBatcherFactory">
      <summary> Factory for <see cref="T:NHibernate.Engine.IBatcher" /> instances.</summary>
    </member>
    <member name="T:NHibernate.AdoNet.IEmbeddedBatcherFactoryProvider">
      <summary>
            Provide the class of <see cref="T:NHibernate.AdoNet.IBatcherFactory" /> according to the configuration 
            and the capabilities of the driver.
            </summary>
      <remarks>
            By default, .Net doesn't have any batching capabilities, drivers that does have
            batching support.
            The BatcherFactory trough session-factory configuration section.
            This interface was added in NHibernate for backdraw compatibility to have the ability
            to specify a default <see cref="T:NHibernate.AdoNet.IBatcherFactory" /> for a specific <see cref="T:NHibernate.Driver.IDriver" />.
            </remarks>
    </member>
    <member name="T:NHibernate.AdoNet.NonBatchingBatcher">
      <summary>
            An implementation of the <see cref="T:NHibernate.Engine.IBatcher" /> 
            interface that does no batching.
            </summary>
    </member>
    <member name="M:NHibernate.AdoNet.NonBatchingBatcher.#ctor(NHibernate.AdoNet.ConnectionManager,NHibernate.IInterceptor)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AdoNet.NonBatchingBatcher" /> class.
            </summary>
      <param name="connectionManager">The <see cref="T:NHibernate.AdoNet.ConnectionManager" /> for this batcher.</param>
      <param name="interceptor">
      </param>
    </member>
    <member name="M:NHibernate.AdoNet.NonBatchingBatcher.AddToBatch(NHibernate.AdoNet.IExpectation)">
      <summary>
            Executes the current <see cref="T:System.Data.IDbCommand" /> and compares the row Count
            to the <c>expectedRowCount</c>.
            </summary>
      <param name="expectation">
            The expected number of rows affected by the query.  A value of less than <c>0</c>
            indicates that the number of rows to expect is unknown or should not be a factor.
            </param>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when there is an expected number of rows to be affected and the
            actual number of rows is different.
            </exception>
    </member>
    <member name="M:NHibernate.AdoNet.NonBatchingBatcher.DoExecuteBatch(System.Data.IDbCommand)">
      <summary>
            This Batcher implementation does not support batching so this is a no-op call.  The
            actual execution of the <see cref="T:System.Data.IDbCommand" /> is run in the <c>AddToBatch</c> 
            method.
            </summary>
      <param name="ps">
      </param>
    </member>
    <member name="T:NHibernate.AdoNet.NonBatchingBatcherFactory">
      <summary> 
            A BatcherFactory implementation which constructs Batcher instances
            that do not perform batch operations. 
            </summary>
    </member>
    <member name="T:NHibernate.AdoNet.OracleDataClientBatchingBatcher">
      <summary>
            Summary description for OracleDataClientBatchingBatcher.
            By Tomer Avissar
            </summary>
    </member>
    <member name="T:NHibernate.AdoNet.ResultSetWrapper">
      <summary> 
            A ResultSet delegate, responsible for locally caching the columnName-to-columnIndex
            resolution that has been found to be inefficient in a few vendor's drivers (i.e., Oracle
            and Postgres). 
            </summary>
      <seealso cref="M:System.Data.IDataRecord.GetOrdinal(System.String)" />
    </member>
    <member name="T:NHibernate.AdoNet.SqlClientBatchingBatcher">
      <summary>
            Summary description for SqlClientBatchingBatcher.
            </summary>
    </member>
    <member name="T:NHibernate.AdoNet.SqlClientSqlCommandSet">
      <summary>
            Expose the batch functionality in ADO.Net 2.0
            Microsoft in its wisdom decided to make my life hard and mark it internal.
            Through the use of Reflection and some delegates magic, I opened up the functionality.
            
            Observable performance benefits are 50%+ when used, so it is really worth it.
            </summary>
    </member>
    <member name="M:NHibernate.AdoNet.SqlClientSqlCommandSet.Append(System.Data.SqlClient.SqlCommand)">
      <summary>
            Append a command to the batch
            </summary>
      <param name="command">
      </param>
    </member>
    <member name="M:NHibernate.AdoNet.SqlClientSqlCommandSet.AssertHasParameters(System.Data.SqlClient.SqlCommand)">
      <summary>
            This is required because SqlClient.SqlCommandSet will throw if 
            the command has no parameters.
            </summary>
      <param name="command">
      </param>
    </member>
    <member name="M:NHibernate.AdoNet.SqlClientSqlCommandSet.ExecuteNonQuery">
      <summary>
            Executes the batch
            </summary>
      <returns>
            This seems to be returning the total number of affected rows in all queries
            </returns>
    </member>
    <member name="M:NHibernate.AdoNet.SqlClientSqlCommandSet.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:NHibernate.AdoNet.SqlClientSqlCommandSet.BatchCommand">
      <summary>
            Return the batch command to be executed
            </summary>
    </member>
    <member name="P:NHibernate.AdoNet.SqlClientSqlCommandSet.CountOfCommands">
      <summary>
            The number of commands batched in this instance
            </summary>
    </member>
    <member name="T:NHibernate.HibernateException">
      <summary>
            Any exception that occurs in the O-R persistence layer.
            </summary>
      <remarks>
            Exceptions that occur in the database layer are left as native exceptions.
            </remarks>
    </member>
    <member name="M:NHibernate.HibernateException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.HibernateException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.HibernateException.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException" /> class.
            </summary>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.HibernateException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.HibernateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException" /> class 
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="M:NHibernate.Bytecode.IBytecodeProvider.GetReflectionOptimizer(System.Type,NHibernate.Properties.IGetter[],NHibernate.Properties.ISetter[])">
      <summary>
            Retrieve the <see cref="T:NHibernate.Bytecode.IReflectionOptimizer" /> delegate for this provider
            capable of generating reflection optimization components.
            </summary>
      <param name="clazz">The class to be reflected upon.</param>
      <param name="getters">All property getters to be accessed via reflection.</param>
      <param name="setters">All property setters to be accessed via reflection.</param>
      <returns>The reflection optimization delegate.</returns>
    </member>
    <member name="P:NHibernate.Bytecode.IBytecodeProvider.ProxyFactoryFactory">
      <summary> 
            The specific factory for this provider capable of
            generating run-time proxies for lazy-loading purposes.
             </summary>
    </member>
    <member name="P:NHibernate.Bytecode.IBytecodeProvider.ObjectsFactory">
      <summary>
            NHibernate's object instaciator.
            </summary>
      <remarks>
            For entities <see cref="T:NHibernate.Bytecode.IReflectionOptimizer" /> and its implementations.
            </remarks>
    </member>
    <member name="P:NHibernate.Bytecode.IBytecodeProvider.CollectionTypeFactory">
      <summary>
            Instanciator of NHibernate's collections default types.
            </summary>
    </member>
    <member name="T:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl">
      <summary>
            CodeDOM-based bytecode provider.
            </summary>
    </member>
    <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.#ctor(System.Type,NHibernate.Properties.IGetter[],NHibernate.Properties.ISetter[])">
      <summary>
            ctor
            </summary>
      <param name="mappedClass">The target class</param>
      <param name="setters">Array of setters</param>
      <param name="getters">Array of getters</param>
    </member>
    <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.InitCompiler">
      <summary>
            Set up the compiler options
            </summary>
    </member>
    <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.AddAssembly(System.String)">
      <summary>
            Add an assembly to the list of ReferencedAssemblies
            required to build the class
            </summary>
      <param name="name">
      </param>
    </member>
    <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.Build(System.String)">
      <summary>
            Build the generated code
            </summary>
      <param name="code">Generated code</param>
      <returns>An instance of the generated class</returns>
    </member>
    <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.IsPublic(System.String)">
      <summary>
            Check if the property is public
            </summary>
      <remarks>
        <para>If IsPublic==true I can directly set the property</para>
        <para>If IsPublic==false I need to use the setter/getter</para>
      </remarks>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Bytecode.CodeDom.BytecodeProviderImpl.Generator.GenerateCode">
      <summary>
            Generate the required code
            </summary>
      <returns>C# code</returns>
    </member>
    <member name="T:NHibernate.Bytecode.IAccessOptimizer">
      <summary>
            Represents optimized entity property access.
            </summary>
    </member>
    <member name="T:NHibernate.Bytecode.Lightweight.BytecodeProviderImpl">
      <summary>
            Factory that generate object based on IReflectionOptimizer needed to replace the use
            of reflection.
            </summary>
      <remarks>
            Used in <see cref="T:NHibernate.Persister.Entity.AbstractEntityPersister" /> and
            <see cref="T:NHibernate.Type.ComponentType" /></remarks>
    </member>
    <member name="M:NHibernate.Bytecode.Lightweight.BytecodeProviderImpl.GetReflectionOptimizer(System.Type,NHibernate.Properties.IGetter[],NHibernate.Properties.ISetter[])">
      <summary>
            Generate the IReflectionOptimizer object
            </summary>
      <param name="mappedClass">The target class</param>
      <param name="setters">Array of setters</param>
      <param name="getters">Array of getters</param>
      <returns>
        <see langword="null" /> if the generation fails</returns>
    </member>
    <member name="T:NHibernate.Bytecode.IReflectionOptimizer">
      <summary>
            Represents reflection optimization for a particular class.
            </summary>
    </member>
    <member name="T:NHibernate.Bytecode.IInstantiationOptimizer">
      <summary>
            Represents optimized entity instantiation.
            </summary>
    </member>
    <member name="M:NHibernate.Bytecode.IInstantiationOptimizer.CreateInstance">
      <summary>
            Perform instantiation of an instance of the underlying class.
            </summary>
      <returns>The new instance.</returns>
    </member>
    <member name="M:NHibernate.Bytecode.Lightweight.ReflectionOptimizer.#ctor(System.Type,NHibernate.Properties.IGetter[],NHibernate.Properties.ISetter[])">
      <summary>
            Class constructor.
            </summary>
    </member>
    <member name="M:NHibernate.Bytecode.Lightweight.ReflectionOptimizer.CreateCreateInstanceMethod(System.Type)">
      <summary>
            Generates a dynamic method which creates a new instance of <paramref name="type" />
            when invoked.
            </summary>
    </member>
    <member name="M:NHibernate.Bytecode.Lightweight.ReflectionOptimizer.GenerateGetPropertyValuesMethod(NHibernate.Properties.IGetter[])">
      <summary>
            Generates a dynamic method on the given type.
            </summary>
    </member>
    <member name="M:NHibernate.Bytecode.Lightweight.ReflectionOptimizer.GenerateSetPropertyValuesMethod(NHibernate.Properties.IGetter[],NHibernate.Properties.ISetter[])">
      <summary>
            Generates a dynamic method on the given type.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Bytecode.IObjectsFactory">
      <summary>
            Interface for instanciate all NHibernate objects.
            </summary>
    </member>
    <member name="M:NHibernate.Bytecode.IObjectsFactory.CreateInstance(System.Type)">
      <summary>
            Creates an instance of the specified type.
            </summary>
      <param name="type">The type of object to create.</param>
      <returns>A reference to the created object.</returns>
    </member>
    <member name="M:NHibernate.Bytecode.IObjectsFactory.CreateInstance(System.Type,System.Boolean)">
      <summary>
            Creates an instance of the specified type.
            </summary>
      <param name="type">The type of object to create.</param>
      <param name="nonPublic">true if a public or nonpublic default constructor can match; false if only a public default constructor can match.</param>
      <returns>A reference to the created object.</returns>
    </member>
    <member name="M:NHibernate.Bytecode.IObjectsFactory.CreateInstance(System.Type,System.Object[])">
      <summary>
            Creates an instance of the specified type using the constructor 
            that best matches the specified parameters.
            </summary>
      <param name="type">The type of object to create.</param>
      <param name="ctorArgs">An array of constructor arguments.</param>
      <returns>A reference to the created object.</returns>
    </member>
    <member name="M:NHibernate.Bytecode.EmitUtil.EmitFastInt(System.Reflection.Emit.ILGenerator,System.Int32)">
      <summary>
            Emits an <c>ldc.i4</c> opcode using the fastest available opcode choice.
            </summary>
    </member>
    <member name="M:NHibernate.Bytecode.EmitUtil.PreparePropertyForSet(System.Reflection.Emit.ILGenerator,System.Type)">
      <summary>
            Emits IL to unbox a value type and if null, create a new instance of the value type.
            </summary>
      <remarks>
            This does not work if the value type doesn't have a default constructor - we delegate
            that to the ISetter.
            </remarks>
    </member>
    <member name="M:NHibernate.Bytecode.EmitUtil.DefineDelegateType(System.String,System.Reflection.Emit.ModuleBuilder,System.Type,System.Type[])">
      <summary>
            Defines a new delegate type.
            </summary>
    </member>
    <member name="T:NHibernate.Bytecode.ICollectionTypeFactory">
      <summary>
            Type factory for collections types.
            </summary>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.Array(System.String,System.String,System.Boolean,System.Type)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an <see cref="T:System.Array" />.
            </summary>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="elementClass">The <see cref="T:System.Type" /> to use to create the array.</param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            An <see cref="T:NHibernate.Type.ArrayType" /> for the specified role.
            </returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.Bag(System.String,System.String,System.Boolean)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an <see cref="T:System.Collections.IList" />
            with bag semantics.
            </summary>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            A <see cref="T:NHibernate.Type.BagType" /> for the specified role.
            </returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.Bag``1(System.String,System.String,System.Boolean)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an 
            <see cref="T:System.Collections.Generic.IList`1" /> with bag semantics.
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">
            The name of the property in the owner object containing the collection ID, 
            or <see langword="null" /> if it is the primary key.
            </param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            A <see cref="T:NHibernate.Type.GenericBagType`1" /> for the specified role.
            </returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.List(System.String,System.String,System.Boolean)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an <see cref="T:System.Collections.IList" />.
            </summary>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            A <see cref="T:NHibernate.Type.ListType" /> for the specified role.
            </returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.List``1(System.String,System.String,System.Boolean)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an 
            <see cref="T:System.Collections.Generic.IList`1" /> with list 
            semantics.
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">
            The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.
            </param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            A <see cref="T:NHibernate.Type.ListType" /> for the specified role.
            </returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.IdBag(System.String,System.String,System.Boolean)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an <see cref="T:System.Collections.IList" />
            with id-bag semantics.
            </summary>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            A <see cref="T:NHibernate.Type.IdentifierBagType" /> for the specified role.
            </returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.IdBag``1(System.String,System.String,System.Boolean)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an 
            <see cref="T:System.Collections.Generic.IList`1" /> with identifier
            bag semantics.
            </summary>
      <typeparam name="T">The type of elements in the list.</typeparam>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.
            </param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            A <see cref="T:NHibernate.Type.GenericIdentifierBagType`1" /> for the specified role.
            </returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.Set(System.String,System.String,System.Boolean)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an <see cref="T:Iesi.Collections.ISet" />.
            </summary>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            A <see cref="T:NHibernate.Type.SetType" /> for the specified role.
            </returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.SortedSet(System.String,System.String,System.Boolean,System.Collections.IComparer)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an <see cref="T:Iesi.Collections.ISet" />
            that is sorted by an <see cref="T:System.Collections.IComparer" />.
            </summary>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="comparer">The <see cref="T:System.Collections.IComparer" /> that does the sorting.</param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            A <see cref="T:NHibernate.Type.SortedSetType" /> for the specified role.
            </returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.Set``1(System.String,System.String,System.Boolean)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an <see cref="T:Iesi.Collections.Generic.ISet`1" />.
            </summary>
      <typeparam name="T">The type of elements in the collection.</typeparam>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>A <see cref="T:NHibernate.Type.GenericSetType`1" /> for the specified role.</returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.SortedSet``1(System.String,System.String,System.Boolean,System.Collections.Generic.IComparer{``0})">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for a sorted <see cref="T:Iesi.Collections.Generic.ISet`1" />.
            </summary>
      <typeparam name="T">The type of elements in the collection.</typeparam>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> to use for the set.</param>
      <returns>A <see cref="T:NHibernate.Type.GenericSetType`1" /> for the specified role.</returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.OrderedSet``1(System.String,System.String,System.Boolean)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an ordered <see cref="T:Iesi.Collections.Generic.ISet`1" />.
            </summary>
      <typeparam name="T">The type of elements in the collection.</typeparam>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">
            The name of the property in the owner object containing the collection ID, 
            or <see langword="null" /> if it is the primary key.
            </param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>A <see cref="T:NHibernate.Type.GenericSetType`1" /> for the specified role.</returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.Map(System.String,System.String,System.Boolean)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an <see cref="T:System.Collections.IDictionary" />.
            </summary>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">
            The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            A <see cref="T:NHibernate.Type.MapType" /> for the specified role.
            </returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.OrderedMap(System.String,System.String,System.Boolean)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an <see cref="T:System.Collections.IDictionary" />
            that maintains insertion order of elements.
            </summary>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            A <see cref="T:NHibernate.Type.OrderedMapType" /> for the specified role.
            </returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.SortedMap(System.String,System.String,System.Boolean,System.Collections.IComparer)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an <see cref="T:System.Collections.IDictionary" />
            that is sorted by an <see cref="T:System.Collections.IComparer" />.
            </summary>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="comparer">The <see cref="T:System.Collections.IComparer" /> that does the sorting.</param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            A <see cref="T:NHibernate.Type.SortedMapType" /> for the specified role.
            </returns>
    </member>
    <member name="M:NHibernate.Bytecode.ICollectionTypeFactory.Map``2(System.String,System.String,System.Boolean)">
      <summary>
            Creates a new <see cref="T:NHibernate.Type.CollectionType" /> for an 
            <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
      <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of values in the dictionary.</typeparam>
      <param name="role">The role the collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.
            </param>
      <param name="embedded">Is embedded in XML (not supported yet)</param>
      <returns>
            A <see cref="T:NHibernate.Type.MapType" /> for the specified role.
            </returns>
    </member>
    <member name="T:NHibernate.Bytecode.IProxyFactoryFactory">
      <summary> 
            An interface for factories of <see cref="T:NHibernate.Proxy.IProxyFactory">proxy factory</see> instances.
            </summary>
      <remarks>
            Used to abstract from the tupizer.
            </remarks>
    </member>
    <member name="M:NHibernate.Bytecode.IProxyFactoryFactory.BuildProxyFactory">
      <summary> 
            Build a proxy factory specifically for handling runtime
            lazy loading. 
            </summary>
      <returns> The lazy-load proxy factory. </returns>
    </member>
    <member name="T:NHibernate.Bytecode.NullBytecodeProvider">
      <summary>
            A <see cref="T:NHibernate.Bytecode.IBytecodeProvider" /> implementation that returns
            <see langword="null" />, disabling reflection optimization.
            </summary>
    </member>
    <member name="T:NHibernate.Cache.Entry.CacheEntry">
      <summary>
            A cached instance of a persistent class
            </summary>
    </member>
    <member name="T:NHibernate.Cache.ICacheConcurrencyStrategy">
      <summary>
            Implementors manage transactional access to cached data.
            </summary>
      <remarks>
        <para>
            Transactions pass in a timestamp indicating transaction start time.
            </para>
        <para>
            When used to cache entities and collections the key is the identifier of the
            entity/collection and the value should be set to the <see cref="T:NHibernate.Cache.Entry.CacheEntry" /> 
            for an entity and the results of <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Disassemble(NHibernate.Persister.Collection.ICollectionPersister)" />
            for a collection.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Get(NHibernate.Cache.CacheKey,System.Int64)">
      <summary>
            Attempt to retrieve an object from the Cache
            </summary>
      <param name="key">The key (id) of the object to get out of the Cache.</param>
      <param name="txTimestamp">A timestamp prior to the transaction start time</param>
      <returns>The cached object or <see langword="null" /></returns>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
    </member>
    <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Put(NHibernate.Cache.CacheKey,System.Object,System.Int64,System.Object,System.Collections.IComparer,System.Boolean)">
      <summary>
            Attempt to cache an object, after loading from the database
            </summary>
      <param name="key">The key (id) of the object to put in the Cache.</param>
      <param name="value">The value</param>
      <param name="txTimestamp">A timestamp prior to the transaction start time</param>
      <param name="version">the version number of the object we are putting</param>
      <param name="versionComparer">a Comparer to be used to compare version numbers</param>
      <param name="minimalPut">indicates that the cache should avoid a put if the item is already cached</param>
      <returns>
        <see langword="true" /> if the object was successfully cached</returns>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
    </member>
    <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Lock(NHibernate.Cache.CacheKey,System.Object)">
      <summary>
            We are going to attempt to update/delete the keyed object
            </summary>
      <param name="key">The key</param>
      <param name="version">
      </param>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
      <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
    </member>
    <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Evict(NHibernate.Cache.CacheKey)">
      <summary>
            Called after an item has become stale (before the transaction completes).
            </summary>
      <param name="key">
      </param>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
      <remarks>This method is used by "synchronous" concurrency strategies.</remarks>
    </member>
    <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Update(NHibernate.Cache.CacheKey,System.Object,System.Object,System.Object)">
      <summary>
            Called after an item has been updated (before the transaction completes),
            instead of calling Evict().
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <param name="currentVersion">
      </param>
      <param name="previousVersion">
      </param>
      <remarks>This method is used by "synchronous" concurrency strategies.</remarks>
    </member>
    <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Insert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
      <summary>
            Called after an item has been inserted (before the transaction completes), instead of calling Evict().
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <param name="currentVersion">
      </param>
      <remarks>This method is used by "synchronous" concurrency strategies.</remarks>
    </member>
    <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Release(NHibernate.Cache.CacheKey,NHibernate.Cache.ISoftLock)">
      <summary>
            Called when we have finished the attempted update/delete (which may or
            may not have been successful), after transaction completion.
            </summary>
      <param name="key">The key</param>
      <param name="lock">The soft lock</param>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
      <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
    </member>
    <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.AfterUpdate(NHibernate.Cache.CacheKey,System.Object,System.Object,NHibernate.Cache.ISoftLock)">
      <summary>
            Called after an item has been updated (after the transaction completes),
            instead of calling Release().
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <param name="version">
      </param>
      <param name="lock">
      </param>
      <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
    </member>
    <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.AfterInsert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
      <summary>
            Called after an item has been inserted (after the transaction completes), instead of calling release().
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <param name="version">
      </param>
      <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
    </member>
    <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Remove(NHibernate.Cache.CacheKey)">
      <summary>
            Evict an item from the cache immediately (without regard for transaction isolation).
            </summary>
      <param name="key">
      </param>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
    </member>
    <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Clear">
      <summary>
            Evict all items from the cache immediately.
            </summary>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
    </member>
    <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Destroy">
      <summary>
            Clean up all resources.
            </summary>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
    </member>
    <member name="P:NHibernate.Cache.ICacheConcurrencyStrategy.RegionName">
      <summary>
            Gets the cache region name.
            </summary>
    </member>
    <member name="P:NHibernate.Cache.ICacheConcurrencyStrategy.Cache">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Cache.ICache" /> for this strategy to use.
            </summary>
      <value>The <see cref="T:NHibernate.Cache.ICache" /> for this strategy to use.</value>
    </member>
    <member name="T:NHibernate.Cache.ReadWriteCache">
      <summary>
            Caches data that is sometimes updated while maintaining the semantics of
            "read committed" isolation level. If the database is set to "repeatable
            read", this concurrency strategy <em>almost</em> maintains the semantics.
            Repeatable read isolation is compromised in the case of concurrent writes.
            This is an "asynchronous" concurrency strategy.
            </summary>
      <remarks>
            If this strategy is used in a cluster, the underlying cache implementation
            must support distributed hard locks (which are held only momentarily). This
            strategy also assumes that the underlying cache implementation does not do
            asynchronous replication and that state has been fully replicated as soon
            as the lock is released.
            <seealso cref="T:NHibernate.Cache.NonstrictReadWriteCache" /> for a faster algorithm
            <seealso cref="T:NHibernate.Cache.ICacheConcurrencyStrategy" /></remarks>
    </member>
    <member name="M:NHibernate.Cache.ReadWriteCache.NextLockId">
      <summary>
            Generate an id for a new lock. Uniqueness per cache instance is very
            desirable but not absolutely critical. Must be called from one of the
            synchronized methods of this class.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cache.ReadWriteCache.Get(NHibernate.Cache.CacheKey,System.Int64)">
      <summary>
            Do not return an item whose timestamp is later than the current
            transaction timestamp. (Otherwise we might compromise repeatable
            read unnecessarily.) Do not return an item which is soft-locked.
            Always go straight to the database instead.
            </summary>
      <remarks>
            Note that since reading an item from that cache does not actually
            go to the database, it is possible to see a kind of phantom read
            due to the underlying row being updated after we have read it
            from the cache. This would not be possible in a lock-based
            implementation of repeatable read isolation. It is also possible
            to overwrite changes made and committed by another transaction
            after the current transaction read the item from the cache. This
            problem would be caught by the update-time version-checking, if 
            the data is versioned or timestamped.
            </remarks>
    </member>
    <member name="M:NHibernate.Cache.ReadWriteCache.Lock(NHibernate.Cache.CacheKey,System.Object)">
      <summary>
            Stop any other transactions reading or writing this item to/from
            the cache. Send them straight to the database instead. (The lock
            does time out eventually.) This implementation tracks concurrent
            locks by transactions which simultaneously attempt to write to an
            item.
            </summary>
    </member>
    <member name="M:NHibernate.Cache.ReadWriteCache.Put(NHibernate.Cache.CacheKey,System.Object,System.Int64,System.Object,System.Collections.IComparer,System.Boolean)">
      <summary>
            Do not add an item to the cache unless the current transaction
            timestamp is later than the timestamp at which the item was
            invalidated. (Otherwise, a stale item might be re-added if the
            database is operating in repeatable read isolation mode.)
            </summary>
      <returns>Whether the item was actually put into the cache</returns>
    </member>
    <member name="M:NHibernate.Cache.ReadWriteCache.DecrementLock(System.Object,NHibernate.Cache.CacheLock)">
      <summary>
            decrement a lock and put it back in the cache
            </summary>
    </member>
    <member name="M:NHibernate.Cache.ReadWriteCache.AfterUpdate(NHibernate.Cache.CacheKey,System.Object,System.Object,NHibernate.Cache.ISoftLock)">
      <summary>
            Re-cache the updated state, if and only if there there are
            no other concurrent soft locks. Release our lock.
            </summary>
    </member>
    <member name="M:NHibernate.Cache.ReadWriteCache.IsUnlockable(NHibernate.Cache.ISoftLock,NHibernate.Cache.ReadWriteCache.ILockable)">
      <summary>
            Is the client's lock commensurate with the item in the cache?
            If it is not, we know that the cache expired the original
            lock.
            </summary>
    </member>
    <member name="P:NHibernate.Cache.ReadWriteCache.RegionName">
      <summary>
            Gets the cache region name.
            </summary>
    </member>
    <member name="T:NHibernate.Cache.CachedItem">
      <summary>
            An item of cached data, timestamped with the time it was cached, when it was locked,
            when it was unlocked
            </summary>
    </member>
    <member name="M:NHibernate.Cache.CachedItem.Lock(System.Int64,System.Int32)">
      <summary>
            Lock the item
            </summary>
    </member>
    <member name="M:NHibernate.Cache.CachedItem.IsGettable(System.Int64)">
      <summary>
            Is this item visible to the timestamped transaction?
            </summary>
      <param name="txTimestamp">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cache.CachedItem.IsPuttable(System.Int64,System.Object,System.Collections.IComparer)">
      <summary>
            Don't overwrite already cached items
            </summary>
      <param name="txTimestamp">
      </param>
      <param name="newVersion">
      </param>
      <param name="comparator">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Cache.CachedItem.FreshTimestamp">
      <summary>
            The timestamp on the cached data
            </summary>
    </member>
    <member name="P:NHibernate.Cache.CachedItem.Value">
      <summary>
            The actual cached data
            </summary>
    </member>
    <member name="P:NHibernate.Cache.CachedItem.IsLock">
      <summary>
            Not a lock!
            </summary>
    </member>
    <member name="T:NHibernate.Cache.CacheException">
      <summary>
            Represents any exception from an <see cref="T:NHibernate.Cache.ICache" />.
            </summary>
    </member>
    <member name="M:NHibernate.Cache.CacheException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.Cache.CacheException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException" /> class.
            </summary>
      <param name="message">The message that describes the error.</param>
    </member>
    <member name="M:NHibernate.Cache.CacheException.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException" /> class.
            </summary>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.Cache.CacheException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.Cache.CacheException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.Cache.CacheFactory">
      <summary>
            Factory class for creating an <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy" />.
            </summary>
    </member>
    <member name="F:NHibernate.Cache.CacheFactory.Transactional">
      <remarks>
            No providers implement transactional caching currently,
            it was ported from Hibernate just for the sake of completeness.
            </remarks>
    </member>
    <member name="M:NHibernate.Cache.CacheFactory.CreateCache(System.String,System.String,System.Boolean,NHibernate.Cfg.Settings,System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Creates an <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy" /> from the parameters.
            </summary>
      <param name="usage">The name of the strategy that <see cref="T:NHibernate.Cache.ICacheProvider" /> should use for the class.</param>
      <param name="name">The name of the class the strategy is being created for.</param>
      <param name="mutable">
        <see langword="true" /> if the object being stored in the cache is mutable.</param>
      <param name="settings">Used to retrieve the global cache region prefix.</param>
      <param name="properties">Properties the cache provider can use to configure the cache.</param>
      <returns>An <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy" /> to use for this object in the <see cref="T:NHibernate.Cache.ICache" />.</returns>
    </member>
    <member name="T:NHibernate.Cache.CacheKey">
      <summary>
            Allows multiple entity classes / collection roles to be 
            stored in the same cache region. Also allows for composite 
            keys which do not properly implement equals()/hashCode().
            </summary>
    </member>
    <member name="M:NHibernate.Cache.CacheKey.#ctor(System.Object,NHibernate.Type.IType,System.String,NHibernate.EntityMode,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary> 
            Construct a new key for a collection or entity instance.
            Note that an entity name should always be the root entity 
            name, not a subclass entity name. 
            </summary>
      <param name="id">The identifier associated with the cached data </param>
      <param name="type">The Hibernate type mapping </param>
      <param name="entityOrRoleName">The entity or collection-role name. </param>
      <param name="entityMode">The entiyt mode of the originating session </param>
      <param name="factory">The session factory for which we are caching </param>
    </member>
    <member name="T:NHibernate.Cache.ISoftLock">
      <summary>
            Marker interface, denoting a client-visible "soft lock" on a cached item.
            </summary>
    </member>
    <member name="T:NHibernate.Cache.CacheLock">
      <summary>
            A soft lock which supports concurrent locking,
            timestamped with the time it was released
            </summary>
      <remarks>
            This class was named Lock in H2.1
            </remarks>
    </member>
    <member name="M:NHibernate.Cache.CacheLock.Lock(System.Int64,System.Int32)">
      <summary>
            Increment the lock, setting the
            new lock timeout
            </summary>
    </member>
    <member name="M:NHibernate.Cache.CacheLock.Unlock(System.Int64)">
      <summary>
            Decrement the lock, setting the unlock
            timestamp if now unlocked
            </summary>
      <param name="currentTimestamp">
      </param>
    </member>
    <member name="M:NHibernate.Cache.CacheLock.IsPuttable(System.Int64,System.Object,System.Collections.IComparer)">
      <summary>
            Can the timestamped transaction re-cache this
            locked item now?
            </summary>
    </member>
    <member name="M:NHibernate.Cache.CacheLock.IsGettable(System.Int64)">
      <summary>
            locks are not returned to the client!
            </summary>
    </member>
    <member name="P:NHibernate.Cache.CacheLock.WasLockedConcurrently">
      <summary>
            Was this lock held concurrently by multiple
            transactions?
            </summary>
    </member>
    <member name="P:NHibernate.Cache.CacheLock.IsLock">
      <summary>
            Yes, this is a lock
            </summary>
    </member>
    <member name="T:NHibernate.Cache.ICache">
      <summary>
            Implementors define a caching algorithm.
            </summary>
      <remarks>
        <threadsafety instance="true" />
        <para>
            All implementations <em>must</em> be threadsafe.
            </para>
        <para>
            The key is the identifier of the object that is being cached and the 
            value is a <see cref="T:NHibernate.Cache.CachedItem" />.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Cache.ICache.Get(System.Object)">
      <summary>
            Get the object from the Cache
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cache.ICache.Put(System.Object,System.Object)">
      <summary>
      </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:NHibernate.Cache.ICache.Remove(System.Object)">
      <summary>
            Remove an item from the Cache.
            </summary>
      <param name="key">The Key of the Item in the Cache to remove.</param>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
    </member>
    <member name="M:NHibernate.Cache.ICache.Clear">
      <summary>
            Clear the Cache
            </summary>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
    </member>
    <member name="M:NHibernate.Cache.ICache.Destroy">
      <summary>
            Clean up.
            </summary>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
    </member>
    <member name="M:NHibernate.Cache.ICache.Lock(System.Object)">
      <summary>
            If this is a clustered cache, lock the item
            </summary>
      <param name="key">The Key of the Item in the Cache to lock.</param>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
    </member>
    <member name="M:NHibernate.Cache.ICache.Unlock(System.Object)">
      <summary>
            If this is a clustered cache, unlock the item
            </summary>
      <param name="key">The Key of the Item in the Cache to unlock.</param>
      <exception cref="T:NHibernate.Cache.CacheException">
      </exception>
    </member>
    <member name="M:NHibernate.Cache.ICache.NextTimestamp">
      <summary>
            Generate a timestamp
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Cache.ICache.Timeout">
      <summary>
            Get a reasonable "lock timeout"
            </summary>
    </member>
    <member name="P:NHibernate.Cache.ICache.RegionName">
      <summary>
            Gets the name of the cache region
            </summary>
    </member>
    <member name="T:NHibernate.Cache.FakeCache">
      <summary>
            Used by <see cref="T:NHibernate.Cache.NoCacheProvider" /></summary>
    </member>
    <member name="T:NHibernate.Cache.HashtableCache">
      <summary>
            A simple <see cref="T:System.Collections.Hashtable" />-based cache
            </summary>
    </member>
    <member name="M:NHibernate.Cache.HashtableCache.Get(System.Object)">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Cache.HashtableCache.Put(System.Object,System.Object)">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Cache.HashtableCache.Remove(System.Object)">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Cache.HashtableCache.Clear">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Cache.HashtableCache.Destroy">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Cache.HashtableCache.Lock(System.Object)">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Cache.HashtableCache.Unlock(System.Object)">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Cache.HashtableCache.NextTimestamp">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Cache.HashtableCache.Timeout">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Cache.ICacheProvider">
      <summary>
            Support for pluggable caches
            </summary>
    </member>
    <member name="M:NHibernate.Cache.ICacheProvider.BuildCache(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Configure the cache
            </summary>
      <param name="regionName">the name of the cache region</param>
      <param name="properties">configuration settings</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cache.ICacheProvider.NextTimestamp">
      <summary>
            generate a timestamp
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cache.ICacheProvider.Start(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Callback to perform any necessary initialization of the underlying cache implementation
            during ISessionFactory construction.
            </summary>
      <param name="properties">current configuration settings</param>
    </member>
    <member name="M:NHibernate.Cache.ICacheProvider.Stop">
      <summary>
            Callback to perform any necessary cleanup of the underlying cache implementation
            during <see cref="M:NHibernate.ISessionFactory.Close" />.
            </summary>
    </member>
    <member name="T:NHibernate.Cache.HashtableCacheProvider">
      <summary>
            Cache Provider plugin for NHibernate that is configured by using
            <c>cache.provider_class="NHibernate.Cache.HashtableCacheProvider"</c></summary>
    </member>
    <member name="T:NHibernate.Cache.IOptimisticCacheSource">
      <summary> 
            Contract for sources of optimistically lockable data sent to the second level cache.
            </summary>
      <remarks>
            Note currently <see cref="T:NHibernate.Persister.Entity.IEntityPersister">EntityPersisters</see> are
            the only viable source.
            </remarks>
    </member>
    <member name="P:NHibernate.Cache.IOptimisticCacheSource.IsVersioned">
      <summary> 
            Does this source represent versioned (i.e., and thus optimistically lockable) data? 
            </summary>
      <returns> True if this source represents versioned data; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Cache.IOptimisticCacheSource.VersionComparator">
      <summary> Get the comparator used to compare two different version values together. </summary>
      <returns> An appropriate comparator. </returns>
    </member>
    <member name="T:NHibernate.Cache.IQueryCache">
      <summary>
            Defines the contract for caches capable of storing query results.  These
            caches should only concern themselves with storing the matching result ids.
            The transactional semantics are necessarily less strict than the semantics
            of an item cache.
            </summary>
    </member>
    <member name="T:NHibernate.Cache.IQueryCacheFactory">
      <summary>
            Defines a factory for query cache instances.  These factories are responsible for
            creating individual QueryCache instances.
            </summary>
    </member>
    <member name="T:NHibernate.Cache.NoCacheProvider">
      <summary>
            A cache provider placeholder used when caching is disabled.
            </summary>
    </member>
    <member name="M:NHibernate.Cache.NoCacheProvider.BuildCache(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Configure the cache
            </summary>
      <param name="regionName">the name of the cache region</param>
      <param name="properties">configuration settings</param>
      <exception cref="T:NHibernate.Cache.CacheException" />
    </member>
    <member name="M:NHibernate.Cache.NoCacheProvider.NextTimestamp">
      <summary>
            Generate a timestamp
            </summary>
    </member>
    <member name="M:NHibernate.Cache.NoCacheProvider.Start(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Callback to perform any necessary initialization of the underlying cache implementation during SessionFactory
            construction.
            </summary>
      <param name="properties">current configuration settings.</param>
    </member>
    <member name="M:NHibernate.Cache.NoCacheProvider.Stop">
      <summary>
            Callback to perform any necessary cleanup of the underlying cache implementation during SessionFactory.close().
            </summary>
    </member>
    <member name="T:NHibernate.Cache.NonstrictReadWriteCache">
      <summary>
            Caches data that is sometimes updated without ever locking the cache. 
            If concurrent access to an item is possible, this concurrency strategy 
            makes no guarantee that the item returned from the cache is the latest 
            version available in the database. Configure your cache timeout accordingly! 
            This is an "asynchronous" concurrency strategy.
            <seealso cref="T:NHibernate.Cache.ReadWriteCache" /> for a much stricter algorithm
            </summary>
    </member>
    <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Get(NHibernate.Cache.CacheKey,System.Int64)">
      <summary>
            Get the most recent version, if available.
            </summary>
    </member>
    <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Put(NHibernate.Cache.CacheKey,System.Object,System.Int64,System.Object,System.Collections.IComparer,System.Boolean)">
      <summary>
            Add an item to the cache
            </summary>
    </member>
    <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Lock(NHibernate.Cache.CacheKey,System.Object)">
      <summary>
            Do nothing
            </summary>
    </member>
    <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Evict(NHibernate.Cache.CacheKey)">
      <summary>
            Invalidate the item
            </summary>
    </member>
    <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Update(NHibernate.Cache.CacheKey,System.Object,System.Object,System.Object)">
      <summary>
            Invalidate the item
            </summary>
    </member>
    <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Insert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
      <summary>
            Do nothing
            </summary>
    </member>
    <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Release(NHibernate.Cache.CacheKey,NHibernate.Cache.ISoftLock)">
      <summary>
            Invalidate the item (again, for safety).
            </summary>
    </member>
    <member name="M:NHibernate.Cache.NonstrictReadWriteCache.AfterUpdate(NHibernate.Cache.CacheKey,System.Object,System.Object,NHibernate.Cache.ISoftLock)">
      <summary>
            Invalidate the item (again, for safety).
            </summary>
    </member>
    <member name="M:NHibernate.Cache.NonstrictReadWriteCache.AfterInsert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
      <summary>
            Do nothing
            </summary>
    </member>
    <member name="P:NHibernate.Cache.NonstrictReadWriteCache.RegionName">
      <summary>
            Gets the cache region name.
            </summary>
    </member>
    <member name="M:NHibernate.Cache.QueryKey.#ctor(NHibernate.Engine.ISessionFactoryImplementor,NHibernate.SqlCommand.SqlString,NHibernate.Engine.QueryParameters,Iesi.Collections.ISet)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.QueryKey" /> class.
            </summary>
      <param name="factory">the session factory for this query key, required to get the identifiers of entities that are used as values.</param>
      <param name="queryString">The query string.</param>
      <param name="queryParameters">The query parameters.</param>
      <param name="filters">The filters.</param>
    </member>
    <member name="T:NHibernate.Cache.ReadOnlyCache">
      <summary>
            Caches data that is never updated
            </summary>
    </member>
    <member name="M:NHibernate.Cache.ReadOnlyCache.Lock(NHibernate.Cache.CacheKey,System.Object)">
      <summary>
            Unsupported!
            </summary>
    </member>
    <member name="M:NHibernate.Cache.ReadOnlyCache.Release(NHibernate.Cache.CacheKey,NHibernate.Cache.ISoftLock)">
      <summary>
            Unsupported!
            </summary>
    </member>
    <member name="M:NHibernate.Cache.ReadOnlyCache.AfterUpdate(NHibernate.Cache.CacheKey,System.Object,System.Object,NHibernate.Cache.ISoftLock)">
      <summary>
            Unsupported!
            </summary>
    </member>
    <member name="M:NHibernate.Cache.ReadOnlyCache.AfterInsert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
      <summary>
            Do nothing.
            </summary>
    </member>
    <member name="M:NHibernate.Cache.ReadOnlyCache.Evict(NHibernate.Cache.CacheKey)">
      <summary>
            Do nothing.
            </summary>
    </member>
    <member name="M:NHibernate.Cache.ReadOnlyCache.Insert(NHibernate.Cache.CacheKey,System.Object,System.Object)">
      <summary>
            Do nothing.
            </summary>
    </member>
    <member name="M:NHibernate.Cache.ReadOnlyCache.Update(NHibernate.Cache.CacheKey,System.Object,System.Object,System.Object)">
      <summary>
            Unsupported!
            </summary>
    </member>
    <member name="P:NHibernate.Cache.ReadOnlyCache.RegionName">
      <summary>
            Gets the cache region name.
            </summary>
    </member>
    <member name="T:NHibernate.Cache.StandardQueryCache">
      <summary>
            The standard implementation of the Hibernate <see cref="T:NHibernate.Cache.IQueryCache" />
            interface.  This implementation is very good at recognizing stale query
            results and re-running queries when it detects this condition, recaching
            the new results.
            </summary>
    </member>
    <member name="T:NHibernate.Cache.StandardQueryCacheFactory">
      <summary>
            Standard Hibernate implementation of the IQueryCacheFactory interface.  Returns
            instances of <see cref="T:NHibernate.Cache.StandardQueryCache" />.
            </summary>
    </member>
    <member name="T:NHibernate.Cache.Timestamper">
      <summary>
            Generates increasing identifiers (in a single application domain only).
            </summary>
      <remarks>
            Not valid across multiple application domains. Identifiers are not necessarily
            strictly increasing, but usually are.
            </remarks>
    </member>
    <member name="F:NHibernate.Cache.Timestamper.OneMs">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Cache.Timestamper.Next">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Cache.UpdateTimestampsCache">
      <summary>
            Tracks the timestamps of the most recent updates to particular tables. It is
            important that the cache timeout of the underlying cache implementation be set
            to a higher value than the timeouts of any of the query caches. In fact, we 
            recommend that the the underlying cache not be configured for expiry at all.
            Note, in particular, that an LRU cache expiry policy is never appropriate.
            </summary>
    </member>
    <member name="M:NHibernate.Cache.UpdateTimestampsCache.Invalidate(System.Object[])">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper">
      <summary>
            Helper to parse hibernate-configuration XmlNode.
            </summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.CfgSectionName">
      <summary>
            The XML node name for hibernate configuration section in the App.config/Web.config and
            for the hibernate.cfg.xml .
            </summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.CfgSchemaXMLNS">
      <summary>The XML Namespace for the nhibernate-configuration</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.ByteCodeProviderExpression">
      <summary>XPath expression for bytecode-provider property.</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.ReflectionOptimizerExpression">
      <summary>XPath expression for reflection-optimizer property.</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryExpression">
      <summary>XPath expression for session-factory whole node.</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryPropertiesExpression">
      <summary>XPath expression for session-factory.property nodes</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryMappingsExpression">
      <summary>XPath expression for session-factory.mapping nodes</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryClassesCacheExpression">
      <summary>XPath expression for session-factory.class-cache nodes</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryCollectionsCacheExpression">
      <summary>XPath expression for session-factory.collection-cache nodes</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryEventsExpression">
      <summary>XPath expression for session-factory.event nodes</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.SessionFactoryListenersExpression">
      <summary>XPath expression for session-factory.listener nodes</summary>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.ByteCodeProviderConvertFrom(System.String)">
      <summary>
            Convert a string to <see cref="T:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType" />.
            </summary>
      <param name="byteCodeProvider">The string that represent <see cref="T:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType" />.</param>
      <returns>
            The <paramref name="byteCodeProvider" /> converted to <see cref="T:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType" />.
            <see cref="F:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType.Null" /> for invalid values.
            </returns>
      <remarks>
            See <see cref="T:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType" /> for allowed values.
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.ClassCacheUsageConvertFrom(System.String)">
      <summary>
            Convert a string to <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage" />.
            </summary>
      <param name="usage">The string that represent <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage" />.</param>
      <returns>
            The <paramref name="usage" /> converted to <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage" />.
            </returns>
      <exception cref="T:NHibernate.Cfg.HibernateConfigException">If the values is invalid.</exception>
      <remarks>
            See <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage" /> for allowed values.
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.ClassCacheIncludeConvertFrom(System.String)">
      <summary>
            Convert a string to <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude" />.
            </summary>
      <param name="include">The string that represent <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude" />.</param>
      <returns>
            The <paramref name="include" /> converted to <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude" />.
            </returns>
      <exception cref="T:NHibernate.Cfg.HibernateConfigException">If the values is invalid.</exception>
      <remarks>
            See <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude" /> for allowed values.
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.CfgXmlHelper.ListenerTypeConvertFrom(System.String)">
      <summary>
            Convert a string to <see cref="T:NHibernate.Event.ListenerType" />.
            </summary>
      <param name="listenerType">The string that represent <see cref="T:NHibernate.Event.ListenerType" />.</param>
      <returns>
            The <paramref name="listenerType" /> converted to <see cref="T:NHibernate.Event.ListenerType" />.
            </returns>
      <exception cref="T:NHibernate.Cfg.HibernateConfigException">If the values is invalid.</exception>
      <remarks>
            See <see cref="T:NHibernate.Event.ListenerType" /> for allowed values.
            </remarks>
    </member>
    <member name="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage">
      <summary>
            Values for class-cache and collection-cache strategy.
            </summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage.Readonly">
      <summary>Xml value: read-only</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage.ReadWrite">
      <summary>Xml value: read-write</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage.NonStrictReadWrite">
      <summary>Xml value: nonstrict-read-write</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage.Transactional">
      <summary>Xml value: transactional</summary>
    </member>
    <member name="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude">
      <summary>
            Values for class-cache include.
            </summary>
      <remarks>Not implemented in Cache.</remarks>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude.All">
      <summary>Xml value: all</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude.NonLazy">
      <summary>Xml value: non-lazy</summary>
    </member>
    <member name="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration">
      <summary>
            Configuration parsed values for a class-cache XML node.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.#ctor(System.String,NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration" /> class.
            </summary>
      <param name="clazz">The class full name.</param>
      <param name="usage">Cache strategy.</param>
      <exception cref="T:System.ArgumentException">When <paramref name="clazz" /> is null or empty.</exception>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.#ctor(System.String,NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage,NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration" /> class.
            </summary>
      <param name="clazz">The class full name.</param>
      <param name="usage">Cache strategy.</param>
      <param name="include">Values for class-cache include.</param>
      <exception cref="T:System.ArgumentException">When <paramref name="clazz" /> is null or empty.</exception>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.#ctor(System.String,NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration" /> class.
            </summary>
      <param name="clazz">The class full name.</param>
      <param name="usage">Cache strategy.</param>
      <param name="region">The cache region.</param>
      <exception cref="T:System.ArgumentException">When <paramref name="clazz" /> is null or empty.</exception>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.#ctor(System.String,NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage,NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration" /> class.
            </summary>
      <param name="clazz">The class full name.</param>
      <param name="usage">Cache strategy.</param>
      <param name="include">Values for class-cache include.</param>
      <param name="region">The cache region.</param>
      <exception cref="T:System.ArgumentException">When <paramref name="clazz" /> is null or empty.</exception>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.Class">
      <summary>
            The class full name.
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.Region">
      <summary>
            The cache region.
            </summary>
      <remarks>If null or empty the <see cref="P:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.Class" /> is used during configuration.</remarks>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.Usage">
      <summary>
            Cache strategy.
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.ClassCacheConfiguration.Include">
      <summary>
            class-cache include.
            </summary>
      <remarks>
            Not implemented in Cache.
            Default value <see cref="F:NHibernate.Cfg.ConfigurationSchema.ClassCacheInclude.All" />.
            </remarks>
    </member>
    <member name="T:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration">
      <summary>
            Configuration parsed values for a collection-cache XML node.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration.#ctor(System.String,NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration" /> class.
            </summary>
      <param name="collection">The cache role.</param>
      <param name="usage">Cache strategy.</param>
      <exception cref="T:System.ArgumentException">When <paramref name="collection" /> is null or empty.</exception>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration.#ctor(System.String,NHibernate.Cfg.ConfigurationSchema.ClassCacheUsage,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration" /> class.
            </summary>
      <param name="collection">The cache role.</param>
      <param name="usage">Cache strategy.</param>
      <param name="region">The cache region.</param>
      <exception cref="T:System.ArgumentException">When <paramref name="collection" /> is null or empty.</exception>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration.Collection">
      <summary>
            The role.
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration.Region">
      <summary>
            The cache region.
            </summary>
      <remarks>If null or empty the <see cref="P:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration.Collection" /> is used during configuration.</remarks>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.CollectionCacheConfiguration.Usage">
      <summary>
            Cache strategy.
            </summary>
    </member>
    <member name="T:NHibernate.Cfg.ConfigurationSchema.EventConfiguration">
      <summary>
            Configuration parsed values for a event XML node.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.EventConfiguration.#ctor(NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration,NHibernate.Event.ListenerType)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.EventConfiguration" /> class.
            </summary>
      <param name="listener">The listener.</param>
      <param name="type">The type.</param>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.EventConfiguration.Type">
      <summary>
            The default type of listeners.
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.EventConfiguration.Listeners">
      <summary>
            Listeners for this event.
            </summary>
    </member>
    <member name="T:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType">
      <summary>
            Values for bytecode-provider system property.
            </summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType.Codedom">
      <summary>Xml value: codedom</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType.Lcg">
      <summary>Xml value: lcg</summary>
    </member>
    <member name="F:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType.Null">
      <summary>Xml value: null</summary>
    </member>
    <member name="T:NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration">
      <summary>
            Configuration parsed values for hibernate-configuration section.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration.#ctor(System.Xml.XmlReader)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration" /> class.
            </summary>
      <param name="hbConfigurationReader">The XML reader to parse.</param>
      <remarks>
            The nhibernate-configuration.xsd is applied to the XML.
            </remarks>
      <exception cref="T:NHibernate.Cfg.HibernateConfigException">When nhibernate-configuration.xsd can't be applied.</exception>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration.ByteCodeProviderType">
      <summary>
            Value for bytecode-provider system property.
            </summary>
      <remarks>Default value <see cref="F:NHibernate.Cfg.ConfigurationSchema.BytecodeProviderType.Lcg" />.</remarks>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration.UseReflectionOptimizer">
      <summary>
            Value for reflection-optimizer system property.
            </summary>
      <remarks>Default value true.</remarks>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.HibernateConfiguration.SessionFactory">
      <summary>
            The <see cref="T:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration" /> if the session-factory exists in hibernate-configuration;
            Otherwise null.
            </summary>
    </member>
    <member name="T:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration">
      <summary>
            Configuration parsed values for a listener XML node
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration" /> class.
            </summary>
      <param name="clazz">The class full name.</param>
      <exception cref="T:System.ArgumentException">When <paramref name="clazz" /> is null or empty.</exception>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration.#ctor(System.String,NHibernate.Event.ListenerType)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration" /> class.
            </summary>
      <param name="clazz">The class full name.</param>
      <param name="type">The listener type.</param>
      <exception cref="T:System.ArgumentException">When <paramref name="clazz" /> is null or empty.</exception>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration.Class">
      <summary>
            The class full name.
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.ListenerConfiguration.Type">
      <summary>
            The listener type.
            </summary>
      <remarks>Default value <see cref="F:NHibernate.Event.ListenerType.NotValidType" /> mean that the value is ignored.</remarks>
    </member>
    <member name="T:NHibernate.Cfg.ConfigurationSchema.MappingConfiguration">
      <summary>
            Configuration parsed values for a mapping XML node
            </summary>
      <remarks>
            There are 3 possible combinations of mapping attributes
            1 - resource and assembly:  NHibernate will read the mapping resource from the specified assembly
            2 - file only: NHibernate will read the mapping from the file.
            3 - assembly only: NHibernate will find all the resources ending in hbm.xml from the assembly.
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.MappingConfiguration.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.MappingConfiguration" /> class.
            </summary>
      <param name="file">Mapped file.</param>
      <exception cref="T:System.ArgumentException">When <paramref name="file" /> is null or empty.</exception>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.MappingConfiguration.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.MappingConfiguration" /> class.
            </summary>
      <param name="assembly">The assembly name.</param>
      <param name="resource">The mapped embedded resource.</param>
      <exception cref="T:System.ArgumentException">When <paramref name="assembly" /> is null or empty.</exception>
    </member>
    <member name="T:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration">
      <summary>
            Configuration parsed values for a session-factory XML node.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration" /> class.
            </summary>
      <param name="name">The session factory name. Null or empty string are allowed.</param>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration.Name">
      <summary>
            The session factory name.
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration.Properties">
      <summary>
            Session factory propeties bag.
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration.Mappings">
      <summary>
            Session factory mapping configuration.
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration.ClassesCache">
      <summary>
            Session factory class-cache configurations.
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration.CollectionsCache">
      <summary>
            Session factory collection-cache configurations.
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration.Events">
      <summary>
            Session factory event configurations.
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.ConfigurationSchema.SessionFactoryConfiguration.Listeners">
      <summary>
            Session factory listener configurations.
            </summary>
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.IAssemblyResourceFilter">
      <summary>
            Responsible for determining whether an embedded resource should be parsed for HBM XML data while
            iterating through an <see cref="T:System.Reflection.Assembly" />.
            </summary>
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.EndsWithHbmXmlFilter">
      <summary>
            Responsible for checking that a resource name matches the default pattern of "*.hbm.xml". This is the
            default filter for <see cref="T:NHibernate.Cfg.MappingSchema.MappingDocumentAggregator" />.
            </summary>
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmAny">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.metavalue">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.column1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.idtype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.metatype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.insert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.update">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.cascade">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.index">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmAny.node">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmBase">
      <summary>A base class for HBM schema classes that provides helper methods.</summary>
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmMeta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMeta.attribute">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMeta.inherit">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMeta.Text">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmMetaValue">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMetaValue.value">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMetaValue.class">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmColumn">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.length">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.precision">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.scale">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.notnull">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.notnullSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.unique">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.uniqueSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.uniquekey">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.sqltype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.index">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.check">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmColumn.default">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmComment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComment.Text">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmArray">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.subselect">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.cache">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.synchronize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.key">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.Item">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.Item1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.loader">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.sqlinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.sqlupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.sqldelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.sqldeleteall">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.table">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.schema">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.catalog">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.subselect1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.inverse">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.mutable">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.elementclass">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.cascade">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.where">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.batchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.batchsizeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.outerjoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.outerjoinSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.fetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.fetchSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.persister">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.collectiontype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.check">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmArray.embedxml">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmSubselect">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubselect.Text">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCache">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCache.usage">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCache.region">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCache.include">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCacheUsage">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheUsage.ReadOnly">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheUsage.ReadWrite">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheUsage.NonstrictReadWrite">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheUsage.Transactional">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCacheInclude">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheInclude.All">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheInclude.NonLazy">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmSynchronize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSynchronize.table">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmKey">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.column1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.propertyref">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.foreignkey">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.ondelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.notnull">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.notnullSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.update">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.updateSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.unique">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKey.uniqueSpecified">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmOndelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOndelete.Cascade">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOndelete.Noaction">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmIndex">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndex.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndex.column1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndex.type">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndex.length">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmListIndex">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmListIndex.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmListIndex.column1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmListIndex.base">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCompositeElement">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeElement.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeElement.parent">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeElement.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeElement.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeElement.node">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmParent">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmParent.name">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmManyToOne">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.entityname">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.notnull">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.notnullSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.unique">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.uniquekey">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.index">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.cascade">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.outerjoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.outerjoinSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.fetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.fetchSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.update">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.insert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.foreignkey">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.propertyref">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.formula">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.lazySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.notfound">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToOne.embedxml">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmFormula">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFormula.Text">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmOuterJoinStrategy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOuterJoinStrategy.Auto">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOuterJoinStrategy.True">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOuterJoinStrategy.False">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmFetchMode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFetchMode.Select">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFetchMode.Join">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmLaziness">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLaziness.False">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLaziness.Proxy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLaziness.NoProxy">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmNotFoundMode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmNotFoundMode.Ignore">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmNotFoundMode.Exception">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement.parent">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmNestedCompositeElement.node">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmProperty">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.type">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.type1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.length">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.precision">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.scale">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.notnull">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.notnullSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.unique">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.uniquekey">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.index">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.update">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.updateSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.insert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.insertSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.formula">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperty.generated">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmType">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmType.param">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmType.name">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmParam">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmParam.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmParam.Text">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmPropertyGeneration">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPropertyGeneration.Never">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPropertyGeneration.Insert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPropertyGeneration.Always">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmElement">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.type">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.formula">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.type1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.length">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.precision">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.scale">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.notnull">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmElement.unique">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmManyToAny">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToAny.metavalue">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToAny.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToAny.column1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToAny.idtype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToAny.metatype">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmManyToMany">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.filter">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.embedxml">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.entityname">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.formula">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.notfound">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.outerjoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.outerjoinSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.fetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.fetchSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.lazySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.foreignkey">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.unique">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.where">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.orderby">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmManyToMany.propertyref">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmFilter">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFilter.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFilter.condition">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFilter.Text">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmRestrictedLaziness">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmRestrictedLaziness.False">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmRestrictedLaziness.Proxy">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmOneToMany">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToMany.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToMany.notfound">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToMany.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToMany.embedxml">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToMany.entityname">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmLoader">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLoader.queryref">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCustomSQL">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQL.callable">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQL.callableSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQL.check">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQL.checkSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQL.Text">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCustomSQLCheck">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQLCheck.None">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQLCheck.Rowcount">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCustomSQLCheck.Param">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCollectionFetchMode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionFetchMode.Select">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionFetchMode.Join">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionFetchMode.Subselect">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmBag">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.subselect">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.cache">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.synchronize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.key">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.Item">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.loader">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.sqlinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.sqlupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.sqldelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.sqldeleteall">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.filter">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.table">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.schema">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.catalog">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.subselect1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.lazySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.inverse">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.mutable">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.cascade">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.orderby">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.where">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.batchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.batchsizeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.outerjoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.outerjoinSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.fetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.fetchSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.persister">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.collectiontype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.check">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.embedxml">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.generic">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmBag.genericSpecified">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCollectionLazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionLazy.True">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionLazy.False">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionLazy.Extra">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmClass">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.subselect">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.cache">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.synchronize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.tuplizer">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.Item">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.discriminator">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.naturalid">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.Item1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.Items1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.loader">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.sqlinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.sqlupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.sqldelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.filter">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.resultset">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.Items2">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.entityname">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.proxy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.lazySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.schemaaction">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.table">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.schema">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.catalog">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.subselect1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.discriminatorvalue">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.mutable">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.abstract">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.abstractSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.polymorphism">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.where">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.persister">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.dynamicupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.dynamicinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.batchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.batchsizeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.selectbeforeupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.check">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.rowid">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmClass.node">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmTuplizer">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTuplizer.entitymode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTuplizer.entitymodeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTuplizer.class">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmTuplizerEntitymode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTuplizerEntitymode.Poco">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTuplizerEntitymode.Xml">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTuplizerEntitymode.DynamicMap">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCompositeId">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.mapped">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeId.unsavedvalue">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.entityname">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.column1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.foreignkey">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyManyToOne.lazySpecified">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmKeyProperty">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.type">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.type1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.column1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.length">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmKeyProperty.node">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmUnsavedValueType">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnsavedValueType.Undefined">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnsavedValueType.Any">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnsavedValueType.None">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmId">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmId.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmId.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmId.type">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmId.generator">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmId.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmId.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmId.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmId.column1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmId.type1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmId.length">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmId.unsavedvalue">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmGenerator">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmGenerator.param">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmGenerator.class">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmDiscriminator">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.Item">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.formula">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.type">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.notnull">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.length">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.force">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDiscriminator.insert">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmNaturalId">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmNaturalId.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmNaturalId.mutable">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmComponent">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.tuplizer">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.parent">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.unique">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.update">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.insert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmComponent.node">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmDynamicComponent">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.unique">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.update">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.insert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDynamicComponent.node">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmList">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.subselect">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.cache">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.synchronize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.key">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.Item">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.Item1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.loader">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.sqlinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.sqlupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.sqldelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.sqldeleteall">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.filter">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.table">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.schema">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.catalog">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.subselect1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.lazySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.inverse">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.mutable">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.cascade">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.orderby">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.where">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.batchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.batchsizeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.outerjoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.outerjoinSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.fetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.fetchSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.persister">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.collectiontype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.check">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.embedxml">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.generic">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmList.genericSpecified">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmMap">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.subselect">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.cache">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.synchronize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.key">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.Item">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.Item1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.loader">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.sqlinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.sqlupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.sqldelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.sqldeleteall">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.filter">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.table">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.schema">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.catalog">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.subselect1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.lazySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.inverse">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.mutable">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.cascade">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.orderby">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.where">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.batchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.batchsizeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.outerjoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.outerjoinSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.fetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.fetchSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.persister">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.collectiontype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.check">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.embedxml">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.generic">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.genericSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMap.sort">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCompositeIndex">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeIndex.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeIndex.class">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCompositeMapKey">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeMapKey.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCompositeMapKey.class">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmIndexManyToAny">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToAny.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToAny.idtype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToAny.metatype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToAny.column1">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmIndexManyToMany">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToMany.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToMany.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToMany.entityname">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToMany.column1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIndexManyToMany.foreignkey">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmMapKey">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKey.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKey.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKey.formula">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKey.type">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKey.length">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKey.node">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany.entityname">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany.formula">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapKeyManyToMany.foreignkey">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmOneToOne">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.formula">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.formula1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.entityname">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.cascade">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.outerjoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.outerjoinSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.fetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.fetchSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.constrained">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.foreignkey">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.propertyref">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.lazySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOneToOne.embedxml">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.subselect">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.cache">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.synchronize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.key">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.Item">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.element">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.loader">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.sqlinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.sqlupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.sqldelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.sqldeleteall">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.table">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.schema">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.catalog">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.subselect1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.mutable">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.where">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.batchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.outerjoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.outerjoinSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.fetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.fetchSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.persister">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.collectiontype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.check">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitiveArray.embedxml">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayOuterjoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayOuterjoin.True">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayOuterjoin.False">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayOuterjoin.Auto">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayFetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayFetch.Join">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayFetch.Select">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPrimitivearrayFetch.Subselect">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmSet">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.subselect">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.cache">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.synchronize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.key">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.Item">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.loader">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.sqlinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.sqlupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.sqldelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.sqldeleteall">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.filter">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.table">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.schema">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.catalog">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.subselect1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.lazySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.inverse">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.mutable">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.cascade">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.orderby">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.where">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.batchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.batchsizeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.outerjoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.outerjoinSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.fetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.fetchSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.persister">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.collectiontype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.check">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.embedxml">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.generic">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.genericSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSet.sort">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmIdbag">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.subselect">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.cache">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.synchronize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.collectionid">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.key">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.Item">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.loader">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.sqlinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.sqlupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.sqldelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.sqldeleteall">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.filter">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.table">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.schema">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.catalog">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.subselect1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.lazySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.inverse">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.mutable">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.cascade">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.orderby">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.where">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.batchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.batchsizeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.outerjoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.outerjoinSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.fetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.fetchSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.persister">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.collectiontype">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.check">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.embedxml">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.generic">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmIdbag.genericSpecified">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCollectionId">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionId.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionId.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionId.generator">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionId.column1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionId.type">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCollectionId.length">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmTimestamp">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.unsavedvalue">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.unsavedvalueSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.source">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestamp.generated">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmTimestampUnsavedvalue">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestampUnsavedvalue.Null">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestampUnsavedvalue.Undefined">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmTimestampSource">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestampSource.Vm">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTimestampSource.Db">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmVersionGeneration">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersionGeneration.Never">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersionGeneration.Always">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmVersion">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.node">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.access">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.column1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.type">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.unsavedvalue">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.generated">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.insert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmVersion.insertSpecified">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmProperties">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.unique">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.insert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.update">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.optimisticlock">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmProperties.node">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmJoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.subselect">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.key">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.sqlinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.sqlupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.sqldelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.table">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.schema">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.catalog">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.subselect1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.fetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.inverse">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoin.optional">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmJoinFetch">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinFetch.Join">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinFetch.Select">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.subselect">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.synchronize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.tuplizer">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.key">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.joinedsubclass1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.loader">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.sqlinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.sqlupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.sqldelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.resultset">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.Items1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.entityname">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.proxy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.table">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.schema">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.catalog">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.subselect1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.dynamicupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.dynamicinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.selectbeforeupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.extends">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.lazySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.abstract">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.abstractSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.persister">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.check">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.batchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmJoinedSubclass.node">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmResultSet">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmResultSet.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmResultSet.name">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmLoadCollection">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLoadCollection.returnproperty">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLoadCollection.alias">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLoadCollection.role">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLoadCollection.lockmode">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmReturnProperty">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnProperty.returncolumn">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnProperty.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnProperty.column">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmReturnColumn">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnColumn.name">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmLockMode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLockMode.None">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLockMode.Read">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLockMode.Upgrade">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLockMode.UpgradeNowait">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmLockMode.Write">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmReturn">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturn.returndiscriminator">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturn.returnproperty">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturn.alias">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturn.entityname">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturn.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturn.lockmode">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmReturnDiscriminator">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnDiscriminator.column">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmReturnJoin">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnJoin.returnproperty">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnJoin.alias">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnJoin.property">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnJoin.lockmode">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmReturnScalar">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnScalar.column">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmReturnScalar.type">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmQuery">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.Text">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.flushmode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.flushmodeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.cacheable">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.cacheregion">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.fetchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.fetchsizeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.timeout">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.cachemode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.cachemodeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.readonly">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.readonlySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQuery.comment">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmQueryParam">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQueryParam.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmQueryParam.type">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmFlushMode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFlushMode.Auto">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFlushMode.Never">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFlushMode.Always">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCacheMode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheMode.Get">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheMode.Ignore">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheMode.Normal">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheMode.Put">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCacheMode.Refresh">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmSqlQuery">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.Text">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.resultsetref">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.flushmode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.flushmodeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.cacheable">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.cacheregion">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.fetchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.fetchsizeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.timeout">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.cachemode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.cachemodeSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.readonly">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.readonlySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSqlQuery.callable">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmSubclass">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.tuplizer">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.synchronize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.join">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.subclass1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.loader">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.sqlinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.sqlupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.sqldelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.resultset">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.Items1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.entityname">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.proxy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.discriminatorvalue">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.dynamicupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.dynamicinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.selectbeforeupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.extends">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.lazySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.abstract">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.abstractSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.persister">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.batchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmSubclass.node">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmUnionSubclass">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.subselect">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.synchronize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.comment">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.tuplizer">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.unionsubclass1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.loader">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.sqlinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.sqlupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.sqldelete">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.resultset">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.Items1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.entityname">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.proxy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.table">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.schema">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.catalog">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.subselect1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.dynamicupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.dynamicinsert">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.selectbeforeupdate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.extends">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.lazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.lazySpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.abstract">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.abstractSpecified">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.persister">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.check">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.batchsize">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmUnionSubclass.node">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmPolymorphismType">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPolymorphismType.Implicit">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmPolymorphismType.Explicit">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmOptimisticLockMode">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOptimisticLockMode.None">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOptimisticLockMode.Version">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOptimisticLockMode.Dirty">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmOptimisticLockMode.All">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmCreate">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmCreate.Text">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmDatabaseObject">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDatabaseObject.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDatabaseObject.dialectscope">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmDefinition">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDefinition.class">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmDrop">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDrop.Text">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmDialectScope">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDialectScope.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmDialectScope.Text">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmFilterDef">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterDef.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterDef.Text">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterDef.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterDef.condition">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmFilterParam">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterParam.name">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmFilterParam.type">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmMapping">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.meta">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.typedef">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.import">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.Items">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.resultset">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.Items1">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.filterdef">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.databaseobject">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.schema">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.catalog">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.defaultcascade">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.defaultaccess">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.defaultlazy">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.autoimport">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.namespace">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmMapping.assembly">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmTypedef">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTypedef.param">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTypedef.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmTypedef.name">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.HbmImport">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmImport.class">
      <remarks />
    </member>
    <member name="F:NHibernate.Cfg.MappingSchema.HbmImport.rename">
      <remarks />
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.IMappingDocumentParser">
      <summary>
            Responsible for converting a <see cref="T:System.IO.Stream" /> of HBM XML into an instance of
            <see cref="T:NHibernate.Cfg.MappingSchema.HbmMapping" />.
            </summary>
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.MappingDocumentAggregator">
      <summary>
            Responsible for building a list of <see cref="T:NHibernate.Cfg.MappingSchema.HbmMapping" /> objects from a range of acceptable
            sources.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.MappingSchema.MappingDocumentAggregator.#ctor">
      <summary>
            Calls the greedy constructor, passing it new instances of <see cref="T:NHibernate.Cfg.MappingSchema.MappingDocumentParser" /> and
            <see cref="T:NHibernate.Cfg.MappingSchema.EndsWithHbmXmlFilter" />.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.MappingSchema.MappingDocumentAggregator.Add(System.Reflection.Assembly,NHibernate.Cfg.MappingSchema.IAssemblyResourceFilter)">
      <summary>Adds any embedded resource streams which pass the <paramref name="filter" />.</summary>
      <param name="assembly">An assembly containing embedded mapping documents.</param>
      <param name="filter">A custom filter.</param>
    </member>
    <member name="M:NHibernate.Cfg.MappingSchema.MappingDocumentAggregator.Add(System.Reflection.Assembly)">
      <summary>Adds any embedded resource streams which pass the default filter.</summary>
      <param name="assembly">An assembly containing embedded mapping documents.</param>
    </member>
    <member name="T:NHibernate.Cfg.MappingSchema.MappingDocumentParser">
      <summary>
            Responsible for converting a <see cref="T:System.IO.Stream" /> of HBM XML into an instance of
            <see cref="T:NHibernate.Cfg.MappingSchema.HbmMapping" />.
            </summary>
      <remarks>Uses an <see cref="T:System.Xml.Serialization.XmlSerializer" /> to deserialize HBM.</remarks>
    </member>
    <member name="M:NHibernate.Cfg.XmlHbmBinding.Binder.FullQualifiedClassName(System.String,NHibernate.Cfg.Mappings)">
      <summary>
            Converts a partial class name into a fully qualified one
            </summary>
      <param name="className">
      </param>
      <param name="mappings">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.XmlHbmBinding.Binder.FullClassName(System.String,NHibernate.Cfg.Mappings)">
      <summary>
            Converts a partial class name into a fully one
            </summary>
      <param name="className">
      </param>
      <param name="mappings">
      </param>
      <returns>The class FullName (without the assembly)</returns>
      <remarks>
            The FullName is equivalent to the default entity-name
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.XmlHbmBinding.Binder.ClassForFullNameChecked(System.String,System.String)">
      <summary>
            Attempts to find a type by its full name. Throws a <see cref="T:NHibernate.MappingException" />
            using the provided <paramref name="errorMessage" /> in case of failure.
            </summary>
      <param name="fullName">name of the class to find</param>
      <param name="errorMessage">Error message to use for
            the <see cref="T:NHibernate.MappingException" /> in case of failure. Should contain
            the <c>{0}</c> formatting placeholder.</param>
      <returns>A <see cref="T:System.Type" /> instance.</returns>
      <exception cref="T:NHibernate.MappingException">
            Thrown when there is an error loading the class.
            </exception>
    </member>
    <member name="M:NHibernate.Cfg.XmlHbmBinding.Binder.ClassForNameChecked(System.String,NHibernate.Cfg.Mappings,System.String)">
      <summary>
            Similar to <see cref="M:NHibernate.Cfg.XmlHbmBinding.Binder.ClassForFullNameChecked(System.String,System.String)" />, but handles short class names
            by calling <see cref="M:NHibernate.Cfg.XmlHbmBinding.Binder.FullQualifiedClassName(System.String,NHibernate.Cfg.Mappings)" />.
            </summary>
      <param name="name">
      </param>
      <param name="mappings">
      </param>
      <param name="errorMessage">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.XmlHbmBinding.CollectionBinder.BindCollection(System.Xml.XmlNode,NHibernate.Mapping.Collection,System.String,System.String,System.Type,System.Collections.Generic.IDictionary{System.String,NHibernate.Mapping.MetaAttribute})">
      <remarks>
            Called for all collections. <paramref name="containingType" /> parameter
            was added in NH to allow for reflection related to generic types.
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.XmlHbmBinding.CollectionBinder.BindArray(System.Xml.XmlNode,NHibernate.Mapping.Array,System.String,System.String,System.Type,System.Collections.Generic.IDictionary{System.String,NHibernate.Mapping.MetaAttribute})">
      <remarks>
            Called for arrays and primitive arrays
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.XmlHbmBinding.CollectionBinder.BindMapSecondPass(System.Xml.XmlNode,NHibernate.Mapping.Map,System.Collections.Generic.IDictionary{System.String,NHibernate.Mapping.PersistentClass},System.Collections.Generic.IDictionary{System.String,NHibernate.Mapping.MetaAttribute})">
      <summary>
            Called for Maps
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.XmlHbmBinding.CollectionBinder.BindCollectionSecondPass(System.Xml.XmlNode,NHibernate.Mapping.Collection,System.Collections.Generic.IDictionary{System.String,NHibernate.Mapping.PersistentClass},System.Collections.Generic.IDictionary{System.String,NHibernate.Mapping.MetaAttribute})">
      <remarks>
            Called for all collections
            </remarks>
    </member>
    <member name="T:NHibernate.Cfg.ClassExtractor">
      <summary>
            Extracts the names of classes mapped in a given file,
            and the names of the classes they extend.
            </summary>
    </member>
    <member name="T:NHibernate.Cfg.ClassExtractor.ClassEntry">
      <summary>
            Holds information about mapped classes found in the <c>hbm.xml</c> files.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.ClassExtractor.GetClassEntries(System.Xml.XmlDocument)">
      <summary>
            Returns a collection of <see cref="T:NHibernate.Cfg.ClassExtractor.ClassEntry" /> containing
            information about all classes in this stream.
            </summary>
      <param name="document">A validated <see cref="T:System.Xml.XmlDocument" /> representing
            a mapping file.</param>
    </member>
    <member name="T:NHibernate.Cfg.Configuration">
      <summary>
            Allows the application to specify properties and mapping documents to be used when creating
            a <see cref="T:NHibernate.ISessionFactory" />.
            </summary>
      <remarks>
        <para>
            Usually an application will create a single <see cref="T:NHibernate.Cfg.Configuration" />, build a single instance
            of <see cref="T:NHibernate.ISessionFactory" />, and then instantiate <see cref="T:NHibernate.ISession" /> objects in threads
            servicing client requests.
            </para>
        <para>
            The <see cref="T:NHibernate.Cfg.Configuration" /> is meant only as an initialization-time object. <see cref="T:NHibernate.ISessionFactory" />
            is immutable and does not retain any association back to the <see cref="T:NHibernate.Cfg.Configuration" /></para>
      </remarks>
    </member>
    <member name="F:NHibernate.Cfg.Configuration.MappingSchemaXMLNS">
      <summary>The XML Namespace for the nhibernate-mapping</summary>
    </member>
    <member name="F:NHibernate.Cfg.Configuration.DefaultHibernateCfgFileName">
      <summary>Default name for hibernate configuration file.</summary>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.Reset">
      <summary>
            Clear the internal state of the <see cref="T:NHibernate.Cfg.Configuration" /> object.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.#ctor">
      <summary>
            Create a new Configuration object.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.GetClassMapping(System.Type)">
      <summary>
            Get the mapping for a particular class
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.GetClassMapping(System.String)">
      <summary> Get the mapping for a particular entity </summary>
      <param name="entityName">An entity name. </param>
      <returns> the entity mapping information </returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.GetCollectionMapping(System.String)">
      <summary>
            Get the mapping for a particular collection role
            </summary>
      <param name="role">a collection role</param>
      <returns>
        <see cref="T:NHibernate.Mapping.Collection" />
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddFile(System.String)">
      <summary>
            Read mappings from a particular XML file. This method is equivalent
            to <see cref="M:NHibernate.Cfg.Configuration.AddXmlFile(System.String)" />.
            </summary>
      <param name="xmlFile">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddXmlFile(System.String)">
      <summary>
            Read mappings from a particular XML file.
            </summary>
      <param name="xmlFile">a path to a file</param>
      <returns>This configuration object.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddXml(System.String,System.String)">
      <summary>
            Read mappings from a <see cref="T:System.String" />. This method is equivalent to
            <see cref="M:NHibernate.Cfg.Configuration.AddXmlString(System.String)" />.
            </summary>
      <param name="xml">an XML string</param>
      <param name="name">The name to use in error reporting. May be <see langword="null" />.</param>
      <returns>This configuration object.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddXmlString(System.String)">
      <summary>
            Read mappings from a <see cref="T:System.String" />.
            </summary>
      <param name="xml">an XML string</param>
      <returns>This configuration object.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddUrl(System.String)">
      <summary>
            Read mappings from a URL.
            </summary>
      <param name="url">a URL</param>
      <returns>This configuration object.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddUrl(System.Uri)">
      <summary>
            Read mappings from a URL.
            </summary>
      <param name="url">a <see cref="T:System.Uri" /> to read the mappings from.</param>
      <returns>This configuration object.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddDocument(System.Xml.XmlDocument,System.String)">
      <summary>
            Read mappings from an <see cref="T:System.Xml.XmlDocument" />.
            </summary>
      <param name="doc">A loaded <see cref="T:System.Xml.XmlDocument" /> that contains the mappings.</param>
      <param name="name">The name of the document, for error reporting purposes.</param>
      <returns>This configuration object.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddValidatedDocument(NHibernate.Cfg.NamedXmlDocument)">
      <summary>
            Takes the validated XmlDocument and has the Binder do its work of
            creating Mapping objects from the Mapping Xml.
            </summary>
      <param name="doc">The NamedXmlDocument that contains the <b>validated</b> mapping XML file.</param>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.CreateMappings(NHibernate.Dialect.Dialect)">
      <summary>
            Create a new <see cref="T:NHibernate.Cfg.Mappings" /> to add classes and collection
            mappings to.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddInputStream(System.IO.Stream)">
      <summary>
            Read mappings from a <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="xmlInputStream">The stream containing XML</param>
      <returns>This Configuration object.</returns>
      <remarks>
            The <see cref="T:System.IO.Stream" /> passed in through the parameter <paramref name="xmlInputStream" />
            is not <em>guaranteed</em> to be cleaned up by this method.  It is the caller's responsiblity to
            ensure that <paramref name="xmlInputStream" /> is properly handled when this method
            completes.
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddInputStream(System.IO.Stream,System.String)">
      <summary>
            Read mappings from a <see cref="T:System.IO.Stream" />.
            </summary>
      <param name="xmlInputStream">The stream containing XML</param>
      <param name="name">The name of the stream to use in error reporting. May be <see langword="null" />.</param>
      <returns>This Configuration object.</returns>
      <remarks>
            The <see cref="T:System.IO.Stream" /> passed in through the parameter <paramref name="xmlInputStream" />
            is not <em>guaranteed</em> to be cleaned up by this method.  It is the caller's responsiblity to
            ensure that <paramref name="xmlInputStream" /> is properly handled when this method
            completes.
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddResource(System.String,System.Reflection.Assembly)">
      <summary>
            Adds the mappings in the resource of the assembly.
            </summary>
      <param name="path">The path to the resource file in the assembly.</param>
      <param name="assembly">The assembly that contains the resource file.</param>
      <returns>This configuration object.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddResources(System.Collections.Generic.IEnumerable{System.String},System.Reflection.Assembly)">
      <summary>
            Adds the mappings from ebedded resources of the assembly.
            </summary>
      <param name="paths">Paths to the resource files in the assembly.</param>
      <param name="assembly">The assembly that contains the resource files.</param>
      <returns>This configuration object.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddClass(System.Type)">
      <summary>
            Read a mapping from an embedded resource, using a convention.
            </summary>
      <param name="persistentClass">The type to map.</param>
      <returns>This configuration object.</returns>
      <remarks>
            The convention is for class <c>Foo.Bar.Foo</c> to be mapped by
            the resource named <c>Foo.Bar.Foo.hbm.xml</c>, embedded in
            the class' assembly. If the mappings and classes are defined
            in different assemblies or don't follow the naming convention,
            this method cannot be used.
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddAssembly(System.String)">
      <summary>
            Adds all of the assembly's embedded resources whose names end with <c>.hbm.xml</c>.
            </summary>
      <param name="assemblyName">The name of the assembly to load.</param>
      <returns>This configuration object.</returns>
      <remarks>
            The assembly must be loadable using <see cref="M:System.Reflection.Assembly.Load(System.String)" />. If this
            condition is not satisfied, load the assembly manually and call
            <see cref="M:NHibernate.Cfg.Configuration.AddAssembly(System.Reflection.Assembly)" /> instead.
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddAssembly(System.Reflection.Assembly)">
      <summary>
            Adds all of the assembly's embedded resources whose names end with <c>.hbm.xml</c>.
            </summary>
      <param name="assembly">The assembly.</param>
      <returns>This configuration object.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddDirectory(System.IO.DirectoryInfo)">
      <summary>
            Read all mapping documents from a directory tree. Assume that any
            file named <c>*.hbm.xml</c> is a mapping document.
            </summary>
      <param name="dir">a directory</param>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.GenerateDropSchemaScript(NHibernate.Dialect.Dialect)">
      <summary>
            Generate DDL for dropping tables
            </summary>
      <seealso cref="T:NHibernate.Tool.hbm2ddl.SchemaExport" />
    </member>
    <member name="M:NHibernate.Cfg.Configuration.GenerateSchemaCreationScript(NHibernate.Dialect.Dialect)">
      <summary>
            Generate DDL for creating tables
            </summary>
      <param name="dialect">
      </param>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.BuildMappings">
      <summary> 
            Call this to ensure the mappings are fully compiled/built. Usefull to ensure getting
            access to all information in the metamodel when calling e.g. getClassMappings().
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.SecondPassCompile">
      <remarks>
            This method may be called many times!!
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.BuildSessionFactory">
      <summary>
            Instantiate a new <see cref="T:NHibernate.ISessionFactory" />, using the properties and mappings in this
            configuration. The <see cref="T:NHibernate.ISessionFactory" /> will be immutable, so changes made to the
            configuration after building the <see cref="T:NHibernate.ISessionFactory" /> will not affect it.
            </summary>
      <returns>An <see cref="T:NHibernate.ISessionFactory" /> instance.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.SetDefaultAssembly(System.String)">
      <summary>
            Set the default assembly to use for the mappings added to the configuration
            afterwards.
            </summary>
      <param name="newDefaultAssembly">The default assembly name.</param>
      <returns>This configuration instance.</returns>
      <remarks>
            This setting can be overridden for a mapping file by setting <c>default-assembly</c>
            attribute of <c>&lt;hibernate-mapping&gt;</c> element.
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.SetDefaultNamespace(System.String)">
      <summary>
            Set the default namespace to use for the mappings added to the configuration
            afterwards.
            </summary>
      <param name="newDefaultNamespace">The default namespace.</param>
      <returns>This configuration instance.</returns>
      <remarks>
            This setting can be overridden for a mapping file by setting <c>default-namespace</c>
            attribute of <c>&lt;hibernate-mapping&gt;</c> element.
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.SetInterceptor(NHibernate.IInterceptor)">
      <summary>
            Sets the default interceptor for use by all sessions.
            </summary>
      <param name="newInterceptor">The default interceptor.</param>
      <returns>This configuration instance.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.SetProperties(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Specify a completely new set of properties
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddProperties(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Adds an <see cref="T:System.Collections.IDictionary" /> of configuration properties.  The 
            Key is the name of the Property and the Value is the <see cref="T:System.String" />
            value of the Property.
            </summary>
      <param name="additionalProperties">An <see cref="T:System.Collections.IDictionary" /> of configuration properties.</param>
      <returns>
            This <see cref="T:NHibernate.Cfg.Configuration" /> object.
            </returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.SetProperty(System.String,System.String)">
      <summary>
            Sets the value of the configuration property.
            </summary>
      <param name="name">The name of the property.</param>
      <param name="value">The value of the property.</param>
      <returns>
            This configuration object.
            </returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.GetProperty(System.String)">
      <summary>
            Gets the value of the configuration property.
            </summary>
      <param name="name">The name of the property.</param>
      <returns>The configured value of the property, or <see langword="null" /> if the property was not specified.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.Configure">
      <summary>
            Configure NHibernate using the <c>&lt;hibernate-configuration&gt;</c> section
            from the application config file, if found, or the file <c>hibernate.cfg.xml</c> if the
            <c>&lt;hibernate-configuration&gt;</c> section not include the session-factory configuration.
            </summary>
      <returns>A configuration object initialized with the file.</returns>
      <remarks>
            To configure NHibernate explicitly using <c>hibernate.cfg.xml</c>, appling merge/override
            of the application configuration file, use this code:
            <code>
            	configuration.Configure("path/to/hibernate.cfg.xml");
            </code></remarks>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.Configure(System.String)">
      <summary>
            Configure NHibernate using the file specified.
            </summary>
      <param name="fileName">The location of the XML file to use to configure NHibernate.</param>
      <returns>A Configuration object initialized with the file.</returns>
      <remarks>
            Calling Configure(string) will override/merge the values set in app.config or web.config
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.Configure(System.Reflection.Assembly,System.String)">
      <summary>
            Configure NHibernate using a resource contained in an Assembly.
            </summary>
      <param name="assembly">The <see cref="T:System.Reflection.Assembly" /> that contains the resource.</param>
      <param name="resourceName">The name of the manifest resource being requested.</param>
      <returns>A Configuration object initialized from the manifest resource.</returns>
      <remarks>
            Calling Configure(Assembly, string) will overwrite the values set in app.config or web.config
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.Configure(System.Xml.XmlReader)">
      <summary>
            Configure NHibernate using the specified XmlReader.
            </summary>
      <param name="textReader">The <see cref="T:System.Xml.XmlReader" /> that contains the Xml to configure NHibernate.</param>
      <returns>A Configuration object initialized with the file.</returns>
      <remarks>
            Calling Configure(XmlReader) will overwrite the values set in app.config or web.config
            </remarks>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.SetCacheConcurrencyStrategy(System.String,System.String)">
      <summary>
            Set up a cache for an entity class
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.SetCollectionCacheConcurrencyStrategy(System.String,System.String)">
      <summary>
            Set up a cache for a collection role
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.BuildSettings">
      <summary>
            Create an object-oriented view of the configuration properties
            </summary>
      <returns>A <see cref="T:NHibernate.Cfg.Settings" /> object initialized from the settings properties.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.SetNamingStrategy(NHibernate.Cfg.INamingStrategy)">
      <summary>
            Set a custom naming strategy
            </summary>
      <param name="newNamingStrategy">the NamingStrategy to set</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.LoadMappingDocument(System.Xml.XmlReader,System.String)">
      <summary>
            Load and validate the mappings in the <see cref="T:System.Xml.XmlReader" /> against
            the nhibernate-mapping-2.2 schema, without adding them to the configuration.
            </summary>
      <remarks>
            This method is made public to be usable from the unit tests. It is not intended
            to be called by end users.
            </remarks>
      <param name="hbmReader">The XmlReader that contains the mapping.</param>
      <param name="name">The name of the document, for error reporting purposes.</param>
      <returns>NamedXmlDocument containing the validated XmlDocument built from the XmlReader.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddXmlReader(System.Xml.XmlReader)">
      <summary>
            Adds the Mappings in the <see cref="T:System.Xml.XmlReader" /> after validating it
            against the nhibernate-mapping-2.2 schema.
            </summary>
      <param name="hbmReader">The XmlReader that contains the mapping.</param>
      <returns>This Configuration object.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.AddXmlReader(System.Xml.XmlReader,System.String)">
      <summary>
            Adds the Mappings in the <see cref="T:System.Xml.XmlReader" /> after validating it
            against the nhibernate-mapping-2.2 schema.
            </summary>
      <param name="hbmReader">The XmlReader that contains the mapping.</param>
      <param name="name">The name of the document to use for error reporting. May be <see langword="null" />.</param>
      <returns>This Configuration object.</returns>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.SetListeners(NHibernate.Event.ListenerType,System.String[])">
      <summary>
            Set or clear listener for a given <see cref="T:NHibernate.Event.ListenerType" />.
            </summary>
      <param name="type">The <see cref="T:NHibernate.Event.ListenerType" />.</param>
      <param name="listenerClasses">The array of AssemblyQualifiedName of each listener for <paramref name="type" />.</param>
      <remarks>
        <paramref name="listenerClasses" /> must implements the interface related with <paramref name="type" />.
            All listeners of the given <see cref="T:NHibernate.Event.ListenerType" /> will be cleared if the <paramref name="listenerClasses" /> 
            is null or empty.
            </remarks>
      <exception cref="T:NHibernate.MappingException">
            when an element of <paramref name="listenerClasses" /> have an invalid value or cant be instantiated.
            </exception>
    </member>
    <member name="M:NHibernate.Cfg.Configuration.SetListener(NHibernate.Event.ListenerType,System.Object)">
      <summary>
            Set or clear listener for a given <see cref="T:NHibernate.Event.ListenerType" />.
            </summary>
      <param name="type">The <see cref="T:NHibernate.Event.ListenerType" />.</param>
      <param name="listener">The listener for <paramref name="type" /> or null to clear.</param>
      <remarks>
        <paramref name="listener" /> must implements the interface related with <paramref name="type" />.</remarks>
      <seealso cref="N:NHibernate.Event" />
    </member>
    <member name="M:NHibernate.Cfg.Configuration.SetListeners(NHibernate.Event.ListenerType,System.Object[])">
      <summary>
            Set or clear listeners for a given <see cref="T:NHibernate.Event.ListenerType" />.
            </summary>
      <param name="type">The <see cref="T:NHibernate.Event.ListenerType" />.</param>
      <param name="listeners">The listener for <paramref name="type" /> or null to clear.</param>
      <remarks>Listeners of <paramref name="listeners" /> must implements one of the interface of event listenesr.</remarks>
      <seealso cref="N:NHibernate.Event" />
    </member>
    <member name="M:NHibernate.Cfg.Configuration.GenerateSchemaUpdateScript(NHibernate.Dialect.Dialect,NHibernate.Tool.hbm2ddl.DatabaseMetadata)">
      <summary>
             Generate DDL for altering tables
            </summary>
      <seealso cref="T:NHibernate.Tool.hbm2ddl.SchemaUpdate" />
    </member>
    <member name="P:NHibernate.Cfg.Configuration.ClassMappings">
      <summary>
            The class mappings 
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.Configuration.CollectionMappings">
      <summary>
            The collection mappings
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.Configuration.TableMappings">
      <summary>
            The table mappings
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.Configuration.NamedQueries">
      <summary>
            The named queries
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.Configuration.EntityNotFoundDelegate">
      <summary> 
            Retrieve the user-supplied delegate to handle non-existent entity scenarios.
            </summary>
      <remarks>
            Specify a user-supplied delegate to be used to handle scenarios where an entity could not be
            located by specified id.  This is mainly intended for EJB3 implementations to be able to
            control how proxy initialization errors should be handled...
            </remarks>
    </member>
    <member name="P:NHibernate.Cfg.Configuration.Interceptor">
      <summary>
            Gets or sets the <see cref="T:NHibernate.IInterceptor" /> to use.
            </summary>
      <value>The <see cref="T:NHibernate.IInterceptor" /> to use.</value>
    </member>
    <member name="P:NHibernate.Cfg.Configuration.Properties">
      <summary>
            Gets or sets the <see cref="T:System.Collections.IDictionary" /> that contains the configuration
            properties and their values.
            </summary>
      <value>
            The <see cref="T:System.Collections.IDictionary" /> that contains the configuration
            properties and their values.
            </value>
    </member>
    <member name="P:NHibernate.Cfg.Configuration.Imports">
      <summary>
            Get the query language imports (entityName/className -&gt; AssemblyQualifiedName)
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.Configuration.NamedSQLQueries">
      <summary>
            The named SQL queries
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.Configuration.NamingStrategy">
      <summary>
            Naming strategy for tables and columns
            </summary>
    </member>
    <member name="T:NHibernate.Engine.IMapping">
      <summary>
            Defines operations common to "compiled" mappings (ie. <c>SessionFactory</c>) and
            "uncompiled" mappings (ie <c>Configuration</c> that are used by implementors of <c>IType</c></summary>
    </member>
    <member name="T:NHibernate.Cfg.ConfigurationSectionHandler">
      <summary>
            Summary description for ConfigurationSectionHandler.
            </summary>
    </member>
    <member name="T:NHibernate.Cfg.INamingStrategy">
      <summary>
            A set of rules for determining the physical column and table names given the information in the mapping
            document. May be used to implement project-scoped naming standards for database objects.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.INamingStrategy.ClassToTableName(System.String)">
      <summary>
            Return a table name for an entity class
            </summary>
      <param name="className">the fully-qualified class name</param>
      <returns>a table name</returns>
    </member>
    <member name="M:NHibernate.Cfg.INamingStrategy.PropertyToColumnName(System.String)">
      <summary>
            Return a column name for a property path expression 
            </summary>
      <param name="propertyName">a property path</param>
      <returns>a column name</returns>
    </member>
    <member name="M:NHibernate.Cfg.INamingStrategy.TableName(System.String)">
      <summary>
            Alter the table name given in the mapping document
            </summary>
      <param name="tableName">a table name</param>
      <returns>a table name</returns>
    </member>
    <member name="M:NHibernate.Cfg.INamingStrategy.ColumnName(System.String)">
      <summary>
            Alter the column name given in the mapping document
            </summary>
      <param name="columnName">a column name</param>
      <returns>a column name</returns>
    </member>
    <member name="M:NHibernate.Cfg.INamingStrategy.PropertyToTableName(System.String,System.String)">
      <summary>
            Return a table name for a collection
            </summary>
      <param name="className">the fully-qualified name of the owning entity class</param>
      <param name="propertyName">a property path</param>
      <returns>a table name</returns>
    </member>
    <member name="M:NHibernate.Cfg.INamingStrategy.LogicalColumnName(System.String,System.String)">
      <summary> 
            Return the logical column name used to refer to a column in the metadata
            (like index, unique constraints etc)
            A full bijection is required between logicalNames and physical ones
            logicalName have to be case insersitively unique for a given table 
            </summary>
      <param name="columnName">given column name if any </param>
      <param name="propertyName">property name of this column </param>
    </member>
    <member name="T:NHibernate.Cfg.DefaultNamingStrategy">
      <summary>
            The default <cref name="INamingStrategy" /></summary>
      <remarks>See <cref name="ImprovedNamingStrategy" /> for a better alternative</remarks>
    </member>
    <member name="F:NHibernate.Cfg.DefaultNamingStrategy.Instance">
      <summary>
            The singleton instance
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.DefaultNamingStrategy.ClassToTableName(System.String)">
      <summary>
            Return the unqualified class name
            </summary>
      <param name="className">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.DefaultNamingStrategy.PropertyToColumnName(System.String)">
      <summary>
            Return the unqualified property name
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.DefaultNamingStrategy.TableName(System.String)">
      <summary>
            Return the argument
            </summary>
      <param name="tableName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.DefaultNamingStrategy.ColumnName(System.String)">
      <summary>
            Return the argument
            </summary>
      <param name="columnName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.DefaultNamingStrategy.PropertyToTableName(System.String,System.String)">
      <summary>
            Return the unqualified property name
            </summary>
      <param name="className">
      </param>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Cfg.Environment">
      <summary>
            Provides access to configuration information.
            </summary>
      <remarks>
            NHibernate has two property scopes:
            <list><item><description>
            	 Factory-level properties may be passed to the <see cref="T:NHibernate.ISessionFactory" /> when it is
            	 instantiated. Each instance might have different property values. If no properties are
            	 specified, the factory gets them from Environment
            	</description></item><item><description>
            	 System-level properties are shared by all factory instances and are always determined
            	 by the <see cref="T:NHibernate.Cfg.Environment" /> properties
            	</description></item></list>
            In NHibernate, <c>&lt;hibernate-configuration&gt;</c> section in the application configuration file
            corresponds to Java system-level properties; <c>&lt;session-factory&gt;</c>
            section is the session-factory-level configuration. 
            
            It is possible to use the application configuration file (App.config) together with the NHibernate 
            configuration file (hibernate.cfg.xml) at the same time.
            Properties in hibernate.cfg.xml override/merge properties in application configuration file where same
            property is found. For others configuration a merge is applied.
            </remarks>
    </member>
    <member name="F:NHibernate.Cfg.Environment.ConnectionStringName">
      <summary>
            Used to find the .Net 2.0 named connection string
            </summary>
    </member>
    <member name="F:NHibernate.Cfg.Environment.DefaultSchema">
      <summary> A default database schema (owner) name to use for unqualified tablenames</summary>
    </member>
    <member name="F:NHibernate.Cfg.Environment.DefaultCatalog">
      <summary> A default database catalog name to use for unqualified tablenames</summary>
    </member>
    <member name="F:NHibernate.Cfg.Environment.DefaultEntityMode">
      <summary>The EntityMode in which set the Session opened from the SessionFactory.</summary>
    </member>
    <member name="F:NHibernate.Cfg.Environment.FormatSql">
      <summary> Enable formatting of SQL logged to the console</summary>
    </member>
    <member name="F:NHibernate.Cfg.Environment.QueryStartupChecking">
      <summary> Should named queries be checked during startup (the default is enabled). </summary>
      <remarks>Mainly intended for test environments.</remarks>
    </member>
    <member name="F:NHibernate.Cfg.Environment.GenerateStatistics">
      <summary> Enable statistics collection</summary>
    </member>
    <member name="M:NHibernate.Cfg.Environment.VerifyProperties(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Issue warnings to user when any obsolete property names are used.
            </summary>
      <param name="props">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Cfg.Environment.Version">
      <summary>
            NHibernate version (informational).
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.Environment.Properties">
      <summary>
            Gets a copy of the configuration found in <c>&lt;hibernate-configuration&gt;</c> section
            of app.config/web.config.
            </summary>
      <remarks>
            This is the replacement for hibernate.properties
            </remarks>
    </member>
    <member name="P:NHibernate.Cfg.Environment.BytecodeProvider">
      <summary>
            The bytecode provider to use.
            </summary>
      <remarks>
            This property is read from the <c>&lt;nhibernate&gt;</c> section
            of the application configuration file by default. Since it is not
            always convenient to configure NHibernate through the application
            configuration file, it is also possible to set the property value
            manually. This should only be done before a configuration object
            is created, otherwise the change may not take effect.
            </remarks>
    </member>
    <member name="P:NHibernate.Cfg.Environment.UseReflectionOptimizer">
      <summary>
            Whether to enable the use of reflection optimizer
            </summary>
      <remarks>
            This property is read from the <c>&lt;nhibernate&gt;</c> section
            of the application configuration file by default. Since it is not
            always convenient to configure NHibernate through the application
            configuration file, it is also possible to set the property value
            manually. This should only be done before a configuration object
            is created, otherwise the change may not take effect.
            </remarks>
    </member>
    <member name="T:NHibernate.Cfg.ExtendsQueueEntry">
      <summary> 
            Represents a mapping queued for delayed processing to await
            processing of an extends entity upon which it depends. 
            </summary>
    </member>
    <member name="T:NHibernate.MappingException">
      <summary>
            An exception that usually occurs at configuration time, rather than runtime, as a result of
            something screwy in the O-R mappings
            </summary>
    </member>
    <member name="M:NHibernate.MappingException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.MappingException.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException" /> class.
            </summary>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.MappingException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.MappingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.Cfg.HibernateConfigException">
      <summary>
            An exception that occurs at configuration time, rather than runtime, as a result of
            something screwy in the hibernate.cfg.xml.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.HibernateConfigException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.HibernateConfigException" /> class.
            </summary>
      <remarks>Default message is used.</remarks>
    </member>
    <member name="M:NHibernate.Cfg.HibernateConfigException.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.HibernateConfigException" /> class.
            </summary>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.Cfg.HibernateConfigException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.HibernateConfigException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.Cfg.HibernateConfigException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.HibernateConfigException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.Cfg.HibernateConfigException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cfg.HibernateConfigException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.Cfg.ImprovedNamingStrategy">
      <summary>
            Summary description for ImprovedNamingStrategy.
            </summary>
    </member>
    <member name="F:NHibernate.Cfg.ImprovedNamingStrategy.Instance">
      <summary>
            The singleton instance
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.ClassToTableName(System.String)">
      <summary>
            Return the unqualified class name, mixed case converted to underscores
            </summary>
      <param name="className">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.PropertyToColumnName(System.String)">
      <summary>
            Return the full property path with underscore separators, mixed case converted to underscores
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.TableName(System.String)">
      <summary>
            Convert mixed case to underscores
            </summary>
      <param name="tableName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.ColumnName(System.String)">
      <summary>
            Convert mixed case to underscores
            </summary>
      <param name="columnName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.PropertyToTableName(System.String,System.String)">
      <summary>
            Return the full property path prefixed by the unqualified class name, with underscore separators, mixed case converted to underscores
            </summary>
      <param name="className">
      </param>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Cfg.Mappings">
      <summary>
            A collection of mappings from classes and collections to relational database tables.
            </summary>
      <remarks>Represents a single <c>&lt;hibernate-mapping&gt;</c> element.</remarks>
    </member>
    <member name="F:NHibernate.Cfg.Mappings.columnNameBindingPerTable">
      <summary> 
            Binding table between the logical column name and the name out of the naming strategy
            for each table.
            According that when the column name is not set, the property name is considered as such
            This means that while theoretically possible through the naming strategy contract, it is
            forbidden to have 2 real columns having the same logical name
            </summary>
    </member>
    <member name="F:NHibernate.Cfg.Mappings.tableNameBinding">
      <summary> 
            Binding between logical table name and physical one (ie after the naming strategy has been applied)
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.Mappings.AddClass(NHibernate.Mapping.PersistentClass)">
      <summary>
      </summary>
      <param name="persistentClass">
      </param>
    </member>
    <member name="M:NHibernate.Cfg.Mappings.AddCollection(NHibernate.Mapping.Collection)">
      <summary>
      </summary>
      <param name="collection">
      </param>
    </member>
    <member name="M:NHibernate.Cfg.Mappings.AddImport(System.String,System.String)">
      <summary>
            Adds an import to allow for the full class name <c>Namespace.Entity (AssemblyQualifiedName)</c> 
            to be referenced as <c>Entity</c> or some other name in HQL.
            </summary>
      <param name="className">The name of the type that is being renamed.</param>
      <param name="rename">The new name to use in HQL for the type.</param>
      <exception cref="T:NHibernate.MappingException">Thrown when the rename already identifies another type.</exception>
    </member>
    <member name="P:NHibernate.Cfg.Mappings.NamingStrategy">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Cfg.Mappings.DefaultNamespace">
      <summary>
            The default namespace for persistent classes
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.Mappings.DefaultAssembly">
      <summary>
            The default assembly for persistent classes
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.Mappings.DefaultCascade">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Cfg.Mappings.DefaultAccess">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Cfg.Mappings.IsAutoImport">
      <summary>
            Gets or sets a boolean indicating if the Fully Qualified Type name should
            automatically have an import added as the class name.
            </summary>
      <value>
        <see langword="true" /> if the class name should be used as an import.</value>
      <remarks>
            Auto-import is used to shorten the string used to refer to types to just their
            unqualified name.  So if the type <c>MyAssembly.MyNamespace.MyClass, MyAssembly</c> has
            <c>auto-import="false"</c> then all use of it in HQL would need to be the fully qualified
            version <c>MyAssembly.MyNamespace.MyClass</c>. If <c>auto-import="true"</c>, the type could
            be referred to in HQL as just <c>MyClass</c>.
            </remarks>
    </member>
    <member name="T:NHibernate.Cfg.MappingsQueue">
      <summary>
            Queues mapping files according to their dependency order.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.MappingsQueue.AddDocument(NHibernate.Cfg.NamedXmlDocument)">
      <summary>
            Adds the specified document to the queue.
            </summary>
    </member>
    <member name="M:NHibernate.Cfg.MappingsQueue.GetNextAvailableResource">
      <summary>
            Gets a <see cref="T:NHibernate.Cfg.NamedXmlDocument" /> that can now be processed (i.e.
            that doesn't depend on classes not yet processed).
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Cfg.MappingsQueue.CheckNoUnavailableEntries">
      <summary>
            Checks that no unprocessed documents remain in the queue.
            </summary>
    </member>
    <member name="T:NHibernate.Cfg.MappingsQueueEntry">
      <summary>
            Holds information about mapped classes found in an embedded resource
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.MappingsQueueEntry.RequiredClassNames">
      <summary>
            Gets the names of all entities outside this resource
            needed by the classes in this resource.
            </summary>
    </member>
    <member name="P:NHibernate.Cfg.MappingsQueueEntry.ContainedClassNames">
      <summary>
            Gets the names of all entities in this resource
            </summary>
    </member>
    <member name="T:NHibernate.Cfg.Settings">
      <summary>
            Settings that affect the behavior of NHibernate at runtime.
            </summary>
    </member>
    <member name="T:NHibernate.Cfg.SettingsFactory">
      <summary>
            Reads configuration properties and configures a <see cref="T:NHibernate.Cfg.Settings" /> instance. 
            </summary>
    </member>
    <member name="T:NHibernate.Classic.ILifecycle">
      <summary>
            Provides callbacks from the <see cref="T:NHibernate.ISession" /> to the persistent object. Persistent classes may
            implement this interface but they are not required to.
            </summary>
      <remarks>
        <para>
          <see cref="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)" />, <see cref="M:NHibernate.Classic.ILifecycle.OnDelete(NHibernate.ISession)" />, and <see cref="M:NHibernate.Classic.ILifecycle.OnUpdate(NHibernate.ISession)" /> are intended to be used
            to cascade saves and deletions of dependent objects. This is an alternative to declaring cascaded
            operations in the mapping file.
            </para>
        <para>
          <see cref="M:NHibernate.Classic.ILifecycle.OnLoad(NHibernate.ISession,System.Object)" /> may be used to initialize transient properties of the object from its persistent
            state. It may <em>not</em> be used to load dependent objects since the <see cref="T:NHibernate.ISession" /> interface
            may not be invoked from inside this method.
            </para>
        <para>
            A further intended usage of <see cref="M:NHibernate.Classic.ILifecycle.OnLoad(NHibernate.ISession,System.Object)" />, <see cref="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)" />, and <see cref="M:NHibernate.Classic.ILifecycle.OnUpdate(NHibernate.ISession)" />
            is to store a reference to the <see cref="T:NHibernate.ISession" /> for later use.
            </para>
        <para>
            If <see cref="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)" />, <see cref="M:NHibernate.Classic.ILifecycle.OnUpdate(NHibernate.ISession)" />, or <see cref="M:NHibernate.Classic.ILifecycle.OnDelete(NHibernate.ISession)" /> return
            <see cref="F:NHibernate.Classic.LifecycleVeto.Veto" />, the operation is silently vetoed. If a <see cref="T:NHibernate.CallbackException" />
            is thrown, the operation is vetoed and the exception is passed back to the application.
            </para>
        <para>
            Note that <see cref="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)" /> is called after an identifier is assigned to the object, except when
            <c>identity</c> key generation is used.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Classic.ILifecycle.OnSave(NHibernate.ISession)">
      <summary>
            Called when an entity is saved
            </summary>
      <param name="s">The session</param>
      <returns>If we should veto the save</returns>
    </member>
    <member name="M:NHibernate.Classic.ILifecycle.OnUpdate(NHibernate.ISession)">
      <summary>
            Called when an entity is passed to <see cref="M:NHibernate.ISession.Update(System.Object)" />.
            </summary>
      <param name="s">The session</param>
      <returns>A <see cref="T:NHibernate.Classic.LifecycleVeto" /> value indicating whether the operation
            should be vetoed or allowed to proceed.</returns>
      <remarks>
            This method is <em>not</em> called every time the object's state is
            persisted during a flush.
            </remarks>
    </member>
    <member name="M:NHibernate.Classic.ILifecycle.OnDelete(NHibernate.ISession)">
      <summary>
            Called when an entity is deleted
            </summary>
      <param name="s">The session</param>
      <returns>A <see cref="T:NHibernate.Classic.LifecycleVeto" /> value indicating whether the operation
            should be vetoed or allowed to proceed.</returns>
    </member>
    <member name="M:NHibernate.Classic.ILifecycle.OnLoad(NHibernate.ISession,System.Object)">
      <summary>
            Called after an entity is loaded. 
            </summary>
      <remarks>
        <note>It is illegal to access the <see cref="T:NHibernate.ISession" /> from inside this method.</note>. 
            However, the object may keep a reference to the session for later use
            </remarks>
      <param name="s">The session</param>
      <param name="id">The identifier</param>
    </member>
    <member name="F:NHibernate.Classic.LifecycleVeto.Veto">
      <summary>
            Veto the action
            </summary>
    </member>
    <member name="F:NHibernate.Classic.LifecycleVeto.NoVeto">
      <summary>
            Accept the action
            </summary>
    </member>
    <member name="T:NHibernate.Classic.IValidatable">
      <summary>
            Implemented by persistent classes with invariants that must be checked before inserting
            into or updating the database
            </summary>
    </member>
    <member name="M:NHibernate.Classic.IValidatable.Validate">
      <summary>
            Validate the state of the object before persisting it. If a violation occurs,
            throw a <see cref="T:NHibernate.Classic.ValidationFailure" />. This method must not change the state of the object
            by side-effect.
            </summary>
    </member>
    <member name="T:NHibernate.Classic.ValidationFailure">
      <summary>
            Thrown from <see cref="M:NHibernate.Classic.IValidatable.Validate" /> when an invariant was violated. Some applications
            might subclass this exception in order to provide more information about the violation
            </summary>
    </member>
    <member name="M:NHibernate.Classic.ValidationFailure.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.Classic.ValidationFailure.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.Classic.ValidationFailure.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure" /> class.
            </summary>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.Classic.ValidationFailure.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.Classic.ValidationFailure.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Classic.ValidationFailure" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.Collection.IPersistentCollection">
      <summary>
        <para>
            Persistent collections are treated as value objects by NHibernate.
            ie. they have no independent existence beyond the object holding
            a reference to them. Unlike instances of entity classes, they are
            automatically deleted when unreferenced and automatically become
            persistent when held by a persistent object. Collections can be
            passed between different objects (change "roles") and this might
            cause their elements to move from one database table to another.
            </para>
        <para>
            NHibernate "wraps" a collection in an instance of
            <see cref="T:NHibernate.Collection.IPersistentCollection" />. This mechanism is designed
            to support tracking of changes to the collection's persistent
            state and lazy instantiation of collection elements. The downside
            is that only certain abstract collection types are supported and
            any extra semantics are lost.
            </para>
        <para>
            Applications should <b>never</b> use classes in this namespace
            directly, unless extending the "framework" here.
            </para>
        <para>
            Changes to <b>structure</b> of the collection are recorded by the
            collection calling back to the session. Changes to mutable
            elements (ie. composite elements) are discovered by cloning their
            state when the collection is initialized and comparing at flush
            time.
            </para>
      </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.GetValue">
      <summary>
            Return the user-visible collection (or array) instance
            </summary>
      <returns>
            By default, the NHibernate wrapper is an acceptable collection for
            the end user code to work with because it is interface compatible.
            An NHibernate PersistentList is an IList, an NHibernate PersistentMap is an IDictionary
            and those are the types user code is expecting.
            </returns>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.SetSnapshot(System.Object,System.String,System.Object)">
      <summary> After flushing, re-init snapshot state.</summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.PostAction">
      <summary>
            Clears out any Queued Additions.
            </summary>
      <remarks>
            After a Flush() the database is in synch with the in-memory
            contents of the Collection.  Since everything is in synch remove
            any Queued Additions.
            </remarks>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.BeginRead">
      <summary>
            Called just before reading any rows from the <see cref="T:System.Data.IDataReader" /></summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Called after reading all rows from the <see cref="T:System.Data.IDataReader" /></summary>
      <remarks>
            This should be overridden by sub collections that use temporary collections
            to store values read from the db.
            </remarks>
      <returns>
            true if NOT has Queued operations
            </returns>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.AfterInitialize(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Called after initializing from cache
            </summary>
      <returns>
            true if NOT has Queued operations
            </returns>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.UnsetSession(NHibernate.Engine.ISessionImplementor)">
      <summary>
            Disassociate this collection from the given session.
            </summary>
      <param name="currentSession">
      </param>
      <returns>true if this was currently associated with the given session</returns>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.SetCurrentSession(NHibernate.Engine.ISessionImplementor)">
      <summary>
            Associate the collection with the given session.
            </summary>
      <param name="session">
      </param>
      <returns>false if the collection was already associated with the session</returns>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
      <summary>
            Read the state of the collection from a disassembled cached value.
            </summary>
      <param name="persister">
      </param>
      <param name="disassembled">
      </param>
      <param name="owner">
      </param>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.Entries(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Iterate all collection entries, during update of the database
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerable" /> that gives access to all entries
            in the collection.
            </returns>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)">
      <summary>
            Reads the row from the <see cref="T:System.Data.IDataReader" />.
            </summary>
      <remarks>
            This method should be prepared to handle duplicate elements caused by fetching multiple collections,
            or <see cref="M:NHibernate.Hql.Classic.QueryTranslator.FetchedCollections.IsUnsafe(NHibernate.Persister.Collection.ICollectionPersister)" /> should be updated
            to return <see langword="true" /> for the collection type.
            </remarks>
      <param name="reader">The IDataReader that contains the value of the Identifier</param>
      <param name="role">The persister for this Collection.</param>
      <param name="descriptor">The descriptor providing result set column names</param>
      <param name="owner">The owner of this Collection.</param>
      <returns>The object that was contained in the row.</returns>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.GetIdentifier(System.Object,System.Int32)">
      <summary>
            Get the identifier of the given collection entry
            </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.GetIndex(System.Object,System.Int32,NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Get the index of the given collection entry
            </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.GetElement(System.Object)">
      <summary>
            Get the value of the given collection entry
            </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.GetSnapshotElement(System.Object,System.Int32)">
      <summary>
            Get the snapshot value of the given collection entry
            </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.BeforeInitialize(NHibernate.Persister.Collection.ICollectionPersister,System.Int32)">
      <summary>
            Called before any elements are read into the collection,
            allowing appropriate initializations to occur.
            </summary>
      <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> for this persistent collection.</param>
      <param name="anticipatedSize">The anticipated size of the collection after initilization is complete.</param>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.EqualsSnapshot(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Does the current state exactly match the snapshot?
            </summary>
      <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> to compare the elements of the Collection.</param>
      <returns>
        <see langword="true" /> if the wrapped collection is different than the snapshot
            of the collection or if one of the elements in the collection is
            dirty.
            </returns>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.IsSnapshotEmpty(System.Object)">
      <summary> Is the snapshot empty?</summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.Disassemble(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Disassemble the collection, ready for the cache
            </summary>
      <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> for this Collection.</param>
      <returns>The contents of the persistent collection in a cacheable form.</returns>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.NeedsRecreate(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Gets a <see cref="T:System.Boolean" /> indicating if the rows for this collection
            need to be recreated in the table.
            </summary>
      <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> for this Collection.</param>
      <returns>
        <see langword="false" /> by default since most collections can determine which rows need to be
            individually updated/inserted/deleted.  Currently only <see cref="T:NHibernate.Collection.PersistentBag" />'s for <c>many-to-many</c>
            need to be recreated.
            </returns>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.GetSnapshot(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Return a new snapshot of the current state of the collection
            </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.ForceInitialization">
      <summary>
            To be called internally by the session, forcing
            immediate initalization.
            </summary>
      <remarks>
            This method is similar to <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Initialize(System.Boolean)" />, except that different exceptions are thrown.
            </remarks>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.EntryExists(System.Object,System.Int32)">
      <summary>
            Does an element exist at this entry in the collection?
            </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)">
      <summary>
            Do we need to insert this element?
            </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)">
      <summary>
            Do we need to update this element?
            </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.GetDeletes(NHibernate.Persister.Collection.ICollectionPersister,System.Boolean)">
      <summary>
            Get all the elements that need deleting
            </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.IsWrapper(System.Object)">
      <summary>
            Is this the wrapper for the given underlying collection instance?
            </summary>
      <param name="collection">The collection to see if this IPersistentCollection is wrapping.</param>
      <returns>
        <see langword="true" /> if the IPersistentCollection is wrappping the collection instance,
            <see langword="false" /> otherwise.
            </returns>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.GetQueuedOrphans(System.String)">
      <summary> Get the "queued" orphans</summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.ClearDirty">
      <summary>
            Clear the dirty flag, after flushing changes
            to the database.
            </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.Dirty">
      <summary>
            Mark the collection as dirty
            </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.PreInsert(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Called before inserting rows, to ensure that any surrogate keys are fully generated
            </summary>
      <param name="persister">
      </param>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.AfterRowInsert(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Int32,System.Object)">
      <summary>
            Called after inserting a row, to fetch the natively generated id
            </summary>
    </member>
    <member name="M:NHibernate.Collection.IPersistentCollection.GetOrphans(System.Object,System.String)">
      <summary>
            Get all "orphaned" elements
            </summary>
      <param name="snapshot">The snapshot of the collection.</param>
      <param name="entityName">The persistent class whose objects
            the collection is expected to contain.</param>
      <returns>
            An <see cref="T:System.Collections.ICollection" /> that contains all of the elements
            that have been orphaned.
            </returns>
    </member>
    <member name="P:NHibernate.Collection.IPersistentCollection.Owner">
      <summary>
            The owning entity.
            </summary>
      <remarks>
            Note that the owner is only set during the flush
            cycle, and when a new collection wrapper is created
            while loading an entity.
            </remarks>
    </member>
    <member name="P:NHibernate.Collection.IPersistentCollection.Key">
      <summary> Get the current collection key value</summary>
    </member>
    <member name="P:NHibernate.Collection.IPersistentCollection.Role">
      <summary> Get the current role name</summary>
    </member>
    <member name="P:NHibernate.Collection.IPersistentCollection.IsUnreferenced">
      <summary> Is the collection unreferenced?</summary>
    </member>
    <member name="P:NHibernate.Collection.IPersistentCollection.IsDirty">
      <summary>
            Is the collection dirty? Note that this is only
            reliable during the flush cycle, after the
            collection elements are dirty checked against
            the snapshot.
            </summary>
    </member>
    <member name="P:NHibernate.Collection.IPersistentCollection.StoredSnapshot">
      <summary> Get the snapshot cached by the collection instance </summary>
    </member>
    <member name="P:NHibernate.Collection.IPersistentCollection.Empty">
      <summary>
            Is the initialized collection empty?
            </summary>
    </member>
    <member name="P:NHibernate.Collection.IPersistentCollection.IsDirectlyAccessible">
      <summary>
            Gets a <see cref="T:System.Boolean" /> indicating if the underlying collection is directly
            accessible through code.
            </summary>
      <value>
        <see langword="true" /> if we are not guaranteed that the NHibernate collection wrapper
            is being used.
            </value>
      <remarks>
            This is typically <see langword="false" /> whenever a transient object that contains a collection is being
            associated with an <see cref="T:NHibernate.ISession" /> through <see cref="M:NHibernate.ISession.Save(System.Object)" /> or <see cref="M:NHibernate.ISession.SaveOrUpdate(System.Object)" />.
            NHibernate can't guarantee that it will know about all operations that would cause NHibernate's collections
            to call <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Read" /> or <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Write" />.
            </remarks>
    </member>
    <member name="P:NHibernate.Collection.IPersistentCollection.WasInitialized">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Collection.IPersistentCollection.HasQueuedOperations">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Collection.IPersistentCollection.QueuedAdditionIterator">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Collection.AbstractPersistentCollection">
      <summary>
            Base class for implementing <see cref="T:NHibernate.Collection.IPersistentCollection" />.
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.#ctor">
      <summary>
            Not called by Hibernate, but used by non-NET serialization, eg. SOAP libraries.
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetValue">
      <summary>
            Return the user-visible collection (or array) instance
            </summary>
      <returns>
            By default, the NHibernate wrapper is an acceptable collection for
            the end user code to work with because it is interface compatible.
            An NHibernate PersistentList is an IList, an NHibernate PersistentMap is an IDictionary
            and those are the types user code is expecting.
            </returns>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.Read">
      <summary>
            Called by any read-only method of the collection interface
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.ReadSize">
      <summary> Called by the <tt>Count</tt> property</summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.Write">
      <summary>
            Called by any writer method of the collection interface
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.QueueOperation(NHibernate.Collection.AbstractPersistentCollection.IDelayedOperation)">
      <summary>
            Queue an addition, delete etc. if the persistent collection supports it
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.PerformQueuedOperations">
      <summary> 
            After reading all existing elements from the database,
            add the queued elements to the underlying collection.
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.PostAction">
      <summary>
            Clears out any Queued operation.
            </summary>
      <remarks>
            After flushing, clear any "queued" additions, since the
            database state is now synchronized with the memory state.
            </remarks>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.BeginRead">
      <summary>
            Called just before reading any rows from the <see cref="T:System.Data.IDataReader" /></summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Called after reading all rows from the <see cref="T:System.Data.IDataReader" /></summary>
      <remarks>
            This should be overridden by sub collections that use temporary collections
            to store values read from the db.
            </remarks>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.Initialize(System.Boolean)">
      <summary>
            Initialize the collection, if possible, wrapping any exceptions
            in a runtime exception
            </summary>
      <param name="writing">currently obsolete</param>
      <exception cref="T:NHibernate.LazyInitializationException">if we cannot initialize</exception>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.SetInitialized">
      <summary>
            Mark the collection as initialized.
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.UnsetSession(NHibernate.Engine.ISessionImplementor)">
      <summary>
            Disassociate this collection from the given session.
            </summary>
      <param name="currentSession">
      </param>
      <returns>true if this was currently associated with the given session</returns>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.SetCurrentSession(NHibernate.Engine.ISessionImplementor)">
      <summary>
            Associate the collection with the given session.
            </summary>
      <param name="session">
      </param>
      <returns>false if the collection was already associated with the session</returns>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.NeedsRecreate(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Gets a <see cref="T:System.Boolean" /> indicating if the rows for this collection
            need to be recreated in the table.
            </summary>
      <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> for this Collection.</param>
      <returns>
        <see langword="false" /> by default since most collections can determine which rows need to be
            individually updated/inserted/deleted.  Currently only <see cref="T:NHibernate.Collection.PersistentBag" />'s for <c>many-to-many</c>
            need to be recreated.
            </returns>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.ForceInitialization">
      <summary>
            To be called internally by the session, forcing
            immediate initalization.
            </summary>
      <remarks>
            This method is similar to <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Initialize(System.Boolean)" />, except that different exceptions are thrown.
            </remarks>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetSnapshot">
      <summary>
            Gets the Snapshot from the current session the collection is in.
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.PreInsert(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Called before inserting rows, to ensure that any surrogate keys are fully generated
            </summary>
      <param name="persister">
      </param>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.AfterRowInsert(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Int32,System.Object)">
      <summary>
            Called after inserting a row, to fetch the natively generated id
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetOrphans(System.Object,System.String)">
      <summary>
            Get all "orphaned" elements
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetOrphans(System.Collections.ICollection,System.Collections.ICollection,System.String,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Given a collection of entity instances that used to
            belong to the collection, and a collection of instances
            that currently belong, return a collection of orphans
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.Disassemble(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Disassemble the collection, ready for the cache
            </summary>
      <param name="persister">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.IsWrapper(System.Object)">
      <summary>
            Is this the wrapper for the given underlying collection instance?
            </summary>
      <param name="collection">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.EntryExists(System.Object,System.Int32)">
      <summary>
            Does an element exist at this entry in the collection?
            </summary>
      <param name="entry">
      </param>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetDeletes(NHibernate.Persister.Collection.ICollectionPersister,System.Boolean)">
      <summary>
            Get all the elements that need deleting
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
      <summary>
            Read the state of the collection from a disassembled cached value.
            </summary>
      <param name="persister">
      </param>
      <param name="disassembled">
      </param>
      <param name="owner">
      </param>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)">
      <summary>
            Do we need to update this element?
            </summary>
      <param name="entry">
      </param>
      <param name="i">
      </param>
      <param name="elemType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)">
      <summary>
            Reads the row from the <see cref="T:System.Data.IDataReader" />.
            </summary>
      <param name="reader">The IDataReader that contains the value of the Identifier</param>
      <param name="role">The persister for this Collection.</param>
      <param name="descriptor">The descriptor providing result set column names</param>
      <param name="owner">The owner of this Collection.</param>
      <returns>The object that was contained in the row.</returns>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)">
      <summary>
            Do we need to insert this element?
            </summary>
      <param name="entry">
      </param>
      <param name="i">
      </param>
      <param name="elemType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.GetIndex(System.Object,System.Int32,NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Get the index of the given collection entry
            </summary>
    </member>
    <member name="M:NHibernate.Collection.AbstractPersistentCollection.BeforeInitialize(NHibernate.Persister.Collection.ICollectionPersister,System.Int32)">
      <summary>
            Called before any elements are read into the collection,
            allowing appropriate initializations to occur.
            </summary>
      <param name="persister">The underlying collection persister. </param>
      <param name="anticipatedSize">The anticipated size of the collection after initilization is complete. </param>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.IsConnectedToSession">
      <summary>
            Is the collection currently connected to an open session?
            </summary>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.IsOperationQueueEnabled">
      <summary>
            Is this collection in a state that would allow us to "queue" additions?
            </summary>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.PutQueueEnabled">
      <summary> Is this collection in a state that would allow us to
            "queue" puts? This is a special case, because of orphan
            delete.
            </summary>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.ClearQueueEnabled">
      <summary> Is this collection in a state that would allow us to
            "queue" clear? This is a special case, because of orphan
            delete.
            </summary>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.IsInverseCollection">
      <summary> Is this the "inverse" end of a bidirectional association?</summary>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.InverseCollectionNoOrphanDelete">
      <summary> 
            Is this the "inverse" end of a bidirectional association with
            no orphan delete enabled?
            </summary>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.InverseOneToManyOrNoOrphanDelete">
      <summary> 
            Is this the "inverse" end of a bidirectional one-to-many, or 
            of a collection with no orphan delete?
            </summary>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.Session">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.Empty">
      <summary>
            Is the initialized collection empty?
            </summary>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.IsDirectlyAccessible">
      <summary>
            Gets a <see cref="T:System.Boolean" /> indicating if the underlying collection is directly
            accessible through code.
            </summary>
      <value>
        <see langword="true" /> if we are not guaranteed that the NHibernate collection wrapper
            is being used.
            </value>
      <remarks>
            This is typically <see langword="false" /> whenever a transient object that contains a collection is being
            associated with an <see cref="T:NHibernate.ISession" /> through <see cref="M:NHibernate.ISession.Save(System.Object)" /> or <see cref="M:NHibernate.ISession.SaveOrUpdate(System.Object)" />.
            NHibernate can't guarantee that it will know about all operations that would cause NHibernate's collections
            to call <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Read" /> or <see cref="M:NHibernate.Collection.AbstractPersistentCollection.Write" />.
            </remarks>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.WasInitialized">
      <summary> Is this instance initialized?</summary>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.HasQueuedOperations">
      <summary> Does this instance have any "queued" additions?</summary>
    </member>
    <member name="P:NHibernate.Collection.AbstractPersistentCollection.QueuedAdditionIterator">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Collection.PersistentBag">
      <summary>
            An unordered, unkeyed collection that can contain the same element
            multiple times. The .NET collections API has no Bag class.
            Most developers seem to use <see cref="T:System.Collections.IList" />s to represent bag semantics,
            so NHibernate follows this practice.
            </summary>
    </member>
    <member name="M:NHibernate.Collection.PersistentBag.CountOccurrences(System.Object,System.Collections.IList,NHibernate.Type.IType,NHibernate.EntityMode)">
      <summary>
            Counts the number of times that the <paramref name="element" /> occurs
            in the <paramref name="list" />.
            </summary>
      <param name="element">The element to find in the list.</param>
      <param name="list">The <see cref="T:System.Collections.IList" /> to search.</param>
      <param name="elementType">The <see cref="T:NHibernate.Type.IType" /> that can determine equality.</param>
      <param name="entityMode">The entity mode.</param>
      <returns>
            The number of occurrences of the element in the list.
            </returns>
    </member>
    <member name="M:NHibernate.Collection.PersistentBag.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
      <summary>
            Initializes this PersistentBag from the cached values.
            </summary>
      <param name="persister">The CollectionPersister to use to reassemble the PersistentBag.</param>
      <param name="disassembled">The disassembled PersistentBag.</param>
      <param name="owner">The owner object.</param>
    </member>
    <member name="M:NHibernate.Collection.PersistentBag.NeedsRecreate(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Gets a <see cref="T:System.Boolean" /> indicating if this PersistentBag needs to be recreated
            in the database.
            </summary>
      <param name="persister">
      </param>
      <returns>
        <see langword="false" /> if this is a <c>one-to-many</c> Bag, <see langword="true" /> if this is not
            a <c>one-to-many</c> Bag.  Since a Bag is an unordered, unindexed collection 
            that permits duplicates it is not possible to determine what has changed in a
            <c>many-to-many</c> so it is just recreated.
            </returns>
    </member>
    <member name="T:NHibernate.Collection.Generic.PersistentGenericBag`1">
      <summary>
            An unordered, unkeyed collection that can contain the same element
            multiple times. The .NET collections API, has no <c>Bag</c>.
            Most developers seem to use <see cref="T:System.Collections.Generic.IList`1" /> to represent bag semantics,
            so NHibernate follows this practice.
            </summary>
      <typeparam name="T">The type of the element the bag should hold.</typeparam>
      <remarks>The underlying collection used is an <see cref="T:System.Collections.Generic.List`1" /></remarks>
    </member>
    <member name="T:NHibernate.Collection.PersistentIdentifierBag">
      <summary>
            Implements "bag" semantics more efficiently than a regular <see cref="T:NHibernate.Collection.PersistentBag" />
            by adding a synthetic identifier column to the table.
            </summary>
      <remarks>
        <para>
            The identifier is unique for all rows in the table, allowing very efficient
            updates and deletes. The value of the identifier is never exposed to the 
            application. 
            </para>
        <para>
            PersistentIdentifierBags may not be used for a many-to-one association.
            Furthermore, there is no reason to use <c>inverse="true"</c>.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Collection.PersistentIdentifierBag.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
      <summary>
            Initializes this Bag from the cached values.
            </summary>
      <param name="persister">The CollectionPersister to use to reassemble the PersistentIdentifierBag.</param>
      <param name="disassembled">The disassembled PersistentIdentifierBag.</param>
      <param name="owner">The owner object.</param>
    </member>
    <member name="T:NHibernate.Collection.Generic.PersistentIdentifierBag`1">
      <summary>
            Implements "bag" semantics more efficiently than <see cref="T:NHibernate.Collection.PersistentBag" /> by adding
            a synthetic identifier column to the table.
            </summary>
      <remarks>
        <para>
            The identifier is unique for all rows in the table, allowing very efficient
            updates and deletes.  The value of the identifier is never exposed to the 
            application. 
            </para>
        <para>
            Identifier bags may not be used for a many-to-one association.  Furthermore,
            there is no reason to use <c>inverse="true"</c>.
            </para>
      </remarks>
    </member>
    <member name="T:NHibernate.Collection.PersistentList">
      <summary>
            A persistent wrapper for an <see cref="T:System.Collections.IList" /></summary>
      <remarks>
            The underlying collection used in an <see cref="T:System.Collections.ArrayList" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Collection.PersistentList.#ctor(NHibernate.Engine.ISessionImplementor)">
      <summary>
            Initializes an instance of the <see cref="T:NHibernate.Collection.PersistentList" />
            in the <paramref name="session" />.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> the list is in.</param>
    </member>
    <member name="M:NHibernate.Collection.PersistentList.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.IList)">
      <summary>
            Initializes an instance of the <see cref="T:NHibernate.Collection.PersistentList" />
            that wraps an existing <see cref="T:System.Collections.IList" /> in the <paramref name="session" />.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> the list is in.</param>
      <param name="list">The <see cref="T:System.Collections.IList" /> to wrap.</param>
    </member>
    <member name="M:NHibernate.Collection.PersistentList.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
      <summary>
            Initializes this PersistentList from the cached values.
            </summary>
      <param name="persister">The CollectionPersister to use to reassemble the PersistentList.</param>
      <param name="disassembled">The disassembled PersistentList.</param>
      <param name="owner">The owner object.</param>
    </member>
    <member name="T:NHibernate.Collection.Generic.PersistentGenericList`1">
      <summary>
            A persistent wrapper for an <see cref="T:System.Collections.Generic.IList`1" /></summary>
      <typeparam name="T">The type of the element the list should hold.</typeparam>
      <remarks>The underlying collection used is a <see cref="T:System.Collections.Generic.List`1" /></remarks>
    </member>
    <member name="T:NHibernate.Collection.PersistentMap">
      <summary>
            A persistent wrapper for a <see cref="T:System.Collections.IDictionary" />. Underlying collection
            is a <see cref="T:System.Collections.Hashtable" />.
            </summary>
    </member>
    <member name="M:NHibernate.Collection.PersistentMap.#ctor(NHibernate.Engine.ISessionImplementor)">
      <summary>
            Construct an uninitialized PersistentMap.
            </summary>
      <param name="session">The ISession the PersistentMap should be a part of.</param>
    </member>
    <member name="M:NHibernate.Collection.PersistentMap.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.IDictionary)">
      <summary>
            Construct an initialized PersistentMap based off the values from the existing IDictionary.
            </summary>
      <param name="session">The ISession the PersistentMap should be a part of.</param>
      <param name="map">The IDictionary that contains the initial values.</param>
    </member>
    <member name="M:NHibernate.Collection.PersistentMap.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
      <summary>
            Initializes this PersistentMap from the cached values.
            </summary>
      <param name="persister">The CollectionPersister to use to reassemble the PersistentMap.</param>
      <param name="disassembled">The disassembled PersistentMap.</param>
      <param name="owner">The owner object.</param>
    </member>
    <member name="T:NHibernate.Collection.Generic.PersistentGenericMap`2">
      <summary>
            A persistent wrapper for a <see cref="T:System.Collections.Generic.IDictionary`2" />.  Underlying
            collection is a <see cref="T:System.Collections.Generic.Dictionary`2" /></summary>
      <typeparam name="TKey">The type of the keys in the IDictionary.</typeparam>
      <typeparam name="TValue">The type of the elements in the IDictionary.</typeparam>
    </member>
    <member name="T:NHibernate.Collection.PersistentSet">
      <summary>
            .NET has no design equivalent for Java's Set so we are going to use the
            Iesi.Collections library. This class is internal to NHibernate and shouldn't
            be used by user code.
            </summary>
      <remarks>
            The code for the Iesi.Collections library was taken from the article
            <a href="http://www.codeproject.com/csharp/sets.asp">Add Support for "Set" Collections
            to .NET</a> that was written by JasonSmith.
            </remarks>
    </member>
    <member name="F:NHibernate.Collection.PersistentSet.set">
      <summary>
            The <see cref="T:Iesi.Collections.ISet" /> that NHibernate is wrapping.
            </summary>
    </member>
    <member name="F:NHibernate.Collection.PersistentSet.tempList">
      <summary>
            A temporary list that holds the objects while the PersistentSet is being
            populated from the database.  
            </summary>
      <remarks>
            This is necessary to ensure that the object being added to the PersistentSet doesn't
            have its' <c>GetHashCode()</c> and <c>Equals()</c> methods called during the load
            process.
            </remarks>
    </member>
    <member name="M:NHibernate.Collection.PersistentSet.#ctor(NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Constructor matching super.
            Instantiates a lazy set (the underlying set is un-initialized).
            </summary>
      <param name="session">The session to which this set will belong. </param>
    </member>
    <member name="M:NHibernate.Collection.PersistentSet.#ctor(NHibernate.Engine.ISessionImplementor,Iesi.Collections.ISet)">
      <summary> 
            Instantiates a non-lazy set (the underlying set is constructed
            from the incoming set reference).
            </summary>
      <param name="session">The session to which this set will belong. </param>
      <param name="original">The underlying set data. </param>
    </member>
    <member name="M:NHibernate.Collection.PersistentSet.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
      <summary>
            Initializes this PersistentSet from the cached values.
            </summary>
      <param name="persister">The CollectionPersister to use to reassemble the PersistentSet.</param>
      <param name="disassembled">The disassembled PersistentSet.</param>
      <param name="owner">The owner object.</param>
    </member>
    <member name="M:NHibernate.Collection.PersistentSet.BeginRead">
      <summary>
            Set up the temporary List that will be used in the EndRead() 
            to fully create the set.
            </summary>
    </member>
    <member name="M:NHibernate.Collection.PersistentSet.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Takes the contents stored in the temporary list created during <c>BeginRead()</c>
            that was populated during <c>ReadFrom()</c> and write it to the underlying 
            PersistentSet.
            </summary>
    </member>
    <member name="T:NHibernate.Collection.Generic.PersistentGenericSet`1">
      <summary>
            .NET has no design equivalent for Java's Set so we are going to use the
            Iesi.Collections library. This class is internal to NHibernate and shouldn't
            be used by user code.
            </summary>
      <remarks>
            The code for the Iesi.Collections library was taken from the article
            <a href="http://www.codeproject.com/csharp/sets.asp">Add Support for "Set" Collections
            to .NET</a> that was written by JasonSmith.
            </remarks>
    </member>
    <member name="T:NHibernate.Collection.PersistentArrayHolder">
      <summary>
            A persistent wrapper for an array. lazy initialization is NOT supported
            </summary>
      <remarks> Use of Hibernate arrays is not really recommended. </remarks>
    </member>
    <member name="F:NHibernate.Collection.PersistentArrayHolder.tempList">
      <summary>
            A temporary list that holds the objects while the PersistentArrayHolder is being
            populated from the database.
            </summary>
    </member>
    <member name="M:NHibernate.Collection.PersistentArrayHolder.GetValue">
      <summary>
            Returns the user-visible portion of the NHibernate PersistentArrayHolder.
            </summary>
      <returns>
            The array that contains the data, not the NHibernate wrapper.
            </returns>
    </member>
    <member name="M:NHibernate.Collection.PersistentArrayHolder.BeginRead">
      <summary>
            Before <see cref="M:NHibernate.Collection.PersistentArrayHolder.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)" /> is called the PersistentArrayHolder needs to setup 
            a temporary list to hold the objects.
            </summary>
    </member>
    <member name="M:NHibernate.Collection.PersistentArrayHolder.EndRead(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Takes the contents stored in the temporary list created during <see cref="M:NHibernate.Collection.PersistentArrayHolder.BeginRead" />
            that was populated during <see cref="M:NHibernate.Collection.PersistentArrayHolder.ReadFrom(System.Data.IDataReader,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Object)" /> and write it to the underlying 
            array.
            </summary>
    </member>
    <member name="M:NHibernate.Collection.PersistentArrayHolder.InitializeFromCache(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Object)">
      <summary>
            Initializes this array holder from the cached values.
            </summary>
      <param name="persister">The CollectionPersister to use to reassemble the Array.</param>
      <param name="disassembled">The disassembled Array.</param>
      <param name="owner">The owner object.</param>
    </member>
    <member name="P:NHibernate.Collection.PersistentArrayHolder.Array">
      <summary>
            Gets or sets the array.
            </summary>
      <value>The array.</value>
    </member>
    <member name="T:NHibernate.Connection.IConnectionProvider">
      <summary>
            A strategy for obtaining ADO.NET <see cref="T:System.Data.IDbConnection" />.
            </summary>
      <remarks>
            The <c>IConnectionProvider</c> interface is not intended to be exposed to the application.
            Instead it is used internally by NHibernate to obtain <see cref="T:System.Data.IDbConnection" />. 
            Implementors should provide a public default constructor.
            </remarks>
    </member>
    <member name="M:NHibernate.Connection.IConnectionProvider.Configure(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Initialize the connection provider from the given properties.
            </summary>
      <param name="settings">The connection provider settings</param>
    </member>
    <member name="M:NHibernate.Connection.IConnectionProvider.CloseConnection(System.Data.IDbConnection)">
      <summary>
            Dispose of a used <see cref="T:System.Data.IDbConnection" /></summary>
      <param name="conn">The <see cref="T:System.Data.IDbConnection" /> to clean up.</param>
    </member>
    <member name="M:NHibernate.Connection.IConnectionProvider.GetConnection">
      <summary>
            Get an open <see cref="T:System.Data.IDbConnection" />.
            </summary>
      <returns>An open <see cref="T:System.Data.IDbConnection" />.</returns>
    </member>
    <member name="P:NHibernate.Connection.IConnectionProvider.Driver">
      <summary>
            Gets the <see cref="T:NHibernate.Driver.IDriver" /> this ConnectionProvider should use to 
            communicate with the .NET Data Provider
            </summary>
      <value>
            The <see cref="T:NHibernate.Driver.IDriver" /> to communicate with the .NET Data Provider.
            </value>
    </member>
    <member name="T:NHibernate.Connection.ConnectionProvider">
      <summary>
            The base class for the ConnectionProvider.
            </summary>
    </member>
    <member name="F:NHibernate.Connection.ConnectionProvider._isAlreadyDisposed">
      <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
    </member>
    <member name="M:NHibernate.Connection.ConnectionProvider.CloseConnection(System.Data.IDbConnection)">
      <summary>
            Closes the <see cref="T:System.Data.IDbConnection" />.
            </summary>
      <param name="conn">The <see cref="T:System.Data.IDbConnection" /> to clean up.</param>
    </member>
    <member name="M:NHibernate.Connection.ConnectionProvider.Configure(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Configures the ConnectionProvider with the Driver and the ConnectionString.
            </summary>
      <param name="settings">An <see cref="T:System.Collections.IDictionary" /> that contains the settings for this ConnectionProvider.</param>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when a <see cref="F:NHibernate.Cfg.Environment.ConnectionString" /> could not be found 
            in the <c>settings</c> parameter or the Driver Class could not be loaded.
            </exception>
    </member>
    <member name="M:NHibernate.Connection.ConnectionProvider.GetNamedConnectionString(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Get the .NET 2.0 named connection string 
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when a <see cref="F:NHibernate.Cfg.Environment.ConnectionStringName" /> was found 
            in the <c>settings</c> parameter but could not be found in the app.config
            </exception>
    </member>
    <member name="M:NHibernate.Connection.ConnectionProvider.ConfigureDriver(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Configures the driver for the ConnectionProvider.
            </summary>
      <param name="settings">An <see cref="T:System.Collections.IDictionary" /> that contains the settings for the Driver.</param>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the <see cref="F:NHibernate.Cfg.Environment.ConnectionDriver" /> could not be 
            found in the <c>settings</c> parameter or there is a problem with creating
            the <see cref="T:NHibernate.Driver.IDriver" />.
            </exception>
    </member>
    <member name="M:NHibernate.Connection.ConnectionProvider.GetConnection">
      <summary>
            Get an open <see cref="T:System.Data.IDbConnection" />.
            </summary>
      <returns>An open <see cref="T:System.Data.IDbConnection" />.</returns>
    </member>
    <member name="M:NHibernate.Connection.ConnectionProvider.Finalize">
      <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
    </member>
    <member name="M:NHibernate.Connection.ConnectionProvider.Dispose">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
    </member>
    <member name="M:NHibernate.Connection.ConnectionProvider.Dispose(System.Boolean)">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
      <param name="isDisposing">Indicates if this ConnectionProvider is being Disposed of or Finalized.</param>
      <remarks>
        <p>
            If this ConnectionProvider is being Finalized (<c>isDisposing==false</c>) then make 
            sure not to call any methods that could potentially bring this 
            ConnectionProvider back to life.
            </p>
        <p>
            If any subclasses manage resources that also need to be disposed of this method
            should be overridden, but don't forget to call it in the override.
            </p>
      </remarks>
    </member>
    <member name="P:NHibernate.Connection.ConnectionProvider.ConnectionString">
      <summary>
            Gets the <see cref="T:System.String" /> for the <see cref="T:System.Data.IDbConnection" />
            to connect to the database.
            </summary>
      <value>
            The <see cref="T:System.String" /> for the <see cref="T:System.Data.IDbConnection" />
            to connect to the database.
            </value>
    </member>
    <member name="P:NHibernate.Connection.ConnectionProvider.Driver">
      <summary>
            Gets the <see cref="T:NHibernate.Driver.IDriver" /> that can create the <see cref="T:System.Data.IDbConnection" /> object.
            </summary>
      <value>
            The <see cref="T:NHibernate.Driver.IDriver" /> that can create the <see cref="T:System.Data.IDbConnection" />.
            </value>
    </member>
    <member name="T:NHibernate.Connection.ConnectionProviderFactory">
      <summary>
            Instanciates a connection provider given configuration properties.
            </summary>
    </member>
    <member name="T:NHibernate.Connection.DriverConnectionProvider">
      <summary>
            A ConnectionProvider that uses an IDriver to create connections.
            </summary>
    </member>
    <member name="M:NHibernate.Connection.DriverConnectionProvider.CloseConnection(System.Data.IDbConnection)">
      <summary>
            Closes and Disposes of the <see cref="T:System.Data.IDbConnection" />.
            </summary>
      <param name="conn">The <see cref="T:System.Data.IDbConnection" /> to clean up.</param>
    </member>
    <member name="M:NHibernate.Connection.DriverConnectionProvider.GetConnection">
      <summary>
            Gets a new open <see cref="T:System.Data.IDbConnection" /> through 
            the <see cref="T:NHibernate.Driver.IDriver" />.
            </summary>
      <returns>
            An Open <see cref="T:System.Data.IDbConnection" />.
            </returns>
      <exception cref="T:System.Exception">
            If there is any problem creating or opening the <see cref="T:System.Data.IDbConnection" />.
            </exception>
    </member>
    <member name="T:NHibernate.Connection.UserSuppliedConnectionProvider">
      <summary>
            An implementation of the <c>IConnectionProvider</c> that simply throws an exception when
            a connection is requested.
            </summary>
      <remarks>
            This implementation indicates that the user is expected to supply an ADO.NET connection
            </remarks>
    </member>
    <member name="M:NHibernate.Connection.UserSuppliedConnectionProvider.CloseConnection(System.Data.IDbConnection)">
      <summary>
            Throws an <see cref="T:System.InvalidOperationException" /> if this method is called
            because the user is responsible for closing <see cref="T:System.Data.IDbConnection" />s.
            </summary>
      <param name="conn">The <see cref="T:System.Data.IDbConnection" /> to clean up.</param>
      <exception cref="T:System.InvalidOperationException">
            Thrown when this method is called.  User is responsible for closing
            <see cref="T:System.Data.IDbConnection" />s.
            </exception>
    </member>
    <member name="M:NHibernate.Connection.UserSuppliedConnectionProvider.GetConnection">
      <summary>
            Throws an <see cref="T:System.InvalidOperationException" /> if this method is called
            because the user is responsible for creating <see cref="T:System.Data.IDbConnection" />s.
            </summary>
      <returns>
            No value is returned because an <see cref="T:System.InvalidOperationException" /> is thrown.
            </returns>
      <exception cref="T:System.InvalidOperationException">
            Thrown when this method is called.  User is responsible for creating
            <see cref="T:System.Data.IDbConnection" />s.
            </exception>
    </member>
    <member name="M:NHibernate.Connection.UserSuppliedConnectionProvider.Configure(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Configures the ConnectionProvider with only the Driver class.
            </summary>
      <param name="settings">
      </param>
      <remarks>
            All other settings of the Connection are the responsibility of the User since they configured
            NHibernate to use a Connection supplied by the User.
            </remarks>
    </member>
    <member name="T:NHibernate.Context.ICurrentSessionContext">
      <summary>
            Defines the contract for implementations which know how to
            scope the notion of a <see cref="M:NHibernate.ISessionFactory.GetCurrentSession">current session</see>.
            </summary>
      <remarks>
        <para>
            Implementations should adhere to the following:
            <list type="bullet"><item><description>contain a constructor accepting a single argument of type
            <see cref="T:NHibernate.Engine.ISessionFactoryImplementor" /></description></item><item><description>should be thread safe</description></item><item><description>should be fully serializable</description></item></list></para>
        <para>
            Implementors should be aware that they are also fully responsible for
            cleanup of any generated current-sessions.
            </para>
        <para>
            Note that there will be exactly one instance of the configured
            ICurrentSessionContext implementation per <see cref="T:NHibernate.ISessionFactory" />.
            </para>
        <para>
            It is recommended to inherit from the class <see cref="T:NHibernate.Context.CurrentSessionContext" />
            whenever possible as it simplifies the implementation and provides
            single entry point with session binding support.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Context.ICurrentSessionContext.CurrentSession">
      <summary>
            Retrieve the current session according to the scoping defined
            by this implementation.
            </summary>
      <returns>The current session.</returns>
      <exception cref="T:NHibernate.HibernateException">Typically indicates an issue
            locating or creating the current session.</exception>
    </member>
    <member name="T:NHibernate.Context.CurrentSessionContext">
      <summary>
            Extends the contract defined by <see cref="T:NHibernate.Context.ICurrentSessionContext" />
            by providing methods to bind and unbind sessions to the current context.
            </summary>
      <remarks>
            The notion of a contextual session is managed by some external entity
            (generally some form of interceptor like the HttpModule).
            This external manager is responsible for scoping these contextual sessions
            appropriately binding/unbinding them here for exposure to the application
            through <see cref="M:NHibernate.ISessionFactory.GetCurrentSession" /> calls.
            </remarks>
    </member>
    <member name="M:NHibernate.Context.CurrentSessionContext.CurrentSession">
      <summary>
            Retrieve the current session according to the scoping defined
            by this implementation.
            </summary>
      <returns>The current session.</returns>
      <exception cref="T:NHibernate.HibernateException">Indicates an issue
            locating the current session.</exception>
    </member>
    <member name="M:NHibernate.Context.CurrentSessionContext.Bind(NHibernate.ISession)">
      <summary>
            Binds the specified session to the current context.
            </summary>
    </member>
    <member name="M:NHibernate.Context.CurrentSessionContext.HasBind(NHibernate.ISessionFactory)">
      <summary>
            Returns whether there is a session bound to the current context.
            </summary>
    </member>
    <member name="M:NHibernate.Context.CurrentSessionContext.Unbind(NHibernate.ISessionFactory)">
      <summary>
            Unbinds and returns the current session.
            </summary>
    </member>
    <member name="P:NHibernate.Context.CurrentSessionContext.Session">
      <summary> Gets or sets the currently bound session. </summary>
    </member>
    <member name="M:NHibernate.Context.MapBasedSessionContext.GetMap">
      <summary>
            Get the dicitonary mapping session factory to its current session.
            </summary>
    </member>
    <member name="M:NHibernate.Context.MapBasedSessionContext.SetMap(System.Collections.IDictionary)">
      <summary>
            Set the map mapping session factory to its current session.
            </summary>
    </member>
    <member name="P:NHibernate.Context.MapBasedSessionContext.Session">
      <summary>
            Gets or sets the currently bound session.
            </summary>
    </member>
    <member name="T:NHibernate.Context.CallSessionContext">
      <summary>
            Provides a <see cref="M:NHibernate.ISessionFactory.GetCurrentSession">current session</see>
            for each <see cref="T:System.Runtime.Remoting.Messaging.CallContext" />.
            Not recommended for .NET 2.0 web applications.
            </summary>
    </member>
    <member name="M:NHibernate.Context.CallSessionContext.SetMap(System.Collections.IDictionary)">
      <summary>
            The key is the session factory and the value is the bound session.
            </summary>
    </member>
    <member name="M:NHibernate.Context.CallSessionContext.GetMap">
      <summary>
            The key is the session factory and the value is the bound session.
            </summary>
    </member>
    <member name="T:NHibernate.Context.ManagedWebSessionContext">
      <summary>
            Provides a <see cref="M:NHibernate.ISessionFactory.GetCurrentSession">current session</see>
            for each <see cref="T:System.Web.HttpContext" />.
            Works only with Web Applications.
            </summary>
    </member>
    <member name="T:NHibernate.Context.ThreadLocalSessionContext">
      <summary>
            A <see cref="T:NHibernate.Context.ICurrentSessionContext" /> impl which scopes the notion of current
            session by the current thread of execution. Threads do not give us a 
            nice hook to perform any type of cleanup making
            it questionable for this impl to actually generate Session instances.  In
            the interest of usability, it was decided to have this default impl
            actually generate a session upon first request and then clean it up
            after the <see cref="T:NHibernate.ITransaction" /> associated with that session
            is committed/rolled-back.  In order for ensuring that happens, the sessions
            generated here are unusable until after {@link Session#beginTransaction()}
            has been called. If <tt>Close()</tt> is called on a session managed by
            this class, it will be automatically unbound.
            <p />
            Additionally, the static <see cref="M:NHibernate.Context.ThreadLocalSessionContext.Bind(NHibernate.ISession)" /> and <see cref="M:NHibernate.Context.ThreadLocalSessionContext.Unbind(NHibernate.ISessionFactory)" /> methods are
            provided to allow application code to explicitly control opening and
            closing of these sessions.  This, with some from of interception,
            is the preferred approach.  It also allows easy framework integration
            and one possible approach for implementing long-sessions.
            <p /></summary>
    </member>
    <member name="M:NHibernate.Context.ThreadLocalSessionContext.Unbind(NHibernate.ISessionFactory)">
      <summary>
            Unassociate a previously bound session from the current thread of execution.
            </summary>
      <param name="factory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Context.ThreadStaticSessionContext">
      <summary>
            Provides a <see cref="M:NHibernate.ISessionFactory.GetCurrentSession">current session</see>
            for each thread using the [<see cref="T:System.ThreadStaticAttribute" />].
            To avoid if there are two session factories in the same thread.
            </summary>
    </member>
    <member name="P:NHibernate.Context.ThreadStaticSessionContext.Session">
      <summary> Gets or sets the currently bound session. </summary>
    </member>
    <member name="T:NHibernate.Context.WebSessionContext">
      <summary>
            Provides a <see cref="M:NHibernate.ISessionFactory.GetCurrentSession">current session</see>
            for each <see cref="T:System.Web.HttpContext" />. Works only with web applications.
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.ICriterion">
      <summary>
            An object-oriented representation of a query criterion that may be used as a constraint
            in a <see cref="T:NHibernate.ICriteria" /> query.
            </summary>
      <remarks>
            Built-in criterion types are provided by the <c>Expression</c> factory class.
            This interface might be implemented by application classes but, more commonly, application 
            criterion types would extend <c>AbstractCriterion</c>.
            </remarks>
    </member>
    <member name="M:NHibernate.Criterion.ICriterion.ToSqlString(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
      <summary>
            Render a SqlString fragment for the expression.
            </summary>
      <returns>A SqlString that contains a valid Sql fragment.</returns>
    </member>
    <member name="M:NHibernate.Criterion.ICriterion.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
            Return typed values for all parameters in the rendered SQL fragment
            </summary>
      <returns>An array of TypedValues for the Expression.</returns>
    </member>
    <member name="M:NHibernate.Criterion.ICriterion.GetProjections">
      <summary>
            Return all projections used in this criterion
            </summary>
      <returns>An array of IProjection used by the Expression.</returns>
    </member>
    <member name="T:NHibernate.Criterion.AbstractCriterion">
      <summary>
            Base class for <see cref="T:NHibernate.Criterion.ICriterion" /> implementations.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.AbstractCriterion.ToString">
      <summary>
            Gets a string representation of the <see cref="T:NHibernate.Criterion.AbstractCriterion" />.  
            </summary>
      <returns>
            A String that shows the contents of the <see cref="T:NHibernate.Criterion.AbstractCriterion" />.
            </returns>
      <remarks>
            This is not a well formed Sql fragment.  It is useful for logging what the <see cref="T:NHibernate.Criterion.AbstractCriterion" />
            looks like.
            </remarks>
    </member>
    <member name="M:NHibernate.Criterion.AbstractCriterion.ToSqlString(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
      <summary>
            Render a SqlString for the expression.
            </summary>
      <returns>A SqlString that contains a valid Sql fragment.</returns>
    </member>
    <member name="M:NHibernate.Criterion.AbstractCriterion.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
            Return typed values for all parameters in the rendered SQL fragment
            </summary>
      <returns>An array of TypedValues for the Expression.</returns>
    </member>
    <member name="M:NHibernate.Criterion.AbstractCriterion.GetProjections">
      <summary>
            Return all projections used in this criterion
            </summary>
      <returns>An array of IProjection used by the Expression.</returns>
    </member>
    <member name="M:NHibernate.Criterion.AbstractCriterion.op_False(NHibernate.Criterion.AbstractCriterion)">
      <summary>
            See here for details:
            http://steve.emxsoftware.com/NET/Overloading+the++and++operators
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.AbstractCriterion.op_True(NHibernate.Criterion.AbstractCriterion)">
      <summary>
            See here for details:
            http://steve.emxsoftware.com/NET/Overloading+the++and++operators
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.AbstractEmptinessExpression.op_False(NHibernate.Criterion.AbstractEmptinessExpression)">
      <summary>
            See here for details:
            http://steve.emxsoftware.com/NET/Overloading+the++and++operators
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.AbstractEmptinessExpression.op_True(NHibernate.Criterion.AbstractEmptinessExpression)">
      <summary>
            See here for details:
            http://steve.emxsoftware.com/NET/Overloading+the++and++operators
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.IProjection.ToSqlString(NHibernate.ICriteria,System.Int32,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
      <summary>
            Render the SQL Fragment.
            </summary>
      <param name="criteria">The criteria.</param>
      <param name="position">The position.</param>
      <param name="criteriaQuery">The criteria query.</param>
      <param name="enabledFilters">The enabled filters.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.IProjection.ToGroupSqlString(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
      <summary>
            Render the SQL Fragment to be used in the Group By Clause.
            </summary>
      <param name="criteria">The criteria.</param>
      <param name="criteriaQuery">The criteria query.</param>
      <param name="enabledFilters">The enabled filters.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.IProjection.GetTypes(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
            Return types for a particular user-visible alias
            </summary>
      <param name="criteria">
      </param>
      <param name="criteriaQuery">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.IProjection.GetTypes(System.String,NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
      </summary>
      <param name="alias">
      </param>
      <param name="criteria">
      </param>
      <param name="criteriaQuery">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.IProjection.GetColumnAliases(System.Int32)">
      <summary>
            Get the SQL select clause column aliases for a particular user-visible alias
            </summary>
      <param name="loc">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.IProjection.GetColumnAliases(System.String,System.Int32)">
      <summary>
            Get the SQL select clause column aliases for a particular user-visible alias
            </summary>
      <param name="alias">
      </param>
      <param name="loc">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.IProjection.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
            Gets the typed values for parameters in this projection
            </summary>
      <param name="criteria">The criteria.</param>
      <param name="criteriaQuery">The criteria query.</param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Criterion.IProjection.Aliases">
      <summary>
            Get the user-visible aliases for this projection (ie. the ones that will be passed to the ResultTransformer)
            </summary>
    </member>
    <member name="P:NHibernate.Criterion.IProjection.IsGrouped">
      <summary>
            Does this projection specify grouping attributes?
            </summary>
    </member>
    <member name="P:NHibernate.Criterion.IProjection.IsAggregate">
      <summary>
            Does this projection specify aggregate attributes?
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.SimpleProjection">
      <summary>
            A single-column projection that may be aliased
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.SimpleProjection.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
            Gets the typed values for parameters in this projection
            </summary>
      <param name="criteria">The criteria.</param>
      <param name="criteriaQuery">The criteria query.</param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Criterion.AggregateProjection">
      <summary>
            An Aggregation
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.AliasedProjection.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
            Gets the typed values for parameters in this projection
            </summary>
      <param name="criteria">The criteria.</param>
      <param name="criteriaQuery">The criteria query.</param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Criterion.LogicalExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that combines two <see cref="T:NHibernate.Criterion.ICriterion" />s 
            with a operator (either "<c>and</c>" or "<c>or</c>") between them.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.LogicalExpression.#ctor(NHibernate.Criterion.ICriterion,NHibernate.Criterion.ICriterion)">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.LogicalExpression" /> class that
            combines two other <see cref="T:NHibernate.Criterion.ICriterion" />s.
            </summary>
      <param name="lhs">The <see cref="T:NHibernate.Criterion.ICriterion" /> to use in the Left Hand Side.</param>
      <param name="rhs">The <see cref="T:NHibernate.Criterion.ICriterion" /> to use in the Right Hand Side.</param>
    </member>
    <member name="M:NHibernate.Criterion.LogicalExpression.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
            Combines the <see cref="T:NHibernate.Engine.TypedValue" /> for the Left Hand Side and the 
            Right Hand Side of the Expression into one array.
            </summary>
      <returns>An array of <see cref="T:NHibernate.Engine.TypedValue" />s.</returns>
    </member>
    <member name="M:NHibernate.Criterion.LogicalExpression.ToSqlString(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
      <summary>
            Converts the LogicalExpression to a <see cref="T:NHibernate.SqlCommand.SqlString" />.
            </summary>
      <returns>A well formed SqlString for the Where clause.</returns>
      <remarks>The SqlString will be enclosed by <c>(</c> and <c>)</c>.</remarks>
    </member>
    <member name="M:NHibernate.Criterion.LogicalExpression.ToString">
      <summary>
            Gets a string representation of the LogicalExpression.  
            </summary>
      <returns>
            The String contains the LeftHandSide.ToString() and the RightHandSide.ToString()
            joined by the Op.
            </returns>
      <remarks>
            This is not a well formed Sql fragment.  It is useful for logging what Expressions
            are being combined.
            </remarks>
    </member>
    <member name="P:NHibernate.Criterion.LogicalExpression.LeftHandSide">
      <summary>
            Gets the <see cref="T:NHibernate.Criterion.ICriterion" /> that will be on the Left Hand Side of the Op.
            </summary>
    </member>
    <member name="P:NHibernate.Criterion.LogicalExpression.RightHandSide">
      <summary>
            Gets the <see cref="T:NHibernate.Criterion.ICriterion" /> that will be on the Right Hand Side of the Op.
            </summary>
    </member>
    <member name="P:NHibernate.Criterion.LogicalExpression.Op">
      <summary>
            Get the Sql operator to put between the two <see cref="T:NHibernate.Criterion.Expression" />s.
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.AndExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.LogicalExpression" /> that combines two <see cref="T:NHibernate.Criterion.ICriterion" />s 
            with an <c>and</c> between them.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.AndExpression.#ctor(NHibernate.Criterion.ICriterion,NHibernate.Criterion.ICriterion)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.AndExpression" /> class
            that combines two <see cref="T:NHibernate.Criterion.ICriterion" />.
            </summary>
      <param name="lhs">The <see cref="T:NHibernate.Criterion.ICriterion" /> to use as the left hand side.</param>
      <param name="rhs">The <see cref="T:NHibernate.Criterion.ICriterion" /> to use as the right hand side.</param>
    </member>
    <member name="P:NHibernate.Criterion.AndExpression.Op">
      <summary>
            Get the Sql operator to put between the two <see cref="T:NHibernate.Criterion.ICriterion" />s.
            </summary>
      <value>The string "<c>and</c>"</value>
    </member>
    <member name="T:NHibernate.Criterion.BetweenExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that represents a "between" constraint.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.BetweenExpression.#ctor(NHibernate.Criterion.IProjection,System.Object,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.BetweenExpression" /> class.
            </summary>
      <param name="_projection">The _projection.</param>
      <param name="_lo">The _lo.</param>
      <param name="_hi">The _hi.</param>
    </member>
    <member name="M:NHibernate.Criterion.BetweenExpression.#ctor(System.String,System.Object,System.Object)">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.BetweenExpression" /> class for
            the named Property.
            </summary>
      <param name="propertyName">The name of the Property of the Class.</param>
      <param name="lo">The low value for the BetweenExpression.</param>
      <param name="hi">The high value for the BetweenExpression.</param>
    </member>
    <member name="M:NHibernate.Criterion.BetweenExpression.ToString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Criterion.CastProjection">
      <summary>
            Casting a value from one type to another, at the database
            level
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.Junction">
      <summary>
            A sequence of logical <see cref="T:NHibernate.Criterion.ICriterion" />s combined by some associative
            logical operator.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.Junction.Add(NHibernate.Criterion.ICriterion)">
      <summary>
            Adds an <see cref="T:NHibernate.Criterion.ICriterion" /> to the list of <see cref="T:NHibernate.Criterion.ICriterion" />s
            to junction together.
            </summary>
      <param name="criterion">The <see cref="T:NHibernate.Criterion.ICriterion" /> to add.</param>
      <returns>
            This <see cref="T:NHibernate.Criterion.Junction" /> instance.
            </returns>
    </member>
    <member name="P:NHibernate.Criterion.Junction.Op">
      <summary>
            Get the Sql operator to put between multiple <see cref="T:NHibernate.Criterion.ICriterion" />s.
            </summary>
    </member>
    <member name="P:NHibernate.Criterion.Junction.EmptyExpression">
      <summary>
            The <see cref="T:NHibernate.SqlCommand.SqlString" /> corresponding to an instance with no added
            subcriteria.
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.Conjunction">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that Junctions together multiple 
            <see cref="T:NHibernate.Criterion.ICriterion" />s with an <c>and</c></summary>
    </member>
    <member name="P:NHibernate.Criterion.Conjunction.Op">
      <summary>
            Get the Sql operator to put between multiple <see cref="T:NHibernate.Criterion.ICriterion" />s.
            </summary>
      <value>The string "<c> and </c>"</value>
    </member>
    <member name="T:NHibernate.Criterion.ConstantProjection">
      <summary>
            This is useful if we want to send a value to the database
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.CountProjection">
      <summary>
            A Count
            </summary>
    </member>
    <member name="F:NHibernate.Criterion.CriteriaSpecification.RootAlias">
      <summary> The alias that refers to the "root" entity of the criteria query.</summary>
    </member>
    <member name="F:NHibernate.Criterion.CriteriaSpecification.AliasToEntityMap">
      <summary> Each row of results is a <see cref="T:System.Collections.IDictionary" /> from alias to entity instance</summary>
    </member>
    <member name="F:NHibernate.Criterion.CriteriaSpecification.RootEntity">
      <summary> Each row of results is an instance of the root entity</summary>
    </member>
    <member name="F:NHibernate.Criterion.CriteriaSpecification.DistinctRootEntity">
      <summary> Each row of results is a distinct instance of the root entity</summary>
    </member>
    <member name="F:NHibernate.Criterion.CriteriaSpecification.Projection">
      <summary> This result transformer is selected implicitly by calling <see cref="M:NHibernate.ICriteria.SetProjection(NHibernate.Criterion.IProjection[])" /></summary>
    </member>
    <member name="F:NHibernate.Criterion.CriteriaSpecification.InnerJoin">
      <summary> Specifies joining to an entity based on an inner join.</summary>
    </member>
    <member name="F:NHibernate.Criterion.CriteriaSpecification.FullJoin">
      <summary> Specifies joining to an entity based on a full join.</summary>
    </member>
    <member name="F:NHibernate.Criterion.CriteriaSpecification.LeftJoin">
      <summary> Specifies joining to an entity based on a left outer join.</summary>
    </member>
    <member name="T:NHibernate.Criterion.DetachedCriteria">
      <summary>
            Some applications need to create criteria queries in "detached
            mode", where the Hibernate session is not available. This class
            may be instantiated anywhere, and then a <c>ICriteria</c>
            may be obtained by passing a session to 
            <c>GetExecutableCriteria()</c>. All methods have the
            same semantics and behavior as the corresponding methods of the
            <c>ICriteria</c> interface.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.DetachedCriteria.GetExecutableCriteria(NHibernate.ISession)">
      <summary>
            Get an executable instance of <c>Criteria</c>,
            to actually run the query.</summary>
    </member>
    <member name="M:NHibernate.Criterion.DetachedCriteria.GetRootEntityTypeIfAvailable">
      <summary>
            Gets the root entity type if available, throws otherwise
            </summary>
      <remarks>
            This is an NHibernate specific method, used by several dependent 
            frameworks for advance integration with NHibernate.
            </remarks>
    </member>
    <member name="M:NHibernate.Criterion.DetachedCriteria.ClearOrders">
      <summary>
            Clear all orders from criteria.
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.Disjunction">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that Junctions together multiple 
            <see cref="T:NHibernate.Criterion.ICriterion" />s with an <c>or</c></summary>
    </member>
    <member name="P:NHibernate.Criterion.Disjunction.Op">
      <summary>
            Get the Sql operator to put between multiple <see cref="T:NHibernate.Criterion.ICriterion" />s.
            </summary>
      <value>The string "<c> or </c>"</value>
    </member>
    <member name="M:NHibernate.Criterion.Distinct.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
            Gets the typed values for parameters in this projection
            </summary>
      <param name="criteria">The criteria.</param>
      <param name="criteriaQuery">The criteria query.</param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Criterion.PropertyExpression">
      <summary>
            Superclass for an <see cref="T:NHibernate.Criterion.ICriterion" /> that represents a
            constraint between two properties (with SQL binary operators).
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.PropertyExpression.#ctor(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.PropertyExpression" /> class.
            </summary>
      <param name="lhsProjection">The projection.</param>
      <param name="rhsPropertyName">Name of the RHS property.</param>
    </member>
    <member name="M:NHibernate.Criterion.PropertyExpression.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.PropertyExpression" /> class.
            </summary>
      <param name="lhsProjection">The LHS projection.</param>
      <param name="rhsProjection">The RHS projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.PropertyExpression.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.PropertyExpression" /> class.
            </summary>
      <param name="lhsPropertyName">Name of the LHS property.</param>
      <param name="rhsPropertyName">Name of the RHS property.</param>
    </member>
    <member name="M:NHibernate.Criterion.PropertyExpression.#ctor(System.String,NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.PropertyExpression" /> class.
            </summary>
      <param name="lhsPropertyName">Name of the LHS property.</param>
      <param name="rhsProjection">The RHS projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.PropertyExpression.ToString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Criterion.PropertyExpression.Op">
      <summary>
            Get the Sql operator to use for the property expression.
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.EqPropertyExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that represents an "equal" constraint 
            between two properties.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.EqPropertyExpression.#ctor(System.String,NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.EqPropertyExpression" /> class.
            </summary>
      <param name="lhsPropertyName">Name of the LHS property.</param>
      <param name="rhsProjection">The RHS projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.EqPropertyExpression.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.EqPropertyExpression" /> class.
            </summary>
      <param name="lhsProjection">The LHS projection.</param>
      <param name="rhsProjection">The RHS projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.EqPropertyExpression.#ctor(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.EqPropertyExpression" /> class.
            </summary>
      <param name="lhsProjection">The projection.</param>
      <param name="rhsPropertyName">Name of the RHS property.</param>
    </member>
    <member name="M:NHibernate.Criterion.EqPropertyExpression.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.EqPropertyExpression" /> class
            that compares two mapped properties using an "equal" constraint.
            </summary>
      <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
      <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
    </member>
    <member name="P:NHibernate.Criterion.EqPropertyExpression.Op">
      <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Criterion.EqPropertyExpression" />.
            </summary>
      <value>The string "<c> = </c>"</value>
    </member>
    <member name="T:NHibernate.Criterion.Example">
      <summary>
            Support for <c>Query By Example</c>.
            </summary>
      <example>
        <code>
            List results = session.CreateCriteria(typeof(Parent))
            .Add( Example.Create(parent).IgnoreCase() )
            .CreateCriteria("child")
            .Add( Example.Create( parent.Child ) )
            .List();
            </code>
      </example>
      <remarks>
            "Examples" may be mixed and matched with "Expressions" in the same <see cref="T:NHibernate.ICriteria" /></remarks>
      <seealso cref="T:NHibernate.ICriteria" />
    </member>
    <member name="T:NHibernate.Criterion.Example.IPropertySelector">
      <summary>
            A strategy for choosing property values for inclusion in the query criteria
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.Example.IPropertySelector.Include(System.Object,System.String,NHibernate.Type.IType)">
      <summary>
            Determine if the Property should be included.
            </summary>
      <param name="propertyValue">The value of the property that is being checked for inclusion.</param>
      <param name="propertyName">The name of the property that is being checked for inclusion.</param>
      <param name="type">The <see cref="T:NHibernate.Type.IType" /> of the property.</param>
      <returns>
        <see langword="true" /> if the Property should be included in the Query, 
            <see langword="false" /> otherwise.
            </returns>
    </member>
    <member name="T:NHibernate.Criterion.Example.AllPropertySelector">
      <summary>
            Implementation of <see cref="T:NHibernate.Criterion.Example.IPropertySelector" /> that includes all
            properties regardless of value.
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.Example.NotNullOrEmptyStringPropertySelector">
      <summary>
            Implementation of <see cref="T:NHibernate.Criterion.Example.IPropertySelector" /> that includes the
            properties that are not <see langword="null" /> and do not have an <see cref="F:System.String.Empty" />
            returned by <c>propertyValue.ToString()</c>.
            </summary>
      <remarks>
            This selector is not present in H2.1. It may be useful if nullable types
            are used for some properties.
            </remarks>
    </member>
    <member name="M:NHibernate.Criterion.Example.SetEscapeCharacter(System.Nullable{System.Char})">
      <summary> Set escape character for "like" clause</summary>
    </member>
    <member name="M:NHibernate.Criterion.Example.SetPropertySelector(NHibernate.Criterion.Example.IPropertySelector)">
      <summary>
            Set the <see cref="T:NHibernate.Criterion.Example.IPropertySelector" /> for this <see cref="T:NHibernate.Criterion.Example" />.
            </summary>
      <param name="selector">The <see cref="T:NHibernate.Criterion.Example.IPropertySelector" /> to determine which properties to include.</param>
      <returns>This <see cref="T:NHibernate.Criterion.Example" /> instance.</returns>
      <remarks>
            This should be used when a custom <see cref="T:NHibernate.Criterion.Example.IPropertySelector" /> has
            been implemented.  Otherwise use the methods <see cref="M:NHibernate.Criterion.Example.ExcludeNulls" /> 
            or <see cref="M:NHibernate.Criterion.Example.ExcludeNone" /> to set the <see cref="T:NHibernate.Criterion.Example.IPropertySelector" />
            to the <see cref="T:NHibernate.Criterion.Example.IPropertySelector" />s built into NHibernate.
            </remarks>
    </member>
    <member name="M:NHibernate.Criterion.Example.ExcludeZeroes">
      <summary>
            Set the <see cref="T:NHibernate.Criterion.Example.IPropertySelector" /> for this <see cref="T:NHibernate.Criterion.Example" />
            to exclude zero-valued properties.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.Example.ExcludeNone">
      <summary>
            Set the <see cref="T:NHibernate.Criterion.Example.IPropertySelector" /> for this <see cref="T:NHibernate.Criterion.Example" />
            to exclude no properties.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.Example.EnableLike(NHibernate.Criterion.MatchMode)">
      <summary>
            Use the "like" operator for all string-valued properties with
            the specified <see cref="T:NHibernate.Criterion.MatchMode" />.
            </summary>
      <param name="matchMode">
            The <see cref="T:NHibernate.Criterion.MatchMode" /> to convert the string to the pattern
            for the <c>like</c> comparison.
            </param>
    </member>
    <member name="M:NHibernate.Criterion.Example.EnableLike">
      <summary>
            Use the "like" operator for all string-valued properties.
            </summary>
      <remarks>
            The default <see cref="T:NHibernate.Criterion.MatchMode" /> is <see cref="F:NHibernate.Criterion.MatchMode.Exact">MatchMode.Exact</see>.
            </remarks>
    </member>
    <member name="M:NHibernate.Criterion.Example.ExcludeProperty(System.String)">
      <summary>
            Exclude a particular named property
            </summary>
      <param name="name">The name of the property to exclude.</param>
    </member>
    <member name="M:NHibernate.Criterion.Example.Create(System.Object)">
      <summary>
            Create a new instance, which includes all non-null properties 
            by default
            </summary>
      <param name="entity">
      </param>
      <returns>A new instance of <see cref="T:NHibernate.Criterion.Example" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Example.#ctor(System.Object,NHibernate.Criterion.Example.IPropertySelector)">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.Example" /> class for a particular
            entity.
            </summary>
      <param name="entity">The <see cref="T:System.Object" /> that the Example is being built from.</param>
      <param name="selector">The <see cref="T:NHibernate.Criterion.Example.IPropertySelector" /> the Example should use.</param>
    </member>
    <member name="M:NHibernate.Criterion.Example.IsPropertyIncluded(System.Object,System.String,NHibernate.Type.IType)">
      <summary>
            Determines if the property should be included in the Query.
            </summary>
      <param name="value">The value of the property.</param>
      <param name="name">The name of the property.</param>
      <param name="type">The <see cref="T:NHibernate.Type.IType" /> of the property.</param>
      <returns>
        <see langword="true" /> if the Property should be included, <see langword="false" /> if
            the Property should not be a part of the Query.
            </returns>
    </member>
    <member name="M:NHibernate.Criterion.Example.AddPropertyTypedValue(System.Object,NHibernate.Type.IType,System.Collections.IList)">
      <summary>
            Adds a <see cref="T:NHibernate.Engine.TypedValue" /> based on the <c>value</c> 
            and <c>type</c> parameters to the <see cref="T:System.Collections.IList" /> in the
            <c>list</c> parameter.
            </summary>
      <param name="value">The value of the Property.</param>
      <param name="type">The <see cref="T:NHibernate.Type.IType" /> of the Property.</param>
      <param name="list">The <see cref="T:System.Collections.IList" /> to add the <see cref="T:NHibernate.Engine.TypedValue" /> to.</param>
      <remarks>
            This method will add <see cref="T:NHibernate.Engine.TypedValue" /> objects to the <c>list</c> parameter.
            </remarks>
    </member>
    <member name="T:NHibernate.Criterion.Restrictions">
      <summary> 
            The <see cref="N:NHibernate.Criterion" /> namespace may be used by applications as a framework for building
            new kinds of <see cref="T:NHibernate.Criterion.ICriterion" />. 
            However, it is intended that most applications will
            simply use the built-in criterion types via the static factory methods of this class.
            </summary>
      <seealso cref="T:NHibernate.ICriteria" />
      <seealso cref="T:NHibernate.Criterion.Projections" />
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.IdEq(System.Object)">
      <summary>
            Apply an "equal" constraint to the identifier property
            </summary>
      <param name="value">
      </param>
      <returns>ICriterion</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.IdEq(NHibernate.Criterion.IProjection)">
      <summary>
            Apply an "equal" constraint from the projection to the identifier property
            </summary>
      <param name="projection">The projection.</param>
      <returns>ICriterion</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Eq(System.String,System.Object)">
      <summary>
            Apply an "equal" constraint to the named property
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="value">The value for the Property.</param>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Eq(NHibernate.Criterion.IProjection,System.Object)">
      <summary>
            Apply an "equal" constraint to the projection
            </summary>
      <param name="projection">The projection.</param>
      <param name="value">The value for the Property.</param>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Like(System.String,System.Object)">
      <summary>
            Apply a "like" constraint to the named property
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="value">The value for the Property.</param>
      <returns>A <see cref="T:NHibernate.Criterion.LikeExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Like(NHibernate.Criterion.IProjection,System.Object)">
      <summary>
            Apply a "like" constraint to the project
            </summary>
      <param name="projection">The projection.</param>
      <param name="value">The value for the Property.</param>
      <returns>A <see cref="T:NHibernate.Criterion.LikeExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Like(NHibernate.Criterion.IProjection,System.String,NHibernate.Criterion.MatchMode)">
      <summary>
            Apply a "like" constraint to the project
            </summary>
      <param name="projection">The projection.</param>
      <param name="value">The value for the Property.</param>
      <param name="matchMode">The match mode.</param>
      <returns>A <see cref="T:NHibernate.Criterion.LikeExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.InsensitiveLike(System.String,System.Object)">
      <summary>
            A case-insensitive "like", similar to Postgres "ilike" operator
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="value">The value for the Property.</param>
      <returns>An <see cref="T:NHibernate.Criterion.InsensitiveLikeExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.InsensitiveLike(NHibernate.Criterion.IProjection,System.Object)">
      <summary>
            A case-insensitive "like", similar to Postgres "ilike" operator
            </summary>
      <param name="projection">The projection.</param>
      <param name="value">The value for the Property.</param>
      <returns>
            An <see cref="T:NHibernate.Criterion.InsensitiveLikeExpression" />.
            </returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Gt(System.String,System.Object)">
      <summary>
            Apply a "greater than" constraint to the named property
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="value">The value for the Property.</param>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Gt(NHibernate.Criterion.IProjection,System.Object)">
      <summary>
            Apply a "greater than" constraint to the projection
            </summary>
      <param name="projection">The projection.</param>
      <param name="value">The value for the Property.</param>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Lt(System.String,System.Object)">
      <summary>
            Apply a "less than" constraint to the named property
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="value">The value for the Property.</param>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Lt(NHibernate.Criterion.IProjection,System.Object)">
      <summary>
            Apply a "less than" constraint to the projection
            </summary>
      <param name="projection">The projection.</param>
      <param name="value">The value for the Property.</param>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Le(System.String,System.Object)">
      <summary>
            Apply a "less than or equal" constraint to the named property
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="value">The value for the Property.</param>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Le(NHibernate.Criterion.IProjection,System.Object)">
      <summary>
            Apply a "less than or equal" constraint to the projection
            </summary>
      <param name="projection">The projection.</param>
      <param name="value">The value for the Property.</param>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Ge(System.String,System.Object)">
      <summary>
            Apply a "greater than or equal" constraint to the named property
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="value">The value for the Property.</param>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Ge(NHibernate.Criterion.IProjection,System.Object)">
      <summary>
            Apply a "greater than or equal" constraint to the projection
            </summary>
      <param name="projection">The projection.</param>
      <param name="value">The value for the Property.</param>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Between(System.String,System.Object,System.Object)">
      <summary>
            Apply a "between" constraint to the named property
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="lo">The low value for the Property.</param>
      <param name="hi">The high value for the Property.</param>
      <returns>A <see cref="T:NHibernate.Criterion.BetweenExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Between(NHibernate.Criterion.IProjection,System.Object,System.Object)">
      <summary>
            Apply a "between" constraint to the projection
            </summary>
      <param name="projection">The projection.</param>
      <param name="lo">The low value for the Property.</param>
      <param name="hi">The high value for the Property.</param>
      <returns>A <see cref="T:NHibernate.Criterion.BetweenExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.In(System.String,System.Object[])">
      <summary>
            Apply an "in" constraint to the named property 
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="values">An array of values.</param>
      <returns>An <see cref="T:NHibernate.Criterion.InExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.In(NHibernate.Criterion.IProjection,System.Object[])">
      <summary>
            Apply an "in" constraint to the projection
            </summary>
      <param name="projection">The projection.</param>
      <param name="values">An array of values.</param>
      <returns>An <see cref="T:NHibernate.Criterion.InExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.In(NHibernate.Criterion.IProjection,System.Collections.ICollection)">
      <summary>
            Apply an "in" constraint to the projection
            </summary>
      <param name="projection">The projection.</param>
      <param name="values">An ICollection of values.</param>
      <returns>An <see cref="T:NHibernate.Criterion.InExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.In(System.String,System.Collections.ICollection)">
      <summary>
            Apply an "in" constraint to the named property
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="values">An ICollection of values.</param>
      <returns>An <see cref="T:NHibernate.Criterion.InExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.InG``1(System.String,System.Collections.Generic.ICollection{``0})">
      <summary>
            Apply an "in" constraint to the named property. This is the generic equivalent
            of <see cref="M:NHibernate.Criterion.Restrictions.In(System.String,System.Collections.ICollection)" />, renamed to avoid ambiguity.
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="values">An <see cref="T:System.Collections.Generic.ICollection`1" />
            of values.</param>
      <returns>An <see cref="T:NHibernate.Criterion.InExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.InG``1(NHibernate.Criterion.IProjection,System.Collections.Generic.ICollection{``0})">
      <summary>
            Apply an "in" constraint to the projection. This is the generic equivalent
            of <see cref="M:NHibernate.Criterion.Restrictions.In(System.String,System.Collections.ICollection)" />, renamed to avoid ambiguity.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="projection">The projection.</param>
      <param name="values">An <see cref="T:System.Collections.Generic.ICollection`1" />
            of values.</param>
      <returns>An <see cref="T:NHibernate.Criterion.InExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.IsNull(System.String)">
      <summary>
            Apply an "is null" constraint to the named property
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <returns>A <see cref="T:NHibernate.Criterion.NullExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.IsNull(NHibernate.Criterion.IProjection)">
      <summary>
            Apply an "is null" constraint to the projection
            </summary>
      <param name="projection">The projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.NullExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.EqProperty(System.String,System.String)">
      <summary>
            Apply an "equal" constraint to two properties
            </summary>
      <param name="propertyName">The lhs Property Name</param>
      <param name="otherPropertyName">The rhs Property Name</param>
      <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.EqProperty(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Apply an "equal" constraint to projection and property
            </summary>
      <param name="projection">The projection.</param>
      <param name="otherPropertyName">The rhs Property Name</param>
      <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.EqProperty(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Apply an "equal" constraint to lshProjection and rshProjection
            </summary>
      <param name="lshProjection">The LHS projection.</param>
      <param name="rshProjection">The RSH projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.EqProperty(System.String,NHibernate.Criterion.IProjection)">
      <summary>
            Apply an "equal" constraint to the property and rshProjection
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="rshProjection">The RSH projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.NotEqProperty(System.String,System.String)">
      <summary>
            Apply an "not equal" constraint to two properties
            </summary>
      <param name="propertyName">The lhs Property Name</param>
      <param name="otherPropertyName">The rhs Property Name</param>
      <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.NotEqProperty(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Apply an "not equal" constraint to projection and property
            </summary>
      <param name="projection">The projection.</param>
      <param name="otherPropertyName">The rhs Property Name</param>
      <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.NotEqProperty(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Apply an "not equal" constraint to the projections
            </summary>
      <param name="lhsProjection">The LHS projection.</param>
      <param name="rhsProjection">The RHS projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.NotEqProperty(System.String,NHibernate.Criterion.IProjection)">
      <summary>
            Apply an "not equal" constraint to the projections
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="rhsProjection">The RHS projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.EqPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.GtProperty(System.String,System.String)">
      <summary>
            Apply a "greater than" constraint to two properties
            </summary>
      <param name="propertyName">The lhs Property Name</param>
      <param name="otherPropertyName">The rhs Property Name</param>
      <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.GtProperty(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Apply a "greater than" constraint to two properties
            </summary>
      <param name="projection">The projection.</param>
      <param name="otherPropertyName">The rhs Property Name</param>
      <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.GtProperty(System.String,NHibernate.Criterion.IProjection)">
      <summary>
            Apply a "greater than" constraint to two properties
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="projection">The projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.GtProperty(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Apply a "greater than" constraint to two properties
            </summary>
      <param name="lhsProjection">The LHS projection.</param>
      <param name="rhsProjection">The RHS projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.GeProperty(System.String,System.String)">
      <summary>
            Apply a "greater than or equal" constraint to two properties
            </summary>
      <param name="propertyName">The lhs Property Name</param>
      <param name="otherPropertyName">The rhs Property Name</param>
      <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.GeProperty(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Apply a "greater than or equal" constraint to two properties
            </summary>
      <param name="lhsProjection">The LHS projection.</param>
      <param name="rhsProjection">The RHS projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.GeProperty(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Apply a "greater than or equal" constraint to two properties
            </summary>
      <param name="projection">The projection.</param>
      <param name="otherPropertyName">The rhs Property Name</param>
      <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.GeProperty(System.String,NHibernate.Criterion.IProjection)">
      <summary>
            Apply a "greater than or equal" constraint to two properties
            </summary>
      <param name="propertyName">The lhs Property Name</param>
      <param name="projection">The projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.LtProperty(System.String,System.String)">
      <summary>
            Apply a "less than" constraint to two properties
            </summary>
      <param name="propertyName">The lhs Property Name</param>
      <param name="otherPropertyName">The rhs Property Name</param>
      <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.LtProperty(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Apply a "less than" constraint to two properties
            </summary>
      <param name="projection">The projection.</param>
      <param name="otherPropertyName">The rhs Property Name</param>
      <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.LtProperty(System.String,NHibernate.Criterion.IProjection)">
      <summary>
            Apply a "less than" constraint to two properties
            </summary>
      <param name="propertyName">The lhs Property Name</param>
      <param name="projection">The projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.LtProperty(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Apply a "less than" constraint to two properties
            </summary>
      <param name="lhsProjection">The LHS projection.</param>
      <param name="rhsProjection">The RHS projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.LtPropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.LeProperty(System.String,System.String)">
      <summary>
            Apply a "less than or equal" constraint to two properties
            </summary>
      <param name="propertyName">The lhs Property Name</param>
      <param name="otherPropertyName">The rhs Property Name</param>
      <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.LeProperty(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Apply a "less than or equal" constraint to two properties
            </summary>
      <param name="projection">The projection.</param>
      <param name="otherPropertyName">The rhs Property Name</param>
      <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.LeProperty(System.String,NHibernate.Criterion.IProjection)">
      <summary>
            Apply a "less than or equal" constraint to two properties
            </summary>
      <param name="propertyName">The lhs Property Name</param>
      <param name="projection">The projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.LeProperty(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Apply a "less than or equal" constraint to two properties
            </summary>
      <param name="lhsProjection">The LHS projection.</param>
      <param name="rhsProjection">The RHS projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.LePropertyExpression" /> .</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.IsNotNull(System.String)">
      <summary>
            Apply an "is not null" constraint to the named property
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <returns>A <see cref="T:NHibernate.Criterion.NotNullExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.IsNotNull(NHibernate.Criterion.IProjection)">
      <summary>
            Apply an "is not null" constraint to the named property
            </summary>
      <param name="projection">The projection.</param>
      <returns>A <see cref="T:NHibernate.Criterion.NotNullExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.IsNotEmpty(System.String)">
      <summary>
            Apply an "is not empty" constraint to the named property 
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <returns>A <see cref="T:NHibernate.Criterion.IsNotEmptyExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.IsEmpty(System.String)">
      <summary>
            Apply an "is not empty" constraint to the named property 
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <returns>A <see cref="T:NHibernate.Criterion.IsEmptyExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.And(NHibernate.Criterion.ICriterion,NHibernate.Criterion.ICriterion)">
      <summary>
            Return the conjunction of two expressions
            </summary>
      <param name="lhs">The Expression to use as the Left Hand Side.</param>
      <param name="rhs">The Expression to use as the Right Hand Side.</param>
      <returns>An <see cref="T:NHibernate.Criterion.AndExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Or(NHibernate.Criterion.ICriterion,NHibernate.Criterion.ICriterion)">
      <summary>
            Return the disjuction of two expressions
            </summary>
      <param name="lhs">The Expression to use as the Left Hand Side.</param>
      <param name="rhs">The Expression to use as the Right Hand Side.</param>
      <returns>An <see cref="T:NHibernate.Criterion.OrExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Not(NHibernate.Criterion.ICriterion)">
      <summary>
            Return the negation of an expression
            </summary>
      <param name="expression">The Expression to negate.</param>
      <returns>A <see cref="T:NHibernate.Criterion.NotExpression" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Conjunction">
      <summary>
            Group expressions together in a single conjunction (A and B and C...)
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.Disjunction">
      <summary>
            Group expressions together in a single disjunction (A or B or C...)
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.Restrictions.AllEq(System.Collections.IDictionary)">
      <summary>
            Apply an "equals" constraint to each property in the key set of a IDictionary
            </summary>
      <param name="propertyNameValues">a dictionary from property names to values</param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Criterion.Expression">
      <summary> 
            This class is semi-deprecated. Use <see cref="T:NHibernate.Criterion.Restrictions" />. 
            </summary>
      <seealso cref="T:NHibernate.Criterion.Restrictions" />
    </member>
    <member name="M:NHibernate.Criterion.Expression.Sql(NHibernate.SqlCommand.SqlString,System.Object[],NHibernate.Type.IType[])">
      <summary>
            Apply a constraint expressed in SQL, with the given SQL parameters
            </summary>
      <param name="sql">
      </param>
      <param name="values">
      </param>
      <param name="types">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Expression.Sql(NHibernate.SqlCommand.SqlString,System.Object,NHibernate.Type.IType)">
      <summary>
            Apply a constraint expressed in SQL, with the given SQL parameter
            </summary>
      <param name="sql">
      </param>
      <param name="value">
      </param>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Expression.Sql(System.String,System.Object,NHibernate.Type.IType)">
      <summary>
            Apply a constraint expressed in SQL, with the given SQL parameter
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.Expression.Sql(NHibernate.SqlCommand.SqlString)">
      <summary>
            Apply a constraint expressed in SQL
            </summary>
      <param name="sql">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Expression.Sql(System.String)">
      <summary>
            Apply a constraint expressed in SQL
            </summary>
      <param name="sql">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Criterion.GePropertyExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that represents an "greater than or equal" constraint
            between two properties.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.GePropertyExpression.#ctor(System.String,NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GePropertyExpression" /> class.
            </summary>
      <param name="lhsPropertyName">Name of the LHS property.</param>
      <param name="rhsProjection">The RHS projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.GePropertyExpression.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GePropertyExpression" /> class.
            </summary>
      <param name="lhsProjection">The LHS projection.</param>
      <param name="rhsProjection">The RHS projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.GePropertyExpression.#ctor(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GePropertyExpression" /> class.
            </summary>
      <param name="lhsProjection">The projection.</param>
      <param name="rhsPropertyName">Name of the RHS property.</param>
    </member>
    <member name="M:NHibernate.Criterion.GePropertyExpression.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GePropertyExpression" /> class
            that compares two mapped properties using an "greater than or equal" constraint.
            </summary>
      <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
      <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
    </member>
    <member name="P:NHibernate.Criterion.GePropertyExpression.Op">
      <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Criterion.LtPropertyExpression" />.
            </summary>
      <value>The string "<c> &lt; </c>"</value>
    </member>
    <member name="M:NHibernate.Criterion.GroupedProjection.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
            Gets the typed values for parameters in this projection
            </summary>
      <param name="criteria">The criteria.</param>
      <param name="criteriaQuery">The criteria query.</param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Criterion.GtPropertyExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that represents an "greater than" constraint 
            between two properties.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.GtPropertyExpression.#ctor(System.String,NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GtPropertyExpression" /> class.
            </summary>
      <param name="lhsPropertyName">Name of the LHS property.</param>
      <param name="rhsProjection">The RHS projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.GtPropertyExpression.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GtPropertyExpression" /> class.
            </summary>
      <param name="lhsProjection">The LHS projection.</param>
      <param name="rhsProjection">The RHS projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.GtPropertyExpression.#ctor(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GtPropertyExpression" /> class.
            </summary>
      <param name="lhsProjection">The projection.</param>
      <param name="rhsPropertyName">Name of the RHS property.</param>
    </member>
    <member name="M:NHibernate.Criterion.GtPropertyExpression.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.GtPropertyExpression" /> class
            that compares two mapped properties using an "greater than" constraint.
            </summary>
      <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
      <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
    </member>
    <member name="P:NHibernate.Criterion.GtPropertyExpression.Op">
      <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Criterion.LtPropertyExpression" />.
            </summary>
      <value>The string "<c> &lt; </c>"</value>
    </member>
    <member name="T:NHibernate.Criterion.ICriteriaQuery">
      <summary> 
            An instance of <see cref="T:NHibernate.Criterion.ICriteriaQuery" /> is passed to criterion, 
            order and projection instances when actually compiling and
            executing the query. This interface is not used by application
            code. 
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.GetColumn(NHibernate.ICriteria,System.String)">
      <summary> Get the names of the columns mapped by a property path, ignoring projection aliases </summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.GetType(NHibernate.ICriteria,System.String)">
      <summary> Get the type of a property path, ignoring projection aliases</summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.GetColumnsUsingProjection(NHibernate.ICriteria,System.String)">
      <summary> Get the names of the columns mapped by a property path</summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.GetTypeUsingProjection(NHibernate.ICriteria,System.String)">
      <summary> Get the type of a property path</summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.GetTypedValue(NHibernate.ICriteria,System.String,System.Object)">
      <summary> Get the a typed value for the given property value.</summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.GetEntityName(NHibernate.ICriteria)">
      <summary> Get the entity name of an entity</summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.GetEntityName(NHibernate.ICriteria,System.String)">
      <summary> 
            Get the entity name of an entity, taking into account
            the qualifier of the property path
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.GetSQLAlias(NHibernate.ICriteria)">
      <summary> Get the root table alias of an entity</summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.GetSQLAlias(NHibernate.ICriteria,System.String)">
      <summary> 
            Get the root table alias of an entity, taking into account
            the qualifier of the property path
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.GetPropertyName(System.String)">
      <summary> Get the property name, given a possibly qualified property name</summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.GetIdentifierColumns(NHibernate.ICriteria)">
      <summary> Get the identifier column names of this entity</summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.GetIdentifierType(NHibernate.ICriteria)">
      <summary> Get the identifier type of this entity</summary>
    </member>
    <member name="M:NHibernate.Criterion.ICriteriaQuery.AddUsedTypedValues(NHibernate.Engine.TypedValue[])">
      <summary>
            When adding values to the query string it is imperative that they are reported via this function back to the query builder. 
            Do not report the same item multiple times as it will be assumed to be a separate parameter.
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.IdentifierEqExpression">
      <summary>
            An identifier constraint
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.InExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that constrains the property 
            to a specified list of values.
            </summary>
      <remarks>
            InExpression - should only be used with a Single Value column - no multicolumn properties...
            </remarks>
    </member>
    <member name="M:NHibernate.Criterion.InExpression.#ctor(NHibernate.Criterion.IProjection,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.InExpression" /> class.
            </summary>
      <param name="projection">The projection.</param>
      <param name="_values">The _values.</param>
    </member>
    <member name="M:NHibernate.Criterion.InExpression.#ctor(System.String,System.Object[])">
      <summary>
      </summary>
      <param name="propertyName">
      </param>
      <param name="values">
      </param>
    </member>
    <member name="M:NHibernate.Criterion.InExpression.ToString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Criterion.InsensitiveLikeExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that represents an "like" constraint
            that is <b>not</b> case sensitive.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.InsensitiveLikeExpression.#ctor(NHibernate.Criterion.IProjection,System.String,NHibernate.Criterion.MatchMode)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.InsensitiveLikeExpression" /> class.
            </summary>
      <param name="projection">The projection.</param>
      <param name="value">The value.</param>
      <param name="matchMode">The match mode.</param>
    </member>
    <member name="M:NHibernate.Criterion.InsensitiveLikeExpression.#ctor(NHibernate.Criterion.IProjection,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.InsensitiveLikeExpression" /> class.
            </summary>
      <param name="projection">The projection.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:NHibernate.Criterion.InsensitiveLikeExpression.#ctor(System.String,System.Object)">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.InsensitiveLikeExpression" /> 
            class for a named Property and its value.
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="value">The value for the Property.</param>
    </member>
    <member name="M:NHibernate.Criterion.InsensitiveLikeExpression.ToString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Criterion.IsEmptyExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that represents empty association constraint.
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.IsNotEmptyExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that represents non-empty association constraint.
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.LePropertyExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that represents an "less than or equal" constraint 
            between two properties.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.LePropertyExpression.#ctor(System.String,NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LePropertyExpression" /> class.
            </summary>
      <param name="lhsPropertyName">Name of the LHS property.</param>
      <param name="rhsProjection">The RHS projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.LePropertyExpression.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LePropertyExpression" /> class.
            </summary>
      <param name="lhsProjection">The LHS projection.</param>
      <param name="rhsProjection">The RHS projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.LePropertyExpression.#ctor(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LePropertyExpression" /> class.
            </summary>
      <param name="lhsProjection">The projection.</param>
      <param name="rhsPropertyName">Name of the RHS property.</param>
    </member>
    <member name="M:NHibernate.Criterion.LePropertyExpression.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LePropertyExpression" /> class
            that compares two mapped properties using an "less than or equal" constraint.
            </summary>
      <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
      <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
    </member>
    <member name="P:NHibernate.Criterion.LePropertyExpression.Op">
      <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Criterion.LePropertyExpression" />.
            </summary>
      <value>The string "<c> &lt;= </c>"</value>
    </member>
    <member name="T:NHibernate.Criterion.LikeExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that represents an "like" constraint.
            </summary>
      <remarks>
            The case sensitivity depends on the database settings for string 
            comparisons.  Use <see cref="T:NHibernate.Criterion.InsensitiveLikeExpression" /> if the
            string comparison should not be case sensitive.
            </remarks>
    </member>
    <member name="T:NHibernate.Criterion.LtPropertyExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that represents an "less than" constraint 
            between two properties.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.LtPropertyExpression.#ctor(System.String,NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LtPropertyExpression" /> class.
            </summary>
      <param name="lhsPropertyName">Name of the LHS property.</param>
      <param name="rhsProjection">The RHS projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.LtPropertyExpression.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LtPropertyExpression" /> class.
            </summary>
      <param name="lhsProjection">The LHS projection.</param>
      <param name="rhsProjection">The RHS projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.LtPropertyExpression.#ctor(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LtPropertyExpression" /> class.
            </summary>
      <param name="lhsProjection">The projection.</param>
      <param name="rhsPropertyName">Name of the RHS property.</param>
    </member>
    <member name="M:NHibernate.Criterion.LtPropertyExpression.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.LtPropertyExpression" /> class
            that compares two mapped properties using an "less than" constraint.
            </summary>
      <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
      <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
    </member>
    <member name="P:NHibernate.Criterion.LtPropertyExpression.Op">
      <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Criterion.LtPropertyExpression" />.
            </summary>
      <value>The string "<c> &lt; </c>"</value>
    </member>
    <member name="T:NHibernate.Criterion.MatchMode">
      <summary>
            Represents an strategy for matching strings using "like".
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.MatchMode.ExactMatchMode">
      <summary>
            The <see cref="T:NHibernate.Criterion.MatchMode" /> that matches the entire string to the pattern.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.MatchMode.ExactMatchMode.#ctor">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.MatchMode.ExactMatchMode" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.MatchMode.ExactMatchMode.ToMatchString(System.String)">
      <summary>
            Converts the string to the Exact MatchMode.
            </summary>
      <param name="pattern">The string to convert to the appropriate match pattern.</param>
      <returns>The <c>pattern</c> exactly the same as it was passed in.</returns>
    </member>
    <member name="T:NHibernate.Criterion.MatchMode.StartMatchMode">
      <summary>
            The <see cref="T:NHibernate.Criterion.MatchMode" /> that matches the start of the string to the pattern.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.MatchMode.StartMatchMode.#ctor">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.MatchMode.StartMatchMode" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.MatchMode.StartMatchMode.ToMatchString(System.String)">
      <summary>
            Converts the string to the Start MatchMode.
            </summary>
      <param name="pattern">The string to convert to the appropriate match pattern.</param>
      <returns>The <c>pattern</c> with a "<c>%</c>" appended at the end.</returns>
    </member>
    <member name="T:NHibernate.Criterion.MatchMode.EndMatchMode">
      <summary>
            The <see cref="T:NHibernate.Criterion.MatchMode" /> that matches the end of the string to the pattern.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.MatchMode.EndMatchMode.#ctor">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.MatchMode.EndMatchMode" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.MatchMode.EndMatchMode.ToMatchString(System.String)">
      <summary>
            Converts the string to the End MatchMode.
            </summary>
      <param name="pattern">The string to convert to the appropriate match pattern.</param>
      <returns>The <c>pattern</c> with a "<c>%</c>" appended at the beginning.</returns>
    </member>
    <member name="T:NHibernate.Criterion.MatchMode.AnywhereMatchMode">
      <summary>
            The <see cref="T:NHibernate.Criterion.MatchMode" /> that exactly matches the string
            by appending "<c>%</c>" to the beginning and end.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.MatchMode.AnywhereMatchMode.#ctor">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.MatchMode.AnywhereMatchMode" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.MatchMode.AnywhereMatchMode.ToMatchString(System.String)">
      <summary>
            Converts the string to the Exact MatchMode.
            </summary>
      <param name="pattern">The string to convert to the appropriate match pattern.</param>
      <returns>The <c>pattern</c> with a "<c>%</c>" appended at the beginning and the end.</returns>
    </member>
    <member name="F:NHibernate.Criterion.MatchMode.Exact">
      <summary>
            Match the entire string to the pattern
            </summary>
    </member>
    <member name="F:NHibernate.Criterion.MatchMode.Start">
      <summary>
            Match the start of the string to the pattern
            </summary>
    </member>
    <member name="F:NHibernate.Criterion.MatchMode.End">
      <summary>
            Match the end of the string to the pattern
            </summary>
    </member>
    <member name="F:NHibernate.Criterion.MatchMode.Anywhere">
      <summary>
            Match the pattern anywhere in the string
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.MatchMode.#ctor(System.Int32,System.String)">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.MatchMode" /> class.
            </summary>
      <param name="intCode">The code that identifies the match mode.</param>
      <param name="name">The friendly name of the match mode.</param>
      <remarks>
            The parameter <c>intCode</c> is used as the key of <see cref="T:System.Collections.IDictionary" />
            to store instances and to ensure only instance of a particular <see cref="T:NHibernate.Criterion.MatchMode" />
            is created.
            </remarks>
    </member>
    <member name="M:NHibernate.Criterion.MatchMode.ToString">
      <summary>
            The string representation of the <see cref="T:NHibernate.Criterion.MatchMode" />.
            </summary>
      <returns>The friendly name used to describe the <see cref="T:NHibernate.Criterion.MatchMode" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.MatchMode.ToMatchString(System.String)">
      <summary>
            Convert the pattern, by appending/prepending "%"
            </summary>
      <param name="pattern">The string to convert to the appropriate match pattern.</param>
      <returns>
            A <see cref="T:System.String" /> that contains a "%" in the appropriate place
            for the Match Strategy.
            </returns>
    </member>
    <member name="T:NHibernate.Criterion.NotExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that negates another <see cref="T:NHibernate.Criterion.ICriterion" />.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.NotExpression.#ctor(NHibernate.Criterion.ICriterion)">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.NotExpression" /> class for an
            <see cref="T:NHibernate.Criterion.ICriterion" /></summary>
      <param name="criterion">The <see cref="T:NHibernate.Criterion.ICriterion" /> to negate.</param>
    </member>
    <member name="T:NHibernate.Criterion.NotNullExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that represents "not null" constraint.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.NotNullExpression.#ctor(NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.NotNullExpression" /> class.
            </summary>
      <param name="projection">The projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.NotNullExpression.#ctor(System.String)">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.NotNullExpression" /> class for a named
            Property that should not be null.
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
    </member>
    <member name="T:NHibernate.Criterion.NullExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that represents "null" constraint.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.NullExpression.#ctor(NHibernate.Criterion.IProjection)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Criterion.NullExpression" /> class.
            </summary>
      <param name="projection">The projection.</param>
    </member>
    <member name="M:NHibernate.Criterion.NullExpression.#ctor(System.String)">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.NotNullExpression" /> class for a named
            Property that should be null.
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
    </member>
    <member name="M:NHibernate.Criterion.NullExpression.ToString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Criterion.Order">
      <summary>
            Represents an order imposed upon a <see cref="T:NHibernate.ICriteria" />
            result set.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.Order.#ctor(NHibernate.Criterion.IProjection,System.Boolean)">
      <summary>
            Constructor for Order.
            </summary>
      <param name="projection">
      </param>
      <param name="ascending">
      </param>
    </member>
    <member name="M:NHibernate.Criterion.Order.#ctor(System.String,System.Boolean)">
      <summary>
            Constructor for Order.
            </summary>
      <param name="propertyName">
      </param>
      <param name="ascending">
      </param>
    </member>
    <member name="M:NHibernate.Criterion.Order.ToSqlString(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
            Render the SQL fragment
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.Order.Asc(System.String)">
      <summary>
            Ascending order
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Order.Asc(NHibernate.Criterion.IProjection)">
      <summary>
            Ascending order
            </summary>
      <param name="projection">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Order.Desc(NHibernate.Criterion.IProjection)">
      <summary>
            Descending order
            </summary>
      <param name="projection">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Order.Desc(System.String)">
      <summary>
            Descending order
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Criterion.OrExpression">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that combines two <see cref="T:NHibernate.Criterion.ICriterion" />s with an 
            <c>"or"</c> between them.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.OrExpression.#ctor(NHibernate.Criterion.ICriterion,NHibernate.Criterion.ICriterion)">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.OrExpression" /> class for 
            two <see cref="T:NHibernate.Criterion.ICriterion" />s.
            </summary>
      <param name="lhs">The <see cref="T:NHibernate.Criterion.ICriterion" /> to use as the left hand side.</param>
      <param name="rhs">The <see cref="T:NHibernate.Criterion.ICriterion" /> to use as the right hand side.</param>
    </member>
    <member name="P:NHibernate.Criterion.OrExpression.Op">
      <summary>
            Get the Sql operator to put between the two <see cref="T:NHibernate.Criterion.Expression" />s.
            </summary>
      <value>Returns "<c>or</c>"</value>
    </member>
    <member name="M:NHibernate.Criterion.ProjectionList.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
            Gets the typed values for parameters in this projection
            </summary>
      <param name="criteria">The criteria.</param>
      <param name="criteriaQuery">The criteria query.</param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Criterion.Projections">
      <summary>
            The <tt>criterion</tt> package may be used by applications as a framework for building
            new kinds of <tt>Projection</tt>. However, it is intended that most applications will
            simply use the built-in projection types via the static factory methods of this class.<br /><br />
            The factory methods that take an alias allow the projected value to be referred to by 
            criterion and order instances.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Distinct(NHibernate.Criterion.IProjection)">
      <summary>
            Create a distinct projection from a projection
            </summary>
      <param name="proj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.ProjectionList">
      <summary>
            Create a new projection list
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.RowCount">
      <summary>
            The query row count, ie. <tt>count(*)</tt></summary>
      <returns>The RowCount projection mapped to an <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.RowCountInt64">
      <summary>
            The query row count, ie. <tt>count(*)</tt></summary>
      <returns>The RowCount projection mapped to an <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Count(NHibernate.Criterion.IProjection)">
      <summary>
            A property value count
            </summary>
      <param name="projection">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Count(System.String)">
      <summary>
            A property value count
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.CountDistinct(System.String)">
      <summary>
            A distinct property value count
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Max(System.String)">
      <summary>
            A property maximum value
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Max(NHibernate.Criterion.IProjection)">
      <summary>
            A projection maximum value
            </summary>
      <param name="projection">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Min(System.String)">
      <summary>
            A property minimum value
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Min(NHibernate.Criterion.IProjection)">
      <summary>
            A projection minimum value
            </summary>
      <param name="projection">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Avg(System.String)">
      <summary>
            A property average value
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Avg(NHibernate.Criterion.IProjection)">
      <summary>
            A property average value
            </summary>
      <param name="projection">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Sum(System.String)">
      <summary>
            A property value sum
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Sum(NHibernate.Criterion.IProjection)">
      <summary>
            A property value sum
            </summary>
      <param name="projection">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.SqlProjection(System.String,System.String[],NHibernate.Type.IType[])">
      <summary>
            A SQL projection, a typed select clause fragment
            </summary>
      <param name="sql">
      </param>
      <param name="columnAliases">
      </param>
      <param name="types">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.SqlGroupProjection(System.String,System.String,System.String[],NHibernate.Type.IType[])">
      <summary>
            A grouping SQL projection, specifying both select clause and group by clause fragments
            </summary>
      <param name="sql">
      </param>
      <param name="groupBy">
      </param>
      <param name="columnAliases">
      </param>
      <param name="types">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.GroupProperty(System.String)">
      <summary>
            A grouping property value
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.GroupProperty(NHibernate.Criterion.IProjection)">
      <summary>
            A grouping projection value
            </summary>
      <param name="projection">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Property(System.String)">
      <summary>
            A projected property value
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Id">
      <summary>
            A projected identifier value
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Alias(NHibernate.Criterion.IProjection,System.String)">
      <summary>
            Assign an alias to a projection, by wrapping it
            </summary>
      <param name="projection">
      </param>
      <param name="alias">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Cast(NHibernate.Type.IType,NHibernate.Criterion.IProjection)">
      <summary>
            Casts the projection result to the specified type.
            </summary>
      <param name="type">The type.</param>
      <param name="projection">The projection.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Constant(System.Object)">
      <summary>
            Return a constant value
            </summary>
      <param name="obj">The obj.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Constant(System.Object,NHibernate.Type.IType)">
      <summary>
            Return a constant value
            </summary>
      <param name="obj">The obj.</param>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.SqlFunction(System.String,NHibernate.Type.IType,NHibernate.Criterion.IProjection[])">
      <summary>
            Calls the named <see cref="T:NHibernate.Dialect.Function.ISQLFunction" /></summary>
      <param name="functionName">Name of the function.</param>
      <param name="type">The type.</param>
      <param name="projections">The projections.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.SqlFunction(NHibernate.Dialect.Function.ISQLFunction,NHibernate.Type.IType,NHibernate.Criterion.IProjection[])">
      <summary>
            Calls the specified <see cref="T:NHibernate.Dialect.Function.ISQLFunction" /></summary>
      <param name="function">the function.</param>
      <param name="type">The type.</param>
      <param name="projections">The projections.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Criterion.Projections.Conditional(NHibernate.Criterion.ICriterion,NHibernate.Criterion.IProjection,NHibernate.Criterion.IProjection)">
      <summary>
            Conditionally return the true or false part, dependention on the criterion
            </summary>
      <param name="criterion">The criterion.</param>
      <param name="whenTrue">The when true.</param>
      <param name="whenFalse">The when false.</param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Criterion.PropertyProjection">
      <summary>
            A property value, or grouped property value
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.Property">
      <summary>
            A factory for property-specific  AbstractCriterion  and projection instances
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.Property.GetProperty(System.String)">
      <summary>
            Get a component attribute of this property
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.PropertySubqueryExpression">
      <summary>
            A comparison between a property value in the outer query and the
             result of a subquery
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.SelectSubqueryExpression">
      <summary>
            A comparison between a property value in the outer query and the
             result of a subquery
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.SimpleExpression">
      <summary>
            The base class for an <see cref="T:NHibernate.Criterion.ICriterion" /> that compares a single Property
            to a value.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.SimpleExpression.#ctor(System.String,System.Object,System.String)">
      <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Criterion.SimpleExpression" /> class for a named
            Property and its value.
            </summary>
      <param name="propertyName">The name of the Property in the class.</param>
      <param name="value">The value for the Property.</param>
      <param name="op">The SQL operation.</param>
    </member>
    <member name="M:NHibernate.Criterion.SimpleExpression.ToSqlString(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
      <summary>
            Converts the SimpleExpression to a <see cref="T:NHibernate.SqlCommand.SqlString" />.
            </summary>
      <returns>A SqlString that contains a valid Sql fragment.</returns>
    </member>
    <member name="M:NHibernate.Criterion.SimpleExpression.ToString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Criterion.SimpleExpression.PropertyName">
      <summary>
            Gets the named Property for the Expression.
            </summary>
      <value>A string that is the name of the Property.</value>
    </member>
    <member name="P:NHibernate.Criterion.SimpleExpression.Value">
      <summary>
            Gets the Value for the Expression.
            </summary>
      <value>An object that is the value for the Expression.</value>
    </member>
    <member name="P:NHibernate.Criterion.SimpleExpression.Op">
      <summary>
            Get the Sql operator to use for the specific 
            subclass of <see cref="T:NHibernate.Criterion.SimpleExpression" />.
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.SimpleSubqueryExpression">
      <summary>
            A comparison between a constant value and the the result of a subquery
            </summary>
    </member>
    <member name="T:NHibernate.Criterion.SQLCriterion">
      <summary>
            An <see cref="T:NHibernate.Criterion.ICriterion" /> that creates a SQLExpression.
            The string {alias} will be replaced by the alias of the root entity.
            </summary>
      <remarks>
            This allows for database specific Expressions at the cost of needing to 
            write a correct <see cref="T:NHibernate.SqlCommand.SqlString" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Criterion.SQLCriterion.ToString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Criterion.SQLProjection">
      <summary>
            A SQL fragment. The string {alias} will be replaced by the alias of the root entity.
            </summary>
    </member>
    <member name="M:NHibernate.Criterion.SQLProjection.GetTypedValues(NHibernate.ICriteria,NHibernate.Criterion.ICriteriaQuery)">
      <summary>
            Gets the typed values for parameters in this projection
            </summary>
      <param name="criteria">The criteria.</param>
      <param name="criteriaQuery">The criteria query.</param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Criterion.Subqueries">
      <summary>
            Factory class for AbstractCriterion instances that represent 
            involving subqueries.
            <c>Expression</c><c>Projection</c><c>AbstractCriterion</c></summary>
    </member>
    <member name="T:NHibernate.Criterion.SubqueryProjection">
      <summary>
            A property value, or grouped property value
            </summary>
    </member>
    <member name="T:NHibernate.DebugHelpers.DictionaryProxy">
      <summary>
            Used to show a better debug display for dictionaries
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.Function.ISQLFunction">
      <summary>
             Provides support routines for the HQL functions as used
             in the various SQL Dialects
            
             Provides an interface for supporting various HQL functions that are
             translated to SQL. The Dialect and its sub-classes use this interface to
             provide details required for processing of the function.
             </summary>
    </member>
    <member name="M:NHibernate.Dialect.Function.ISQLFunction.ReturnType(NHibernate.Type.IType,NHibernate.Engine.IMapping)">
      <summary>
            The function return type
            </summary>
      <param name="columnType">The type of the first argument</param>
      <param name="mapping">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Dialect.Function.ISQLFunction.Render(System.Collections.IList,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Render the function call as SQL.
            </summary>
      <param name="args">List of arguments</param>
      <param name="factory">
      </param>
      <returns>SQL fragment for the fuction.</returns>
    </member>
    <member name="P:NHibernate.Dialect.Function.ISQLFunction.HasArguments">
      <summary>
            Does this function have any arguments?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Function.ISQLFunction.HasParenthesesIfNoArguments">
      <summary>
            If there are no arguments, are parens required?
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.Function.SQLFunctionTemplate">
      <summary>
            Represents HQL functions that can have different representations in different SQL dialects.
            E.g. in HQL we can define function <code>concat(?1, ?2)</code> to concatenate two strings 
            p1 and p2. Target SQL function will be dialect-specific, e.g. <code>(?1 || ?2)</code> for 
            Oracle, <code>concat(?1, ?2)</code> for MySql, <code>(?1 + ?2)</code> for MS SQL.
            Each dialect will define a template as a string (exactly like above) marking function 
            parameters with '?' followed by parameter's index (first index is 1).
            </summary>
    </member>
    <member name="M:NHibernate.Dialect.Function.SQLFunctionTemplate.Render(System.Collections.IList,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Applies the template to passed in arguments.
            </summary>
      <param name="args">args function arguments</param>
      <param name="factory">generated SQL function call</param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Dialect.Function.AnsiExtractFunction">
      <summary>
      </summary>
      <remarks><![CDATA[
             <extract expression> ::=
            					EXTRACT <left paren> <extract field> FROM <extract source> <right paren>
             
            <extract field > ::=
            			<datetime field> | <time zone field >
             
             <datetime field> ::= 
            			YEAR |
            			MONTH |
            			DAY |
            			HOUR |
            			MINUTE |
            			SECOND
             
            <time zone field> ::= 
            			TIMEZONE_HOUR	| 
            			TIMEZONE_MINUTE
             ]]></remarks>
    </member>
    <member name="T:NHibernate.Dialect.Function.AnsiSubstringFunction">
      <summary>
             ANSI-SQL substring  
             Documented in:
             ANSI X3.135-1992
             American National Standard for Information Systems - Database Language - SQL
             </summary>
      <remarks>
             Syntax:
            <![CDATA[
             <character substring function> ::=
             SUBSTRING <left paren> <character value expression> FROM < start position>
             [ FOR <string length> ] <right paren>
            ]]></remarks>
    </member>
    <member name="T:NHibernate.Dialect.Function.AnsiTrimEmulationFunction">
      <summary>
            A SQLFunction implementation that emulates the ANSI SQL trim function
            on dialects which do not support the full definition.  However, this function
            definition does assume the availability of ltrim, rtrim, and replace functions
            which it uses in various combinations to emulate the desired ANSI trim()
            functionality.
            </summary>
    </member>
    <member name="M:NHibernate.Dialect.Function.AnsiTrimEmulationFunction.Render(System.Collections.IList,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
      </summary>
      <param name="args">
      </param>
      <param name="factory">
      </param>
      <returns>
      </returns>
      <remarks>
             according to both the ANSI-SQL and EJB3 specs, trim can either take
             exactly one parameter or a variable number of parameters between 1 and 4.
             from the SQL spec:
             <![CDATA[
             <trim function> ::=
                  TRIM <left paren> <trim operands> <right paren>
            
             <trim operands> ::=
                  [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source>
            
             <trim specification> ::=
                  LEADING
                  | TRAILING
                  | BOTH
             ]]>
             If only trim specification is omitted, BOTH is assumed;
             if trim character is omitted, space is assumed
             </remarks>
    </member>
    <member name="T:NHibernate.Dialect.Function.CastFunction">
      <summary>
            ANSI-SQL style cast(foo as type) where the type is a NHibernate type
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.Function.CastFunction.LazyType">
      <summary>
            Delegate the values to a real type
            </summary>
      <remarks>
            The real return type of Cast is know only after the Cast is parsed.
            This class was created in NH to remove the responsibility of the parser about know the
            real return type.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.ICacheAssembler.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary> Return a cacheable "disassembled" representation of the object.</summary>
      <param name="value">the value to cache </param>
      <param name="session">the session </param>
      <param name="owner">optional parent entity object (needed for collections) </param>
      <returns> the disassembled, deep cloned state </returns>
    </member>
    <member name="M:NHibernate.Type.ICacheAssembler.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary> Reconstruct the object from its cached "disassembled" state.</summary>
      <param name="cached">the disassembled state from the cache </param>
      <param name="session">the session </param>
      <param name="owner">the parent entity object </param>
      <returns> the the object </returns>
    </member>
    <member name="M:NHibernate.Type.ICacheAssembler.BeforeAssemble(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Called before assembling a query result set from the query cache, to allow batch fetching
            of entities missing from the second-level cache.
            </summary>
    </member>
    <member name="T:NHibernate.Type.IType">
      <summary>
			Defines a mapping from a .NET <see cref="T:System.Type" /> to a SQL datatype.
			This interface is intended to be implemented by applications that need custom types.
		</summary>
      <remarks>
			Implementors should usually be immutable and MUST definately be threadsafe.
		</remarks>
    </member>
    <member name="M:NHibernate.Type.IType.SqlTypes(NHibernate.Engine.IMapping)">
      <summary>
		When implemented by a class, returns the SqlTypes for the columns mapped by this IType.
		</summary>
      <param name="mapping">The <see cref="T:NHibernate.Engine.IMapping" /> that uses this IType.</param>
      <returns>An array of <see cref="T:NHibernate.SqlTypes.SqlType" />s.</returns>
    </member>
    <member name="M:NHibernate.Type.IType.GetColumnSpan(NHibernate.Engine.IMapping)">
      <summary>
		When implemented by a class, returns how many columns are used to persist this type.
		</summary>
      <param name="mapping">The <see cref="T:NHibernate.Engine.IMapping" /> that uses this IType.</param>
      <returns>The number of columns this IType spans.</returns>
      <exception cref="T:NHibernate.MappingException">MappingException</exception>
    </member>
    <member name="M:NHibernate.Type.IType.IsDirty(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
		When implemented by a class, should the parent be considered dirty, 
		given both the old and current field or element value?
		</summary>
      <param name="old">The old value</param>
      <param name="current">The current value</param>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /></param>
      <returns>true if the field is dirty</returns>
    </member>
    <member name="M:NHibernate.Type.IType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
		When implemented by a class, gets an instance of the object mapped by 
		this IType from the <see cref="T:System.Data.IDataReader" />.
		</summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> that contains the values</param>
      <param name="names">
		The names of the columns in the <see cref="T:System.Data.IDataReader" /> that contain the 
		value to populate the IType with.
		</param>
      <param name="session">
      </param>
      <param name="owner">
      </param>
      <returns>The object mapped by this IType.</returns>
      <remarks>
		Implementors should handle possibility of null values.
		</remarks>
    </member>
    <member name="M:NHibernate.Type.IType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
		When implemented by a class, gets an instance of the object 
		mapped by this IType from the <see cref="T:System.Data.IDataReader" />.
		</summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> that contains the values</param>
      <param name="name">The name of the column in the <see cref="T:System.Data.IDataReader" /> that contains the 
		value to populate the IType with.</param>
      <param name="session">
      </param>
      <param name="owner">
      </param>
      <returns>The object mapped by this IType.</returns>
      <remarks>
		Implementations should handle possibility of null values.
		This method might be called if the IType is known to be a single-column type.
		</remarks>
    </member>
    <member name="M:NHibernate.Type.IType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,System.Boolean[],NHibernate.Engine.ISessionImplementor)">
      <summary>
		When implemented by a class, puts the value/values from the mapped 
		class into the <see cref="T:System.Data.IDbCommand" />.
		</summary>
      <param name="st">The <see cref="T:System.Data.IDbCommand" /> to put the values into.</param>
      <param name="value">The object that contains the values.</param>
      <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter" /> to start writing the values to.</param>
      <param name="session">
      </param>
      <param name="settable">Indicates which columns are to be set.</param>
      <remarks>
		Implementors should handle possibility of null values.
		A multi-column type should be written to parameters starting from <paramref name="index" />.
		</remarks>
    </member>
    <member name="M:NHibernate.Type.IType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
      <summary>
			When implemented by a class, puts the value/values from the mapped
			class into the <see cref="T:System.Data.IDbCommand" />.
		</summary>
      <param name="st">
			The <see cref="T:System.Data.IDbCommand" /> to put the values into.
		</param>
      <param name="value">The object that contains the values.</param>
      <param name="index">
			The index of the <see cref="T:System.Data.IDbDataParameter" /> to start writing the values to.
		</param>
      <param name="session">
      </param>
      <remarks>
			Implementors should handle possibility of null values.
			A multi-column type should be written to parameters starting from <paramref name="index" />.
		</remarks>
    </member>
    <member name="M:NHibernate.Type.IType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
		When implemented by a class, a representation of the value to be 
		embedded in an XML element
		</summary>
      <param name="value">The object that contains the values.</param>
      <param name="factory">
      </param>
      <returns>An Xml formatted string.</returns>
    </member>
    <member name="M:NHibernate.Type.IType.DeepCopy(System.Object,NHibernate.EntityMode,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
		When implemented by a class, returns a deep copy of the persistent 
		state, stopping at entities and at collections.
		</summary>
      <param name="val">A Collection element or Entity field</param>
      <param name="entityMode">The entityMode.</param>
      <param name="factory">The session factory.</param>
      <returns>A deep copy of the object.</returns>
    </member>
    <member name="M:NHibernate.Type.IType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
		When implemented by a class, retrieves an instance of the mapped class, 
		or the identifier of an entity or collection from a <see cref="T:System.Data.IDataReader" />.
		</summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> that contains the values.</param>
      <param name="names">
		The names of the columns in the <see cref="T:System.Data.IDataReader" /> that contain the 
		value to populate the IType with.
		</param>
      <param name="session">the session</param>
      <param name="owner">The parent Entity</param>
      <returns>An identifier or actual object mapped by this IType.</returns>
      <remarks>
        <para>
		This is useful for 2-phase property initialization - the second phase is a call to
		<c>ResolveIdentifier()</c></para>
        <para>
		Most implementors of this method will just pass the call to <c>NullSafeGet()</c>.
		</para>
      </remarks>
    </member>
    <member name="M:NHibernate.Type.IType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
		When implemented by a class, maps identifiers to Entities or Collections. 
		</summary>
      <param name="value">An identifier or value returned by <c>Hydrate()</c></param>
      <param name="session">The session</param>
      <param name="owner">The parent Entity</param>
      <returns>The Entity or Collection referenced by this Identifier.</returns>
      <remarks>
		This is the second phase of 2-phase property initialization.
		</remarks>
    </member>
    <member name="M:NHibernate.Type.IType.SemiResolve(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Given a hydrated, but unresolved value, return a value that may be used to
            reconstruct property-ref associations.
            </summary>
    </member>
    <member name="M:NHibernate.Type.IType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)">
      <!-- No matching elements were found for the following include tag -->
      <include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.Copy&quot;]/*" />
    </member>
    <member name="M:NHibernate.Type.IType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary,NHibernate.Type.ForeignKeyDirection)">
      <summary> 
            During merge, replace the existing (target) value in the entity we are merging to
            with a new (original) value from the detached entity we are merging. For immutable
            objects, or null values, it is safe to simply return the first parameter. For
            mutable objects, it is safe to return a copy of the first parameter. For objects
            with component values, it might make sense to recursively replace component values. 
            </summary>
      <param name="original">the value from the detached entity being merged </param>
      <param name="target">the value in the managed entity </param>
      <param name="session">
      </param>
      <param name="owner">
      </param>
      <param name="copyCache">
      </param>
      <param name="foreignKeyDirection">
      </param>
      <returns> the value to be merged </returns>
    </member>
    <member name="M:NHibernate.Type.IType.IsSame(System.Object,System.Object,NHibernate.EntityMode)">
      <summary> 
            Compare two instances of the class mapped by this type for persistence
            "equality" - equality of persistent state - taking a shortcut for
            entity references.
            </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <param name="entityMode">
      </param>
      <returns> boolean </returns>
    </member>
    <member name="M:NHibernate.Type.IType.IsEqual(System.Object,System.Object,NHibernate.EntityMode)">
      <summary> 
            Compare two instances of the class mapped by this type for persistence
            "equality" - equality of persistent state.
            </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <param name="entityMode">
      </param>
      <returns> boolean </returns>
    </member>
    <member name="M:NHibernate.Type.IType.IsEqual(System.Object,System.Object,NHibernate.EntityMode,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary> 
            Compare two instances of the class mapped by this type for persistence
            "equality" - equality of persistent state.
            </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <param name="entityMode">
      </param>
      <param name="factory">
      </param>
      <returns> boolean </returns>
    </member>
    <member name="M:NHibernate.Type.IType.GetHashCode(System.Object,NHibernate.EntityMode)">
      <summary> Get a hashcode, consistent with persistence "equality"</summary>
      <param name="x">
      </param>
      <param name="entityMode">
      </param>
    </member>
    <member name="M:NHibernate.Type.IType.GetHashCode(System.Object,NHibernate.EntityMode,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary> Get a hashcode, consistent with persistence "equality"</summary>
      <param name="x">
      </param>
      <param name="entityMode">
      </param>
      <param name="factory">
      </param>
    </member>
    <member name="M:NHibernate.Type.IType.Compare(System.Object,System.Object,System.Nullable{NHibernate.EntityMode})">
      <summary> compare two instances of the type</summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <param name="entityMode">
      </param>
    </member>
    <member name="M:NHibernate.Type.IType.GetSemiResolvedType(NHibernate.Engine.ISessionFactoryImplementor)">
      <summary> Get the type of a semi-resolved value.</summary>
    </member>
    <member name="M:NHibernate.Type.IType.SetToXMLNode(System.Xml.XmlNode,System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary> A representation of the value to be embedded in an XML element. </summary>
      <param name="node">
      </param>
      <param name="value">
      </param>
      <param name="factory">
      </param>
    </member>
    <member name="M:NHibernate.Type.IType.FromXMLNode(System.Xml.XmlNode,NHibernate.Engine.IMapping)">
      <summary> Parse the XML representation of an instance.</summary>
      <param name="xml">
      </param>
      <param name="factory">
      </param>
      <returns> an instance of the type </returns>
    </member>
    <member name="M:NHibernate.Type.IType.ToColumnNullness(System.Object,NHibernate.Engine.IMapping)">
      <summary> 
            Given an instance of the type, return an array of boolean, indicating
            which mapped columns would be null. 
            </summary>
      <param name="value">an instance of the type </param>
      <param name="mapping">
      </param>
    </member>
    <member name="P:NHibernate.Type.IType.Name">
      <summary>
		When implemented by a class, gets the abbreviated name of the type.
		</summary>
      <value>The NHibernate type name.</value>
    </member>
    <member name="P:NHibernate.Type.IType.ReturnedClass">
      <summary>
		When implemented by a class, gets the <see cref="T:System.Type" /> returned 
		by the <c>NullSafeGet()</c> methods.
		</summary>
      <value>
		The <see cref="T:System.Type" /> from the .NET framework.
		</value>
      <remarks>
		This is used to establish the class of an array of this Itype
		</remarks>
    </member>
    <member name="P:NHibernate.Type.IType.IsMutable">
      <summary>
		When implemented by a class, gets the value indicating if the objects 
		of this IType are mutable.
		</summary>
      <value>true if the objects mapped by this IType are mutable.</value>
      <remarks>
		With respect to the referencing object...
		Entities and Collections are considered immutable because they manage their own internal state.
		</remarks>
    </member>
    <member name="P:NHibernate.Type.IType.IsAssociationType">
      <summary>
			When implemented by a class, gets a value indicating if the implementor is castable to an an <see cref="T:NHibernate.Type.IAssociationType" /></summary>
      <value>true if this is an Association</value>
      <remarks>This does not necessarily imply that the type actually represents an association.</remarks>
    </member>
    <member name="P:NHibernate.Type.IType.IsCollectionType">
      <summary>
			When implemented by a class, gets a value indicating if the implementor is a collection type
		</summary>
      <value>true if this is a <see cref="T:NHibernate.Type.CollectionType" />.</value>
    </member>
    <member name="P:NHibernate.Type.IType.IsComponentType">
      <summary>
		When implemented by a class, gets a value indicating if the implementor 
		is an <see cref="T:NHibernate.Type.IAbstractComponentType" />.
		</summary>
      <value>true if this is an <see cref="T:NHibernate.Type.IAbstractComponentType" /></value>
      <remarks>
		If true, the implementation must be castable to <see cref="T:NHibernate.Type.IAbstractComponentType" />.
		A component type may own collections or associations and hence must provide certain extra functionality.
		</remarks>
    </member>
    <member name="P:NHibernate.Type.IType.IsEntityType">
      <summary>
		When implemented by a class, gets a value indicating if the implementor 
		extends <see cref="T:NHibernate.Type.EntityType" /></summary>
      <value>true if this is an <see cref="T:NHibernate.Type.EntityType" /></value>
    </member>
    <member name="P:NHibernate.Type.IType.IsAnyType">
      <!-- No matching elements were found for the following include tag -->
      <include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;P:IType.IsAnyType&quot;]/*" />
    </member>
    <member name="T:NHibernate.Dialect.Function.CharIndexFunction">
      <summary>
            Emulation of locate() on Sybase
            </summary>
    </member>
    <member name="M:NHibernate.Dialect.Function.ClassicAggregateFunction.#ctor(System.String,System.Boolean)">
      <summary>
            Initializes a new instance of the StandardSQLFunction class.
            </summary>
      <param name="name">SQL function name.</param>
      <param name="acceptAsterisk">Whether the function accepts an asterisk (*) in place of arguments</param>
    </member>
    <member name="M:NHibernate.Dialect.Function.ClassicAggregateFunction.#ctor(System.String,System.Boolean,NHibernate.Type.IType)">
      <summary>
            Initializes a new instance of the StandardSQLFunction class.
            </summary>
      <param name="name">SQL function name.</param>
      <param name="acceptAsterisk">True if accept asterisk like argument</param>
      <param name="typeValue">Return type for the fuction.</param>
    </member>
    <member name="T:NHibernate.Dialect.Function.ClassicAvgFunction">
      <summary>
            Classic AVG sqlfunction that return types as it was done in Hibernate 3.1
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.Function.ClassicCountFunction">
      <summary>
            Classic COUNT sqlfunction that return types as it was done in Hibernate 3.1
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.Function.ClassicSumFunction">
      <summary>
            Classic SUM sqlfunction that return types as it was done in Hibernate 3.1
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.Function.NoArgSQLFunction">
      <summary>
            Summary description for NoArgSQLFunction.
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.Function.NvlFunction">
      <summary>
            Emulation of coalesce() on Oracle, using multiple nvl() calls
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.Function.PositionSubstringFunction">
      <summary>
            Emulation of locate() on PostgreSQL
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.Function.StandardSQLFunction">
      <summary>
            Provides a standard implementation that supports the majority of the HQL
            functions that are translated to SQL.
            </summary>
      <remarks>
            The Dialect and its sub-classes use this class to provide details required
            for processing of the associated function.
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Function.StandardSQLFunction.#ctor(System.String)">
      <summary>
            Initializes a new instance of the StandardSQLFunction class.
            </summary>
      <param name="name">SQL function name.</param>
    </member>
    <member name="M:NHibernate.Dialect.Function.StandardSQLFunction.#ctor(System.String,NHibernate.Type.IType)">
      <summary>
            Initializes a new instance of the StandardSQLFunction class.
            </summary>
      <param name="name">SQL function name.</param>
      <param name="typeValue">Return type for the fuction.</param>
    </member>
    <member name="T:NHibernate.Dialect.Function.StandardSafeSQLFunction">
      <summary>
            Provides a standard implementation that supports the majority of the HQL
            functions that are translated to SQL.
            </summary>
      <remarks>
            The Dialect and its sub-classes use this class to provide details required
            for processing of the associated function.
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Function.StandardSafeSQLFunction.#ctor(System.String,System.Int32)">
      <summary>
            Initializes a new instance of the StandardSafeSQLFunction class.
            </summary>
      <param name="name">SQL function name.</param>
      <param name="allowedArgsCount">Exact number of arguments expected.</param>
    </member>
    <member name="M:NHibernate.Dialect.Function.StandardSafeSQLFunction.#ctor(System.String,NHibernate.Type.IType,System.Int32)">
      <summary>
            Initializes a new instance of the StandardSafeSQLFunction class.
            </summary>
      <param name="name">SQL function name.</param>
      <param name="typeValue">Return type for the fuction.</param>
      <param name="allowedArgsCount">Exact number of arguments expected.</param>
    </member>
    <member name="T:NHibernate.Dialect.Function.VarArgsSQLFunction">
      <summary>
            Support for slightly more general templating than StandardSQLFunction,
            with an unlimited number of arguments.
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.Lock.ILockingStrategy">
      <summary> 
            A strategy abstraction for how locks are obtained in the underlying database.
            </summary>
      <remarks>
            All locking provided implemenations assume the underlying database supports
            (and that the connection is in) at least read-committed transaction isolation.
            The most glaring exclusion to this is HSQLDB which only offers support for
            READ_UNCOMMITTED isolation.
            </remarks>
      <seealso cref="M:NHibernate.Dialect.Dialect.GetLockingStrategy(NHibernate.Persister.Entity.ILockable,NHibernate.LockMode)" />
    </member>
    <member name="M:NHibernate.Dialect.Lock.ILockingStrategy.Lock(System.Object,System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Acquire an appropriate type of lock on the underlying data that will
            endure until the end of the current transaction.
            </summary>
      <param name="id">The id of the row to be locked </param>
      <param name="version">The current version (or null if not versioned) </param>
      <param name="obj">The object logically being locked (currently not used) </param>
      <param name="session">The session from which the lock request originated </param>
    </member>
    <member name="T:NHibernate.Dialect.Lock.SelectLockingStrategy">
      <summary> 
            A locking strategy where the locks are obtained through select statements.
             </summary>
      <seealso cref="M:NHibernate.Dialect.Dialect.GetForUpdateString(NHibernate.LockMode)" />
      <seealso cref="M:NHibernate.Dialect.Dialect.AppendLockHint(NHibernate.LockMode,System.String)" />
      <remarks>
            For non-read locks, this is achieved through the Dialect's specific
            SELECT ... FOR UPDATE syntax.
            </remarks>
    </member>
    <member name="T:NHibernate.Dialect.Lock.UpdateLockingStrategy">
      <summary> 
            A locking strategy where the locks are obtained through update statements.
            </summary>
      <remarks> This strategy is not valid for read style locks. </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Lock.UpdateLockingStrategy.#ctor(NHibernate.Persister.Entity.ILockable,NHibernate.LockMode)">
      <summary> 
            Construct a locking strategy based on SQL UPDATE statements.
            </summary>
      <param name="lockable">The metadata for the entity to be locked. </param>
      <param name="lockMode">Indictates the type of lock to be acquired. </param>
      <remarks>
            read-locks are not valid for this strategy.
            </remarks>
    </member>
    <member name="T:NHibernate.Dialect.Schema.IDataBaseSchema">
      <summary>
            This class is specific of NHibernate and supply DatabaseMetaData of Java.
            In the .NET Framework, there is no direct equivalent.
            </summary>
      <remarks>
            Implementation is provide by a dialect.
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetTables(System.String,System.String,System.String,System.String[])">
      <summary>
            Gets a description of the tables available for the catalog
            </summary>
      <param name="catalog">A catalog, retrieves those without a catalog</param>
      <param name="schemaPattern">Schema pattern, retrieves those without the schema</param>
      <param name="tableNamePattern">A table name pattern</param>
      <param name="types">a list of table types to include</param>
      <returns>Each row</returns>
    </member>
    <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetTableMetadata(System.Data.DataRow,System.Boolean)">
      <summary>
            Get the Table MetaData.
            </summary>
      <param name="rs">The <see cref="T:System.Data.DataRow" /> resultSet of <see cref="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetTables(System.String,System.String,System.String,System.String[])" />.</param>
      <param name="extras">Include FKs and indexes</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetColumns(System.String,System.String,System.String,System.String)">
      <summary>
            Gets a description of the table columns available
            </summary>
      <param name="catalog">A catalog, retrieves those without a catalog</param>
      <param name="schemaPattern">Schema pattern, retrieves those without the schema</param>
      <param name="tableNamePattern">A table name pattern</param>
      <param name="columnNamePattern">a columng name patterm</param>
      <returns>A description of the table columns available</returns>
    </member>
    <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetIndexInfo(System.String,System.String,System.String)">
      <summary>
            Get a description of the given table's indices and statistics.
            </summary>
      <param name="catalog">A catalog, retrieves those without a catalog</param>
      <param name="schemaPattern">Schema pattern, retrieves those without the schema</param>
      <param name="tableName">A table name pattern</param>
      <returns>A description of the table's indices available</returns>
      <remarks>The result is relative to the schema collections "Indexes".</remarks>
    </member>
    <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetIndexColumns(System.String,System.String,System.String,System.String)">
      <summary>
            Get a description of the given table's indices and statistics.
            </summary>
      <param name="catalog">A catalog, retrieves those without a catalog</param>
      <param name="schemaPattern">Schema pattern, retrieves those without the schema</param>
      <param name="tableName">A table name pattern</param>
      <param name="indexName">The name of the index</param>
      <returns>A description of the table's indices available</returns>
      <remarks>The result is relative to the schema collections "IndexColumns".</remarks>
    </member>
    <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetForeignKeys(System.String,System.String,System.String)">
      <summary>
            Gets a description of the foreign keys available
            </summary>
      <param name="catalog">A catalog, retrieves those without a catalog</param>
      <param name="schema">Schema name, retrieves those without the schema</param>
      <param name="table">A table name</param>
      <returns>A description of the foreign keys available</returns>
    </member>
    <member name="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetReservedWords">
      <summary>
            Get all reserved words
            </summary>
      <returns>A set of reserved words</returns>
    </member>
    <member name="P:NHibernate.Dialect.Schema.IDataBaseSchema.StoresMixedCaseQuotedIdentifiers">
      <summary>
            In the Java language, this field indicates that the database treats mixed-case, 
            quoted SQL identifiers as case-insensitive and stores them in mixed case.
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Schema.IDataBaseSchema.StoresUpperCaseQuotedIdentifiers">
      <summary>
            In the Java language, this field indicates that the database treats mixed-case, 
            quoted SQL identifiers as case-insensitive and stores them in upper case.
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Schema.IDataBaseSchema.StoresUpperCaseIdentifiers">
      <summary>
            In the Java language, this field indicates that the database treats mixed-case, 
            unquoted SQL identifiers as case-insensitive and stores them in upper case.
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Schema.IDataBaseSchema.StoresLowerCaseQuotedIdentifiers">
      <summary>
            In the Java language, this field indicates that the database treats mixed-case, 
            quoted SQL identifiers as case-insensitive and stores them in lower case. 
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Schema.IDataBaseSchema.StoresLowerCaseIdentifiers">
      <summary>
            In the Java language, this field indicates that the database treats mixed-case, 
            unquoted SQL identifiers as case-insensitive and stores them in lower case, 
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Schema.IDataBaseSchema.ColumnNameForTableName">
      <summary>
            The name of the column that represent the TABLE_NAME in the <see cref="T:System.Data.DataTable" />
            returned by <see cref="M:NHibernate.Dialect.Schema.IDataBaseSchema.GetTables(System.String,System.String,System.String,System.String[])" />.
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.Schema.AbstractDataBaseSchema">
      <summary>
            Common implementation of schema reader.
            </summary>
      <remarks>
            This implementation of <see cref="T:NHibernate.Dialect.Schema.IDataBaseSchema" /> is based on the new <see cref="T:System.Data.Common.DbConnection" /> of
            .NET 2.0.
            </remarks>
      <seealso cref="M:System.Data.Common.DbConnection.GetSchema" />
    </member>
    <member name="T:NHibernate.Dialect.Dialect">
      <summary>
            Represents a dialect of SQL implemented by a particular RDBMS. Subclasses
            implement NHibernate compatibility with different systems.
            </summary>
      <remarks>
            Subclasses should provide a public default constructor that <c>Register()</c>
            a set of type mappings and default Hibernate properties.
            </remarks>
    </member>
    <member name="F:NHibernate.Dialect.Dialect.DefaultBatchSize">
      <summary>
      </summary>
    </member>
    <member name="F:NHibernate.Dialect.Dialect.NoBatch">
      <summary>
      </summary>
    </member>
    <member name="F:NHibernate.Dialect.Dialect.PossibleQuoteChars">
      <summary>
            Characters used for quoting sql identifiers
            </summary>
    </member>
    <member name="F:NHibernate.Dialect.Dialect.PossibleClosedQuoteChars">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.#ctor">
      <summary>
            The base constructor for Dialect.
            </summary>
      <remarks>
            Every subclass should override this and call Register() with every <see cref="T:System.Data.DbType" /> except
            <see cref="F:System.Data.DbType.Object" />, <see cref="F:System.Data.DbType.SByte" />, <see cref="F:System.Data.DbType.UInt16" />, <see cref="F:System.Data.DbType.UInt32" />, 
            <see cref="F:System.Data.DbType.UInt64" />, <see cref="F:System.Data.DbType.VarNumeric" />.
            
            <para>
            The Default properties for this Dialect should also be set - such as whether or not to use outer-joins
            and what the batch size should be.
            </para></remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetDialect">
      <summary> Get an instance of the dialect specified by the current <see cref="T:NHibernate.Cfg.Environment" /> properties. </summary>
      <returns> The specified Dialect </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetDialect(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Get de <see cref="T:NHibernate.Dialect.Dialect" /> from a property bag (prop name <see cref="F:NHibernate.Cfg.Environment.Dialect" />)
            </summary>
      <param name="props">The property bag.</param>
      <returns>An instance of <see cref="T:NHibernate.Dialect.Dialect" />.</returns>
      <exception cref="T:System.ArgumentNullException">When <paramref name="props" /> is null.</exception>
      <exception cref="T:NHibernate.HibernateException">When the property bag don't contains de property <see cref="F:NHibernate.Cfg.Environment.Dialect" />.</exception>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetTypeName(NHibernate.SqlTypes.SqlType)">
      <summary>
            Get the name of the database type associated with the given 
            <see cref="T:NHibernate.SqlTypes.SqlType" />,
            </summary>
      <param name="sqlType">The SqlType</param>
      <returns>The database type name used by ddl.</returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetTypeName(NHibernate.SqlTypes.SqlType,System.Int32,System.Int32,System.Int32)">
      <summary>
            Get the name of the database type associated with the given
            <see cref="T:NHibernate.SqlTypes.SqlType" />.
            </summary>
      <param name="sqlType">The SqlType </param>
      <param name="length">The datatype length </param>
      <param name="precision">The datatype precision </param>
      <param name="scale">The datatype scale </param>
      <returns>The database type name used by ddl.</returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetCastTypeName(NHibernate.SqlTypes.SqlType)">
      <summary> 
            Get the name of the database type appropriate for casting operations
            (via the CAST() SQL function) for the given <see cref="T:NHibernate.SqlTypes.SqlType" /> typecode.
            </summary>
      <param name="sqlType">The <see cref="T:NHibernate.SqlTypes.SqlType" /> typecode </param>
      <returns> The database type name </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.RegisterColumnType(System.Data.DbType,System.Int32,System.String)">
      <summary>
            Subclasses register a typename for the given type code and maximum
            column length. <c>$l</c> in the type name will be replaced by the column
            length (if appropriate)
            </summary>
      <param name="code">The typecode</param>
      <param name="capacity">Maximum length of database type</param>
      <param name="name">The database type name</param>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.RegisterColumnType(System.Data.DbType,System.String)">
      <summary>
            Suclasses register a typename for the given type code. <c>$l</c> in the 
            typename will be replaced by the column length (if appropriate).
            </summary>
      <param name="code">The typecode</param>
      <param name="name">The database type name</param>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetHibernateTypeName(System.Data.DbType)">
      <summary> 
            Get the name of the Hibernate <see cref="T:NHibernate.Type.IType" /> associated with th given
            <see cref="T:System.Data.DbType" /> typecode. 
            </summary>
      <param name="code">The <see cref="T:System.Data.DbType" /> typecode </param>
      <returns> The Hibernate <see cref="T:NHibernate.Type.IType" /> name. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetHibernateTypeName(System.Data.DbType,System.Int32,System.Int32,System.Int32)">
      <summary> 
            Get the name of the Hibernate <see cref="T:NHibernate.Type.IType" /> associated
            with the given <see cref="T:System.Data.DbType" /> typecode with the given storage
            specification parameters. 
            </summary>
      <param name="code">The <see cref="T:System.Data.DbType" /> typecode </param>
      <param name="length">The datatype length </param>
      <param name="precision">The datatype precision </param>
      <param name="scale">The datatype scale </param>
      <returns> The Hibernate <see cref="T:NHibernate.Type.IType" /> name. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.RegisterHibernateType(System.Data.DbType,System.Int32,System.String)">
      <summary> 
            Registers a Hibernate <see cref="T:NHibernate.Type.IType" /> name for the given
            <see cref="T:System.Data.DbType" /> type code and maximum column length. 
            </summary>
      <param name="code">The <see cref="T:System.Data.DbType" /> typecode </param>
      <param name="capacity">The maximum length of database type </param>
      <param name="name">The Hibernate <see cref="T:NHibernate.Type.IType" /> name </param>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.RegisterHibernateType(System.Data.DbType,System.String)">
      <summary> 
            Registers a Hibernate <see cref="T:NHibernate.Type.IType" /> name for the given
            <see cref="T:System.Data.DbType" /> type code. 
            </summary>
      <param name="code">The <see cref="T:System.Data.DbType" /> typecode </param>
      <param name="name">The Hibernate <see cref="T:System.Data.DbType" /> name </param>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.RegisterFunction(System.String,NHibernate.Dialect.Function.ISQLFunction)">
      <summary>
      </summary>
      <param name="name">
      </param>
      <param name="function">
      </param>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetAddForeignKeyConstraintString(System.String,System.String[],System.String,System.String[],System.Boolean)">
      <summary> 
            The syntax used to add a foreign key constraint to a table. 
            </summary>
      <param name="constraintName">The FK constraint name. </param>
      <param name="foreignKey">The names of the columns comprising the FK </param>
      <param name="referencedTable">The table referenced by the FK </param>
      <param name="primaryKey">The explicit columns in the referencedTable referenced by this FK. </param>
      <param name="referencesPrimaryKey">
            if false, constraint should be explicit about which column names the constraint refers to 
            </param>
      <returns> the "add FK" fragment </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetAddPrimaryKeyConstraintString(System.String)">
      <summary>
            The syntax used to add a primary key constraint to a table
            </summary>
      <param name="constraintName">
      </param>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetLockingStrategy(NHibernate.Persister.Entity.ILockable,NHibernate.LockMode)">
      <summary> 
            Get a strategy instance which knows how to acquire a database-level lock
            of the specified mode for this dialect. 
            </summary>
      <param name="lockable">The persister for the entity to be locked. </param>
      <param name="lockMode">The type of lock to be acquired. </param>
      <returns> The appropriate locking strategy. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetForUpdateString(NHibernate.LockMode)">
      <summary> 
            Given a lock mode, determine the appropriate for update fragment to use. 
            </summary>
      <param name="lockMode">The lock mode to apply. </param>
      <returns> The appropriate for update fragment. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetForUpdateString(System.String)">
      <summary> 
            Get the <tt>FOR UPDATE OF column_list</tt> fragment appropriate for this
            dialect given the aliases of the columns to be write locked.
             </summary>
      <param name="aliases">The columns to be write locked. </param>
      <returns> The appropriate <tt>FOR UPDATE OF column_list</tt> clause string. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetForUpdateNowaitString(System.String)">
      <summary> 
            Get the <tt>FOR UPDATE OF column_list NOWAIT</tt> fragment appropriate
            for this dialect given the aliases of the columns to be write locked.
            </summary>
      <param name="aliases">The columns to be write locked. </param>
      <returns> The appropriate <tt>FOR UPDATE colunm_list NOWAIT</tt> clause string. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.ApplyLocksToSql(NHibernate.SqlCommand.SqlString,System.Collections.Generic.IDictionary{System.String,NHibernate.LockMode},System.Collections.Generic.IDictionary{System.String,System.String[]})">
      <summary> 
            Modifies the given SQL by applying the appropriate updates for the specified
            lock modes and key columns.
            </summary>
      <param name="sql">the SQL string to modify </param>
      <param name="aliasedLockModes">a map of lock modes indexed by aliased table names. </param>
      <param name="keyColumnNames">a map of key columns indexed by aliased table names. </param>
      <returns> the modified SQL string. </returns>
      <remarks>
            The behavior here is that of an ANSI SQL <tt>SELECT FOR UPDATE</tt>.  This
            method is really intended to allow dialects which do not support
            <tt>SELECT FOR UPDATE</tt> to achieve this in their own fashion.
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.AppendLockHint(NHibernate.LockMode,System.String)">
      <summary> 
            Some dialects support an alternative means to <tt>SELECT FOR UPDATE</tt>,
            whereby a "lock hint" is appends to the table name in the from clause.
             </summary>
      <param name="lockMode">The lock mode to apply </param>
      <param name="tableName">The name of the table to which to apply the lock hint. </param>
      <returns> The table with any required lock hints. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetDropTableString(System.String)">
      <summary>
            Return SQL needed to drop the named table. May (and should) use
            some form of "if exists" clause, and cascade constraints.
            </summary>
      <param name="tableName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GenerateTemporaryTableName(System.String)">
      <summary> Generate a temporary table name given the bas table. </summary>
      <param name="baseTableName">The table name from which to base the temp table name. </param>
      <returns> The generated temp table name. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.PerformTemporaryTableDDLInIsolation">
      <summary> 
            Does the dialect require that temporary table DDL statements occur in
            isolation from other statements?  This would be the case if the creation
            would cause any current transaction to get committed implicitly.
             </summary>
      <returns> see the result matrix above. </returns>
      <remarks>
            JDBC defines a standard way to query for this information via the
            {@link java.sql.DatabaseMetaData#dataDefinitionCausesTransactionCommit()}
            method.  However, that does not distinguish between temporary table
            DDL and other forms of DDL; MySQL, for example, reports DDL causing a
            transaction commit via its driver, even though that is not the case for
            temporary table DDL.
            <p />
            Possible return values and their meanings:<ul><li>{@link Boolean#TRUE} - Unequivocally, perform the temporary table DDL in isolation.</li><li>{@link Boolean#FALSE} - Unequivocally, do <b>not</b> perform the temporary table DDL in isolation.</li><li><i>null</i> - defer to the JDBC driver response in regards to {@link java.sql.DatabaseMetaData#dataDefinitionCausesTransactionCommit()}</li></ul></remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.DropTemporaryTableAfterUse">
      <summary> Do we need to drop the temporary table after use? </summary>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.RegisterResultSetOutParameter(System.Data.Common.DbCommand,System.Int32)">
      <summary> 
            Registers an OUT parameter which will be returing a
            <see cref="T:System.Data.Common.DbDataReader" />.  How this is accomplished varies greatly
            from DB to DB, hence its inclusion (along with {@link #getResultSet}) here.
             </summary>
      <param name="statement">The callable statement. </param>
      <param name="position">The bind position at which to register the OUT param. </param>
      <returns> The number of (contiguous) bind positions used. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetResultSet(System.Data.Common.DbCommand)">
      <summary> 
            Given a callable statement previously processed by <see cref="M:NHibernate.Dialect.Dialect.RegisterResultSetOutParameter(System.Data.Common.DbCommand,System.Int32)" />,
            extract the <see cref="T:System.Data.Common.DbDataReader" /> from the OUT parameter. 
            </summary>
      <param name="statement">The callable statement. </param>
      <returns> The extracted result set. </returns>
      <throws>  SQLException Indicates problems extracting the result set. </throws>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetDropForeignKeyConstraintString(System.String)">
      <summary>
            The syntax used to drop a foreign key constraint from a table.
            </summary>
      <param name="constraintName">The name of the foreign key constraint to drop.</param>
      <returns>
            The SQL string to drop the foreign key constraint.
            </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetIfNotExistsCreateConstraint(NHibernate.Mapping.Table,System.String)">
      <summary>
            The syntax that is used to check if a constraint does not exists before creating it
            </summary>
      <param name="table">The table.</param>
      <param name="name">The name.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetIfNotExistsCreateConstraintEnd(NHibernate.Mapping.Table,System.String)">
      <summary>
            The syntax that is used to close the if for a constraint exists check, used
            for dialects that requires begin/end for ifs
            </summary>
      <param name="table">The table.</param>
      <param name="name">The name.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetIfExistsDropConstraint(NHibernate.Mapping.Table,System.String)">
      <summary>
            The syntax that is used to check if a constraint exists before dropping it
            </summary>
      <param name="table">The table.</param>
      <param name="name">The name.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetIfExistsDropConstraintEnd(NHibernate.Mapping.Table,System.String)">
      <summary>
            The syntax that is used to close the if for a constraint exists check, used
            for dialects that requires begin/end for ifs
            </summary>
      <param name="table">The table.</param>
      <param name="name">The name.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetDropPrimaryKeyConstraintString(System.String)">
      <summary>
            The syntax used to drop a primary key constraint from a table.
            </summary>
      <param name="constraintName">The name of the primary key constraint to drop.</param>
      <returns>
            The SQL string to drop the primary key constraint.
            </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetDropIndexConstraintString(System.String)">
      <summary>
            The syntax used to drop an index constraint from a table.
            </summary>
      <param name="constraintName">The name of the index constraint to drop.</param>
      <returns>
            The SQL string to drop the primary key constraint.
            </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.AppendIdentitySelectToInsert(NHibernate.SqlCommand.SqlString)">
      <summary> 
            Provided we <see cref="P:NHibernate.Dialect.Dialect.SupportsInsertSelectIdentity" />, then attch the
            "select identity" clause to the  insert statement.
            </summary>
      <param name="insertString">The insert command </param>
      <returns> 
            The insert command with any necessary identity select clause attached.
            Note, if <see cref="P:NHibernate.Dialect.Dialect.SupportsInsertSelectIdentity" /> == false then
            the insert-string should be returned without modification.
            </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetIdentitySelectString(System.String,System.String,System.Data.DbType)">
      <summary> 
            Get the select command to use to retrieve the last generated IDENTITY
            value for a particular table 
            </summary>
      <param name="tableName">The table into which the insert was done </param>
      <param name="identityColumn">The PK column. </param>
      <param name="type">The <see cref="T:System.Data.DbType" /> type code. </param>
      <returns> The appropriate select command </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetIdentityColumnString(System.Data.DbType)">
      <summary> 
            The syntax used during DDL to define a column as being an IDENTITY of
            a particular type. 
            </summary>
      <param name="type">The <see cref="T:System.Data.DbType" /> type code. </param>
      <returns> The appropriate DDL fragment. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetSequenceNextValString(System.String)">
      <summary> 
            Generate the appropriate select statement to to retreive the next value
            of a sequence.
            </summary>
      <param name="sequenceName">the name of the sequence </param>
      <returns> String The "nextval" select string. </returns>
      <remarks>This should be a "stand alone" select statement.</remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetDropSequenceString(System.String)">
      <summary> 
            Typically dialects which support sequences can drop a sequence
            with a single command.  
            </summary>
      <param name="sequenceName">The name of the sequence </param>
      <returns> The sequence drop commands </returns>
      <remarks>
            This is convenience form of <see cref="M:NHibernate.Dialect.Dialect.GetDropSequenceStrings(System.String)" />
            to help facilitate that.
            
            Dialects which support sequences and can drop a sequence in a
            single command need *only* override this method.  Dialects
            which support sequences but require multiple commands to drop
            a sequence should instead override <see cref="M:NHibernate.Dialect.Dialect.GetDropSequenceStrings(System.String)" />. 
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetDropSequenceStrings(System.String)">
      <summary> 
            The multiline script used to drop a sequence. 
            </summary>
      <param name="sequenceName">The name of the sequence </param>
      <returns> The sequence drop commands </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetSelectSequenceNextValString(System.String)">
      <summary> 
            Generate the select expression fragment that will retrieve the next
            value of a sequence as part of another (typically DML) statement.
            </summary>
      <param name="sequenceName">the name of the sequence </param>
      <returns> The "nextval" fragment. </returns>
      <remarks>
            This differs from <see cref="M:NHibernate.Dialect.Dialect.GetSequenceNextValString(System.String)" /> in that this
            should return an expression usable within another statement.
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetCreateSequenceString(System.String)">
      <summary> 
            Typically dialects which support sequences can create a sequence
            with a single command.
            </summary>
      <param name="sequenceName">The name of the sequence </param>
      <returns> The sequence creation command </returns>
      <remarks>
            This is convenience form of <see cref="M:NHibernate.Dialect.Dialect.GetCreateSequenceStrings(System.String,System.Int32,System.Int32)" /> to help facilitate that.
            Dialects which support sequences and can create a sequence in a
            single command need *only* override this method.  Dialects
            which support sequences but require multiple commands to create
            a sequence should instead override <see cref="M:NHibernate.Dialect.Dialect.GetCreateSequenceStrings(System.String,System.Int32,System.Int32)" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetCreateSequenceStrings(System.String,System.Int32,System.Int32)">
      <summary> 
            An optional multi-line form for databases which <see cref="P:NHibernate.Dialect.Dialect.SupportsPooledSequences" />. 
            </summary>
      <param name="sequenceName">The name of the sequence </param>
      <param name="initialValue">The initial value to apply to 'create sequence' statement </param>
      <param name="incrementSize">The increment value to apply to 'create sequence' statement </param>
      <returns> The sequence creation commands </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetCreateSequenceString(System.String,System.Int32,System.Int32)">
      <summary> 
            Overloaded form of <see cref="M:NHibernate.Dialect.Dialect.GetCreateSequenceString(System.String)" />, additionally
            taking the initial value and increment size to be applied to the sequence
            definition.
             </summary>
      <param name="sequenceName">The name of the sequence </param>
      <param name="initialValue">The initial value to apply to 'create sequence' statement </param>
      <param name="incrementSize">The increment value to apply to 'create sequence' statement </param>
      <returns> The sequence creation command </returns>
      <remarks>
            The default definition is to suffix <see cref="M:NHibernate.Dialect.Dialect.GetCreateSequenceString(System.String,System.Int32,System.Int32)" />
            with the string: " start with {initialValue} increment by {incrementSize}" where
            {initialValue} and {incrementSize} are replacement placeholders.  Generally
            dialects should only need to override this method if different key phrases
            are used to apply the allocation information.
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.CreateOuterJoinFragment">
      <summary> 
            Create a <see cref="T:NHibernate.SqlCommand.JoinFragment" /> strategy responsible
            for handling this dialect's variations in how joins are handled. 
            </summary>
      <returns> This dialect's <see cref="T:NHibernate.SqlCommand.JoinFragment" /> strategy. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.CreateCaseFragment">
      <summary> 
            Create a <see cref="T:NHibernate.SqlCommand.CaseFragment" /> strategy responsible
            for handling this dialect's variations in how CASE statements are
            handled. 
            </summary>
      <returns> This dialect's <see cref="T:NHibernate.SqlCommand.CaseFragment" /> strategy. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.ToBooleanValueString(System.Boolean)">
      <summary> The SQL literal value to which this database maps boolean values. </summary>
      <param name="value">The boolean value </param>
      <returns> The appropriate SQL literal. </returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
      <summary>
            Add a <c>LIMIT</c> clause to the given SQL <c>SELECT</c></summary>
      <param name="querySqlString">A Query in the form of a SqlString.</param>
      <param name="offset">Offset of the first row to be returned by the query (zero-based)</param>
      <param name="limit">Maximum number of rows to be returned by the query</param>
      <returns>A new SqlString that contains the <c>LIMIT</c> clause.</returns>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
      <summary> Apply s limit clause to the query. </summary>
      <param name="querySqlString">The query to which to apply the limit. </param>
      <param name="hasOffset">Is the query requesting an offset? </param>
      <returns> the modified SQL </returns>
      <remarks>
            Typically dialects utilize <see cref="P:NHibernate.Dialect.Dialect.SupportsVariableLimit" />
            limit caluses when they support limits.  Thus, when building the
            select command we do not actually need to know the limit or the offest
            since we will just be using placeholders.
            <p />
            Here we do still pass along whether or not an offset was specified
            so that dialects not supporting offsets can generate proper exceptions.
            In general, dialects will override one or the other of this method and
            <see cref="M:NHibernate.Dialect.Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.IsQuoted(System.String)">
      <summary>
            Checks to see if the name has been quoted.
            </summary>
      <param name="name">The name to check if it is quoted</param>
      <returns>true if name is already quoted.</returns>
      <remarks>
            The default implementation is to compare the first character
            to Dialect.OpenQuote and the last char to Dialect.CloseQuote
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.Quote(System.String)">
      <summary>
            Quotes a name.
            </summary>
      <param name="name">The string that needs to be Quoted.</param>
      <returns>A QuotedName </returns>
      <remarks>
        <p>
            This method assumes that the name is not already Quoted.  So if the name passed
            in is <c>"name</c> then it will return <c>"""name"</c>.  It escapes the first char
            - the " with "" and encloses the escaped string with OpenQuote and CloseQuote. 
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.QuoteForAliasName(System.String)">
      <summary>
            Quotes a name for being used as a aliasname
            </summary>
      <remarks>Original implementation calls <see cref="M:NHibernate.Dialect.Dialect.QuoteForTableName(System.String)" /></remarks>
      <param name="aliasName">Name of the alias</param>
      <returns>A Quoted name in the format of OpenQuote + aliasName + CloseQuote</returns>
      <remarks>
        <p>
            If the aliasName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the aliasName that was passed in without going through any
            Quoting process.  So if aliasName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.QuoteForColumnName(System.String)">
      <summary>
            Quotes a name for being used as a columnname
            </summary>
      <remarks>Original implementation calls <see cref="M:NHibernate.Dialect.Dialect.QuoteForTableName(System.String)" /></remarks>
      <param name="columnName">Name of the column</param>
      <returns>A Quoted name in the format of OpenQuote + columnName + CloseQuote</returns>
      <remarks>
        <p>
            If the columnName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the columnName that was passed in without going through any
            Quoting process.  So if columnName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.QuoteForTableName(System.String)">
      <summary>
            Quotes a name for being used as a tablename
            </summary>
      <param name="tableName">Name of the table</param>
      <returns>A Quoted name in the format of OpenQuote + tableName + CloseQuote</returns>
      <remarks>
        <p>
            If the tableName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the tableName that was passed in without going through any
            Quoting process.  So if tableName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.QuoteForSchemaName(System.String)">
      <summary>
            Quotes a name for being used as a schemaname
            </summary>
      <param name="schemaName">Name of the schema</param>
      <returns>A Quoted name in the format of OpenQuote + schemaName + CloseQuote</returns>
      <remarks>
        <p>
            If the schemaName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the schemaName that was passed in without going through any
            Quoting process.  So if schemaName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.UnQuote(System.String)">
      <summary>
            Unquotes and unescapes an already quoted name
            </summary>
      <param name="quoted">Quoted string</param>
      <returns>Unquoted string</returns>
      <remarks>
        <p>
            This method checks the string <c>quoted</c> to see if it is 
            quoted.  If the string <c>quoted</c> is already enclosed in the OpenQuote
            and CloseQuote then those chars are removed.
            </p>
        <p>
            After the OpenQuote and CloseQuote have been cleaned from the string <c>quoted</c>
            then any chars in the string <c>quoted</c> that have been escaped by doubling them
            up are changed back to a single version.
            </p>
        <p>
            The following quoted values return these results
            "quoted" = quoted
            "quote""d" = quote"d
            quote""d = quote"d 
            </p>
        <p>
            If this implementation is not sufficient for your Dialect then it needs to be overridden.
            MsSql2000Dialect is an example of where UnQuoting rules are different.
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.UnQuote(System.String[])">
      <summary>
            Unquotes an array of Quoted Names.
            </summary>
      <param name="quoted">strings to Unquote</param>
      <returns>an array of unquoted strings.</returns>
      <remarks>
            This use UnQuote(string) for each string in the quoted array so
            it should not need to be overridden - only UnQuote(string) needs
            to be overridden unless this implementation is not sufficient.
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.GetSelectClauseNullString(NHibernate.SqlTypes.SqlType)">
      <summary> 
            Given a <see cref="T:System.Data.DbType" /> type code, determine an appropriate
            null value to use in a select clause.
            </summary>
      <param name="sqlType">The <see cref="T:System.Data.DbType" /> type code. </param>
      <returns> The appropriate select clause value fragment. </returns>
      <remarks>
            One thing to consider here is that certain databases might
            require proper casting for the nulls here since the select here
            will be part of a UNION/UNION ALL.
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.Dialect.BuildSQLExceptionConverter">
      <summary> 
            Build an instance of the <see cref="T:NHibernate.Exceptions.ISQLExceptionConverter" /> preferred by this dialect for
            converting <see cref="T:System.Data.Common.DbException" /> into NHibernate's ADOException hierarchy.  
            </summary>
      <returns> The Dialect's preferred <see cref="T:NHibernate.Exceptions.ISQLExceptionConverter" />. </returns>
      <remarks>
            The default Dialect implementation simply returns a converter based on X/Open SQLState codes.
            <para />
            It is strongly recommended that specific Dialect implementations override this
            method, since interpretation of a SQL error is much more accurate when based on
            the ErrorCode rather than the SQLState. Unfortunately, the ErrorCode is a vendor-specific approach. 
            </remarks>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.DefaultProperties">
      <summary>
            Retrieve a set of default Hibernate properties for this database.
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.Functions">
      <summary>
            Aggregate SQL functions as defined in general. This is
            a case-insensitive hashtable!
            </summary>
      <remarks>
            The results of this method should be integrated with the 
            specialization's data.
            </remarks>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.NativeIdentifierGeneratorClass">
      <summary> 
            The class (which implements <see cref="T:NHibernate.Id.IIdentifierGenerator" />)
            which acts as this dialects native generation strategy.
            </summary>
      <returns> The native generator class. </returns>
      <remarks>
            Comes into play whenever the user specifies the native generator.
            </remarks>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.IdentityInsertString">
      <summary>
            The keyword used to insert a generated value into an identity column (or null).
            Need if the dialect does not support inserts that specify no column values.
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.QuerySequencesString">
      <summary> Get the select command used retrieve the names of all sequences.</summary>
      <returns> The select command; or null if sequences are not supported. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SelectGUIDString">
      <summary> 
            Get the command used to select a GUID from the underlying database.
            (Optional operation.)
             </summary>
      <returns> The appropriate command. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.CreateTableString">
      <summary> Command used to create a table. </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.CreateMultisetTableString">
      <summary> 
            Slight variation on <see cref="P:NHibernate.Dialect.Dialect.CreateTableString" />.
            The command used to create a multiset table. 
            </summary>
      <remarks>
            Here, we have the command used to create a table when there is no primary key and
            duplicate rows are expected.
            <p />
            Most databases do not care about the distinction; originally added for
            Teradata support which does care.
            </remarks>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.CreateTemporaryTableString">
      <summary> Command used to create a temporary table. </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.CreateTemporaryTablePostfix">
      <summary> 
            Get any fragments needing to be postfixed to the command for
            temporary table creation. 
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.IsCurrentTimestampSelectStringCallable">
      <summary> 
            Should the value returned by <see cref="P:NHibernate.Dialect.Dialect.CurrentTimestampSelectString" />
            be treated as callable.  Typically this indicates that JDBC escape
            sytnax is being used...
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.CurrentTimestampSelectString">
      <summary> 
            Retrieve the command used to retrieve the current timestammp from the database. 
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.CurrentTimestampSQLFunctionName">
      <summary> 
            The name of the database-specific SQL function for retrieving the
            current timestamp. 
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.NoColumnsInsertString">
      <summary>
            The keyword used to insert a row without specifying any column values
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.LowercaseFunction">
      <summary>
            The name of the SQL function that transforms a string to lowercase
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.AddColumnString">
      <summary>
            The syntax used to add a column to a table. Note this is deprecated
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.NullColumnString">
      <summary>
            The keyword used to specify a nullable column
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.CascadeConstraintsString">
      <summary>
            Completely optional cascading drop clause
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.PrimaryKeyString">
      <summary>
            The keyword used to create a primary key constraint
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.HasAlterTable">
      <summary>
            Does this dialect support the <c>ALTER TABLE</c> syntax?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.DropConstraints">
      <summary>
            Do we need to drop constraints before dropping tables in the dialect?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.QualifyIndexName">
      <summary>
            Do we need to qualify index names with the schema name?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsUnique">
      <summary>
            Does this dialect support the <c>UNIQUE</c> column syntax?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsUniqueConstraintInCreateAlterTable">
      <summary> Does this dialect support adding Unique constraints via create and alter table ?</summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsIfExistsBeforeTableName">
      <summary>
            Does the dialect support the syntax 'drop table if exists NAME'
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsIfExistsAfterTableName">
      <summary>
            Does the dialect support the syntax 'drop table NAME if exists'
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsColumnCheck">
      <summary> Does this dialect support column-level check constraints? </summary>
      <returns> True if column-level CHECK constraints are supported; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsTableCheck">
      <summary> Does this dialect support table-level check constraints? </summary>
      <returns> True if table-level CHECK constraints are supported; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.ForUpdateString">
      <summary>
            Get the string to append to SELECT statements to acquire locks
            for this dialect.
            </summary>
      <value>The appropriate <c>FOR UPDATE</c> clause string.</value>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.ForUpdateOfColumns">
      <summary> Is <tt>FOR UPDATE OF</tt> syntax supported? </summary>
      <value> True if the database supports <tt>FOR UPDATE OF</tt> syntax; false otherwise. </value>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsOuterJoinForUpdate">
      <summary> 
            Does this dialect support <tt>FOR UPDATE</tt> in conjunction with outer joined rows?
            </summary>
      <value> True if outer joined rows can be locked via <tt>FOR UPDATE</tt>. </value>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.ForUpdateNowaitString">
      <summary>
            Retrieves the <c>FOR UPDATE NOWAIT</c> syntax specific to this dialect
            </summary>
      <value>The appropriate <c>FOR UPDATE NOWAIT</c> clause string.</value>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsTemporaryTables">
      <summary> Does this dialect support temporary tables? </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsCurrentTimestampSelection">
      <summary> Does this dialect support a way to retrieve the database's current timestamp value? </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.TimestampResolutionInTicks">
      <summary>
            Gives the best resolution that the database can use for storing
            date/time values, in ticks.
            </summary>
      <remarks>
        <para>
            For example, if the database can store values with 100-nanosecond
            precision, this property is equal to 1L. If the database can only
            store values with 1-millisecond precision, this property is equal
            to 10000L (number of ticks in a millisecond).
            </para>
        <para>
            Used in TimestampType.
            </para>
      </remarks>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsSubSelects">
      <summary>
            Does this dialect support subselects?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsIdentityColumns">
      <summary>
            Does this dialect support identity column key generation?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsInsertSelectIdentity">
      <summary> 
            Does the dialect support some form of inserting and selecting
            the generated IDENTITY value all in the same statement.
             </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.HasDataTypeInIdentityColumn">
      <summary>
            Whether this dialect has an identity clause added to the data type or a
            completely separate identity data type.
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.IdentitySelectString">
      <summary> 
            Get the select command to use to retrieve the last generated IDENTITY value.
            </summary>
      <returns> The appropriate select command </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.IdentityColumnString">
      <summary>
            The keyword used to specify an identity column, if native key generation is supported
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsSequences">
      <summary>
            Does this dialect support sequences?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsPooledSequences">
      <summary> 
            Does this dialect support "pooled" sequences.  Not aware of a better
            name for this.  Essentially can we specify the initial and increment values? 
            </summary>
      <returns> True if such "pooled" sequences are supported; false otherwise. </returns>
      <seealso cref="M:NHibernate.Dialect.Dialect.GetCreateSequenceStrings(System.String,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:NHibernate.Dialect.Dialect.GetCreateSequenceString(System.String,System.Int32,System.Int32)">
      </seealso>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsLimit">
      <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
      <value>False, unless overridden.</value>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsLimitOffset">
      <summary>
            Does this Dialect support an offset?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsVariableLimit">
      <summary>
            Can parameters be used for a statement containing a LIMIT?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.BindLimitParametersInReverseOrder">
      <summary>
            Does the <c>LIMIT</c> clause specify arguments in the "reverse" order
            limit, offset instead of offset, limit?
            </summary>
      <value>False, unless overridden.</value>
      <remarks>Inheritors should return true if the correct order is limit, offset</remarks>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.BindLimitParametersFirst">
      <summary>
            Does the <c>LIMIT</c> clause come at the start of the 
            <c>SELECT</c> statement rather than at the end?
            </summary>
      <value>false, unless overridden</value>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.UseMaxForLimit">
      <summary> 
            Does the <tt>LIMIT</tt> clause take a "maximum" row number instead
            of a total number of returned rows?
            </summary>
      <returns> True if limit is relative from offset; false otherwise. </returns>
      <remarks>
            This is easiest understood via an example.  Consider you have a table
            with 20 rows, but you only want to retrieve rows number 11 through 20.
            Generally, a limit with offset would say that the offset = 11 and the
            limit = 10 (we only want 10 rows at a time); this is specifying the
            total number of returned rows.  Some dialects require that we instead
            specify offset = 11 and limit = 20, where 20 is the "last" row we want
            relative to offset (i.e. total number of rows = 20 - 11 = 9)
            So essentially, is limit relative from offset?  Or is limit absolute?
            </remarks>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.OpenQuote">
      <summary>
            The opening quote for a quoted identifier.
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.CloseQuote">
      <summary>
            The closing quote for a quoted identifier.
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsUnionAll">
      <summary> 
            Does this dialect support UNION ALL, which is generally a faster variant of UNION? 
            True if UNION ALL is supported; false otherwise.
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsEmptyInList">
      <summary> 
            Does this dialect support empty IN lists?
            For example, is [where XYZ in ()] a supported construct?
            </summary>
      <returns> True if empty in lists are supported; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.AreStringComparisonsCaseInsensitive">
      <summary> 
            Are string comparisons implicitly case insensitive.
            In other words, does [where 'XYZ' = 'xyz'] resolve to true? 
            </summary>
      <returns> True if comparisons are case insensitive. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsRowValueConstructorSyntax">
      <summary> 
            Is this dialect known to support what ANSI-SQL terms "row value
            constructor" syntax; sometimes called tuple syntax.
            <p />
            Basically, does it support syntax like
            "... where (FIRST_NAME, LAST_NAME) = ('Steve', 'Ebersole') ...". 
            </summary>
      <returns> 
            True if this SQL dialect is known to support "row value
            constructor" syntax; false otherwise.
            </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsRowValueConstructorSyntaxInInList">
      <summary> 
            If the dialect supports {@link #supportsRowValueConstructorSyntax() row values},
            does it offer such support in IN lists as well?
            <p />
            For example, "... where (FIRST_NAME, LAST_NAME) IN ( (?, ?), (?, ?) ) ..." 
            </summary>
      <returns> 
            True if this SQL dialect is known to support "row value
            constructor" syntax in the IN list; false otherwise.
            </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.UseInputStreamToInsertBlob">
      <summary> 
            Should LOBs (both BLOB and CLOB) be bound using stream operations (i.e.
            {@link java.sql.PreparedStatement#setBinaryStream}). 
            </summary>
      <returns> True if BLOBs and CLOBs should be bound using stream operations. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsParametersInInsertSelect">
      <summary> 
            Does this dialect support parameters within the select clause of
            INSERT ... SELECT ... statements? 
            </summary>
      <returns> True if this is supported; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsResultSetPositionQueryMethodsOnForwardOnlyCursor">
      <summary> 
            Does this dialect support asking the result set its positioning
            information on forward only cursors.  Specifically, in the case of
            scrolling fetches, Hibernate needs to use
            {@link java.sql.ResultSet#isAfterLast} and
            {@link java.sql.ResultSet#isBeforeFirst}.  Certain drivers do not
            allow access to these methods for forward only cursors.
            <p />
            NOTE : this is highly driver dependent! 
            </summary>
      <returns> 
            True if methods like {@link java.sql.ResultSet#isAfterLast} and
            {@link java.sql.ResultSet#isBeforeFirst} are supported for forward
            only cursors; false otherwise.
            </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsCircularCascadeDeleteConstraints">
      <summary> 
            Does this dialect support definition of cascade delete constraints
            which can cause circular chains? 
            </summary>
      <returns> True if circular cascade delete constraints are supported; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsSubselectAsInPredicateLHS">
      <summary> 
            Are subselects supported as the left-hand-side (LHS) of
            IN-predicates.
            <para />
            In other words, is syntax like "... {subquery} IN (1, 2, 3) ..." supported? 
            </summary>
      <returns> True if subselects can appear as the LHS of an in-predicate;false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsExpectedLobUsagePattern">
      <summary> 
            Expected LOB usage pattern is such that I can perform an insert
            via prepared statement with a parameter binding for a LOB value
            without crazy casting to JDBC driver implementation-specific classes...
            <p />
            Part of the trickiness here is the fact that this is largely
            driver dependent.  For example, Oracle (which is notoriously bad with
            LOB support in their drivers historically) actually does a pretty good
            job with LOB support as of the 10.2.x versions of their drivers... 
            </summary>
      <returns> 
            True if normal LOB usage patterns can be used with this driver;
            false if driver-specific hookiness needs to be applied.
            </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsLobValueChangePropogation">
      <summary> Does the dialect support propagating changes to LOB
            values back to the database?  Talking about mutating the
            internal value of the locator as opposed to supplying a new
            locator instance...
            <p />
            For BLOBs, the internal value might be changed by:
            {@link java.sql.Blob#setBinaryStream},
            {@link java.sql.Blob#setBytes(long, byte[])},
            {@link java.sql.Blob#setBytes(long, byte[], int, int)},
            or {@link java.sql.Blob#truncate(long)}.
            <p />
            For CLOBs, the internal value might be changed by:
            {@link java.sql.Clob#setAsciiStream(long)},
            {@link java.sql.Clob#setCharacterStream(long)},
            {@link java.sql.Clob#setString(long, String)},
            {@link java.sql.Clob#setString(long, String, int, int)},
            or {@link java.sql.Clob#truncate(long)}.
            <p />
            NOTE : I do not know the correct answer currently for
            databases which (1) are not part of the cruise control process
            or (2) do not {@link #supportsExpectedLobUsagePattern}. 
            </summary>
      <returns> True if the changes are propagated back to the database; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsUnboundedLobLocatorMaterialization">
      <summary> 
            Is it supported to materialize a LOB locator outside the transaction in
            which it was created?
            <p />
            Again, part of the trickiness here is the fact that this is largely
            driver dependent.
            <p />
            NOTE: all database I have tested which {@link #supportsExpectedLobUsagePattern()}
            also support the ability to materialize a LOB outside the owning transaction... 
            </summary>
      <returns> True if unbounded materialization is supported; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsSubqueryOnMutatingTable">
      <summary> 
            Does this dialect support referencing the table being mutated in
            a subquery.  The "table being mutated" is the table referenced in
            an UPDATE or a DELETE query.  And so can that table then be
            referenced in a subquery of said UPDATE/DELETE query.
            <p />
            For example, would the following two syntaxes be supported:<ul><li>delete from TABLE_A where ID not in ( select ID from TABLE_A )</li><li>update TABLE_A set NON_ID = 'something' where ID in ( select ID from TABLE_A)</li></ul></summary>
      <returns> True if this dialect allows references the mutating table from a subquery. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsExistsInSelect">
      <summary> Does the dialect support an exists statement in the select clause? </summary>
      <returns> True if exists checks are allowed in the select clause; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.DoesReadCommittedCauseWritersToBlockReaders">
      <summary> 
            For the underlying database, is READ_COMMITTED isolation implemented by
            forcing readers to wait for write locks to be released? 
            </summary>
      <returns> True if writers block readers to achieve READ_COMMITTED; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.DoesRepeatableReadCauseReadersToBlockWriters">
      <summary> 
            For the underlying database, is REPEATABLE_READ isolation implemented by
            forcing writers to wait for read locks to be released? 
            </summary>
      <returns> True if readers block writers to achieve REPEATABLE_READ; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.SupportsBindAsCallableArgument">
      <summary> 
            Does this dialect support using a JDBC bind parameter as an argument
            to a function or procedure call? 
            </summary>
      <returns> True if the database supports accepting bind params as args; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.Dialect.IdentityStyleIdentifierGeneratorClass">
      <summary> 
            The class (which implements <see cref="T:NHibernate.Id.IIdentifierGenerator" />)
            which acts as this dialects identity-style generation strategy.
            </summary>
      <returns> The native generator class. </returns>
      <remarks>
            Comes into play whenever the user specifies the "identity" generator.
            </remarks>
    </member>
    <member name="T:NHibernate.Exceptions.IViolatedConstraintNameExtracter">
      <summary> 
            Defines a contract for implementations that can extract the name of a violated
            constraint from a SQLException that is the result of that constraint violation. 
            </summary>
    </member>
    <member name="M:NHibernate.Exceptions.IViolatedConstraintNameExtracter.ExtractConstraintName(System.Data.Common.DbException)">
      <summary> 
            Extract the name of the violated constraint from the given SQLException. 
            </summary>
      <param name="sqle">The exception that was the result of the constraint violation. </param>
      <returns> The extracted constraint name. </returns>
    </member>
    <member name="T:NHibernate.Dialect.DB2Dialect">
      <summary>
            An SQL dialect for DB2.
            </summary>
      <remarks>
            The DB2Dialect defaults the following configuration properties:
            <list type="table"><listheader><term>Property</term><description>Default Value</description></listheader><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.DB2Driver" /></description></item></list></remarks>
    </member>
    <member name="M:NHibernate.Dialect.DB2Dialect.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.DB2Dialect.GetSequenceNextValString(System.String)">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.DB2Dialect.GetCreateSequenceString(System.String)">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.DB2Dialect.GetDropSequenceString(System.String)">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.DB2Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
      <summary>
            Add a <c>LIMIT</c> clause to the given SQL <c>SELECT</c></summary>
      <param name="querySqlString">A Query in the form of a SqlString.</param>
      <param name="hasOffset">Offset of the first row is not zero</param>
      <returns>A new SqlString that contains the <c>LIMIT</c> clause.</returns>
    </member>
    <member name="P:NHibernate.Dialect.DB2Dialect.AddColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.DB2Dialect.DropConstraints">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.DB2Dialect.SupportsIdentityColumns">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.DB2Dialect.IdentitySelectString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.DB2Dialect.IdentityColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.DB2Dialect.IdentityInsertString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.DB2Dialect.SupportsSequences">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.DB2Dialect.SupportsLimit">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.DB2Dialect.BindLimitParametersInReverseOrder">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.DB2Dialect.UseMaxForLimit">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Dialect.DB2400Dialect">
      <summary>
            An SQL dialect for DB2 on iSeries OS/400.
            </summary>
      <remarks>
            The DB2400Dialect defaults the following configuration properties:
            <list type="table"><listheader><term>Property</term><description>Default Value</description></listheader><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.DB2400Driver" /></description></item></list></remarks>
    </member>
    <member name="T:NHibernate.Dialect.FirebirdDialect">
      <summary>
            Summary description for FirebirdDialect.
            </summary>
      <remarks>
            The FirebirdDialect defaults the following configuration properties:
            <list type="table"><listheader><term>Property</term><description>Default Value</description></listheader><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.FirebirdDriver" /></description></item></list></remarks>
    </member>
    <member name="M:NHibernate.Dialect.FirebirdDialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
      <summary>
            Add a <c>FIRST x [SKIP] y</c> clause to the given SQL <c>SELECT</c></summary>
      <param name="querySqlString">A Query in the form of a SqlString.</param>
      <param name="limit">Maximum number of rows to be returned by the query</param>
      <param name="offset">Offset of the first row to process in the result set</param>
      <returns>A new SqlString that contains the <c>FIRST</c> clause.</returns>
    </member>
    <member name="P:NHibernate.Dialect.FirebirdDialect.AddColumnString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Dialect.GenericDialect">
      <summary>
            A generic SQL dialect which may or may not work on any actual databases
            </summary>
    </member>
    <member name="M:NHibernate.Dialect.GenericDialect.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.GenericDialect.AddColumnString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Dialect.InformixDialect">
      <summary>
            Summary description for InformixDialect.
            This dialect is intended to work with IDS version 7.31 
            However I can test only version 10.00 as I have only this version at work
            </summary>
      <remarks>
            The InformixDialect defaults the following configuration properties:
            <list type="table"><listheader><term>ConnectionDriver</term><description>NHibernate.Driver.OdbcDriver</description><term>PrepareSql</term><description>true</description></listheader><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.OdbcDriver" /></description></item></list></remarks>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect.GetForUpdateString(System.String)">
      <summary> 
            Get the <tt>FOR UPDATE OF column_list</tt> fragment appropriate for this
            dialect given the aliases of the columns to be write locked.
             </summary>
      <param name="aliases">The columns to be write locked. </param>
      <returns> The appropriate <tt>FOR UPDATE OF column_list</tt> clause string. </returns>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect.PerformTemporaryTableDDLInIsolation">
      <summary> 
            Does the dialect require that temporary table DDL statements occur in
            isolation from other statements?  This would be the case if the creation
            would cause any current transaction to get committed implicitly.
             </summary>
      <returns> see the result matrix above. </returns>
      <remarks>
            JDBC defines a standard way to query for this information via the
            {@link java.sql.DatabaseMetaData#dataDefinitionCausesTransactionCommit()}
            method.  However, that does not distinguish between temporary table
            DDL and other forms of DDL; MySQL, for example, reports DDL causing a
            transaction commit via its driver, even though that is not the case for
            temporary table DDL.
            <p />
            Possible return values and their meanings:<ul><li>{@link Boolean#TRUE} - Unequivocally, perform the temporary table DDL in isolation.</li><li>{@link Boolean#FALSE} - Unequivocally, do <b>not</b> perform the temporary table DDL in isolation.</li><li><i>null</i> - defer to the JDBC driver response in regards to {@link java.sql.DatabaseMetaData#dataDefinitionCausesTransactionCommit()}</li></ul></remarks>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect.GetIdentitySelectString(System.String,System.String,System.Data.DbType)">
      <summary> 
            Get the select command to use to retrieve the last generated IDENTITY
            value for a particular table 
            </summary>
      <param name="tableName">The table into which the insert was done </param>
      <param name="identityColumn">The PK column. </param>
      <param name="type">The <see cref="T:System.Data.DbType" /> type code. </param>
      <returns> The appropriate select command </returns>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect.GetIdentityColumnString(System.Data.DbType)">
      <summary> 
            The syntax used during DDL to define a column as being an IDENTITY of
            a particular type. 
            </summary>
      <param name="type">The <see cref="T:System.Data.DbType" /> type code. </param>
      <returns> The appropriate DDL fragment. </returns>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect.CreateOuterJoinFragment">
      <summary> 
            Create a <see cref="T:NHibernate.SqlCommand.JoinFragment" /> strategy responsible
            for handling this dialect's variations in how joins are handled. 
            </summary>
      <returns> This dialect's <see cref="T:NHibernate.SqlCommand.JoinFragment" /> strategy. </returns>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect.ToBooleanValueString(System.Boolean)">
      <summary> The SQL literal value to which this database maps boolean values. </summary>
      <param name="value">The boolean value </param>
      <returns> The appropriate SQL literal. </returns>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
      <summary> Apply s limit clause to the query. </summary>
      <param name="querySqlString">The query to which to apply the limit. </param>
      <param name="offset">Offset of the first row to be returned by the query (zero-based)</param>
      <param name="limit">Maximum number of rows to be returned by the query</param>
      <returns> the modified SQL </returns>
      <remarks>
            Typically dialects utilize <see cref="P:NHibernate.Dialect.InformixDialect.SupportsVariableLimit" />
            limit caluses when they support limits.  Thus, when building the
            select command we do not actually need to know the limit or the offest
            since we will just be using placeholders.
            <p />
            Here we do still pass along whether or not an offset was specified
            so that dialects not supporting offsets can generate proper exceptions.
            In general, dialects will override one or the other of this method and
            <see cref="M:NHibernate.Dialect.InformixDialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)" />.
            </remarks>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.IdentityInsertString">
      <summary>
            The keyword used to insert a generated value into an identity column (or null).
            Need if the dialect does not support inserts that specify no column values.
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.CreateTemporaryTableString">
      <summary> Command used to create a temporary table. </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.CreateTemporaryTablePostfix">
      <summary> 
            Get any fragments needing to be postfixed to the command for
            temporary table creation. 
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.IsCurrentTimestampSelectStringCallable">
      <summary> 
            Should the value returned by <see cref="P:NHibernate.Dialect.InformixDialect.CurrentTimestampSelectString" />
            be treated as callable.  Typically this indicates that JDBC escape
            sytnax is being used...
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.CurrentTimestampSelectString">
      <summary> 
            Retrieve the command used to retrieve the current timestammp from the database. 
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.CurrentTimestampSQLFunctionName">
      <summary> 
            The name of the database-specific SQL function for retrieving the
            current timestamp. 
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.AddColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.ForUpdateOfColumns">
      <summary> Is <tt>FOR UPDATE OF</tt> syntax supported? </summary>
      <value> True if the database supports <tt>FOR UPDATE OF</tt> syntax; false otherwise. </value>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.SupportsOuterJoinForUpdate">
      <summary> 
            Does this dialect support <tt>FOR UPDATE</tt> in conjunction with outer joined rows?
            </summary>
      <value> True if outer joined rows can be locked via <tt>FOR UPDATE</tt>. </value>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.SupportsTemporaryTables">
      <summary> Does this dialect support temporary tables? </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.SupportsCurrentTimestampSelection">
      <summary> Does this dialect support a way to retrieve the database's current timestamp value? </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.HasDataTypeInIdentityColumn">
      <summary>
            Whether this dialect have an Identity clause added to the data type or a
            completely seperate identity data type
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.IdentitySelectString">
      <summary>
            The syntax that returns the identity value of the last insert, if native
            key generation is supported
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.IdentityColumnString">
      <summary>
            The keyword used to specify an identity column, if native key generation is supported
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.SupportsSequences">
      <summary>
            Does this dialect support sequences?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.SupportsLimit">
      <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
      <value>False, unless overridden.</value>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.SupportsLimitOffset">
      <summary>
            Does this Dialect support an offset?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.SupportsVariableLimit">
      <summary>
            Can parameters be used for a statement containing a LIMIT?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.BindLimitParametersFirst">
      <summary>
            Does the <c>LIMIT</c> clause come at the start of the 
            <c>SELECT</c> statement rather than at the end?
            </summary>
      <value>false, unless overridden</value>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect.SupportsUnionAll">
      <summary> 
            Does this dialect support UNION ALL, which is generally a faster variant of UNION? 
            True if UNION ALL is supported; false otherwise.
            </summary>
    </member>
    <member name="T:NHibernate.Exceptions.TemplatedViolatedConstraintNameExtracter">
      <summary> 
            Knows how to extract a violated constraint name from an error message based on the
            fact that the constraint name is templated within the message.
            </summary>
    </member>
    <member name="M:NHibernate.Exceptions.TemplatedViolatedConstraintNameExtracter.ExtractUsingTemplate(System.String,System.String,System.String)">
      <summary>
            Extracts the constraint name based on a template (i.e., <i>templateStart</i><b>constraintName</b><i>templateEnd</i>).
            </summary>
      <param name="templateStart">The pattern denoting the start of the constraint name within the message.</param>
      <param name="templateEnd">The pattern denoting the end of the constraint name within the message.</param>
      <param name="message">The templated error message containing the constraint name.</param>
      <returns>The found constraint name, or null.</returns>
    </member>
    <member name="M:NHibernate.Exceptions.TemplatedViolatedConstraintNameExtracter.ExtractConstraintName(System.Data.Common.DbException)">
      <summary> 
            Extract the name of the violated constraint from the given SQLException. 
            </summary>
      <param name="sqle">The exception that was the result of the constraint violation. </param>
      <returns> The extracted constraint name. </returns>
    </member>
    <member name="M:NHibernate.Dialect.IfxViolatedConstraintExtracter.ExtractConstraintName(System.Data.Common.DbException)">
      <summary> 
            Extract the name of the violated constraint from the given DbException.
            </summary>
      <param name="sqle">The exception that was the result of the constraint violation.</param>
      <returns>The extracted constraint name.</returns>
    </member>
    <member name="T:NHibernate.Dialect.InformixDialect0940">
      <summary>
            Summary description for InformixDialect.
            This dialect is intended to work with IDS version 9.40
            </summary>
      <remarks>
            The InformixDialect defaults the following configuration properties:
            <list type="table"><listheader><term>ConnectionDriver</term><description>NHibernate.Driver.OdbcDriver</description><term>PrepareSql</term><description>true</description></listheader><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.OdbcDriver" /></description></item></list></remarks>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect0940.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect0940.GetSequenceNextValString(System.String)">
      <summary> 
            Generate the appropriate select statement to to retreive the next value
            of a sequence.
            </summary>
      <param name="sequenceName">the name of the sequence </param>
      <returns> String The "nextval" select string. </returns>
      <remarks>This should be a "stand alone" select statement.</remarks>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect0940.GetSelectSequenceNextValString(System.String)">
      <summary> 
            Generate the select expression fragment that will retrieve the next
            value of a sequence as part of another (typically DML) statement.
            </summary>
      <param name="sequenceName">the name of the sequence </param>
      <returns> The "nextval" fragment. </returns>
      <remarks>
            This differs from <see cref="M:NHibernate.Dialect.InformixDialect0940.GetSequenceNextValString(System.String)" /> in that this
            should return an expression usable within another statement.
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect0940.CreateOuterJoinFragment">
      <summary> 
            Create a <see cref="T:NHibernate.SqlCommand.JoinFragment" /> strategy responsible
            for handling this dialect's variations in how joins are handled. 
            </summary>
      <returns> This dialect's <see cref="T:NHibernate.SqlCommand.JoinFragment" /> strategy. </returns>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect0940.QuerySequencesString">
      <summary> Get the select command used retrieve the names of all sequences.</summary>
      <returns> The select command; or null if sequences are not supported. </returns>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect0940.SupportsSequences">
      <summary>
            Does this dialect support sequences?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect0940.SupportsPooledSequences">
      <summary> 
            Does this dialect support "pooled" sequences.  Not aware of a better
            name for this.  Essentially can we specify the initial and increment values? 
            </summary>
      <returns> True if such "pooled" sequences are supported; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect0940.SupportsLimit">
      <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
      <value>False, unless overridden.</value>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect0940.SupportsLimitOffset">
      <summary>
            Does this Dialect support an offset?
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.InformixDialect1000">
      <summary>
            Summary description for InformixDialect.
            This dialect is intended to work with IDS version 10.00
            </summary>
      <remarks>
            The InformixDialect defaults the following configuration properties:
            <list type="table"><listheader><term>ConnectionDriver</term><description>NHibernate.Driver.OdbcDriver</description><term>PrepareSql</term><description>true</description></listheader><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.OdbcDriver" /></description></item></list></remarks>
    </member>
    <member name="M:NHibernate.Dialect.InformixDialect1000.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect1000.SupportsLimit">
      <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
      <value>False, unless overridden.</value>
    </member>
    <member name="P:NHibernate.Dialect.InformixDialect1000.SupportsLimitOffset">
      <summary>
            Does this Dialect support an offset?
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.IngresDialect">
      <summary>
            An SQL dialect for IngresSQL.
            </summary>
      <remarks>
            The IngresDialect defaults the following configuration properties:
            <list type="table"><listheader><term>Property</term><description>Default Value</description></listheader><item><term>use_outer_join</term><description><see langword="true" /></description></item><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.IngresDriver" /></description></item></list></remarks>
    </member>
    <member name="T:NHibernate.Dialect.MsSql2000Dialect">
      <summary>
            An SQL dialect compatible with Microsoft SQL Server 2000.
            </summary>
      <remarks>
            The MsSql2000Dialect defaults the following configuration properties:
            <list type="table"><listheader><term>Property</term><description>Default Value</description></listheader><item><term>use_outer_join</term><description><see langword="true" /></description></item><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.SqlClientDriver" /></description></item><item><term>prepare_sql</term><description><see langword="false" /></description></item></list></remarks>
    </member>
    <member name="M:NHibernate.Dialect.MsSql2000Dialect.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.MsSql2000Dialect.GetDropTableString(System.String)">
      <summary>
            Generates the string to drop the table using SQL Server syntax.
            </summary>
      <param name="tableName">The name of the table to drop.</param>
      <returns>The SQL with the <paramref name="tableName" /> inserted.</returns>
    </member>
    <member name="M:NHibernate.Dialect.MsSql2000Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
      <summary>
            Add a <c>LIMIT (TOP)</c> clause to the given SQL <c>SELECT</c></summary>
      <param name="querySqlString">A Query in the form of a SqlString.</param>
      <param name="limit">Maximum number of rows to be returned by the query</param>
      <param name="offset">Offset of the first row to process in the result set</param>
      <returns>A new SqlString that contains the <c>LIMIT</c> clause.</returns>
    </member>
    <member name="M:NHibernate.Dialect.MsSql2000Dialect.Quote(System.String)">
      <summary>
      </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
      <remarks>
            MsSql does not require the OpenQuote to be escaped as long as the first char
            is an OpenQuote.
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.MsSql2000Dialect.UnQuote(System.String)">
      <summary>
      </summary>
      <param name="quoted">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2000Dialect.AddColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2000Dialect.NullColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2000Dialect.QualifyIndexName">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsIdentityColumns">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2000Dialect.IdentityColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2000Dialect.NoColumnsInsertString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2000Dialect.CloseQuote">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2000Dialect.OpenQuote">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsLimit">
      <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
      <value>True, we'll use the SELECT TOP nn syntax.</value>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsLimitOffset">
      <summary>
            Does this Dialect support an offset?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsVariableLimit">
      <summary>
            Can parameters be used for a statement containing a LIMIT?
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2000Dialect.UseMaxForLimit">
      <summary>
            Does the <c>LIMIT</c> clause take a "maximum" row number
            instead of a total number of returned rows?
            </summary>
      <returns>false, unless overridden</returns>
    </member>
    <member name="T:NHibernate.Dialect.MsSql2005Dialect.QuotedAndParenthesisStringTokenizer">
      <summary>
            This specialized string tokenizier will break a string to tokens, taking
            into account single quotes, parenthesis and commas and [ ]
            Notice that we aren't differenciating between [ ) and ( ] on purpose, it would complicate
            the code and it is not legal at any rate.
            </summary>
    </member>
    <member name="M:NHibernate.Dialect.MsSql2005Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
      <summary>
            Add a <c>LIMIT</c> clause to the given SQL <c>SELECT</c></summary>
      <param name="querySqlString">The <see cref="T:NHibernate.SqlCommand.SqlString" /> to base the limit query off of.</param>
      <param name="offset">Offset of the first row to be returned by the query (zero-based)</param>
      <param name="last">Maximum number of rows to be returned by the query</param>
      <returns>A new <see cref="T:NHibernate.SqlCommand.SqlString" /> with the <c>LIMIT</c> clause applied.</returns>
      <remarks>
            The <c>LIMIT</c> SQL will look like
            <code>
            
            SELECT
            	TOP last (columns)
            FROM
            	(SELECT (columns), ROW_NUMBER() OVER(ORDER BY {original order by, with un-aliased column names) as __hibernate_sort_row
            	{original from}) as query
            WHERE query.__hibernate_sort_row &gt; offset
            ORDER BY query.__hibernate_sort_row
            
            </code>
            
            Note that we need to add explicitly specify the columns, because we need to be able to use them
            in a paged subselect. NH-1155
            </remarks>
    </member>
    <member name="M:NHibernate.Dialect.MsSql2005Dialect.HasMatchingParens(System.Collections.Generic.IEnumerable{System.Char})">
      <summary>
            Indicates whether the string fragment contains matching parenthesis
            </summary>
      <param name="statement"> the statement to evaluate</param>
      <returns>true if the statment contains no parenthesis or an equal number of
             opening and closing parenthesis;otherwise false </returns>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2005Dialect.SupportsLimit">
      <summary>
            Sql Server 2005 supports a query statement that provides <c>LIMIT</c>
            functionality.
            </summary>
      <value>
        <c>true</c>
      </value>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2005Dialect.SupportsLimitOffset">
      <summary>
            Sql Server 2005 supports a query statement that provides <c>LIMIT</c>
            functionality with an offset.
            </summary>
      <value>
        <c>true</c>
      </value>
    </member>
    <member name="P:NHibernate.Dialect.MsSql2005Dialect.UseMaxForLimit">
      <summary>
            Sql Server 2005 supports a query statement that provides <c>LIMIT</c>
            functionality with an offset.
            </summary>
      <value>
        <c>false</c>
      </value>
    </member>
    <member name="T:NHibernate.Dialect.MsSql7Dialect">
      <summary>
            An SQL dialect compatible with Microsoft SQL Server 7.
            </summary>
      <remarks>
            There have been no test run with this because the NHibernate team does not
            have a machine with Sql 7 installed on it.  But there have been users using
            Ms Sql 7 with NHibernate.  As issues with Ms Sql 7 and NHibernate become known
            this Dialect will be updated.
            </remarks>
    </member>
    <member name="P:NHibernate.Dialect.MsSql7Dialect.IdentitySelectString">
      <summary>
            Uses @@identity to get the Id value.
            </summary>
      <remarks>
            There is a well known problem with @@identity and triggers that insert into
            rows into other tables that also use an identity column.  The only way I know
            of to get around this problem is to upgrade your database server to Ms Sql 2000.
            </remarks>
    </member>
    <member name="T:NHibernate.Dialect.MsSqlCeDialect">
      <summary>
            A dialect for SQL Server Everywhere (SQL Server CE).
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.MySQLDialect">
      <summary>
            A SQL dialect for MySQL
            </summary>
      <remarks>
            The MySQLDialect defaults the following configuration properties:
            <list type="table"><listheader><term>Property</term><description>Default Value</description></listheader><item><term>use_outer_join</term><description><see langword="true" /></description></item><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.MySqlDataDriver" /></description></item></list></remarks>
    </member>
    <member name="M:NHibernate.Dialect.MySQLDialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
      <summary>
      </summary>
      <param name="querySqlString">
      </param>
      <param name="hasOffset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Dialect.MySQLDialect.GetDropForeignKeyConstraintString(System.String)">
      <summary>
            Create the SQL string to drop a foreign key constraint.
            </summary>
      <param name="constraintName">The name of the foreign key to drop.</param>
      <returns>The SQL string to drop the foreign key constraint.</returns>
    </member>
    <member name="M:NHibernate.Dialect.MySQLDialect.GetDropPrimaryKeyConstraintString(System.String)">
      <summary>
            Create the SQL string to drop a primary key constraint.
            </summary>
      <param name="constraintName">The name of the primary key to drop.</param>
      <returns>The SQL string to drop the primary key constraint.</returns>
    </member>
    <member name="M:NHibernate.Dialect.MySQLDialect.GetDropIndexConstraintString(System.String)">
      <summary>
            Create the SQL string to drop an index.
            </summary>
      <param name="constraintName">The name of the index to drop.</param>
      <returns>The SQL string to drop the index constraint.</returns>
    </member>
    <member name="P:NHibernate.Dialect.MySQLDialect.AddColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MySQLDialect.QualifyIndexName">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MySQLDialect.SupportsIdentityColumns">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MySQLDialect.IdentitySelectString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MySQLDialect.IdentityColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MySQLDialect.CloseQuote">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MySQLDialect.OpenQuote">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.MySQLDialect.SupportsLimit">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Dialect.Oracle8iDialect">
      <summary>
            A dialect for Oracle 8i. 
            </summary>
    </member>
    <member name="M:NHibernate.Dialect.Oracle8iDialect.CreateOuterJoinFragment">
      <summary> 
            Support for the oracle proprietary join syntax... 
            </summary>
      <returns> The orqacle join fragment </returns>
    </member>
    <member name="M:NHibernate.Dialect.Oracle8iDialect.CreateCaseFragment">
      <summary> 
            Map case support to the Oracle DECODE function.  Oracle did not
            add support for CASE until 9i. 
            </summary>
      <returns> The oracle CASE -&gt; DECODE fragment </returns>
    </member>
    <member name="M:NHibernate.Dialect.Oracle8iDialect.GetBasicSelectClauseNullString(NHibernate.SqlTypes.SqlType)">
      <summary> 
            Allows access to the basic <see cref="M:NHibernate.Dialect.Dialect.GetSelectClauseNullString(NHibernate.SqlTypes.SqlType)" />
            implementation... 
            </summary>
      <param name="sqlType">The <see cref="T:NHibernate.SqlTypes.SqlType" /> mapping type</param>
      <returns> The appropriate select cluse fragment </returns>
    </member>
    <member name="T:NHibernate.Dialect.Oracle10gDialect">
      <summary> 
            A dialect specifically for use with Oracle 10g.
            </summary>
      <remarks>
            The main difference between this dialect and <see cref="T:NHibernate.Dialect.Oracle9iDialect" />
            is the use of "ANSI join syntax" here...
            </remarks>
    </member>
    <member name="T:NHibernate.Dialect.OracleLiteDialect">
      <summary>
            It's a immature version, it just work.
            An SQL dialect for Oracle Lite
            </summary>
      <remarks>
            The OracleLiteDialect defaults the following configuration properties:
            <list type="table"><listheader><term>Property</term><description>Default Value</description></listheader><item><term>use_outer_join</term><description><see langword="true" /></description></item><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.OracleLiteDataClientDriver" /></description></item></list></remarks>
    </member>
    <member name="M:NHibernate.Dialect.OracleLiteDialect.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.OracleLiteDialect.GetCreateSequenceString(System.String)">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Dialect.PostgreSQLDialect">
      <summary>
            An SQL dialect for PostgreSQL.
            </summary>
      <remarks>
            The PostgreSQLDialect defaults the following configuration properties:
            <list type="table"><listheader><term>Property</term><description>Default Value</description></listheader><item><term>use_outer_join</term><description><see langword="true" /></description></item><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.NpgsqlDriver" /></description></item></list></remarks>
    </member>
    <member name="M:NHibernate.Dialect.PostgreSQLDialect.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.PostgreSQLDialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
      <summary>
      </summary>
      <param name="querySqlString">
      </param>
      <param name="hasOffset">Offset of the first row to process in the result set is non-zero</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Dialect.PostgreSQLDialect.GetSelectClauseNullString(NHibernate.SqlTypes.SqlType)">
      <summary>PostgreSQL requires to cast NULL values to correctly handle UNION/UNION ALL</summary>
      <remarks>
            See <see href="http://archives.postgresql.org/pgsql-bugs/2005-08/msg00239.php">
            PostgreSQL BUG #1847: Error in some kind of UNION query.</see></remarks>
      <param name="sqlType">The <see cref="T:System.Data.DbType" /> type code.</param>
      <returns>null casted as <paramref name="sqlType" />: "<c>null::sqltypename</c>"</returns>
    </member>
    <member name="P:NHibernate.Dialect.PostgreSQLDialect.AddColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.PostgreSQLDialect.DropConstraints">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.PostgreSQLDialect.SupportsUnionAll">
      <summary>PostgreSQL supports UNION ALL clause</summary>
      <remarks>
            Reference: <see href="http://www.postgresql.org/docs/8.0/static/sql-select.html#SQL-UNION">
            PostgreSQL 8.0 UNION Clause documentation</see></remarks>
      <value>
        <see langword="true" />
      </value>
    </member>
    <member name="T:NHibernate.Dialect.PostgreSQL81Dialect">
      <summary>
            An SQL dialect for PostgreSQL 8.1 and above.
            </summary>
      <remarks>
        <para>
            PostgreSQL 8.1 supports <c>FOR UPDATE ... NOWAIT</c> syntax.
            </para>
        <para>
            PostgreSQL supports Identity column using the "SERIAL" type.
            Serial type is a "virtual" type that will automatically:
            </para>
        <list type="bullet">
          <item>
            <description>Create a sequence named tablename_colname_seq.</description>
          </item>
          <item>
            <description>Set the default value of this column to the next value of the 
            sequence. (using function <c>nextval('tablename_colname_seq')</c>)</description>
          </item>
          <item>
            <description>Add a "NOT NULL" constraint to this column.</description>
          </item>
          <item>
            <description>Set the sequence as "owned by" the table.</description>
          </item>
        </list>
        <para>
            To insert the next value of the sequence into the serial column,
            exclude the column from the list of columns 
            in the INSERT statement or use the DEFAULT key word.
            </para>
        <para>
            If the table or the column is dropped, the sequence is dropped too.
            </para>
      </remarks>
      <seealso cref="T:NHibernate.Dialect.PostgreSQLDialect" />
    </member>
    <member name="M:NHibernate.Dialect.PostgreSQL81Dialect.GetIdentityColumnString(System.Data.DbType)">
      <summary>
            PostgreSQL supports <c>serial</c> and <c>serial4</c> type for 4 bytes integer auto increment column.
            <c>bigserial</c> or <c>serial8</c> can be used for 8 bytes integer auto increment column.
            </summary>
      <returns>
        <c>bigserial</c> if <paramref name="type" /> equal Int64,
            <c>serial</c> otherwise</returns>
    </member>
    <member name="P:NHibernate.Dialect.PostgreSQL81Dialect.SupportsIdentityColumns">
      <summary>
            PostgreSQL supports Identity column using the "SERIAL" type.
            </summary>
    </member>
    <member name="P:NHibernate.Dialect.PostgreSQL81Dialect.HasDataTypeInIdentityColumn">
      <summary>
            PostgreSQL doesn't have type in identity column.
            </summary>
      <remarks>
            To create an identity column it uses the SQL syntax
            <c>CREATE TABLE tablename (colname SERIAL);</c> or 
            <c>CREATE TABLE tablename (colname BIGSERIAL);</c></remarks>
    </member>
    <member name="P:NHibernate.Dialect.PostgreSQL81Dialect.NoColumnsInsertString">
      <summary>
            The sql syntax to insert a row without specifying any column in PostgreSQL is
            <c>INSERT INTO table DEFAULT VALUES;</c></summary>
    </member>
    <member name="P:NHibernate.Dialect.PostgreSQL81Dialect.IdentitySelectString">
      <summary>
            PostgreSQL 8.1 and above defined the fuction <c>lastval()</c> that returns the
            value of the last sequence that <c>nextval()</c> was used on in the current session.
            Call <c>lastval()</c> if <c>nextval()</c> has not yet been called in the current
            session throw an exception.
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.PostgreSQL82Dialect">
      <summary>
            An SQL dialect for PostgreSQL 8.2 and above.
            </summary>
      <remarks>
            PostgreSQL 8.2 supports <c>DROP TABLE IF EXISTS tablename</c>
            and <c>DROP SEQUENCE IF EXISTS sequencename</c> syntax.
            See <see cref="T:NHibernate.Dialect.PostgreSQLDialect" /> for more information.
            </remarks>
    </member>
    <member name="T:NHibernate.Dialect.SQLiteDialect">
      <summary>
            A SQL dialect for SQLite.
            </summary>
      <remarks>
        <p>
            Author: <a href="mailto:ib@stalker.ro"> Ioan Bizau </a></p>
      </remarks>
    </member>
    <member name="M:NHibernate.Dialect.SQLiteDialect.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.SQLiteDialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
      <summary>
            Add a LIMIT N clause to the given SQL <c>SELECT</c></summary>
      <param name="querySqlString">A Query in the form of a SqlString.</param>
      <param name="limit">Maximum number of rows to be returned by the query</param>
      <param name="offset">Offset of the first row to process in the result set</param>
      <returns>A new SqlString that contains the <c>LIMIT</c> clause.</returns>
    </member>
    <member name="T:NHibernate.Dialect.SybaseDialect">
      <summary>
            An SQL dialect compatible with Sybase.
            </summary>
      <remarks>
        <p>
            This dialect probably will not work with schema-export.  If anyone out there
            can fill in the ctor with DbTypes to Strings that would be helpful.
            </p>
            The SybaseDialect defaults the following configuration properties:
            <list type="table"><listheader><term>Property</term><description>Default Value</description></listheader><item><term>use_outer_join</term><description><see langword="true" /></description></item><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.SybaseClientDriver" /></description></item><item><term>prepare_sql</term><description><see langword="false" /></description></item></list></remarks>
    </member>
    <member name="M:NHibernate.Dialect.SybaseDialect.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.SybaseDialect.QuoteForAliasName(System.String)">
      <remarks>
            Sybase does not support quoted aliases, this function thus returns
            <c>aliasName</c> as is.
            </remarks>
    </member>
    <member name="P:NHibernate.Dialect.SybaseDialect.AddColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseDialect.NullColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseDialect.QualifyIndexName">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseDialect.ForUpdateString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseDialect.SupportsIdentityColumns">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseDialect.IdentitySelectString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseDialect.IdentityColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseDialect.NoColumnsInsertString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Dialect.Sybase11Dialect">
      <summary>
            This is a subclass of SybaseDialect for sybase 11 databases (specifically tested against 11.9.2). 11.9.2 does not support ANSI JOINs
            therefore we have to provide  a special join fragment for left/right joins (*= and =* respectively).
            </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.JoinFragment">
      <summary>
            Represents a SQL <c>JOIN</c></summary>
    </member>
    <member name="T:NHibernate.Dialect.Sybase11JoinFragment">
      <summary>
            This class is basically a port of the hibernate 3.2  Sybase 11 join fragment. It uses concepts from that join fragment and the Oracle join fragment in NHibernate
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.SybaseAdoNet12Dialect">
      <summary>
            An SQL dialect compatible with Sybase.
            </summary>
      <remarks>
        <p>
            This dialect probably will not work with schema-export.  If anyone out there
            can fill in the ctor with DbTypes to Strings that would be helpful.
            </p>
            The SybaseDialect defaults the following configuration properties:
            <list type="table"><listheader><term>Property</term><description>Default Value</description></listheader><item><term>use_outer_join</term><description><see langword="true" /></description></item><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.SybaseClientDriver" /></description></item><item><term>prepare_sql</term><description><see langword="false" /></description></item></list></remarks>
    </member>
    <member name="M:NHibernate.Dialect.SybaseAdoNet12Dialect.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Dialect.SybaseAdoNet12Dialect.QuoteForAliasName(System.String)">
      <remarks>
            Sybase does not support quoted aliases, this function thus returns
            <c>aliasName</c> as is.
            </remarks>
    </member>
    <member name="P:NHibernate.Dialect.SybaseAdoNet12Dialect.AddColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseAdoNet12Dialect.NullColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseAdoNet12Dialect.QualifyIndexName">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseAdoNet12Dialect.ForUpdateString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseAdoNet12Dialect.SupportsIdentityColumns">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseAdoNet12Dialect.IdentitySelectString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseAdoNet12Dialect.IdentityColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseAdoNet12Dialect.NoColumnsInsertString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Dialect.SybaseAnywhereDialect">
      <summary>
            An SQL dialect for Sybase Adaptive Server Anywhere 9.0/10.0
            </summary>
      <remarks>
        <p>
            This dialect probably will not work with schema-export.  If anyone out there
            can fill in the ctor with DbTypes to Strings that would be helpful.
            </p>
            The SybaseAnywhereDialect defaults the following configuration properties:
            <list type="table"><listheader><term>Property</term><description>Default Value</description></listheader><item><term>use_outer_join</term><description><see langword="true" /></description></item><item><term>connection.driver_class</term><description><see cref="T:NHibernate.Driver.SybaseClientDriver" /></description></item><item><term>prepare_sql</term><description><see langword="false" /></description></item></list></remarks>
    </member>
    <member name="M:NHibernate.Dialect.SybaseAnywhereDialect.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseAnywhereDialect.IdentityColumnString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseAnywhereDialect.NoColumnsInsertString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Dialect.SybaseAnywhereDialect.DropConstraints">
      <summary>
            ASA does not require to drop constraint before dropping tables, and DROP statement
            syntax used by Hibernate to drop constraint is not compatible with ASA, so disable it.  
            Comments matchs SybaseAnywhereDialect from Hibernate-3.1 src
            </summary>
    </member>
    <member name="T:NHibernate.Dialect.TypeNames">
      <summary>
            This class maps a DbType to names.
            </summary>
      <remarks>
            Associations may be marked with a capacity. Calling the <c>Get()</c>
            method with a type and actual size n will return the associated
            name with smallest capacity &gt;= n, if available and an unmarked
            default type otherwise.
            Eg, setting
            <code>
            	Names.Put(DbType,			"TEXT" );
            	Names.Put(DbType,	255,	"VARCHAR($l)" );
            	Names.Put(DbType,	65534,	"LONGVARCHAR($l)" );
            </code>
            will give you back the following:
            <code>
            	Names.Get(DbType)			// --&gt; "TEXT" (default)
            	Names.Get(DbType,100)		// --&gt; "VARCHAR(100)" (100 is in [0:255])
            	Names.Get(DbType,1000)	// --&gt; "LONGVARCHAR(1000)" (100 is in [256:65534])
            	Names.Get(DbType,100000)	// --&gt; "TEXT" (default)
            </code>
            On the other hand, simply putting
            <code>
            	Names.Put(DbType, "VARCHAR($l)" );
            </code>
            would result in
            <code>
            	Names.Get(DbType)			// --&gt; "VARCHAR($l)" (will cause trouble)
            	Names.Get(DbType,100)		// --&gt; "VARCHAR(100)" 
            	Names.Get(DbType,1000)	// --&gt; "VARCHAR(1000)"
            	Names.Get(DbType,10000)	// --&gt; "VARCHAR(10000)"
            </code></remarks>
    </member>
    <member name="M:NHibernate.Dialect.TypeNames.Get(System.Data.DbType)">
      <summary>
            Get default type name for specified type
            </summary>
      <param name="typecode">the type key</param>
      <returns>the default type name associated with the specified key</returns>
    </member>
    <member name="M:NHibernate.Dialect.TypeNames.Get(System.Data.DbType,System.Int32,System.Int32,System.Int32)">
      <summary>
            Get the type name specified type and size
            </summary>
      <param name="typecode">the type key</param>
      <param name="size">the SQL length </param>
      <param name="scale">the SQL scale </param>
      <param name="precision">the SQL precision </param>
      <returns>
            The associated name with smallest capacity &gt;= size if available and the
            default type name otherwise
            </returns>
    </member>
    <member name="M:NHibernate.Dialect.TypeNames.Put(System.Data.DbType,System.Int32,System.String)">
      <summary>
            Set a type name for specified type key and capacity
            </summary>
      <param name="typecode">the type key</param>
      <param name="capacity">the (maximum) type size/length</param>
      <param name="value">The associated name</param>
    </member>
    <member name="M:NHibernate.Dialect.TypeNames.Put(System.Data.DbType,System.String)">
      <summary>
      </summary>
      <param name="typecode">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="T:NHibernate.Driver.IDriver">
      <summary>
            A strategy for describing how NHibernate should interact with the different .NET Data
            Providers.
            </summary>
      <remarks>
        <para>
            The <c>IDriver</c> interface is not intended to be exposed to the application.
            Instead it is used internally by NHibernate to obtain connection objects, command objects, and
            to generate and prepare <see cref="T:System.Data.IDbCommand">IDbCommands</see>. Implementors should provide a
            public default constructor.
            </para>
        <para>
            This is the interface to implement, or you can inherit from <see cref="T:NHibernate.Driver.DriverBase" /> 
            if you have an ADO.NET data provider that NHibernate does not have built in support for.
            To use the driver, NHibernate property <c>connection.driver_class</c> should be
            set to the assembly-qualified name of the driver class.
            </para>
        <code>
            key="connection.driver_class"
            value="FullyQualifiedClassName, AssemblyName"
            </code>
      </remarks>
    </member>
    <member name="M:NHibernate.Driver.IDriver.Configure(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Configure the driver using <paramref name="settings" />.
            </summary>
    </member>
    <member name="M:NHibernate.Driver.IDriver.CreateConnection">
      <summary>
            Creates an uninitialized IDbConnection object for the specific Driver
            </summary>
    </member>
    <member name="M:NHibernate.Driver.IDriver.GenerateCommand(System.Data.CommandType,NHibernate.SqlCommand.SqlString,NHibernate.SqlTypes.SqlType[])">
      <summary>
            Generates an IDbCommand from the SqlString according to the requirements of the DataProvider.
            </summary>
      <param name="type">The <see cref="T:System.Data.CommandType" /> of the command to generate.</param>
      <param name="sqlString">The SqlString that contains the SQL.</param>
      <param name="parameterTypes">The types of the parameters to generate for the command.</param>
      <returns>An IDbCommand with the CommandText and Parameters fully set.</returns>
    </member>
    <member name="M:NHibernate.Driver.IDriver.PrepareCommand(System.Data.IDbCommand)">
      <summary>
            Prepare the <paramref name="command" /> by calling <see cref="M:System.Data.IDbCommand.Prepare" />.
            May be a no-op if the driver does not support preparing commands, or for any other reason.
            </summary>
      <param name="command">
      </param>
    </member>
    <member name="M:NHibernate.Driver.IDriver.GenerateParameter(System.Data.IDbCommand,System.String,NHibernate.SqlTypes.SqlType)">
      <summary>
            Generates an IDbDataParameter for the IDbCommand.  It does not add the IDbDataParameter to the IDbCommand's
            Parameter collection.
            </summary>
      <param name="command">The IDbCommand to use to create the IDbDataParameter.</param>
      <param name="name">The name to set for IDbDataParameter.Name</param>
      <param name="sqlType">The SqlType to set for IDbDataParameter.</param>
      <returns>An IDbDataParameter ready to be added to an IDbCommand.</returns>
    </member>
    <member name="P:NHibernate.Driver.IDriver.SupportsMultipleOpenReaders">
      <summary>
            Does this Driver support having more than 1 open IDataReader with
            the same IDbConnection.
            </summary>
      <remarks>
        <para>
            A value of <see langword="false" /> indicates that an exception would be thrown if NHibernate
            attempted to have 2 IDataReaders open using the same IDbConnection.  NHibernate
            (since this version is a close to straight port of Hibernate) relies on the 
            ability to recursively open 2 IDataReaders.  If the Driver does not support it
            then NHibernate will read the values from the IDataReader into an <see cref="T:NHibernate.Driver.NDataReader" />.
            </para>
        <para>
            A value of <see langword="true" /> will result in greater performance because an IDataReader can be used
            instead of the <see cref="T:NHibernate.Driver.NDataReader" />.  So if the Driver supports it then make sure
            it is set to <see langword="true" />.
            </para>
      </remarks>
    </member>
    <member name="P:NHibernate.Driver.IDriver.SupportsMultipleQueries">
      <summary>
            Can we issue several select queries in a single query, and get
            several result sets back?
            </summary>
    </member>
    <member name="P:NHibernate.Driver.IDriver.MultipleQueriesSeparator">
      <summary>
            How we separate the queries when we use multiply queries.
            </summary>
    </member>
    <member name="T:NHibernate.Driver.DriverBase">
      <summary>
            Base class for the implementation of IDriver
            </summary>
    </member>
    <member name="M:NHibernate.Driver.DriverBase.FormatNameForSql(System.String)">
      <summary>
            Change the parameterName into the correct format IDbCommand.CommandText
            for the ConnectionProvider
            </summary>
      <param name="parameterName">The unformatted name of the parameter</param>
      <returns>A parameter formatted for an IDbCommand.CommandText</returns>
    </member>
    <member name="M:NHibernate.Driver.DriverBase.FormatNameForParameter(System.String)">
      <summary>
            Changes the parameterName into the correct format for an IDbParameter
            for the Driver.
            </summary>
      <remarks>
            For SqlServerConnectionProvider it will change <c>id</c> to <c>@id</c></remarks>
      <param name="parameterName">The unformatted name of the parameter</param>
      <returns>A parameter formatted for an IDbParameter.</returns>
    </member>
    <member name="M:NHibernate.Driver.DriverBase.GenerateParameter(System.Data.IDbCommand,System.String,NHibernate.SqlTypes.SqlType)">
      <summary>
            Generates an IDbDataParameter for the IDbCommand.  It does not add the IDbDataParameter to the IDbCommand's
            Parameter collection.
            </summary>
      <param name="command">The IDbCommand to use to create the IDbDataParameter.</param>
      <param name="name">The name to set for IDbDataParameter.Name</param>
      <param name="sqlType">The SqlType to set for IDbDataParameter.</param>
      <returns>An IDbDataParameter ready to be added to an IDbCommand.</returns>
    </member>
    <member name="P:NHibernate.Driver.DriverBase.UseNamedPrefixInSql">
      <summary>
            Does this Driver require the use of a Named Prefix in the SQL statement.  
            </summary>
      <remarks>
            For example, SqlClient requires <c>select * from simple where simple_id = @simple_id</c>
            If this is false, like with the OleDb provider, then it is assumed that  
            the <c>?</c> can be a placeholder for the parameter in the SQL statement.
            </remarks>
    </member>
    <member name="P:NHibernate.Driver.DriverBase.UseNamedPrefixInParameter">
      <summary>
            Does this Driver require the use of the Named Prefix when trying
            to reference the Parameter in the Command's Parameter collection.  
            </summary>
      <remarks>
            This is really only useful when the UseNamedPrefixInSql == true.  When this is true the
            code will look like:
            <code>IDbParameter param = cmd.Parameters["@paramName"]</code>
            if this is false the code will be 
            <code>IDbParameter param = cmd.Parameters["paramName"]</code>.
            </remarks>
    </member>
    <member name="P:NHibernate.Driver.DriverBase.NamedPrefix">
      <summary>
            The Named Prefix for parameters.  
            </summary>
      <remarks>
            Sql Server uses <c>"@"</c> and Oracle uses <c>":"</c>.
            </remarks>
    </member>
    <member name="P:NHibernate.Driver.DriverBase.SupportsPreparingCommands">
      <summary>
            Does this Driver support IDbCommand.Prepare().
            </summary>
      <remarks>
        <para>
            A value of <see langword="false" /> indicates that an exception would be thrown or the 
            company that produces the Driver we are wrapping does not recommend using
            IDbCommand.Prepare().
            </para>
        <para>
            A value of <see langword="true" /> indicates that calling IDbCommand.Prepare() will function
            fine on this Driver.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Driver.ReflectionBasedDriver.#ctor(System.String,System.String,System.String)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.ReflectionBasedDriver" /> with
            type names that are loaded from the specified assembly.
            </summary>
      <param name="driverAssemblyName">Assembly to load the types from.</param>
      <param name="connectionTypeName">Connection type name.</param>
      <param name="commandTypeName">Command type name.</param>
    </member>
    <member name="T:NHibernate.Driver.ASA10ClientDriver">
      <summary>
            The ASAClientDriver Driver provides a database driver for Adaptive Server Anywhere 10.0.
            </summary>
    </member>
    <member name="M:NHibernate.Driver.ASA10ClientDriver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.ASAClientDriver" /> class.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the iAnywhere.Data.SQLAnywhere assembly is not and can not be loaded.
            </exception>
    </member>
    <member name="P:NHibernate.Driver.ASA10ClientDriver.UseNamedPrefixInSql">
      <summary>
            iAnywhere.Data.SQLAnywhere uses named parameters in the sql.
            </summary>
      <value>
        <see langword="true" /> - Sybase uses <c>String.Empty</c> in the sql.</value>
    </member>
    <member name="P:NHibernate.Driver.ASA10ClientDriver.NamedPrefix">
      <summary>
            iAnywhere.Data.SQLAnywhere use the <c>string.Empty</c> to locate parameters in sql.
            </summary>
    </member>
    <member name="T:NHibernate.Driver.ASAClientDriver">
      <summary>
            The ASAClientDriver Driver provides a database driver for Adaptive Server Anywhere 9.0.
            </summary>
    </member>
    <member name="M:NHibernate.Driver.ASAClientDriver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.ASAClientDriver" /> class.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the ASA.Data.AsaClient assembly is not and can not be loaded.
            </exception>
    </member>
    <member name="P:NHibernate.Driver.ASAClientDriver.UseNamedPrefixInSql">
      <summary>
            iAnywhere.Data.AsaClient uses named parameters in the sql.
            </summary>
      <value>
        <see langword="true" /> - Sybase uses <c>String.Empty</c> in the sql.</value>
    </member>
    <member name="P:NHibernate.Driver.ASAClientDriver.NamedPrefix">
      <summary>
            iAnywhere.Data.AsaClient use the <c>string.Empty</c> to locate parameters in sql.
            </summary>
    </member>
    <member name="T:NHibernate.Driver.DB2400Driver">
      <summary>
            A NHibernate Driver for using the IBM.Data.DB2.iSeries DataProvider.
            </summary>
    </member>
    <member name="M:NHibernate.Driver.DB2400Driver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.DB2Driver" /> class.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>IBM.Data.DB2.iSeries</c> assembly can not be loaded.
            </exception>
    </member>
    <member name="T:NHibernate.Driver.DB2Driver">
      <summary>
            A NHibernate Driver for using the IBM.Data.DB2 DataProvider.
            </summary>
    </member>
    <member name="M:NHibernate.Driver.DB2Driver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.DB2Driver" /> class.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>IBM.Data.DB2</c> assembly can not be loaded.
            </exception>
    </member>
    <member name="T:NHibernate.Driver.FirebirdClientDriver">
      <summary>
            A NHibernate Driver for using the Firebird data provider located in
            <c>FirebirdSql.Data.FirebirdClient</c> assembly.
            </summary>
    </member>
    <member name="M:NHibernate.Driver.FirebirdClientDriver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.FirebirdDriver" /> class.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>FirebirdSql.Data.Firebird</c> assembly can not be loaded.
            </exception>
    </member>
    <member name="T:NHibernate.Driver.FirebirdDriver">
      <summary>
            A NHibernate Driver for using the FirebirdSql.Data.Firebird DataProvider.
            </summary>
    </member>
    <member name="M:NHibernate.Driver.FirebirdDriver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.FirebirdDriver" /> class.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>FirebirdSql.Data.Firebird</c> assembly can not be loaded.
            </exception>
    </member>
    <member name="T:NHibernate.Driver.IfxDriver">
      <summary>
            A NHibernate Driver for using the Informix DataProvider
            </summary>
    </member>
    <member name="M:NHibernate.Driver.IfxDriver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.IfxDriver" /> class.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>IBM.Data.Informix</c> assembly can not be loaded.
            </exception>
    </member>
    <member name="T:NHibernate.Driver.IngresDriver">
      <summary>
            A NHibernate Driver for using the Ingres DataProvider
            </summary>
      <remarks>
      </remarks>
    </member>
    <member name="T:NHibernate.Driver.MySqlDataDriver">
      <summary>
            Provides a database driver for MySQL.
            </summary>
      <remarks>
        <para>
            In order to use this driver you must have the assembly <c>MySql.Data.dll</c> available for 
            NHibernate to load, including its dependencies (<c>ICSharpCode.SharpZipLib.dll</c> is required by
            the assembly <c>MySql.Data.dll</c> as of the time of this writing).
            </para>
        <para>
            Please check the product's <see href="http://www.mysql.com/products/connector/net/">website</see>
            for any updates and/or documentation regarding MySQL.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Driver.MySqlDataDriver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.MySqlDataDriver" /> class.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>MySql.Data</c> assembly can not be loaded.
            </exception>
    </member>
    <member name="P:NHibernate.Driver.MySqlDataDriver.UseNamedPrefixInSql">
      <summary>
            MySql.Data uses named parameters in the sql.
            </summary>
      <value>
        <see langword="true" /> - MySql uses <c>?</c> in the sql.</value>
    </member>
    <member name="P:NHibernate.Driver.MySqlDataDriver.UseNamedPrefixInParameter">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.MySqlDataDriver.NamedPrefix">
      <summary>
            MySql.Data use the <c>?</c> to locate parameters in sql.
            </summary>
      <value>
        <c>?</c> is used to locate parameters in sql.</value>
    </member>
    <member name="P:NHibernate.Driver.MySqlDataDriver.SupportsMultipleOpenReaders">
      <summary>
            The MySql.Data driver does NOT support more than 1 open IDataReader
            with only 1 IDbConnection.
            </summary>
      <value>
        <see langword="false" /> - it is not supported.</value>
    </member>
    <member name="P:NHibernate.Driver.MySqlDataDriver.SupportsPreparingCommands">
      <summary>
            MySql.Data does not support preparing of commands.
            </summary>
      <value>
        <see langword="false" /> - it is not supported.</value>
      <remarks>
            With the Gamma MySql.Data provider it is throwing an exception with the 
            message "Expected End of data packet" when a select command is prepared.
            </remarks>
    </member>
    <member name="T:NHibernate.Driver.NDataReader">
      <summary>
            Some Data Providers (ie - SqlClient) do not support Multiple Active Result Sets (MARS).
            NHibernate relies on being able to create MARS to read Components and entities inside
            of Collections.
            </summary>
      <remarks>
            This is a completely off-line DataReader - the underlying IDataReader that was used to create
            this has been closed and no connections to the Db exists.
            </remarks>
    </member>
    <member name="T:NHibernate.Driver.NDataReader.NResult">
      <summary>
            Stores a Result from a DataReader in memory.
            </summary>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.NResult.#ctor(System.Data.IDataReader,System.Boolean)">
      <summary>
            Initializes a new instance of the NResult class.
            </summary>
      <param name="reader">The IDataReader to populate the Result with.</param>
      <param name="isMidstream">
        <see langword="true" /> if the <see cref="T:System.Data.IDataReader" /> is already positioned on the record
            to start reading from.
            </param>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.NResult.GetDataTypeName(System.Int32)">
      <summary>
      </summary>
      <param name="colIndex">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.NResult.GetFieldCount">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.NResult.GetFieldType(System.Int32)">
      <summary>
      </summary>
      <param name="colIndex">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.NResult.GetName(System.Int32)">
      <summary>
      </summary>
      <param name="colIndex">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.NResult.GetSchemaTable">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.NResult.GetOrdinal(System.String)">
      <summary>
      </summary>
      <param name="colName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.NResult.GetValue(System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="rowIndex">
      </param>
      <param name="colIndex">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.NResult.GetValue(System.Int32,System.String)">
      <summary>
      </summary>
      <param name="rowIndex">
      </param>
      <param name="colName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.NResult.GetValues(System.Int32,System.Object[])">
      <summary>
      </summary>
      <param name="rowIndex">
      </param>
      <param name="values">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Driver.NDataReader.NResult.RowCount">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.#ctor(System.Data.IDataReader,System.Boolean)">
      <summary>
            Creates a NDataReader from a <see cref="T:System.Data.IDataReader" /></summary>
      <param name="reader">The <see cref="T:System.Data.IDataReader" /> to get the records from the Database.</param>
      <param name="isMidstream">
        <see langword="true" /> if we are loading the <see cref="T:System.Data.IDataReader" /> in the middle of reading it.</param>
      <remarks>
            NHibernate attempts to not have to read the contents of an <see cref="T:System.Data.IDataReader" /> into memory until it absolutely
            has to.  What that means is that it might have processed some records from the <see cref="T:System.Data.IDataReader" /> and will
            pick up the <see cref="T:System.Data.IDataReader" /> midstream so that the underlying <see cref="T:System.Data.IDataReader" /> can be closed 
            so a new one can be opened.
            </remarks>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.ClearCache">
      <summary>
            Sets the values that can be cached back to null and sets the 
            index of the cached column to -1
            </summary>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.NextResult">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.Close">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.Read">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetSchemaTable">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.Dispose">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
      <remarks>
            There are not any unmanaged resources or any disposable managed 
            resources that this class is holding onto.  It is in here
            to comply with the <see cref="T:System.Data.IDataReader" /> interface.
            </remarks>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetInt32(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetValue(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.IsDBNull(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <param name="fieldOffset">
      </param>
      <param name="buffer">
      </param>
      <param name="bufferOffset">
      </param>
      <param name="length">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetByte(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetFieldType(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetDecimal(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetValues(System.Object[])">
      <summary>
      </summary>
      <param name="values">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetName(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetInt64(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetDouble(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetBoolean(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetGuid(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetDateTime(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetOrdinal(System.String)">
      <summary>
      </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetDataTypeName(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetFloat(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetData(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <param name="fieldOffset">
      </param>
      <param name="buffer">
      </param>
      <param name="bufferOffset">
      </param>
      <param name="length">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetString(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetChar(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NDataReader.GetInt16(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Driver.NDataReader.RecordsAffected">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.NDataReader.IsClosed">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.NDataReader.Depth">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.NDataReader.Item(System.String)">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.NDataReader.Item(System.Int32)">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.NDataReader.FieldCount">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Driver.NHybridDataReader">
      <summary>
            An implementation of <see cref="T:System.Data.IDataReader" /> that will work with either an 
            <see cref="T:System.Data.IDataReader" /> returned by Execute or with an <see cref="T:System.Data.IDataReader" />
            whose contents have been read into a <see cref="T:NHibernate.Driver.NDataReader" />.
            </summary>
      <remarks>
        <para>
            This allows NHibernate to use the underlying <see cref="T:System.Data.IDataReader" /> for as long as
            possible without the need to read everything into the <see cref="T:NHibernate.Driver.NDataReader" />.
            </para>
        <para>
            The consumer of the <see cref="T:System.Data.IDataReader" /> returned from <see cref="T:NHibernate.Engine.IBatcher" /> does
            not need to know the underlying reader and can use it the same even if it switches from an
            <see cref="T:System.Data.IDataReader" /> to <see cref="T:NHibernate.Driver.NDataReader" /> in the middle of its use.
            </para>
      </remarks>
    </member>
    <member name="F:NHibernate.Driver.NHybridDataReader._isAlreadyDisposed">
      <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.#ctor(System.Data.IDataReader)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.NHybridDataReader" /> class.
            </summary>
      <param name="reader">The underlying IDataReader to use.</param>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.#ctor(System.Data.IDataReader,System.Boolean)">
      <summary>
            Initializes a new instance of the NHybridDataReader class.
            </summary>
      <param name="reader">The underlying IDataReader to use.</param>
      <param name="inMemory">
        <see langword="true" /> if the contents of the IDataReader should be read into memory right away.</param>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.ReadIntoMemory">
      <summary>
            Reads all of the contents into memory because another <see cref="T:System.Data.IDataReader" />
            needs to be opened.
            </summary>
      <remarks>
            This will result in a no op if the reader is closed or is already in memory.
            </remarks>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.NextResult">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.Close">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.Read">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetSchemaTable">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.Finalize">
      <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.Dispose">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.Dispose(System.Boolean)">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
      <param name="isDisposing">Indicates if this NHybridDataReader is being Disposed of or Finalized.</param>
      <remarks>
            If this NHybridDataReader is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this NHybridDataReader back to life.
            </remarks>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetInt32(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetValue(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.IsDBNull(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <param name="fieldOffset">
      </param>
      <param name="buffer">
      </param>
      <param name="bufferoffset">
      </param>
      <param name="length">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetByte(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetFieldType(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetDecimal(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetValues(System.Object[])">
      <summary>
      </summary>
      <param name="values">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetName(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetInt64(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetDouble(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetBoolean(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetGuid(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetDateTime(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetOrdinal(System.String)">
      <summary>
      </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetDataTypeName(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetFloat(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetData(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <param name="fieldoffset">
      </param>
      <param name="buffer">
      </param>
      <param name="bufferoffset">
      </param>
      <param name="length">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetString(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetChar(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Driver.NHybridDataReader.GetInt16(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Driver.NHybridDataReader.IsMidstream">
      <summary>
            Gets if the object is in the middle of reading a Result.
            </summary>
      <value>
        <see langword="true" /> if NextResult and Read have been called on the <see cref="T:System.Data.IDataReader" />.</value>
    </member>
    <member name="P:NHibernate.Driver.NHybridDataReader.RecordsAffected">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.NHybridDataReader.IsClosed">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.NHybridDataReader.Depth">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.NHybridDataReader.Item(System.String)">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.NHybridDataReader.FieldCount">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Driver.NpgsqlDriver">
      <summary>
            The PostgreSQL data provider provides a database driver for PostgreSQL.
            <p>
            Author: <a href="mailto:oliver@weichhold.com">Oliver Weichhold</a></p></summary>
      <remarks>
        <p>
            In order to use this Driver you must have the Npgsql.dll Assembly available for 
            NHibernate to load it.
            </p>
        <p>
            Please check the products website 
            <a href="http://www.postgresql.org/">http://www.postgresql.org/</a>
            for any updates and or documentation.
            </p>
        <p>
            The homepage for the .NET DataProvider is: 
            <a href="http://pgfoundry.org/projects/npgsql">http://pgfoundry.org/projects/npgsql</a>. 
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.Driver.NpgsqlDriver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.NpgsqlDriver" /> class.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Npgsql</c> assembly can not be loaded.
            </exception>
    </member>
    <member name="T:NHibernate.Driver.OdbcDriver">
      <summary>
            A NHibernate Driver for using the Odbc DataProvider
            </summary>
      <remarks>
            Always look for a native .NET DataProvider before using the Odbc DataProvider.
            </remarks>
    </member>
    <member name="T:NHibernate.Driver.OleDbDriver">
      <summary>
            A NHibernate Driver for using the OleDb DataProvider
            </summary>
      <remarks>
            Always look for a native .NET DataProvider before using the OleDb DataProvider.
            </remarks>
    </member>
    <member name="P:NHibernate.Driver.OleDbDriver.SupportsMultipleOpenReaders">
      <summary>
            OLE DB provider does not support multiple open data readers
            </summary>
    </member>
    <member name="T:NHibernate.Driver.OracleClientDriver">
      <summary>
            A NHibernate Driver for using the Oracle DataProvider.
            </summary>
    </member>
    <member name="T:NHibernate.Driver.OracleDataClientDriver">
      <summary>
            A NHibernate Driver for using the Oracle.DataAccess DataProvider
            </summary>
      <remarks>
            Code was contributed by <a href="http://sourceforge.net/users/jemcalgary/">James Mills</a>
            on the NHibernate forums in this 
            <a href="http://sourceforge.net/forum/message.php?msg_id=2952662">post</a>.
            </remarks>
    </member>
    <member name="M:NHibernate.Driver.OracleDataClientDriver.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.OracleDataClientDriver" />.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Oracle.DataAccess</c> assembly can not be loaded.
            </exception>
    </member>
    <member name="M:NHibernate.Driver.OracleDataClientDriver.InitializeParameter(System.Data.IDbDataParameter,System.String,NHibernate.SqlTypes.SqlType)">
      <remarks>
            This adds logic to ensure that a DbType.Boolean parameter is not created since
            ODP.NET doesn't support it.
            </remarks>
    </member>
    <member name="P:NHibernate.Driver.OracleDataClientDriver.UseNamedPrefixInSql">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.OracleDataClientDriver.UseNamedPrefixInParameter">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.OracleDataClientDriver.NamedPrefix">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Driver.OracleLiteDataClientDriver">
      <summary>
            A NHibernate Driver for using the Oracle.DataAccess.Lite DataProvider
            </summary>
    </member>
    <member name="M:NHibernate.Driver.OracleLiteDataClientDriver.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.OracleLiteDataClientDriver" />.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Oracle.DataAccess.Lite_w32</c> assembly can not be loaded.
            </exception>
    </member>
    <member name="M:NHibernate.Driver.OracleLiteDataClientDriver.InitializeParameter(System.Data.IDbDataParameter,System.String,NHibernate.SqlTypes.SqlType)">
      <remarks>
            This adds logic to ensure that a DbType.Boolean parameter is not created since
            ODP.NET doesn't support it.
            </remarks>
    </member>
    <member name="T:NHibernate.Driver.SqlClientDriver">
      <summary>
            A NHibernate Driver for using the SqlClient DataProvider
            </summary>
    </member>
    <member name="M:NHibernate.Driver.SqlClientDriver.CreateConnection">
      <summary>
            Creates an uninitialized <see cref="T:System.Data.IDbConnection" /> object for 
            the SqlClientDriver.
            </summary>
      <value>An unitialized <see cref="T:System.Data.SqlClient.SqlConnection" /> object.</value>
    </member>
    <member name="M:NHibernate.Driver.SqlClientDriver.CreateCommand">
      <summary>
            Creates an uninitialized <see cref="T:System.Data.IDbCommand" /> object for 
            the SqlClientDriver.
            </summary>
      <value>An unitialized <see cref="T:System.Data.SqlClient.SqlCommand" /> object.</value>
    </member>
    <member name="P:NHibernate.Driver.SqlClientDriver.UseNamedPrefixInSql">
      <summary>
            MsSql requires the use of a Named Prefix in the SQL statement.  
            </summary>
      <remarks>
        <see langword="true" /> because MsSql uses "<c>@</c>".
            </remarks>
    </member>
    <member name="P:NHibernate.Driver.SqlClientDriver.UseNamedPrefixInParameter">
      <summary>
            MsSql requires the use of a Named Prefix in the Parameter.  
            </summary>
      <remarks>
        <see langword="true" /> because MsSql uses "<c>@</c>".
            </remarks>
    </member>
    <member name="P:NHibernate.Driver.SqlClientDriver.NamedPrefix">
      <summary>
            The Named Prefix for parameters.  
            </summary>
      <value>
            Sql Server uses <c>"@"</c>.
            </value>
    </member>
    <member name="P:NHibernate.Driver.SqlClientDriver.SupportsMultipleOpenReaders">
      <summary>
            The SqlClient driver does NOT support more than 1 open IDataReader
            with only 1 IDbConnection.
            </summary>
      <value>
        <see langword="false" /> - it is not supported.</value>
      <remarks>
            MS SQL Server 2000 (and 7) throws an exception when multiple IDataReaders are 
            attempted to be opened.  When SQL Server 2005 comes out a new driver will be 
            created for it because SQL Server 2005 is supposed to support it.
            </remarks>
    </member>
    <member name="T:NHibernate.Driver.SQLite20Driver">
      <summary>
            NHibernate driver for the System.Data.SQLite data provider for .NET 2.0.
            </summary>
      <remarks>
        <p>
            In order to use this driver you must have the System.Data.SQLite.dll assembly available
            for NHibernate to load. This assembly includes the SQLite.dll or SQLite3.dll libraries.
            </p>
        <p>
            You can get the System.Data.SQLite.dll assembly from http://sourceforge.net/projects/sqlite-dotnet2.
            </p>
        <p>
            Please check <a href="http://www.sqlite.org/">http://www.sqlite.org/</a> for more information regarding SQLite.
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.Driver.SQLite20Driver.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.SQLiteDriver" />.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>SQLite.NET</c> assembly can not be loaded.
            </exception>
    </member>
    <member name="T:NHibernate.Driver.SQLiteDriver">
      <summary>
            NHibernate driver for the SQLite.NET data provider.
            <p>
            Author: <a href="mailto:ib@stalker.ro"> Ioan Bizau </a></p></summary>
      <remarks>
        <p>
            In order to use this Driver you must have the SQLite.NET.dll Assembly available for NHibernate to load it.
            You must also have the SQLite.dll and SQLite3.dll libraries.
            </p>
        <p>
            Please check <a href="http://www.sqlite.org/"> http://www.sqlite.org/ </a> for more information regarding SQLite.
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.Driver.SQLiteDriver.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.SQLiteDriver" />.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>SQLite.NET</c> assembly can not be loaded.
            </exception>
    </member>
    <member name="T:NHibernate.Driver.SqlServerCeDriver">
      <summary>
            A NHibernate driver for Microsoft SQL Server CE data provider
            </summary>
    </member>
    <member name="M:NHibernate.Driver.SqlServerCeDriver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.SqlServerCeDriver" /> class.
            </summary>
    </member>
    <member name="P:NHibernate.Driver.SqlServerCeDriver.UseNamedPrefixInSql">
      <summary>
            MsSql requires the use of a Named Prefix in the SQL statement.  
            </summary>
      <remarks>
        <see langword="true" /> because MsSql uses "<c>@</c>".
            </remarks>
    </member>
    <member name="P:NHibernate.Driver.SqlServerCeDriver.UseNamedPrefixInParameter">
      <summary>
            MsSql requires the use of a Named Prefix in the Parameter.  
            </summary>
      <remarks>
        <see langword="true" /> because MsSql uses "<c>@</c>".
            </remarks>
    </member>
    <member name="P:NHibernate.Driver.SqlServerCeDriver.NamedPrefix">
      <summary>
            The Named Prefix for parameters.  
            </summary>
      <value>
            Sql Server uses <c>"@"</c>.
            </value>
    </member>
    <member name="P:NHibernate.Driver.SqlServerCeDriver.SupportsMultipleOpenReaders">
      <summary>
            The SqlClient driver does NOT support more than 1 open IDataReader
            with only 1 IDbConnection.
            </summary>
      <value>
        <see langword="false" /> - it is not supported.</value>
      <remarks>
            Ms Sql 2000 (and 7) throws an Exception when multiple DataReaders are 
            attempted to be Opened.  When Yukon comes out a new Driver will be 
            created for Yukon because it is supposed to support it.
            </remarks>
    </member>
    <member name="T:NHibernate.Driver.SybaseAdoNet12ClientDriver">
      <summary>
            The SybaseClientDriver Driver provides a database driver for Sybase.
            </summary>
      <remarks>
            It has been reported to work with the <see cref="T:NHibernate.Dialect.MsSql2000Dialect" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Driver.SybaseAdoNet12ClientDriver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.SybaseClientDriver" /> class.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the Sybase.Data.AseClient assembly can not be loaded.
            </exception>
    </member>
    <member name="P:NHibernate.Driver.SybaseAdoNet12ClientDriver.UseNamedPrefixInSql">
      <summary>
            Sybase.Data.AseClient uses named parameters in the sql.
            </summary>
      <value>
        <see langword="true" /> - Sybase uses <c>@</c> in the sql.</value>
    </member>
    <member name="P:NHibernate.Driver.SybaseAdoNet12ClientDriver.UseNamedPrefixInParameter">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.SybaseAdoNet12ClientDriver.NamedPrefix">
      <summary>
            Sybase.Data.AseClient use the <c>@</c> to locate parameters in sql.
            </summary>
      <value>
        <c>@</c> is used to locate parameters in sql.</value>
    </member>
    <member name="T:NHibernate.Driver.SybaseClientDriver">
      <summary>
            The SybaseClientDriver Driver provides a database driver for Sybase.
            </summary>
      <remarks>
            It has been reported to work with the <see cref="T:NHibernate.Dialect.MsSql2000Dialect" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Driver.SybaseClientDriver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.SybaseClientDriver" /> class.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the Sybase.Data.AseClient assembly can not be loaded.
            </exception>
    </member>
    <member name="P:NHibernate.Driver.SybaseClientDriver.UseNamedPrefixInSql">
      <summary>
            Sybase.Data.AseClient uses named parameters in the sql.
            </summary>
      <value>
        <see langword="true" /> - Sybase uses <c>@</c> in the sql.</value>
    </member>
    <member name="P:NHibernate.Driver.SybaseClientDriver.UseNamedPrefixInParameter">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Driver.SybaseClientDriver.NamedPrefix">
      <summary>
            Sybase.Data.AseClient use the <c>@</c> to locate parameters in sql.
            </summary>
      <value>
        <c>@</c> is used to locate parameters in sql.</value>
    </member>
    <member name="T:NHibernate.Engine.Loading.CollectionLoadContext">
      <summary> 
            Represents state associated with the processing of a given <see cref="T:System.Data.IDataReader" />
            in regards to loading collections.
            </summary>
      <remarks>
            Another implementation option to consider is to not expose <see cref="T:System.Data.IDataReader">ResultSets</see>
            directly (in the JDBC redesign) but to always "wrap" them and apply a [series of] context[s] to that wrapper.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.Loading.CollectionLoadContext.#ctor(NHibernate.Engine.Loading.LoadContexts,System.Data.IDataReader)">
      <summary> 
            Creates a collection load context for the given result set. 
            </summary>
      <param name="loadContexts">Callback to other collection load contexts. </param>
      <param name="resultSet">The result set this is "wrapping".</param>
    </member>
    <member name="M:NHibernate.Engine.Loading.CollectionLoadContext.GetLoadingCollection(NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary> 
            Retrieve the collection that is being loaded as part of processing this result set. 
            </summary>
      <param name="persister">The persister for the collection being requested. </param>
      <param name="key">The key of the collection being requested. </param>
      <returns> The loading collection (see discussion above). </returns>
      <remarks>
            Basically, there are two valid return values from this method:<ul><li>an instance of {@link PersistentCollection} which indicates to
            continue loading the result set row data into that returned collection
            instance; this may be either an instance already associated and in the
            midst of being loaded, or a newly instantiated instance as a matching
            associated collection was not found.</li><li><i>null</i> indicates to ignore the corresponding result set row
            data relating to the requested collection; this indicates that either
            the collection was found to already be associated with the persistence
            context in a fully loaded state, or it was found in a loading state
            associated with another result set processing context.</li></ul></remarks>
    </member>
    <member name="M:NHibernate.Engine.Loading.CollectionLoadContext.EndLoadingCollections(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary> 
            Finish the process of collection-loading for this bound result set.  Mainly this
            involves cleaning up resources and notifying the collections that loading is
            complete. 
            </summary>
      <param name="persister">The persister for which to complete loading. </param>
    </member>
    <member name="M:NHibernate.Engine.Loading.CollectionLoadContext.AddCollectionToCache(NHibernate.Engine.Loading.LoadingCollectionEntry,NHibernate.Persister.Collection.ICollectionPersister)">
      <summary> Add the collection to the second-level cache </summary>
      <param name="lce">The entry representing the collection to add </param>
      <param name="persister">The persister </param>
    </member>
    <member name="T:NHibernate.Engine.Loading.LoadContexts">
      <summary> 
            Maps <see cref="T:System.Data.IDataReader" /> to specific contextual data
            related to processing that <see cref="T:System.Data.IDataReader" />.
            </summary>
      <remarks>
            Implementation note: internally an <see cref="T:NHibernate.Util.IdentityMap" /> is used to maintain
            the mappings; <see cref="T:NHibernate.Util.IdentityMap" /> was chosen because I'd rather not be
            dependent upon potentially bad <see cref="T:System.Data.IDataReader" /> and <see cref="T:System.Data.IDataReader" />
            implementations.
            Considering the JDBC-redesign work, would further like this contextual info
            not mapped separately, but available based on the result set being processed.
            This would also allow maintaining a single mapping as we could reliably get
            notification of the result-set closing...
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.Loading.LoadContexts.#ctor(NHibernate.Engine.IPersistenceContext)">
      <summary> Creates and binds this to the given persistence context. </summary>
      <param name="persistenceContext">The persistence context to which this will be bound. </param>
    </member>
    <member name="M:NHibernate.Engine.Loading.LoadContexts.Cleanup(System.Data.IDataReader)">
      <summary> 
            Release internal state associated with the given result set.
             </summary>
      <param name="resultSet">The result set for which it is ok to release associated resources. </param>
      <remarks>
            This should be called when we are done with processing said result set,
            ideally as the result set is being closed.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.Loading.LoadContexts.Cleanup">
      <summary> Release internal state associated with *all* result sets. </summary>
      <remarks>
            This is intended as a "failsafe" process to make sure we get everything
            cleaned up and released.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.Loading.LoadContexts.GetCollectionLoadContext(System.Data.IDataReader)">
      <summary> 
            Get the {@link CollectionLoadContext} associated with the given
            {@link ResultSet}, creating one if needed. 
            </summary>
      <param name="resultSet">The result set for which to retrieve the context. </param>
      <returns> The processing context. </returns>
    </member>
    <member name="M:NHibernate.Engine.Loading.LoadContexts.LocateLoadingCollection(NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary> 
            Attempt to locate the loading collection given the owner's key.  The lookup here
            occurs against all result-set contexts... 
            </summary>
      <param name="persister">The collection persister </param>
      <param name="ownerKey">The owner key </param>
      <returns> The loading collection, or null if not found. </returns>
    </member>
    <member name="M:NHibernate.Engine.Loading.LoadContexts.RegisterLoadingCollectionXRef(NHibernate.Engine.CollectionKey,NHibernate.Engine.Loading.LoadingCollectionEntry)">
      <summary> 
            Register a loading collection xref. 
            </summary>
      <param name="entryKey">The xref collection key </param>
      <param name="entry">The corresponding loading collection entry </param>
      <remarks>
            This xref map is used because sometimes a collection is in process of
            being loaded from one result set, but needs to be accessed from the
            context of another "nested" result set processing.
            Implementation note: package protected, as this is meant solely for use
            by {@link CollectionLoadContext} to be able to locate collections
            being loaded by other {@link CollectionLoadContext}s/{@link ResultSet}s.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.Loading.LoadContexts.UnregisterLoadingCollectionXRef(NHibernate.Engine.CollectionKey)">
      <summary> 
            The inverse of {@link #registerLoadingCollectionXRef}.  Here, we are done
            processing the said collection entry, so we remove it from the
            load context.
            </summary>
      <param name="key">The key of the collection we are done processing. </param>
      <remarks>
            The idea here is that other loading collections can now reference said
            collection directly from the {@link PersistenceContext} because it
            has completed its load cycle.
            Implementation note: package protected, as this is meant solely for use
            by {@link CollectionLoadContext} to be able to locate collections
            being loaded by other {@link CollectionLoadContext}s/{@link ResultSet}s.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.Loading.LoadContexts.LocateLoadingCollectionEntry(NHibernate.Engine.CollectionKey)">
      <summary> 
            Locate the LoadingCollectionEntry within *any* of the tracked
            <see cref="T:NHibernate.Engine.Loading.CollectionLoadContext" />s.
            </summary>
      <param name="key">The collection key. </param>
      <returns> The located entry; or null. </returns>
      <remarks>
            Implementation note: package protected, as this is meant solely for use
            by <see cref="T:NHibernate.Engine.Loading.CollectionLoadContext" /> to be able to locate collections
            being loaded by other <see cref="T:NHibernate.Engine.Loading.CollectionLoadContext" />s/ResultSets. 
            </remarks>
    </member>
    <member name="P:NHibernate.Engine.Loading.LoadContexts.PersistenceContext">
      <summary> 
            Retrieves the persistence context to which this is bound.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.Loading.LoadContexts.HasLoadingCollectionEntries">
      <summary> 
            Do we currently have any internal entries corresponding to loading
            collections?
            </summary>
      <returns> True if we currently hold state pertaining to loading collections; false otherwise. </returns>
    </member>
    <member name="T:NHibernate.Engine.Loading.LoadingCollectionEntry">
      <summary> 
            Represents a collection currently being loaded. 
            </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.Sql.INativeSQLQueryReturn">
      <summary> Describes a return in a native SQL query. </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.Sql.NativeSQLQueryNonScalarReturn">
      <summary> 
            Represents the base information for a non-scalar return defined as part of
            a native sql query. 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.Query.Sql.NativeSQLQueryNonScalarReturn.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String[]},NHibernate.LockMode)">
      <summary> Constructs some form of non-scalar return descriptor </summary>
      <param name="alias">The result alias </param>
      <param name="propertyResults">Any user-supplied column-&gt;property mappings </param>
      <param name="lockMode">The lock mode to apply to the return. </param>
    </member>
    <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryNonScalarReturn.Alias">
      <summary> Retrieve the defined result alias </summary>
    </member>
    <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryNonScalarReturn.LockMode">
      <summary> Retrieve the lock-mode to apply to this return </summary>
    </member>
    <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryNonScalarReturn.PropertyResultsMap">
      <summary> Retrieve the user-supplied column-&gt;property mappings. </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.Sql.NativeSQLQueryCollectionReturn">
      <summary> 
            Represents a return defined as part of a native sql query which
            names a collection role in the form {classname}.{collectionrole}; it
            is used in defining a custom sql query for loading an entity's
            collection in non-fetching scenarios (i.e., loading the collection
            itself as the "root" of the result). 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.Query.Sql.NativeSQLQueryCollectionReturn.#ctor(System.String,System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String[]},NHibernate.LockMode)">
      <summary> Construct a native-sql return representing a collection initializer </summary>
      <param name="alias">The result alias </param>
      <param name="ownerEntityName">
            The entity-name of the entity owning the collection to be initialized. 
            </param>
      <param name="ownerProperty">
            The property name (on the owner) which represents
            the collection to be initialized.
            </param>
      <param name="propertyResults">Any user-supplied column-&gt;property mappings </param>
      <param name="lockMode">The lock mode to apply to the collection. </param>
    </member>
    <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryCollectionReturn.OwnerEntityName">
      <summary> 
            The class owning the collection. 
            </summary>
    </member>
    <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryCollectionReturn.OwnerProperty">
      <summary> 
            The name of the property representing the collection from the <see cref="P:NHibernate.Engine.Query.Sql.NativeSQLQueryCollectionReturn.OwnerEntityName" />. 
            </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.Sql.NativeSQLQueryJoinReturn">
      <summary> 
            Represents a return defined as part of a native sql query which
            names a fetched role. 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.Query.Sql.NativeSQLQueryJoinReturn.#ctor(System.String,System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String[]},NHibernate.LockMode)">
      <summary> Construct a return descriptor representing some form of fetch. </summary>
      <param name="alias">The result alias </param>
      <param name="ownerAlias">The owner's result alias </param>
      <param name="ownerProperty">The owner's property representing the thing to be fetched </param>
      <param name="propertyResults">Any user-supplied column-&gt;property mappings </param>
      <param name="lockMode">The lock mode to apply </param>
    </member>
    <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryJoinReturn.OwnerAlias">
      <summary> The alias of the owner of this fetched association. </summary>
    </member>
    <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryJoinReturn.OwnerProperty">
      <summary> 
            Retrieve the property name (relative to the owner) which maps to
            the association to be fetched. 
            </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.Sql.NativeSQLQueryRootReturn">
      <summary> 
            Represents a return defined as part of a native sql query which
            names a "root" entity.  A root entity means it is explicitly a
            "column" in the result, as opposed to a fetched relationship or role. 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.Query.Sql.NativeSQLQueryRootReturn.#ctor(System.String,System.String,NHibernate.LockMode)">
      <summary> 
            Construct a return representing an entity returned at the root
            of the result.
             </summary>
      <param name="alias">The result alias </param>
      <param name="entityName">The entity name. </param>
      <param name="lockMode">The lock mode to apply </param>
    </member>
    <member name="M:NHibernate.Engine.Query.Sql.NativeSQLQueryRootReturn.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String[]},NHibernate.LockMode)">
      <summary> 
            Construct a return representing an entity returned at the root
            of the result. 
            </summary>
      <param name="alias">The result alias </param>
      <param name="entityName">The entity name. </param>
      <param name="propertyResults">Any user-supplied column-&gt;property mappings </param>
      <param name="lockMode">The lock mode to apply </param>
    </member>
    <member name="P:NHibernate.Engine.Query.Sql.NativeSQLQueryRootReturn.ReturnEntityName">
      <summary> The name of the entity to be returned. </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.Sql.NativeSQLQueryScalarReturn">
      <summary> Describes a scalar return in a native SQL query. </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.HQLQueryPlan">
      <summary> Defines a query execution plan for an HQL query (or filter). </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.FilterQueryPlan">
      <summary> 
            Extends an HQLQueryPlan to maintain a reference to the collection-role name
            being filtered. 
            </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.NamedParameterDescriptor">
      <summary> Descriptor regarding a named parameter. </summary>
    </member>
    <member name="P:NHibernate.Engine.Query.NamedParameterDescriptor.JpaStyle">
      <summary>
            Not supported yet (AST parse needed)
            </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.NativeSQLQueryPlan">
      <summary> Defines a query execution plan for a native-SQL query. </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.ParameterMetadata">
      <summary> Encapsulates metadata about parameters encountered within a query. </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.ParameterParser">
      <summary>
            The single available method <see cref="M:NHibernate.Engine.Query.ParameterParser.Parse(System.String,NHibernate.Engine.Query.ParameterParser.IRecognizer)" />
            is responsible for parsing a query string and recognizing tokens in
            relation to parameters (either named, ejb3-style, or ordinal) and
            providing callbacks about such recognitions.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.Query.ParameterParser.Parse(System.String,NHibernate.Engine.Query.ParameterParser.IRecognizer)">
      <summary>
            Performs the actual parsing and tokenizing of the query string making appropriate
            callbacks to the given recognizer upon recognition of the various tokens.
            </summary>
      <remarks>
            Note that currently, this only knows how to deal with a single output
            parameter (for callable statements).  If we later add support for
            multiple output params, this, obviously, needs to change.
            </remarks>
      <param name="sqlString">The string to be parsed/tokenized.</param>
      <param name="recognizer">The thing which handles recognition events.</param>
      <exception cref="T:NHibernate.QueryException" />
    </member>
    <member name="T:NHibernate.Engine.Query.ParamLocationRecognizer">
      <summary> 
            Implements a parameter parser recognizer specifically for the purpose
            of journaling parameter locations. 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.Query.ParamLocationRecognizer.ParseLocations(System.String)">
      <summary> 
            Convenience method for creating a param location recognizer and
            initiating the parse. 
            </summary>
      <param name="query">The query to be parsed for parameter locations. </param>
      <returns> The generated recognizer, with journaled location info. </returns>
    </member>
    <member name="P:NHibernate.Engine.Query.ParamLocationRecognizer.NamedParameterDescriptionMap">
      <summary> 
            The dictionary of named parameter locations.
            The dictionary is keyed by parameter name.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.Query.ParamLocationRecognizer.OrdinalParameterLocationList">
      <summary> 
            The list of ordinal parameter locations. 
            </summary>
      <remarks>
            The list elements are integers, representing the location for that given ordinal.
            Thus OrdinalParameterLocationList[n] represents the location for the nth parameter.
            </remarks>
    </member>
    <member name="T:NHibernate.Engine.Query.QueryMetadata">
      <summary> Defines metadata regarding a translated HQL or native-SQL query. </summary>
    </member>
    <member name="P:NHibernate.Engine.Query.QueryMetadata.SourceQuery">
      <summary> Get the source HQL or native-SQL query. </summary>
    </member>
    <member name="P:NHibernate.Engine.Query.QueryMetadata.ReturnAliases">
      <summary> Return source query select clause aliases (if any) </summary>
    </member>
    <member name="P:NHibernate.Engine.Query.QueryMetadata.ReturnTypes">
      <summary> An array of types describing the returns of the source query. </summary>
    </member>
    <member name="P:NHibernate.Engine.Query.QueryMetadata.QuerySpaces">
      <summary> The set of query spaces affected by this source query. </summary>
    </member>
    <member name="T:NHibernate.Engine.Query.QueryPlanCache">
      <summary> Acts as a cache for compiled query plans, as well as query-parameter metadata. </summary>
    </member>
    <member name="T:NHibernate.Engine.Transaction.IIsolatedWork">
      <summary>
            Represents work that needs to be performed in a manner
            which isolates it from any current application unit of
            work transaction.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.Transaction.IIsolatedWork.DoWork(System.Data.IDbConnection,System.Data.IDbTransaction)">
      <summary>
            Perform the actual work to be done.
            </summary>
      <param name="connection">The ADP connection to use.</param>
      <param name="transaction">The active transaction of the connection.</param>
    </member>
    <member name="T:NHibernate.Engine.Transaction.Isolater">
      <summary>
            Class which provides the isolation semantics required by
            an <see cref="T:NHibernate.Engine.Transaction.IIsolatedWork" />.
            </summary>
      <remarks>
        <list type="bullet">
          <listheader>
            <description>Processing comes in two flavors:</description>
          </listheader>
          <item>
            <term>
              <see cref="M:NHibernate.Engine.Transaction.Isolater.DoIsolatedWork(NHibernate.Engine.Transaction.IIsolatedWork,NHibernate.Engine.ISessionImplementor)" />
            </term>
            <description>makes sure the work to be done is performed in a seperate, distinct transaction</description>
          </item>
          <item>
            <term>
              <see cref="M:NHibernate.Engine.Transaction.Isolater.DoNonTransactedWork(NHibernate.Engine.Transaction.IIsolatedWork,NHibernate.Engine.ISessionImplementor)" />
            </term>
            <description>makes sure the work to be done is performed outside the scope of any transaction</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:NHibernate.Engine.Transaction.Isolater.DoIsolatedWork(NHibernate.Engine.Transaction.IIsolatedWork,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Ensures that all processing actually performed by the given work will
            occur on a seperate transaction. 
            </summary>
      <param name="work">The work to be performed. </param>
      <param name="session">The session from which this request is originating. </param>
    </member>
    <member name="M:NHibernate.Engine.Transaction.Isolater.DoNonTransactedWork(NHibernate.Engine.Transaction.IIsolatedWork,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Ensures that all processing actually performed by the given work will
            occur outside of a transaction. 
            </summary>
      <param name="work">The work to be performed. </param>
      <param name="session">The session from which this request is originating. </param>
    </member>
    <member name="T:NHibernate.Engine.ActionQueue">
      <summary> 
            Responsible for maintaining the queue of actions related to events.
            <para>
            The ActionQueue holds the DML operations queued as part of a session's
            transactional-write-behind semantics. DML operations are queued here
            until a flush forces them to be executed against the database. 
            </para></summary>
    </member>
    <member name="M:NHibernate.Engine.ActionQueue.ExecuteInserts">
      <summary> 
            Perform all currently queued entity-insertion actions.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ActionQueue.ExecuteActions">
      <summary> 
            Perform all currently queued actions. 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ActionQueue.PrepareActions">
      <summary>
            Prepares the internal action queues for execution.  
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ActionQueue.AfterTransactionCompletion(System.Boolean)">
      <summary> 
            Performs cleanup of any held cache softlocks.
            </summary>
      <param name="success">Was the transaction successful.</param>
    </member>
    <member name="M:NHibernate.Engine.ActionQueue.AreTablesToBeUpdated(Iesi.Collections.Generic.ISet{System.String})">
      <summary> 
            Check whether the given tables/query-spaces are to be executed against
            given the currently queued actions. 
            </summary>
      <param name="tables">The table/query-spaces to check. </param>
      <returns> True if we contain pending actions against any of the given tables; false otherwise.</returns>
    </member>
    <member name="P:NHibernate.Engine.ActionQueue.AreInsertionsOrDeletionsQueued">
      <summary> 
            Check whether any insertion or deletion actions are currently queued. 
            </summary>
      <returns> True if insertions or deletions are currently queued; false otherwise.</returns>
    </member>
    <member name="T:NHibernate.Engine.AssociationKey">
      <summary> 
            Identifies a named association belonging to a particular
            entity instance. Used to record the fact that an association
            is null during loading. 
            </summary>
    </member>
    <member name="F:NHibernate.Engine.BatchFetchQueue.batchLoadableEntityKeys">
      <summary>
            Defines a sequence of <see cref="T:NHibernate.Engine.EntityKey" /> elements that are currently
            eligible for batch fetching.
            </summary>
      <remarks>
            Even though this is a map, we only use the keys.  A map was chosen in
            order to utilize a <see cref="T:NHibernate.Util.LinkedHashMap`2" /> to maintain sequencing
            as well as uniqueness.
            </remarks>
    </member>
    <member name="F:NHibernate.Engine.BatchFetchQueue.subselectsByEntityKey">
      <summary>
            A map of <see cref="T:NHibernate.Engine.SubselectFetch">subselect-fetch descriptors</see>
            keyed by the <see cref="T:NHibernate.Engine.EntityKey" /> against which the descriptor is
            registered.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.BatchFetchQueue.context">
      <summary>
            The owning persistence context.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.BatchFetchQueue.#ctor(NHibernate.Engine.IPersistenceContext)">
      <summary>
            Constructs a queue for the given context.
            </summary>
      <param name="context">The owning persistence context.</param>
    </member>
    <member name="M:NHibernate.Engine.BatchFetchQueue.Clear">
      <summary>
            Clears all entries from this fetch queue.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.BatchFetchQueue.GetSubselect(NHibernate.Engine.EntityKey)">
      <summary>
            Retrieve the fetch descriptor associated with the given entity key.
            </summary>
      <param name="key">The entity key for which to locate any defined subselect fetch.</param>
      <returns>The fetch descriptor; may return null if no subselect fetch queued for
            this entity key.</returns>
    </member>
    <member name="M:NHibernate.Engine.BatchFetchQueue.AddSubselect(NHibernate.Engine.EntityKey,NHibernate.Engine.SubselectFetch)">
      <summary>
            Adds a subselect fetch decriptor for the given entity key.
            </summary>
      <param name="key">The entity for which to register the subselect fetch.</param>
      <param name="subquery">The fetch descriptor.</param>
    </member>
    <member name="M:NHibernate.Engine.BatchFetchQueue.RemoveSubselect(NHibernate.Engine.EntityKey)">
      <summary>
            After evicting or deleting an entity, we don't need to
            know the query that was used to load it anymore (don't
            call this after loading the entity, since we might still
            need to load its collections)
            </summary>
    </member>
    <member name="M:NHibernate.Engine.BatchFetchQueue.ClearSubselects">
      <summary>
            Clears all pending subselect fetches from the queue.
            </summary>
      <remarks>
            Called after flushing.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.BatchFetchQueue.AddBatchLoadableEntityKey(NHibernate.Engine.EntityKey)">
      <summary>
            If an EntityKey represents a batch loadable entity, add
            it to the queue.
            </summary>
      <remarks>
            Note that the contract here is such that any key passed in should
            previously have been been checked for existence within the
            <see cref="T:NHibernate.ISession" />; failure to do so may cause the
            referenced entity to be included in a batch even though it is
            already associated with the <see cref="T:NHibernate.ISession" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.BatchFetchQueue.RemoveBatchLoadableEntityKey(NHibernate.Engine.EntityKey)">
      <summary>
            After evicting or deleting or loading an entity, we don't
            need to batch fetch it anymore, remove it from the queue
            if necessary
            </summary>
    </member>
    <member name="M:NHibernate.Engine.BatchFetchQueue.GetCollectionBatch(NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Int32,NHibernate.EntityMode)">
      <summary>
            Get a batch of uninitialized collection keys for a given role
            </summary>
      <param name="collectionPersister">The persister for the collection role.</param>
      <param name="id">A key that must be included in the batch fetch</param>
      <param name="batchSize">the maximum number of keys to return</param>
      <param name="entityMode">The entity mode.</param>
      <returns>an array of collection keys, of length batchSize (padded with nulls)</returns>
    </member>
    <member name="M:NHibernate.Engine.BatchFetchQueue.GetEntityBatch(NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Int32,NHibernate.EntityMode)">
      <summary>
            Get a batch of unloaded identifiers for this class, using a slightly
            complex algorithm that tries to grab keys registered immediately after
            the given key.
            </summary>
      <param name="persister">The persister for the entities being loaded.</param>
      <param name="id">The identifier of the entity currently demanding load.</param>
      <param name="batchSize">The maximum number of keys to return</param>
      <param name="entityMode">The entity mode.</param>
      <returns>an array of identifiers, of length batchSize (possibly padded with nulls)</returns>
    </member>
    <member name="T:NHibernate.Engine.CascadePoint">
      <summary>
            The types of children to cascade to
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CascadePoint.AfterInsertBeforeDelete">
      <summary>
            A cascade point that occurs just after the insertion of the parent
            entity and just before deletion
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CascadePoint.BeforeInsertAfterDelete">
      <summary>
            A cascade point that occurs just before the insertion of the parent entity
            and just after deletion
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CascadePoint.AfterInsertBeforeDeleteViaCollection">
      <summary>
            A cascade point that occurs just after the insertion of the parent entity
            and just before deletion, inside a collection
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CascadePoint.AfterUpdate">
      <summary>
            A cascade point that occurs just after the update of the parent entity
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CascadePoint.BeforeFlush">
      <summary> A cascade point that occurs just before the session is flushed</summary>
    </member>
    <member name="F:NHibernate.Engine.CascadePoint.AfterEvict">
      <summary>
            A cascade point that occurs just after eviction of the parent entity from the
            session cache
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CascadePoint.BeforeRefresh">
      <summary> 
            A cascade point that occurs just after locking a transient parent entity into the
            session cache
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CascadePoint.AfterLock">
      <summary>
            A cascade point that occurs just after locking a transient parent entity into the session cache
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CascadePoint.BeforeMerge">
      <summary>
            A cascade point that occurs just before merging from a transient parent entity into
            the object in the session cache
            </summary>
    </member>
    <member name="T:NHibernate.Engine.Cascade">
      <summary> 
            Delegate responsible, in conjunction with the various
            <see cref="T:NHibernate.Engine.CascadingAction" />, for implementing cascade processing. 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.Cascade.CascadeOn(NHibernate.Persister.Entity.IEntityPersister,System.Object)">
      <summary> Cascade an action from the parent entity instance to all its children. </summary>
      <param name="persister">The parent's entity persister </param>
      <param name="parent">The parent reference. </param>
    </member>
    <member name="M:NHibernate.Engine.Cascade.CascadeOn(NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object)">
      <summary> 
            Cascade an action from the parent entity instance to all its children.  This
            form is typicaly called from within cascade actions. 
            </summary>
      <param name="persister">The parent's entity persister </param>
      <param name="parent">The parent reference. </param>
      <param name="anything">
            Typically some form of cascade-local cache
            which is specific to each CascadingAction type
            </param>
    </member>
    <member name="M:NHibernate.Engine.Cascade.CascadeProperty(System.Object,NHibernate.Type.IType,NHibernate.Engine.CascadeStyle,System.Object,System.Boolean)">
      <summary> Cascade an action to the child or children</summary>
    </member>
    <member name="M:NHibernate.Engine.Cascade.CascadeCollection(System.Object,NHibernate.Engine.CascadeStyle,System.Object,NHibernate.Type.CollectionType)">
      <summary> Cascade an action to a collection</summary>
    </member>
    <member name="M:NHibernate.Engine.Cascade.CascadeToOne(System.Object,NHibernate.Type.IType,NHibernate.Engine.CascadeStyle,System.Object,System.Boolean)">
      <summary> Cascade an action to a to-one association or any type</summary>
    </member>
    <member name="M:NHibernate.Engine.Cascade.CascadeCollectionElements(System.Object,NHibernate.Type.CollectionType,NHibernate.Engine.CascadeStyle,NHibernate.Type.IType,System.Object,System.Boolean)">
      <summary> Cascade to the collection elements</summary>
    </member>
    <member name="M:NHibernate.Engine.Cascade.DeleteOrphans(System.String,NHibernate.Collection.IPersistentCollection)">
      <summary> Delete any entities that were removed from the collection</summary>
    </member>
    <member name="T:NHibernate.Engine.CascadeStyle">
      <summary> A contract for defining the aspects of cascading various persistence actions. </summary>
      <seealso cref="T:NHibernate.Engine.CascadingAction" />
    </member>
    <member name="F:NHibernate.Engine.CascadeStyle.AllDeleteOrphan">
      <summary> save / delete / update / evict / lock / replicate / merge / persist + delete orphans</summary>
    </member>
    <member name="F:NHibernate.Engine.CascadeStyle.All">
      <summary> save / delete / update / evict / lock / replicate / merge / persist</summary>
    </member>
    <member name="F:NHibernate.Engine.CascadeStyle.Update">
      <summary> save / update</summary>
    </member>
    <member name="F:NHibernate.Engine.CascadeStyle.Lock">
      <summary> lock</summary>
    </member>
    <member name="F:NHibernate.Engine.CascadeStyle.Refresh">
      <summary> refresh</summary>
    </member>
    <member name="F:NHibernate.Engine.CascadeStyle.Evict">
      <summary> evict</summary>
    </member>
    <member name="F:NHibernate.Engine.CascadeStyle.Replicate">
      <summary> replicate</summary>
    </member>
    <member name="F:NHibernate.Engine.CascadeStyle.Merge">
      <summary> merge</summary>
    </member>
    <member name="F:NHibernate.Engine.CascadeStyle.Persist">
      <summary> create</summary>
    </member>
    <member name="F:NHibernate.Engine.CascadeStyle.Delete">
      <summary> delete</summary>
    </member>
    <member name="F:NHibernate.Engine.CascadeStyle.DeleteOrphan">
      <summary> delete + delete orphans</summary>
    </member>
    <member name="F:NHibernate.Engine.CascadeStyle.None">
      <summary> no cascades</summary>
    </member>
    <member name="M:NHibernate.Engine.CascadeStyle.#ctor">
      <summary> package-protected constructor</summary>
    </member>
    <member name="M:NHibernate.Engine.CascadeStyle.DoCascade(NHibernate.Engine.CascadingAction)">
      <summary> For this style, should the given action be cascaded? </summary>
      <param name="action">The action to be checked for cascade-ability. </param>
      <returns> True if the action should be cascaded under this style; false otherwise. </returns>
    </member>
    <member name="M:NHibernate.Engine.CascadeStyle.ReallyDoCascade(NHibernate.Engine.CascadingAction)">
      <summary> 
            Probably more aptly named something like doCascadeToCollectionElements(); 
            it is however used from both the collection and to-one logic branches...
            </summary>
      <param name="action">The action to be checked for cascade-ability. </param>
      <returns> True if the action should be really cascaded under this style; false otherwise. </returns>
      <remarks>
            For this style, should the given action really be cascaded?  The default
            implementation is simply to return {@link #doCascade}; for certain
            styles (currently only delete-orphan), however, we need to be able to
            control this separately.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.CascadeStyle.GetCascadeStyle(System.String)">
      <summary> Factory method for obtaining named cascade styles </summary>
      <param name="cascade">The named cascade style name. </param>
      <returns> The appropriate CascadeStyle </returns>
    </member>
    <member name="P:NHibernate.Engine.CascadeStyle.HasOrphanDelete">
      <summary> Do we need to delete orphaned collection elements? </summary>
      <returns> True if this style need to account for orphan delete operations; false otherwise. </returns>
    </member>
    <member name="T:NHibernate.Engine.CascadingAction">
      <summary>
            A session action that may be cascaded from parent entity to its children
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CascadingAction.Delete">
      <seealso cref="M:NHibernate.ISession.Delete(System.Object)" />
    </member>
    <member name="F:NHibernate.Engine.CascadingAction.Lock">
      <seealso cref="M:NHibernate.ISession.Lock(System.Object,NHibernate.LockMode)" />
    </member>
    <member name="F:NHibernate.Engine.CascadingAction.Refresh">
      <seealso cref="M:NHibernate.ISession.Refresh(System.Object)" />
    </member>
    <member name="F:NHibernate.Engine.CascadingAction.Evict">
      <seealso cref="M:NHibernate.ISession.Evict(System.Object)" />
    </member>
    <member name="F:NHibernate.Engine.CascadingAction.SaveUpdate">
      <seealso cref="M:NHibernate.ISession.SaveOrUpdate(System.Object)" />
    </member>
    <member name="F:NHibernate.Engine.CascadingAction.Merge">
      <seealso cref="M:NHibernate.ISession.Merge(System.Object)" />
    </member>
    <member name="F:NHibernate.Engine.CascadingAction.SaveUpdateCopy">
      <seealso cref="M:NHibernate.ISession.SaveOrUpdateCopy(System.Object)" />
    </member>
    <member name="F:NHibernate.Engine.CascadingAction.Persist">
      <seealso cref="M:NHibernate.ISession.Persist(System.Object)" />
    </member>
    <member name="F:NHibernate.Engine.CascadingAction.PersistOnFlush">
      <summary> Execute persist during flush time </summary>
      <seealso cref="M:NHibernate.ISession.Persist(System.Object)" />
    </member>
    <member name="F:NHibernate.Engine.CascadingAction.Replicate">
      <seealso cref="M:NHibernate.ISession.Replicate(System.Object,NHibernate.ReplicationMode)" />
    </member>
    <member name="M:NHibernate.Engine.CascadingAction.Cascade(NHibernate.Event.IEventSource,System.Object,System.String,System.Object,System.Boolean)">
      <summary> Cascade the action to the child object. </summary>
      <param name="session">The session within which the cascade is occurring. </param>
      <param name="child">The child to which cascading should be performed. </param>
      <param name="entityName">The child's entity name </param>
      <param name="anything">Typically some form of cascade-local cache which is specific to each CascadingAction type </param>
      <param name="isCascadeDeleteEnabled">Are cascading deletes enabled. </param>
    </member>
    <member name="M:NHibernate.Engine.CascadingAction.GetCascadableChildrenIterator(NHibernate.Event.IEventSource,NHibernate.Type.CollectionType,System.Object)">
      <summary> 
            Given a collection, get an iterator of the children upon which the
            current cascading action should be visited. 
            </summary>
      <param name="session">The session within which the cascade is occurring. </param>
      <param name="collectionType">The mapping type of the collection. </param>
      <param name="collection">The collection instance. </param>
      <returns> The children iterator. </returns>
    </member>
    <member name="M:NHibernate.Engine.CascadingAction.NoCascade(NHibernate.Event.IEventSource,System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister,System.Int32)">
      <summary> 
            Called (in the case of <see cref="P:NHibernate.Engine.CascadingAction.RequiresNoCascadeChecking" /> returning true) to validate
            that no cascade on the given property is considered a valid semantic. 
            </summary>
      <param name="session">The session within which the cascade is occurring. </param>
      <param name="child">The property value </param>
      <param name="parent">The property value owner </param>
      <param name="persister">The entity persister for the owner </param>
      <param name="propertyIndex">The index of the property within the owner. </param>
    </member>
    <member name="M:NHibernate.Engine.CascadingAction.GetAllElementsIterator(NHibernate.Event.IEventSource,NHibernate.Type.CollectionType,System.Object)">
      <summary> 
            Given a collection, get an iterator of all its children, loading them
            from the database if necessary. 
            </summary>
      <param name="session">The session within which the cascade is occurring. </param>
      <param name="collectionType">The mapping type of the collection. </param>
      <param name="collection">The collection instance. </param>
      <returns> The children iterator. </returns>
    </member>
    <member name="M:NHibernate.Engine.CascadingAction.GetLoadedElementsIterator(NHibernate.Engine.ISessionImplementor,NHibernate.Type.CollectionType,System.Object)">
      <summary> 
            Iterate just the elements of the collection that are already there. Don't load
            any new elements from the database.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.CascadingAction.DeleteOrphans">
      <summary> Does this action potentially extrapolate to orphan deletes? </summary>
      <returns> True if this action can lead to deletions of orphans. </returns>
    </member>
    <member name="P:NHibernate.Engine.CascadingAction.RequiresNoCascadeChecking">
      <summary> Does the specified cascading action require verification of no cascade validity? </summary>
      <returns> True if this action requires no-cascade verification; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Engine.CascadingAction.PerformOnLazyProperty">
      <summary> Should this action be performed (or noCascade consulted) in the case of lazy properties.</summary>
    </member>
    <member name="T:NHibernate.Engine.CollectionEntry">
      <summary>
            We need an entry to tell us all about the current state
            of a collection with respect to its persistent state
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CollectionEntry.snapshot">
      <summary>session-start/post-flush persistent state</summary>
    </member>
    <member name="F:NHibernate.Engine.CollectionEntry.role">
      <summary>allow the snapshot to be serialized</summary>
    </member>
    <member name="F:NHibernate.Engine.CollectionEntry.loadedPersister">
      <summary>
            The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> when the Collection was loaded.
            </summary>
      <remarks>
            This can be <see langword="null" /> if the Collection was not loaded by NHibernate and 
            was passed in along with a transient object.
            </remarks>
    </member>
    <member name="F:NHibernate.Engine.CollectionEntry.loadedKey">
      <summary>
            The identifier of the Entity that is the owner of this Collection 
            during the load or post flush.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CollectionEntry.reached">
      <summary>
            Indicates that the Collection can still be reached by an Entity
            that exist in the <see cref="T:NHibernate.ISession" />.
            </summary>
      <remarks>
            It is also used to ensure that the Collection is not shared between
            two Entities.  
            </remarks>
    </member>
    <member name="F:NHibernate.Engine.CollectionEntry.processed">
      <summary>
            Indicates that the Collection has been processed and is ready
            to have its state synchronized with the database.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CollectionEntry.doupdate">
      <summary>
            Indicates that a Collection needs to be updated.
            </summary>
      <remarks>
            A Collection needs to be updated whenever the contents of the Collection
            have been changed. 
            </remarks>
    </member>
    <member name="F:NHibernate.Engine.CollectionEntry.doremove">
      <summary>
            Indicates that a Collection has old elements that need to be removed.
            </summary>
      <remarks>
            A Collection needs to have removals performed whenever its role changes or
            the key changes and it has a loadedPersister - ie - it was loaded by NHibernate.
            </remarks>
    </member>
    <member name="F:NHibernate.Engine.CollectionEntry.dorecreate">
      <summary>
            Indicates that a Collection needs to be recreated.
            </summary>
      <remarks>
            A Collection needs to be recreated whenever its role changes
            or the owner changes.
            </remarks>
    </member>
    <member name="F:NHibernate.Engine.CollectionEntry.ignore">
      <summary>
            If we instantiate a collection during the <see cref="M:NHibernate.ISession.Flush" />
            process, we must ignore it for the rest of the flush.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.CollectionEntry.currentPersister">
      <summary>
            The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> that is currently responsible
            for the Collection.
            </summary>
      <remarks>
            This is set when NHibernate is updating a reachable or an
            unreachable collection.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.CollectionEntry.#ctor(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Engine.CollectionEntry" />.
            </summary>
      <remarks> 
            For newly wrapped collections, or dereferenced collection wrappers
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.CollectionEntry.#ctor(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Boolean)">
      <summary> For collections just loaded from the database</summary>
    </member>
    <member name="M:NHibernate.Engine.CollectionEntry.#ctor(NHibernate.Collection.IPersistentCollection,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Engine.CollectionEntry" /> for initialized detached collections.
            </summary>
      <remarks>
             For initialized detached collections
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.CollectionEntry.Dirty(NHibernate.Collection.IPersistentCollection)">
      <summary> 
            Determine if the collection is "really" dirty, by checking dirtiness
            of the collection elements, if necessary
            </summary>
    </member>
    <member name="M:NHibernate.Engine.CollectionEntry.PreFlush(NHibernate.Collection.IPersistentCollection)">
      <summary>
            Prepares this CollectionEntry for the Flush process.
            </summary>
      <param name="collection">The <see cref="T:NHibernate.Collection.IPersistentCollection" /> that this CollectionEntry will be responsible for flushing.</param>
    </member>
    <member name="M:NHibernate.Engine.CollectionEntry.PostInitialize(NHibernate.Collection.IPersistentCollection)">
      <summary>
            Updates the CollectionEntry to reflect that the <see cref="T:NHibernate.Collection.IPersistentCollection" />
            has been initialized.
            </summary>
      <param name="collection">The initialized <see cref="T:NHibernate.Collection.AbstractPersistentCollection" /> that this Entry is for.</param>
    </member>
    <member name="M:NHibernate.Engine.CollectionEntry.PostFlush(NHibernate.Collection.IPersistentCollection)">
      <summary>
            Updates the CollectionEntry to reflect that it is has been successfully flushed to the database.
            </summary>
      <param name="collection">The <see cref="T:NHibernate.Collection.IPersistentCollection" /> that was flushed.</param>
      <remarks>
            Called after a <em>successful</em> flush.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.CollectionEntry.SetLoadedPersister(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Sets the information in this CollectionEntry that is specific to the
            <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" />.
            </summary>
      <param name="persister">
            The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> that is 
            responsible for the Collection.
            </param>
    </member>
    <member name="P:NHibernate.Engine.CollectionEntry.Key">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Engine.CollectionEntry.Role">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Engine.CollectionEntry.Snapshot">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Engine.CollectionKey">
      <summary> 
            Uniquely identifies a collection instance in a particular session. 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.Collections.ProcessUnreachableCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Record the fact that this collection was dereferenced 
            </summary>
      <param name="coll">The collection to be updated by unreachability. </param>
      <param name="session">The session.</param>
    </member>
    <member name="M:NHibernate.Engine.Collections.ProcessReachableCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Type.CollectionType,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Initialize the role of the collection. 
            </summary>
      <param name="collection">The collection to be updated by reachibility. </param>
      <param name="type">The type of the collection. </param>
      <param name="entity">The owner of the collection. </param>
      <param name="session">The session.</param>
    </member>
    <member name="T:NHibernate.Engine.EntityEntry">
      <summary>
            We need an entry to tell us all about the current state
            of an object with respect to its persistent state
            </summary>
    </member>
    <member name="M:NHibernate.Engine.EntityEntry.#ctor(NHibernate.Engine.Status,System.Object[],System.Object,System.Object,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,NHibernate.EntityMode,System.Boolean,System.Boolean)">
      <summary>
            Initializes a new instance of EntityEntry.
            </summary>
      <param name="status">The current <see cref="P:NHibernate.Engine.EntityEntry.Status" /> of the Entity.</param>
      <param name="loadedState">The snapshot of the Entity's state when it was loaded.</param>
      <param name="rowId">
      </param>
      <param name="id">The identifier of the Entity in the database.</param>
      <param name="version">The version of the Entity.</param>
      <param name="lockMode">The <see cref="P:NHibernate.Engine.EntityEntry.LockMode" /> for the Entity.</param>
      <param name="existsInDatabase">A boolean indicating if the Entity exists in the database.</param>
      <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> that is responsible for this Entity.</param>
      <param name="entityMode">
      </param>
      <param name="disableVersionIncrement">
      </param>
      <param name="lazyPropertiesAreUnfetched">
      </param>
    </member>
    <member name="M:NHibernate.Engine.EntityEntry.PostInsert">
      <summary> 
            After actually inserting a row, record the fact that the instance exists on the 
            database (needed for identity-column key generation)
            </summary>
    </member>
    <member name="M:NHibernate.Engine.EntityEntry.PostUpdate(System.Object,System.Object[],System.Object)">
      <summary>
            After actually updating the database, update the snapshot information,
            and escalate the lock mode.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.EntityEntry.PostDelete">
      <summary> 
            After actually deleting a row, record the fact that the instance no longer
            exists in the database
            </summary>
    </member>
    <member name="P:NHibernate.Engine.EntityEntry.LockMode">
      <summary>
            Gets or sets the current <see cref="P:NHibernate.Engine.EntityEntry.LockMode" /> of the Entity.
            </summary>
      <value>The <see cref="P:NHibernate.Engine.EntityEntry.LockMode" /> of the Entity.</value>
    </member>
    <member name="P:NHibernate.Engine.EntityEntry.Status">
      <summary>
            Gets or sets the <see cref="P:NHibernate.Engine.EntityEntry.Status" /> of this Entity with respect to its 
            persistence in the database.
            </summary>
      <value>The <see cref="P:NHibernate.Engine.EntityEntry.Status" /> of this Entity.</value>
    </member>
    <member name="P:NHibernate.Engine.EntityEntry.Id">
      <summary>
            Gets or sets the identifier of the Entity in the database.
            </summary>
      <value>The identifier of the Entity in the database if one has been assigned.</value>
      <remarks>This might be <see langword="null" /> when the <see cref="P:NHibernate.Engine.EntityEntry.Status" /> is 
            <see cref="F:NHibernate.Engine.Status.Saving" /> and the database generates the id.</remarks>
    </member>
    <member name="P:NHibernate.Engine.EntityEntry.LoadedState">
      <summary>
            Gets or sets the snapshot of the Entity when it was loaded from the database.
            </summary>
      <value>The snapshot of the Entity.</value>
      <remarks>
            There will only be a value when the Entity was loaded in the current Session.
            </remarks>
    </member>
    <member name="P:NHibernate.Engine.EntityEntry.DeletedState">
      <summary>
            Gets or sets the snapshot of the Entity when it was marked as being ready for deletion.
            </summary>
      <value>The snapshot of the Entity.</value>
      <remarks>This will be <see langword="null" /> if the Entity is not being deleted.</remarks>
    </member>
    <member name="P:NHibernate.Engine.EntityEntry.ExistsInDatabase">
      <summary>
            Gets or sets a <see cref="T:System.Boolean" /> indicating if this Entity exists in the database.
            </summary>
      <value>
        <see langword="true" /> if it is already in the database.</value>
      <remarks>
            It can also be <see langword="true" /> if it does not exists in the database yet and the 
            <see cref="P:NHibernate.Persister.Entity.IEntityPersister.IsIdentifierAssignedByInsert" /> is <see langword="true" />.
            </remarks>
    </member>
    <member name="P:NHibernate.Engine.EntityEntry.Version">
      <summary>
            Gets or sets the version of the Entity.
            </summary>
      <value>The version of the Entity.</value>
    </member>
    <member name="P:NHibernate.Engine.EntityEntry.Persister">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> that is responsible for this Entity.
            </summary>
      <value>The <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> that is responsible for this Entity.</value>
    </member>
    <member name="P:NHibernate.Engine.EntityEntry.EntityName">
      <summary>
            Gets the Fully Qualified Name of the class this Entity is an instance of.
            </summary>
      <value>The Fully Qualified Name of the class this Entity is an instance of.</value>
    </member>
    <member name="T:NHibernate.Engine.EntityKey">
      <summary>
            A globally unique identifier of an instance, consisting of the user-visible identifier
            and the identifier space (eg. tablename)
            </summary>
    </member>
    <member name="M:NHibernate.Engine.EntityKey.#ctor(System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.EntityMode)">
      <summary> Construct a unique identifier for an entity class instance</summary>
    </member>
    <member name="M:NHibernate.Engine.EntityKey.#ctor(System.Object,System.String,System.String,NHibernate.Type.IType,System.Boolean,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.EntityMode)">
      <summary> Used to reconstruct an EntityKey during deserialization. </summary>
      <param name="identifier">The identifier value </param>
      <param name="rootEntityName">The root entity name </param>
      <param name="entityName">The specific entity name </param>
      <param name="identifierType">The type of the identifier value </param>
      <param name="batchLoadable">Whether represented entity is eligible for batch loading </param>
      <param name="factory">The session factory </param>
      <param name="entityMode">The entity's entity mode </param>
    </member>
    <member name="M:NHibernate.Engine.EntityKey.SetSessionFactory(NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            To use in deserialization callback
            </summary>
      <param name="sessionFactory">
      </param>
    </member>
    <member name="T:NHibernate.Engine.EntityUniqueKey">
      <summary> 
            Used to uniquely key an entity instance in relation to a particular session
            by some unique property reference, as opposed to identifier.
            Uniqueing information consists of the entity-name, the referenced
            property name, and the referenced property value. 
            </summary>
      <seealso cref="T:NHibernate.Engine.EntityKey" />
    </member>
    <member name="T:NHibernate.Engine.FilterDefinition">
      <summary>
            A FilterDefinition defines the global attributes of a dynamic filter.  This
            information includes its name as well as its defined parameters (name and type).
            </summary>
    </member>
    <member name="M:NHibernate.Engine.FilterDefinition.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,NHibernate.Type.IType})">
      <summary>
            Set the named parameter's value list for this filter. 
            </summary>
      <param name="name">The name of the filter for which this configuration is in effect.</param>
      <param name="defaultCondition">The default filter condition.</param>
      <param name="parameterTypes">A dictionary storing the NHibernate <see cref="T:NHibernate.Type.IType" /> type
            of each parameter under its name.</param>
    </member>
    <member name="M:NHibernate.Engine.FilterDefinition.GetParameterType(System.String)">
      <summary>
            Retreive the type of the named parameter defined for this filter.
            </summary>
      <param name="parameterName">The name of the filter parameter for which to return the type.</param>
      <returns>The type of the named parameter.</returns>
    </member>
    <member name="P:NHibernate.Engine.FilterDefinition.FilterName">
      <summary>
            Get the name of the filter this configuration defines.
            </summary>
      <returns>The filter name for this configuration.</returns>
    </member>
    <member name="P:NHibernate.Engine.FilterDefinition.ParameterNames">
      <summary>
            Get a set of the parameters defined by this configuration.
            </summary>
      <returns>The parameters named by this configuration.</returns>
    </member>
    <member name="T:NHibernate.Engine.ForeignKeys">
      <summary> Algorithms related to foreign key constraint transparency </summary>
    </member>
    <member name="M:NHibernate.Engine.ForeignKeys.Nullifier.NullifyTransientReferences(System.Object[],NHibernate.Type.IType[])">
      <summary> 
            Nullify all references to entities that have not yet 
            been inserted in the database, where the foreign key
            points toward that entity
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ForeignKeys.Nullifier.NullifyTransientReferences(System.Object,NHibernate.Type.IType)">
      <summary> 
            Return null if the argument is an "unsaved" entity (ie. 
            one with no existing database row), or the input argument 
            otherwise. This is how Hibernate avoids foreign key constraint
            violations.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ForeignKeys.Nullifier.IsNullifiable(System.String,System.Object)">
      <summary> 
            Determine if the object already exists in the database, using a "best guess"
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ForeignKeys.IsNotTransient(System.String,System.Object,System.Nullable{System.Boolean},NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Is this instance persistent or detached?
            </summary>
      <remarks>
            If <paramref name="assumed" /> is non-null, don't hit the database to make the 
            determination, instead assume that value; the client code must be 
            prepared to "recover" in the case that this assumed result is incorrect.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.ForeignKeys.IsTransient(System.String,System.Object,System.Nullable{System.Boolean},NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Is this instance, which we know is not persistent, actually transient? 
            If <tt>assumed</tt> is non-null, don't hit the database to make the 
            determination, instead assume that value; the client code must be 
            prepared to "recover" in the case that this assumed result is incorrect.
            </summary>
      <remarks>
            If <paramref name="assumed" /> is non-null, don't hit the database to make the 
            determination, instead assume that value; the client code must be 
            prepared to "recover" in the case that this assumed result is incorrect.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.ForeignKeys.GetEntityIdentifierIfNotUnsaved(System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Return the identifier of the persistent or transient object, or throw
            an exception if the instance is "unsaved"
            </summary>
      <remarks>
            Used by OneToOneType and ManyToOneType to determine what id value should 
            be used for an object that may or may not be associated with the session. 
            This does a "best guess" using any/all info available to use (not just the 
            EntityEntry).
            </remarks>
    </member>
    <member name="T:NHibernate.Engine.IdentifierValue">
      <summary>
            A strategy for determining if an identifier value is an identifier of a new 
            transient instance or a previously persistent transient instance. The strategy
            is determined by the <c>Unsaved-Value</c> attribute in the mapping file.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.IdentifierValue.SaveAny">
      <summary>
            Always assume the transient instance is newly instantiated
            </summary>
    </member>
    <member name="F:NHibernate.Engine.IdentifierValue.SaveNone">
      <summary>
            Never assume that transient instance is newly instantiated
            </summary>
    </member>
    <member name="F:NHibernate.Engine.IdentifierValue.SaveNull">
      <summary>
            Assume the transient instance is newly instantiated if the identifier
            is null.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.IdentifierValue.Undefined">
      <summary> Assume nothing.</summary>
    </member>
    <member name="M:NHibernate.Engine.IdentifierValue.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Engine.IdentifierValue.#ctor(System.Object)">
      <summary>
            Assume the transient instance is newly instantiated if its identifier is null or
            equal to <c>Value</c></summary>
      <param name="value">
      </param>
    </member>
    <member name="M:NHibernate.Engine.IdentifierValue.IsUnsaved(System.Object)">
      <summary>
            Does the given identifier belong to a new instance
            </summary>
    </member>
    <member name="T:NHibernate.Engine.IPersistenceContext">
      <summary> 
            Holds the state of the persistence context, including the 
            first-level cache, entries, snapshots, proxies, etc. 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddUnownedCollection(NHibernate.Engine.CollectionKey,NHibernate.Collection.IPersistentCollection)">
      <summary> Add a collection which has no owner loaded</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.UseUnownedCollection(NHibernate.Engine.CollectionKey)">
      <summary> 
            Get and remove a collection whose owner is not yet loaded,
            when its owner is being loaded
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.Clear">
      <summary> Clear the state of the persistence context</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.SetEntryStatus(NHibernate.Engine.EntityEntry,NHibernate.Engine.Status)">
      <summary> Set the status of an entry</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AfterTransactionCompletion">
      <summary> Called after transactions end</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetDatabaseSnapshot(System.Object,NHibernate.Persister.Entity.IEntityPersister)">
      <summary> 
            Get the current state of the entity as known to the underlying
            database, or null if there is no corresponding row 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetCachedDatabaseSnapshot(NHibernate.Engine.EntityKey)">
      <summary> 
            Retrieve the cached database snapshot for the requested entity key.
            </summary>
      <param name="key">The entity key for which to retrieve the cached snapshot </param>
      <returns> The cached snapshot </returns>
      <remarks>
        <list type="bullet">
          <listheader>
            <description>This differs from <see cref="M:NHibernate.Engine.IPersistenceContext.GetDatabaseSnapshot(System.Object,NHibernate.Persister.Entity.IEntityPersister)" /> is two important respects:</description>
          </listheader>
          <item>
            <description>no snapshot is obtained from the database if not already cached</description>
          </item>
          <item>
            <description>an entry of NO_ROW here is interpreted as an exception</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetNaturalIdSnapshot(System.Object,NHibernate.Persister.Entity.IEntityPersister)">
      <summary> 
            Get the values of the natural id fields as known to the underlying 
            database, or null if the entity has no natural id or there is no 
            corresponding row.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddEntity(NHibernate.Engine.EntityKey,System.Object)">
      <summary> Add a canonical mapping from entity key to entity instance</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetEntity(NHibernate.Engine.EntityKey)">
      <summary> 
            Get the entity instance associated with the given <tt>EntityKey</tt></summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.ContainsEntity(NHibernate.Engine.EntityKey)">
      <summary> Is there an entity with the given key in the persistence context</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.RemoveEntity(NHibernate.Engine.EntityKey)">
      <summary> 
            Remove an entity from the session cache, also clear
            up other state associated with the entity, all except
            for the <tt>EntityEntry</tt></summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetEntity(NHibernate.Engine.EntityUniqueKey)">
      <summary> Get an entity cached by unique key</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddEntity(NHibernate.Engine.EntityUniqueKey,System.Object)">
      <summary> Add an entity to the cache by unique key</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetEntry(System.Object)">
      <summary> 
            Retrieve the EntityEntry representation of the given entity. 
            </summary>
      <param name="entity">The entity for which to locate the EntityEntry. </param>
      <returns> The EntityEntry for the given entity. </returns>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.RemoveEntry(System.Object)">
      <summary> Remove an entity entry from the session cache</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.IsEntryFor(System.Object)">
      <summary> Is there an EntityEntry for this instance?</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetCollectionEntry(NHibernate.Collection.IPersistentCollection)">
      <summary> Get the collection entry for a persistent collection</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddEntity(System.Object,NHibernate.Engine.Status,System.Object[],NHibernate.Engine.EntityKey,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,System.Boolean,System.Boolean)">
      <summary> Adds an entity to the internal caches.</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddEntry(System.Object,NHibernate.Engine.Status,System.Object[],System.Object,System.Object,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,System.Boolean,System.Boolean)">
      <summary> 
            Generates an appropriate EntityEntry instance and adds it 
            to the event source's internal caches.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.ContainsCollection(NHibernate.Collection.IPersistentCollection)">
      <summary> Is the given collection associated with this persistence context?</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.ContainsProxy(NHibernate.Proxy.INHibernateProxy)">
      <summary> Is the given proxy associated with this persistence context?</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.ReassociateIfUninitializedProxy(System.Object)">
      <summary> 
            Takes the given object and, if it represents a proxy, reassociates it with this event source. 
            </summary>
      <param name="value">The possible proxy to be reassociated. </param>
      <returns> Whether the passed value represented an actual proxy which got initialized. </returns>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.ReassociateProxy(System.Object,System.Object)">
      <summary> 
            If a deleted entity instance is re-saved, and it has a proxy, we need to
            reset the identifier of the proxy 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.Unproxy(System.Object)">
      <summary> 
            Get the entity instance underlying the given proxy, throwing
            an exception if the proxy is uninitialized. If the given object
            is not a proxy, simply return the argument.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.UnproxyAndReassociate(System.Object)">
      <summary> 
            Possibly unproxy the given reference and reassociate it with the current session. 
            </summary>
      <param name="maybeProxy">The reference to be unproxied if it currently represents a proxy. </param>
      <returns> The unproxied instance. </returns>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.CheckUniqueness(NHibernate.Engine.EntityKey,System.Object)">
      <summary> 
            Attempts to check whether the given key represents an entity already loaded within the
            current session.
            </summary>
      <param name="obj">The entity reference against which to perform the uniqueness check.</param>
      <param name="key">The entity key.</param>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.NarrowProxy(NHibernate.Proxy.INHibernateProxy,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object)">
      <summary> 
            If the existing proxy is insufficiently "narrow" (derived), instantiate a new proxy
            and overwrite the registration of the old one. This breaks == and occurs only for
            "class" proxies rather than "interface" proxies. Also init the proxy to point to
            the given target implementation if necessary. 
            </summary>
      <param name="proxy">The proxy instance to be narrowed. </param>
      <param name="persister">The persister for the proxied entity. </param>
      <param name="key">The internal cache key for the proxied entity. </param>
      <param name="obj">(optional) the actual proxied entity instance. </param>
      <returns> An appropriately narrowed instance. </returns>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.ProxyFor(NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object)">
      <summary> 
            Return the existing proxy associated with the given <tt>EntityKey</tt>, or the
            third argument (the entity associated with the key) if no proxy exists. Init
            the proxy to the target implementation, if necessary.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.ProxyFor(System.Object)">
      <summary> 
            Return the existing proxy associated with the given <tt>EntityKey</tt>, or the
            argument (the entity associated with the key) if no proxy exists.
            (slower than the form above)
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetCollectionOwner(System.Object,NHibernate.Persister.Collection.ICollectionPersister)">
      <summary> Get the entity that owns this persistent collection</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetLoadedCollectionOwnerOrNull(NHibernate.Collection.IPersistentCollection)">
      <summary> Get the entity that owned this persistent collection when it was loaded </summary>
      <param name="collection">The persistent collection </param>
      <returns> 
            The owner if its entity ID is available from the collection's loaded key
            and the owner entity is in the persistence context; otherwise, returns null
            </returns>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetLoadedCollectionOwnerIdOrNull(NHibernate.Collection.IPersistentCollection)">
      <summary> Get the ID for the entity that owned this persistent collection when it was loaded </summary>
      <param name="collection">The persistent collection </param>
      <returns> the owner ID if available from the collection's loaded key; otherwise, returns null </returns>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddUninitializedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,System.Object)">
      <summary> add a collection we just loaded up (still needs initializing)</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddUninitializedDetachedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
      <summary> add a detached uninitialized collection</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddNewCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
      <summary> 
            Add a new collection (ie. a newly created one, just instantiated by the
            application, with no database state or snapshot)
            </summary>
      <param name="collection">The collection to be associated with the persistence context </param>
      <param name="persister">
      </param>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddInitializedDetachedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
      <summary> 
            add an (initialized) collection that was created by another session and passed
            into update() (ie. one with a snapshot and existing state on the database)
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddInitializedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,System.Object)">
      <summary> add a collection we just pulled out of the cache (does not need initializing)</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetCollection(NHibernate.Engine.CollectionKey)">
      <summary> Get the collection instance associated with the <tt>CollectionKey</tt></summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddNonLazyCollection(NHibernate.Collection.IPersistentCollection)">
      <summary> 
            Register a collection for non-lazy loading at the end of the two-phase load
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.InitializeNonLazyCollections">
      <summary> 
            Force initialization of all non-lazy collections encountered during
            the current two-phase load (actually, this is a no-op, unless this
            is the "outermost" load)
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetCollectionHolder(System.Object)">
      <summary> Get the <tt>PersistentCollection</tt> object for an array</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddCollectionHolder(NHibernate.Collection.IPersistentCollection)">
      <summary> Register a <tt>PersistentCollection</tt> object for an array.
            Associates a holder with an array - MUST be called after loading 
            array, since the array instance is not created until endLoad().
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.RemoveCollectionHolder(System.Object)">
      <summary> 
            Remove the mapping of collection to holder during eviction of the owning entity
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetSnapshot(NHibernate.Collection.IPersistentCollection)">
      <summary> Get the snapshot of the pre-flush collection state</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetCollectionEntryOrNull(System.Object)">
      <summary> 
            Get the collection entry for a collection passed to filter,
            which might be a collection wrapper, an array, or an unwrapped
            collection. Return null if there is no entry.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetProxy(NHibernate.Engine.EntityKey)">
      <summary> Get an existing proxy by key</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddProxy(NHibernate.Engine.EntityKey,NHibernate.Proxy.INHibernateProxy)">
      <summary> Add a proxy to the session cache</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.RemoveProxy(NHibernate.Engine.EntityKey)">
      <summary> Remove a proxy from the session cache</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.IncrementCascadeLevel">
      <summary> Called before cascading</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.DecrementCascadeLevel">
      <summary> Called after cascading</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.BeforeLoad">
      <summary> Call this before beginning a two-phase load</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AfterLoad">
      <summary> Call this after finishing a two-phase load</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetOwnerId(System.String,System.String,System.Object,System.Collections.IDictionary)">
      <summary> 
            Search the persistence context for an owner for the child object,
            given a collection role
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.GetIndexInOwner(System.String,System.String,System.Object,System.Collections.IDictionary)">
      <summary> 
            Search the persistence context for an index of the child object, given a collection role
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.AddNullProperty(NHibernate.Engine.EntityKey,System.String)">
      <summary> 
            Record the fact that the association belonging to the keyed entity is null.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.IsPropertyNull(NHibernate.Engine.EntityKey,System.String)">
      <summary> Is the association property belonging to the keyed entity null?</summary>
    </member>
    <member name="M:NHibernate.Engine.IPersistenceContext.SetReadOnly(System.Object,System.Boolean)">
      <summary> Set the object to read only and discard it's snapshot</summary>
    </member>
    <member name="P:NHibernate.Engine.IPersistenceContext.Session">
      <summary> 
            Get the session to which this persistence context is bound. 
            </summary>
    </member>
    <member name="P:NHibernate.Engine.IPersistenceContext.LoadContexts">
      <summary> 
            Retrieve this persistence context's managed load context.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.IPersistenceContext.BatchFetchQueue">
      <summary> 
            Get the <tt>BatchFetchQueue</tt>, instantiating one if necessary.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.IPersistenceContext.NullifiableEntityKeys">
      <summary> Retrieve the set of EntityKeys representing nullifiable references</summary>
    </member>
    <member name="P:NHibernate.Engine.IPersistenceContext.EntitiesByKey">
      <summary> Get the mapping from key value to entity instance</summary>
    </member>
    <member name="P:NHibernate.Engine.IPersistenceContext.EntityEntries">
      <summary> Get the mapping from entity instance to entity entry</summary>
    </member>
    <member name="P:NHibernate.Engine.IPersistenceContext.CollectionEntries">
      <summary> Get the mapping from collection instance to collection entry</summary>
    </member>
    <member name="P:NHibernate.Engine.IPersistenceContext.CollectionsByKey">
      <summary> Get the mapping from collection key to collection instance</summary>
    </member>
    <member name="P:NHibernate.Engine.IPersistenceContext.CascadeLevel">
      <summary> How deep are we cascaded?</summary>
    </member>
    <member name="P:NHibernate.Engine.IPersistenceContext.Flushing">
      <summary>Is a flush cycle currently in process?</summary>
      <remarks>Called before and after the flushcycle</remarks>
    </member>
    <member name="P:NHibernate.Engine.IPersistenceContext.HasNonReadOnlyEntities">
      <summary>False if we know for certain that all the entities are read-only</summary>
    </member>
    <member name="T:NHibernate.ISessionFactory">
      <summary>
            Creates <c>ISession</c>s.
            </summary>
      <remarks>
        <para>
            Usually an application has a single <c>SessionFactory</c>. Threads servicing client requests
            obtain <c>ISession</c>s from the factory. Implementors must be threadsafe.
            </para>
        <para>
          <c>ISessionFactory</c>s are immutable. The behaviour of a <c>SessionFactory</c>
            is controlled by properties supplied at configuration time.
            These properties are defined on <c>Environment</c></para>
      </remarks>
    </member>
    <member name="M:NHibernate.ISessionFactory.OpenSession(System.Data.IDbConnection)">
      <summary>
            Open a <c>ISession</c> on the given connection
            </summary>
      <param name="conn">A connection provided by the application</param>
      <returns>A session</returns>
      <remarks>
            Note that the second-level cache will be disabled if you
            supply a ADO.NET connection. NHibernate will not be able to track
            any statements you might have executed in the same transaction.
            Consider implementing your own <see cref="T:NHibernate.Connection.IConnectionProvider" />.
            </remarks>
    </member>
    <member name="M:NHibernate.ISessionFactory.OpenSession(NHibernate.IInterceptor)">
      <summary>
            Create database connection and open a <c>ISession</c> on it, specifying an interceptor
            </summary>
      <param name="sessionLocalInterceptor">A session-scoped interceptor</param>
      <returns>A session</returns>
    </member>
    <member name="M:NHibernate.ISessionFactory.OpenSession(System.Data.IDbConnection,NHibernate.IInterceptor)">
      <summary>
            Open a <c>ISession</c> on the given connection, specifying an interceptor
            </summary>
      <param name="conn">A connection provided by the application</param>
      <param name="sessionLocalInterceptor">A session-scoped interceptor</param>
      <returns>A session</returns>
      <remarks>
            Note that the second-level cache will be disabled if you
            supply a ADO.NET connection. NHibernate will not be able to track
            any statements you might have executed in the same transaction.
            Consider implementing your own <see cref="T:NHibernate.Connection.IConnectionProvider" />.
            </remarks>
    </member>
    <member name="M:NHibernate.ISessionFactory.OpenSession">
      <summary>
            Create a database connection and open a <c>ISession</c> on it
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ISessionFactory.GetClassMetadata(System.Type)">
      <summary>
            Get the <see cref="T:NHibernate.Metadata.IClassMetadata" /> associated with the given entity class
            </summary>
      <param name="persistentClass">the given entity type.</param>
      <returns>The class metadata or <see langword="null" /> if not found.</returns>
      <seealso cref="T:NHibernate.Metadata.IClassMetadata" />
    </member>
    <member name="M:NHibernate.ISessionFactory.GetClassMetadata(System.String)">
      <summary> Get the <see cref="T:NHibernate.Metadata.IClassMetadata" /> associated with the given entity name </summary>
      <param name="entityName">the given entity name.</param>
      <returns>The class metadata or <see langword="null" /> if not found.</returns>
      <seealso cref="T:NHibernate.Metadata.IClassMetadata" />
    </member>
    <member name="M:NHibernate.ISessionFactory.GetCollectionMetadata(System.String)">
      <summary>
            Get the <c>CollectionMetadata</c> associated with the named collection role
            </summary>
      <param name="roleName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ISessionFactory.GetAllClassMetadata">
      <summary> 
            Get all <see cref="T:NHibernate.Metadata.IClassMetadata" /> as a <see cref="T:System.Collections.IDictionary" /> from entityname <see langword="string" />
            to metadata object
            </summary>
      <returns> A dictionary from <see langword="string" /> an entity name to <see cref="T:NHibernate.Metadata.IClassMetadata" /></returns>
    </member>
    <member name="M:NHibernate.ISessionFactory.GetAllCollectionMetadata">
      <summary>
            Get all <c>CollectionMetadata</c> as a <c>IDictionary</c> from role name
            to metadata object
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ISessionFactory.Close">
      <summary>
            Destroy this <c>SessionFactory</c> and release all resources 
            connection pools, etc). It is the responsibility of the application
            to ensure that there are no open <c>Session</c>s before calling
            <c>close()</c>. 
            </summary>
    </member>
    <member name="M:NHibernate.ISessionFactory.Evict(System.Type)">
      <summary>
            Evict all entries from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
      <param name="persistentClass">
      </param>
    </member>
    <member name="M:NHibernate.ISessionFactory.Evict(System.Type,System.Object)">
      <summary>
            Evict an entry from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
      <param name="persistentClass">
      </param>
      <param name="id">
      </param>
    </member>
    <member name="M:NHibernate.ISessionFactory.EvictEntity(System.String)">
      <summary> 
            Evict all entries from the second-level cache. This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy. Use with care.
            </summary>
    </member>
    <member name="M:NHibernate.ISessionFactory.EvictEntity(System.String,System.Object)">
      <summary> 
            Evict an entry from the second-level  cache. This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy. Use with care.
            </summary>
    </member>
    <member name="M:NHibernate.ISessionFactory.EvictCollection(System.String)">
      <summary>
            Evict all entries from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
      <param name="roleName">
      </param>
    </member>
    <member name="M:NHibernate.ISessionFactory.EvictCollection(System.String,System.Object)">
      <summary>
            Evict an entry from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
      <param name="roleName">
      </param>
      <param name="id">
      </param>
    </member>
    <member name="M:NHibernate.ISessionFactory.EvictQueries">
      <summary>
            Evict any query result sets cached in the default query cache region.
            </summary>
    </member>
    <member name="M:NHibernate.ISessionFactory.EvictQueries(System.String)">
      <summary>
            Evict any query result sets cached in the named query cache region.
            </summary>
      <param name="cacheRegion">
      </param>
    </member>
    <member name="M:NHibernate.ISessionFactory.OpenStatelessSession">
      <summary> Get a new stateless session.</summary>
    </member>
    <member name="M:NHibernate.ISessionFactory.OpenStatelessSession(System.Data.IDbConnection)">
      <summary> Get a new stateless session for the given ADO.NET connection.</summary>
    </member>
    <member name="M:NHibernate.ISessionFactory.GetFilterDefinition(System.String)">
      <summary>
            Obtain the definition of a filter by name.
            </summary>
      <param name="filterName">The name of the filter for which to obtain the definition.</param>
      <return>The filter definition.</return>
    </member>
    <member name="M:NHibernate.ISessionFactory.GetCurrentSession">
      <summary>
            Obtains the current session.
            </summary>
      <remarks>
        <para>
            The definition of what exactly "current" means is controlled by the <see cref="T:NHibernate.Context.ICurrentSessionContext" />
            implementation configured for use.
            </para>
      </remarks>
      <returns>The current session.</returns>
      <exception cref="T:NHibernate.HibernateException">Indicates an issue locating a suitable current session.</exception>
    </member>
    <member name="P:NHibernate.ISessionFactory.Statistics">
      <summary> Get the statistics for this session factory</summary>
    </member>
    <member name="P:NHibernate.ISessionFactory.IsClosed">
      <summary> Was this <see cref="T:NHibernate.ISessionFactory" /> already closed?</summary>
    </member>
    <member name="P:NHibernate.ISessionFactory.DefinedFilterNames">
      <summary>
            Obtain a set of the names of all filters defined on this SessionFactory.
            </summary>
      <return>The set of filter names.</return>
    </member>
    <member name="T:NHibernate.Engine.ISessionFactoryImplementor">
      <summary>
            Defines the internal contract between the <c>ISessionFactory</c> and other parts of NHibernate
            such as implementors of <c>IType</c>.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetEntityPersister(System.String)">
      <summary>
            Get the persister for the named entity
            </summary>
      <param name="entityName">The name of the entity that is persisted.</param>
      <returns>The <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> for the entity.</returns>
      <exception cref="T:NHibernate.MappingException">If no <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> can be found.</exception>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetCollectionPersister(System.String)">
      <summary>
            Get the persister object for a collection role
            </summary>
      <param name="role">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetReturnTypes(System.String)">
      <summary>
            Get the return types of a query
            </summary>
      <param name="queryString">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetReturnAliases(System.String)">
      <summary> Get the return aliases of a query</summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetImplementors(System.String)">
      <summary>
            Get the names of all persistent classes that implement/extend the given interface/class
            </summary>
      <param name="className">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetImportedClassName(System.String)">
      <summary>
            Get a class name, using query language imports
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetQueryCache(System.String)">
      <summary>
            Get a particular named query cache, or the default cache
            </summary>
      <param name="regionName">the name of the cache region, or null for the default
            query cache</param>
      <returns>the existing cache, or a newly created cache if none by that
            region name</returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetNamedQuery(System.String)">
      <summary>
            Gets the <c>hql</c> query identified by the <c>name</c>.
            </summary>
      <param name="queryName">The name of that identifies the query.</param>
      <returns>
            A <c>hql</c> query or <see langword="null" /> if the named
            query does not exist.
            </returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetIdentifierGenerator(System.String)">
      <summary>
            Get the identifier generator for the hierarchy
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetSecondLevelCacheRegion(System.String)">
      <summary> Get a named second-level cache region</summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.OpenSession(System.Data.IDbConnection,System.Boolean,System.Boolean,NHibernate.ConnectionReleaseMode)">
      <summary>
            Open a session conforming to the given parameters. Used mainly
            for current session processing.
            </summary>
      <param name="connection">The external ado.net connection to use, if one (i.e., optional).</param>
      <param name="flushBeforeCompletionEnabled">
            Should the session be auto-flushed 
            prior to transaction completion?
            </param>
      <param name="autoCloseSessionEnabled">
            Should the session be auto-closed after
            transaction completion?
            </param>
      <param name="connectionReleaseMode">The release mode for managed jdbc connections.</param>
      <returns>An appropriate session.</returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetCollectionRolesByEntityParticipant(System.String)">
      <summary> 
            Retrieves a set of all the collection roles in which the given entity
            is a participant, as either an index or an element.
            </summary>
      <param name="entityName">The entity name for which to get the collection roles.</param>
      <returns> 
            Set of all the collection roles in which the given entityName participates.
            </returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.TryGetEntityPersister(System.String)">
      <summary>
            Get the persister for the named entity
            </summary>
      <param name="entityName">The name of the entity that is persisted.</param>
      <returns>
            The <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> for the entity or <see langword="null" /> is the name was not found.
            </returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionFactoryImplementor.TryGetGuessEntityName(System.Type)">
      <summary>
            Get the entity-name for a given mapped class.
            </summary>
      <param name="implementor">the mapped class</param>
      <returns>the enntity name where available or null</returns>
    </member>
    <member name="P:NHibernate.Engine.ISessionFactoryImplementor.Dialect">
      <summary>
            Get the SQL <see cref="T:NHibernate.Dialect.Dialect" />.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.ISessionFactoryImplementor.ConnectionProvider">
      <summary>
            Get the <see cref="T:NHibernate.Connection.IConnectionProvider" /> used.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.ISessionFactoryImplementor.UpdateTimestampsCache">
      <summary> The cache of table update timestamps</summary>
    </member>
    <member name="P:NHibernate.Engine.ISessionFactoryImplementor.StatisticsImplementor">
      <summary> Statistics SPI</summary>
    </member>
    <member name="P:NHibernate.Engine.ISessionFactoryImplementor.SQLExceptionConverter">
      <summary> Retrieves the SQLExceptionConverter in effect for this SessionFactory. </summary>
      <returns> The SQLExceptionConverter for this SessionFactory. </returns>
    </member>
    <member name="P:NHibernate.Engine.ISessionFactoryImplementor.QueryCache">
      <summary>
            Get the default query cache
            </summary>
    </member>
    <member name="P:NHibernate.Engine.ISessionFactoryImplementor.CurrentSessionContext">
      <summary>
            Gets the ICurrentSessionContext instance attached to this session factory.
            </summary>
    </member>
    <member name="T:NHibernate.Engine.ISessionImplementor">
      <summary>
            Defines the internal contract between the <c>Session</c> and other parts of Hibernate
            such as implementors of <c>Type</c> or <c>ClassPersister</c></summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.Initialize">
      <summary>
            Initialize the session after its construction was complete
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.InitializeCollection(NHibernate.Collection.IPersistentCollection,System.Boolean)">
      <summary>
            Initialize the collection (if not already initialized)
            </summary>
      <param name="collection">
      </param>
      <param name="writing">
      </param>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.InternalLoad(System.String,System.Object,System.Boolean,System.Boolean)">
      <summary>
            Load an instance without checking if it was deleted. If it does not exist and isn't nullable, throw an exception.
            This method may create a new proxy or return an existing proxy.
            </summary>
      <param name="entityName">The entityName (or class full name) to load.</param>
      <param name="id">The identifier of the object in the database.</param>
      <param name="isNullable">Allow null instance</param>
      <param name="eager">When enabled, the object is eagerly fetched.</param>
      <returns>
            A proxy of the object or an instance of the object if the <c>persistentClass</c> does not have a proxy.
            </returns>
      <exception cref="T:NHibernate.ObjectNotFoundException">No object could be found with that <c>id</c>.</exception>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.ImmediateLoad(System.String,System.Object)">
      <summary>
            Load an instance immediately. Do not return a proxy.
            </summary>
      <param name="entityName">
      </param>
      <param name="id">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.List(System.String,NHibernate.Engine.QueryParameters)">
      <summary>
            Execute a <c>List()</c> query
            </summary>
      <param name="query">
      </param>
      <param name="parameters">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.List``1(System.String,NHibernate.Engine.QueryParameters)">
      <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.List(System.String,NHibernate.Engine.QueryParameters)" /></summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.List``1(NHibernate.Impl.CriteriaImpl)">
      <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.List(NHibernate.Impl.CriteriaImpl)" /></summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.Enumerable(System.String,NHibernate.Engine.QueryParameters)">
      <summary>
            Execute an <c>Iterate()</c> query
            </summary>
      <param name="query">
      </param>
      <param name="parameters">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.Enumerable``1(System.String,NHibernate.Engine.QueryParameters)">
      <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.Enumerable(System.String,NHibernate.Engine.QueryParameters)" /></summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.ListFilter(System.Object,System.String,NHibernate.Engine.QueryParameters)">
      <summary>
            Execute a filter
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.ListFilter``1(System.Object,System.String,NHibernate.Engine.QueryParameters)">
      <summary>
            Execute a filter (strongly-typed version).
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.EnumerableFilter(System.Object,System.String,NHibernate.Engine.QueryParameters)">
      <summary>
            Collection from a filter
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.EnumerableFilter``1(System.Object,System.String,NHibernate.Engine.QueryParameters)">
      <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.EnumerableFilter(System.Object,System.String,NHibernate.Engine.QueryParameters)" /></summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.GetEntityPersister(System.String,System.Object)">
      <summary> Get the <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> for any instance</summary>
      <param name="entityName">optional entity name </param>
      <param name="obj">the entity instance </param>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.AfterTransactionBegin(NHibernate.ITransaction)">
      <summary>
            Notify the session that an NHibernate transaction has begun.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.BeforeTransactionCompletion(NHibernate.ITransaction)">
      <summary>
            Notify the session that the transaction is about to complete
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.AfterTransactionCompletion(System.Boolean,NHibernate.ITransaction)">
      <summary>
            Notify the session that the transaction completed, so we no longer own the old locks.
            (Also we should release cache softlocks). May be called multiple times during the transaction
            completion process.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.GetContextEntityIdentifier(System.Object)">
      <summary>
            Return the identifier of the persistent object, or null if transient
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.Instantiate(System.String,System.Object)">
      <summary>
            Instantiate the entity class, initializing with the given identifier
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.List(NHibernate.Engine.Query.Sql.NativeSQLQuerySpecification,NHibernate.Engine.QueryParameters)">
      <summary>
            Execute an SQL Query
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.List``1(NHibernate.Engine.Query.Sql.NativeSQLQuerySpecification,NHibernate.Engine.QueryParameters)">
      <summary>
            Strongly-typed version of <see cref="M:NHibernate.Engine.ISessionImplementor.List(NHibernate.Engine.Query.Sql.NativeSQLQuerySpecification,NHibernate.Engine.QueryParameters)" /></summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.ListCustomQuery(NHibernate.Loader.Custom.ICustomQuery,NHibernate.Engine.QueryParameters,System.Collections.IList)">
      <summary> Execute an SQL Query</summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.GetFilterParameterValue(System.String)">
      <summary>
            Retrieve the currently set value for a filter parameter.
            </summary>
      <param name="filterParameterName">The filter parameter name in the format 
            {FILTER_NAME.PARAMETER_NAME}.</param>
      <returns>The filter parameter value.</returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.GetFilterParameterType(System.String)">
      <summary>
            Retrieve the type for a given filter parameter.
            </summary>
      <param name="filterParameterName">The filter parameter name in the format 
            {FILTER_NAME.PARAMETER_NAME}.</param>
      <returns>The filter parameter type.</returns>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.GetEntityUsingInterceptor(NHibernate.Engine.EntityKey)">
      <summary> 
            Get the entity instance associated with the given <tt>Key</tt>,
            calling the Interceptor if necessary
            </summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.BestGuessEntityName(System.Object)">
      <summary> The best guess entity name for an entity not in an association</summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.GuessEntityName(System.Object)">
      <summary> The guessed entity name for an entity not in an association</summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.ExecuteNativeUpdate(NHibernate.Engine.Query.Sql.NativeSQLQuerySpecification,NHibernate.Engine.QueryParameters)">
      <summary> Execute a native SQL update or delete query</summary>
    </member>
    <member name="M:NHibernate.Engine.ISessionImplementor.ExecuteUpdate(System.String,NHibernate.Engine.QueryParameters)">
      <summary> Execute a HQL update or delete query</summary>
    </member>
    <member name="P:NHibernate.Engine.ISessionImplementor.Timestamp">
      <summary>
            System time before the start of the transaction
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Engine.ISessionImplementor.Factory">
      <summary>
            Get the creating SessionFactoryImplementor
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Engine.ISessionImplementor.Batcher">
      <summary>
            Get the prepared statement <c>Batcher</c> for this session
            </summary>
    </member>
    <member name="P:NHibernate.Engine.ISessionImplementor.EnabledFilters">
      <summary>
            Return the currently enabled filters.  The filter map is keyed by filter
            name, with values corresponding to the <see cref="T:NHibernate.Impl.FilterImpl" />
            instance.
            </summary>
      <returns>The currently enabled filters.</returns>
    </member>
    <member name="P:NHibernate.Engine.ISessionImplementor.Listeners">
      <summary> Retrieves the configured event listeners from this event source. </summary>
    </member>
    <member name="P:NHibernate.Engine.ISessionImplementor.PersistenceContext">
      <summary> Get the persistence context for this session</summary>
    </member>
    <member name="P:NHibernate.Engine.ISessionImplementor.IsOpen">
      <summary>
            Is the <c>ISession</c> still open?
            </summary>
    </member>
    <member name="P:NHibernate.Engine.ISessionImplementor.IsConnected">
      <summary>
            Is the <c>ISession</c> currently connected?
            </summary>
    </member>
    <member name="P:NHibernate.Engine.ISessionImplementor.IsClosed">
      <summary> Determine whether the session is closed.  Provided separately from
            {@link #isOpen()} as this method does not attempt any JTA synch
            registration, where as {@link #isOpen()} does; which makes this one
            nicer to use for most internal purposes. 
            </summary>
      <returns> True if the session is closed; false otherwise.
            </returns>
    </member>
    <member name="P:NHibernate.Engine.ISessionImplementor.TransactionInProgress">
      <summary> 
            Does this <tt>Session</tt> have an active Hibernate transaction
            or is there a JTA transaction in progress?
            </summary>
    </member>
    <member name="P:NHibernate.Engine.ISessionImplementor.EntityMode">
      <summary> Retrieve the entity mode in effect for this session. </summary>
    </member>
    <member name="M:NHibernate.Engine.JoinHelper.GetAliasedLHSColumnNames(NHibernate.Type.IAssociationType,System.String,System.Int32,NHibernate.Persister.Entity.IOuterJoinLoadable,NHibernate.Engine.IMapping)">
      <summary>
            Get the aliased columns of the owning entity which are to 
            be used in the join
            </summary>
    </member>
    <member name="M:NHibernate.Engine.JoinHelper.GetLHSColumnNames(NHibernate.Type.IAssociationType,System.Int32,NHibernate.Persister.Entity.IOuterJoinLoadable,NHibernate.Engine.IMapping)">
      <summary>
            Get the columns of the owning entity which are to 
            be used in the join
            </summary>
    </member>
    <member name="M:NHibernate.Engine.JoinHelper.GetAliasedLHSColumnNames(NHibernate.Type.IAssociationType,System.String,System.Int32,System.Int32,NHibernate.Persister.Entity.IOuterJoinLoadable,NHibernate.Engine.IMapping)">
      <summary>
            Get the aliased columns of the owning entity which are to 
            be used in the join
            </summary>
    </member>
    <member name="M:NHibernate.Engine.JoinHelper.GetLHSColumnNames(NHibernate.Type.IAssociationType,System.Int32,System.Int32,NHibernate.Persister.Entity.IOuterJoinLoadable,NHibernate.Engine.IMapping)">
      <summary>
            Get the columns of the owning entity which are to 
            be used in the join
            </summary>
    </member>
    <member name="M:NHibernate.Engine.JoinHelper.GetRHSColumnNames(NHibernate.Type.IAssociationType,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Get the columns of the associated table which are to 
            be used in the join
            </summary>
    </member>
    <member name="T:NHibernate.Engine.Nullability">
      <summary> 
            Implements the algorithm for validating property values
            for illegal null values
            </summary>
    </member>
    <member name="M:NHibernate.Engine.Nullability.CheckNullability(System.Object[],NHibernate.Persister.Entity.IEntityPersister,System.Boolean)">
      <summary> 
            Check nullability of the class persister properties
            </summary>
      <param name="values">entity properties </param>
      <param name="persister">class persister </param>
      <param name="isUpdate">wether it is intended to be updated or saved </param>
    </member>
    <member name="M:NHibernate.Engine.Nullability.CheckSubElementsNullability(NHibernate.Type.IType,System.Object)">
      <summary> 
            Check sub elements-nullability. Returns property path that break
            nullability or null if none 
            </summary>
      <param name="propertyType">type to check </param>
      <param name="value">value to check </param>
      <returns> property path </returns>
    </member>
    <member name="M:NHibernate.Engine.Nullability.CheckComponentNullability(System.Object,NHibernate.Type.IAbstractComponentType)">
      <summary> 
            Check component nullability. Returns property path that break
            nullability or null if none 
            </summary>
      <param name="value">component properties </param>
      <param name="compType">component not-nullable type </param>
      <returns> property path </returns>
    </member>
    <member name="M:NHibernate.Engine.Nullability.BuildPropertyPath(System.String,System.String)">
      <summary> 
            Return a well formed property path.
            Basicaly, it will return parent.child 
            </summary>
      <param name="parent">parent in path </param>
      <param name="child">child in path </param>
      <returns> parent-child path</returns>
    </member>
    <member name="T:NHibernate.Engine.QueryParameters">
      <summary>
            Container for data that is used during the NHibernate query/load process. 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.QueryParameters.LogParameters(NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Engine.QueryParameters.ValidateParameters">
      <summary>
            Ensure the Types and Values are the same length.
            </summary>
      <exception cref="T:NHibernate.QueryException">
            If the Lengths of <see cref="P:NHibernate.Engine.QueryParameters.PositionalParameterTypes" /> and 
            <see cref="P:NHibernate.Engine.QueryParameters.PositionalParameterValues" /> are not equal.
            </exception>
    </member>
    <member name="P:NHibernate.Engine.QueryParameters.HasRowSelection">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Engine.QueryParameters.NamedParameters">
      <summary>
            Named parameters.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.QueryParameters.PositionalParameterTypes">
      <summary>
            Gets or sets an array of <see cref="T:NHibernate.Type.IType" /> objects that is stored at the index 
            of the Parameter.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.QueryParameters.PositionalParameterValues">
      <summary>
            Gets or sets an array of <see cref="T:System.Object" /> objects that is stored at the index 
            of the Parameter.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.QueryParameters.RowSelection">
      <summary>
            Gets or sets the <see cref="P:NHibernate.Engine.QueryParameters.RowSelection" /> for the Query.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.QueryParameters.LockModes">
      <summary>
            Gets or sets an <see cref="T:System.Collections.IDictionary" /> that contains the alias name of the
            object from hql as the key and the <see cref="T:NHibernate.LockMode" /> as the value.
            </summary>
      <value>An <see cref="T:System.Collections.IDictionary" /> of lock modes.</value>
    </member>
    <member name="T:NHibernate.Engine.RowSelection">
      <summary>
            Information to determine how to run an IDbCommand and what
            records to return from the IDataReader.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.RowSelection.NoValue">
      <summary>
            Indicates that the no value has been set on the Property.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.RowSelection.FirstRow">
      <summary>
            Gets or Sets the Index of the First Row to Select
            </summary>
      <value>The Index of the First Rows to Select</value>
      <remarks>Defaults to 0 unless specifically set.</remarks>
    </member>
    <member name="P:NHibernate.Engine.RowSelection.MaxRows">
      <summary>
            Gets or Sets the Maximum Number of Rows to Select
            </summary>
      <value>The Maximum Number of Rows to Select</value>
      <remarks>Defaults to NoValue unless specifically set.</remarks>
    </member>
    <member name="P:NHibernate.Engine.RowSelection.Timeout">
      <summary>
            Gets or Sets the Timeout of the Query
            </summary>
      <value>The Query Timeout</value>
      <remarks>Defaults to NoValue unless specifically set.</remarks>
    </member>
    <member name="T:NHibernate.Engine.StatefulPersistenceContext">
      <summary> 
            A <see cref="T:NHibernate.Engine.IPersistenceContext" /> represents the state of persistent "stuff" which
            NHibernate is tracking.  This includes persistent entities, collections,
            as well as proxies generated. 
            </summary>
      <remarks>
            There is meant to be a one-to-one correspondence between a SessionImpl and
            a PersistentContext.  The SessionImpl uses the PersistentContext to track
            the current state of its context.  Event-listeners then use the
            PersistentContext to drive their processing.
            </remarks>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.#ctor(NHibernate.Engine.ISessionImplementor)">
      <summary> Constructs a PersistentContext, bound to the given session. </summary>
      <param name="session">The session "owning" this context. </param>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddUnownedCollection(NHibernate.Engine.CollectionKey,NHibernate.Collection.IPersistentCollection)">
      <summary> Add a collection which has no owner loaded</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.UseUnownedCollection(NHibernate.Engine.CollectionKey)">
      <summary> 
            Get and remove a collection whose owner is not yet loaded,
            when its owner is being loaded
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.Clear">
      <summary> Clear the state of the persistence context</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.SetEntryStatus(NHibernate.Engine.EntityEntry,NHibernate.Engine.Status)">
      <summary> Set the status of an entry</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AfterTransactionCompletion">
      <summary> Called after transactions end</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetDatabaseSnapshot(System.Object,NHibernate.Persister.Entity.IEntityPersister)">
      <summary> 
            Get the current state of the entity as known to the underlying
            database, or null if there is no corresponding row 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetCachedDatabaseSnapshot(NHibernate.Engine.EntityKey)">
      <summary> 
            Retrieve the cached database snapshot for the requested entity key.
            </summary>
      <param name="key">The entity key for which to retrieve the cached snapshot </param>
      <returns> The cached snapshot </returns>
      <remarks>
        <list type="bullet">
          <listheader>
            <description>This differs from <see cref="M:NHibernate.Engine.StatefulPersistenceContext.GetDatabaseSnapshot(System.Object,NHibernate.Persister.Entity.IEntityPersister)" /> is two important respects:</description>
          </listheader>
          <item>
            <description>no snapshot is obtained from the database if not already cached</description>
          </item>
          <item>
            <description>an entry of NO_ROW here is interpreted as an exception</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetNaturalIdSnapshot(System.Object,NHibernate.Persister.Entity.IEntityPersister)">
      <summary> 
            Get the values of the natural id fields as known to the underlying 
            database, or null if the entity has no natural id or there is no 
            corresponding row.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddEntity(NHibernate.Engine.EntityKey,System.Object)">
      <summary> Add a canonical mapping from entity key to entity instance</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetEntity(NHibernate.Engine.EntityKey)">
      <summary> 
            Get the entity instance associated with the given <tt>EntityKey</tt></summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.ContainsEntity(NHibernate.Engine.EntityKey)">
      <summary> Is there an entity with the given key in the persistence context</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.RemoveEntity(NHibernate.Engine.EntityKey)">
      <summary> 
            Remove an entity from the session cache, also clear
            up other state associated with the entity, all except
            for the <tt>EntityEntry</tt></summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetEntity(NHibernate.Engine.EntityUniqueKey)">
      <summary> Get an entity cached by unique key</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddEntity(NHibernate.Engine.EntityUniqueKey,System.Object)">
      <summary> Add an entity to the cache by unique key</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetEntry(System.Object)">
      <summary> 
            Retrieve the EntityEntry representation of the given entity. 
            </summary>
      <param name="entity">The entity for which to locate the EntityEntry. </param>
      <returns> The EntityEntry for the given entity. </returns>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.RemoveEntry(System.Object)">
      <summary> Remove an entity entry from the session cache</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.IsEntryFor(System.Object)">
      <summary> Is there an EntityEntry for this instance?</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetCollectionEntry(NHibernate.Collection.IPersistentCollection)">
      <summary> Get the collection entry for a persistent collection</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddEntity(System.Object,NHibernate.Engine.Status,System.Object[],NHibernate.Engine.EntityKey,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,System.Boolean,System.Boolean)">
      <summary> Adds an entity to the internal caches.</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddEntry(System.Object,NHibernate.Engine.Status,System.Object[],System.Object,System.Object,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,System.Boolean,System.Boolean)">
      <summary> 
            Generates an appropriate EntityEntry instance and adds it 
            to the event source's internal caches.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.ContainsCollection(NHibernate.Collection.IPersistentCollection)">
      <summary> Is the given collection associated with this persistence context?</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.ContainsProxy(NHibernate.Proxy.INHibernateProxy)">
      <summary> Is the given proxy associated with this persistence context?</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.ReassociateIfUninitializedProxy(System.Object)">
      <summary> 
            Takes the given object and, if it represents a proxy, reassociates it with this event source. 
            </summary>
      <param name="value">The possible proxy to be reassociated. </param>
      <returns> Whether the passed value represented an actual proxy which got initialized. </returns>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.ReassociateProxy(System.Object,System.Object)">
      <summary> 
            If a deleted entity instance is re-saved, and it has a proxy, we need to
            reset the identifier of the proxy 
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.ReassociateProxy(NHibernate.Proxy.ILazyInitializer,NHibernate.Proxy.INHibernateProxy)">
      <summary> 
            Associate a proxy that was instantiated by another session with this session
            </summary>
      <param name="li">The proxy initializer. </param>
      <param name="proxy">The proxy to reassociate. </param>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.Unproxy(System.Object)">
      <summary> 
            Get the entity instance underlying the given proxy, throwing
            an exception if the proxy is uninitialized. If the given object
            is not a proxy, simply return the argument.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.UnproxyAndReassociate(System.Object)">
      <summary> 
            Possibly unproxy the given reference and reassociate it with the current session. 
            </summary>
      <param name="maybeProxy">The reference to be unproxied if it currently represents a proxy. </param>
      <returns> The unproxied instance. </returns>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.CheckUniqueness(NHibernate.Engine.EntityKey,System.Object)">
      <summary> 
            Attempts to check whether the given key represents an entity already loaded within the
            current session.
            </summary>
      <param name="obj">The entity reference against which to perform the uniqueness check.</param>
      <param name="key">The entity key.</param>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.NarrowProxy(NHibernate.Proxy.INHibernateProxy,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object)">
      <summary> 
            If the existing proxy is insufficiently "narrow" (derived), instantiate a new proxy
            and overwrite the registration of the old one. This breaks == and occurs only for
            "class" proxies rather than "interface" proxies. Also init the proxy to point to
            the given target implementation if necessary. 
            </summary>
      <param name="proxy">The proxy instance to be narrowed. </param>
      <param name="persister">The persister for the proxied entity. </param>
      <param name="key">The internal cache key for the proxied entity. </param>
      <param name="obj">(optional) the actual proxied entity instance. </param>
      <returns> An appropriately narrowed instance. </returns>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.ProxyFor(NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object)">
      <summary> 
            Return the existing proxy associated with the given <tt>EntityKey</tt>, or the
            third argument (the entity associated with the key) if no proxy exists. Init
            the proxy to the target implementation, if necessary.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.ProxyFor(System.Object)">
      <summary> 
            Return the existing proxy associated with the given <tt>EntityKey</tt>, or the
            argument (the entity associated with the key) if no proxy exists.
            (slower than the form above)
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetCollectionOwner(System.Object,NHibernate.Persister.Collection.ICollectionPersister)">
      <summary> Get the entity that owns this persistent collection</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetLoadedCollectionOwnerOrNull(NHibernate.Collection.IPersistentCollection)">
      <summary> Get the entity that owned this persistent collection when it was loaded </summary>
      <param name="collection">The persistent collection </param>
      <returns> 
            The owner, if its entity ID is available from the collection's loaded key
            and the owner entity is in the persistence context; otherwise, returns null
            </returns>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetLoadedCollectionOwnerIdOrNull(NHibernate.Collection.IPersistentCollection)">
      <summary> Get the ID for the entity that owned this persistent collection when it was loaded </summary>
      <param name="collection">The persistent collection </param>
      <returns> the owner ID if available from the collection's loaded key; otherwise, returns null </returns>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetLoadedCollectionOwnerIdOrNull(NHibernate.Engine.CollectionEntry)">
      <summary> Get the ID for the entity that owned this persistent collection when it was loaded </summary>
      <param name="ce">The collection entry </param>
      <returns> the owner ID if available from the collection's loaded key; otherwise, returns null </returns>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddUninitializedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,System.Object)">
      <summary> add a collection we just loaded up (still needs initializing)</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddUninitializedDetachedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
      <summary> add a detached uninitialized collection</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddNewCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
      <summary> 
            Add a new collection (ie. a newly created one, just instantiated by the
            application, with no database state or snapshot)
            </summary>
      <param name="collection">The collection to be associated with the persistence context </param>
      <param name="persister">
      </param>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Engine.CollectionEntry,System.Object)">
      <summary> Add an collection to the cache, with a given collection entry. </summary>
      <param name="coll">The collection for which we are adding an entry.</param>
      <param name="entry">The entry representing the collection. </param>
      <param name="key">The key of the collection's entry. </param>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister)">
      <summary> Add a collection to the cache, creating a new collection entry for it </summary>
      <param name="collection">The collection for which we are adding an entry. </param>
      <param name="persister">The collection persister </param>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddInitializedDetachedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection)">
      <summary> 
            add an (initialized) collection that was created by another session and passed
            into update() (ie. one with a snapshot and existing state on the database)
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddInitializedCollection(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,System.Object)">
      <summary> add a collection we just pulled out of the cache (does not need initializing)</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetCollection(NHibernate.Engine.CollectionKey)">
      <summary> Get the collection instance associated with the <tt>CollectionKey</tt></summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddNonLazyCollection(NHibernate.Collection.IPersistentCollection)">
      <summary> 
            Register a collection for non-lazy loading at the end of the two-phase load
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.InitializeNonLazyCollections">
      <summary> 
            Force initialization of all non-lazy collections encountered during
            the current two-phase load (actually, this is a no-op, unless this
            is the "outermost" load)
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetCollectionHolder(System.Object)">
      <summary> Get the <tt>PersistentCollection</tt> object for an array</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddCollectionHolder(NHibernate.Collection.IPersistentCollection)">
      <summary> Register a <tt>PersistentCollection</tt> object for an array.
            Associates a holder with an array - MUST be called after loading 
            array, since the array instance is not created until endLoad().
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.RemoveCollectionHolder(System.Object)">
      <summary> 
            Remove the mapping of collection to holder during eviction of the owning entity
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetSnapshot(NHibernate.Collection.IPersistentCollection)">
      <summary> Get the snapshot of the pre-flush collection state</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetCollectionEntryOrNull(System.Object)">
      <summary> 
            Get the collection entry for a collection passed to filter,
            which might be a collection wrapper, an array, or an unwrapped
            collection. Return null if there is no entry.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetProxy(NHibernate.Engine.EntityKey)">
      <summary> Get an existing proxy by key</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddProxy(NHibernate.Engine.EntityKey,NHibernate.Proxy.INHibernateProxy)">
      <summary> Add a proxy to the session cache</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.RemoveProxy(NHibernate.Engine.EntityKey)">
      <summary> Remove a proxy from the session cache</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.IncrementCascadeLevel">
      <summary> Called before cascading</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.DecrementCascadeLevel">
      <summary> Called after cascading</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.BeforeLoad">
      <summary> Call this before begining a two-phase load</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AfterLoad">
      <summary> Call this after finishing a two-phase load</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetOwnerId(System.String,System.String,System.Object,System.Collections.IDictionary)">
      <summary> 
            Search the persistence context for an owner for the child object,
            given a collection role
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.GetIndexInOwner(System.String,System.String,System.Object,System.Collections.IDictionary)">
      <summary> 
            Search the persistence context for an index of the child object, given a collection role
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.AddNullProperty(NHibernate.Engine.EntityKey,System.String)">
      <summary> 
            Record the fact that the association belonging to the keyed entity is null.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.IsPropertyNull(NHibernate.Engine.EntityKey,System.String)">
      <summary> Is the association property belonging to the keyed entity null?</summary>
    </member>
    <member name="M:NHibernate.Engine.StatefulPersistenceContext.SetReadOnly(System.Object,System.Boolean)">
      <summary> Set the object to read only and discard it's snapshot</summary>
    </member>
    <member name="P:NHibernate.Engine.StatefulPersistenceContext.Session">
      <summary> 
            Get the session to which this persistence context is bound. 
            </summary>
    </member>
    <member name="P:NHibernate.Engine.StatefulPersistenceContext.LoadContexts">
      <summary> 
            Retrieve this persistence context's managed load context.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.StatefulPersistenceContext.BatchFetchQueue">
      <summary> 
            Get the <tt>BatchFetchQueue</tt>, instantiating one if necessary.
            </summary>
    </member>
    <member name="P:NHibernate.Engine.StatefulPersistenceContext.NullifiableEntityKeys">
      <summary> Retrieve the set of EntityKeys representing nullifiable references</summary>
    </member>
    <member name="P:NHibernate.Engine.StatefulPersistenceContext.EntitiesByKey">
      <summary> Get the mapping from key value to entity instance</summary>
    </member>
    <member name="P:NHibernate.Engine.StatefulPersistenceContext.EntityEntries">
      <summary> Get the mapping from entity instance to entity entry</summary>
    </member>
    <member name="P:NHibernate.Engine.StatefulPersistenceContext.CollectionEntries">
      <summary> Get the mapping from collection instance to collection entry</summary>
    </member>
    <member name="P:NHibernate.Engine.StatefulPersistenceContext.CollectionsByKey">
      <summary> Get the mapping from collection key to collection instance</summary>
    </member>
    <member name="P:NHibernate.Engine.StatefulPersistenceContext.CascadeLevel">
      <summary> How deep are we cascaded?</summary>
    </member>
    <member name="P:NHibernate.Engine.StatefulPersistenceContext.Flushing">
      <summary>Is a flush cycle currently in process?</summary>
      <remarks>Called before and after the flushcycle</remarks>
    </member>
    <member name="P:NHibernate.Engine.StatefulPersistenceContext.HasNonReadOnlyEntities">
      <summary>False if we know for certain that all the entities are read-only</summary>
    </member>
    <member name="T:NHibernate.Engine.Status">
      <summary>
            Represents the status of an entity with respect to 
            this session. These statuses are for internal 
            book-keeping only and are not intended to represent 
            any notion that is visible to the <b>application</b>. 
            </summary>
    </member>
    <member name="F:NHibernate.Engine.Status.Loaded">
      <summary>
            The Entity is snapshotted in the Session with the same state as the database
            (called Managed in H3).
            </summary>
    </member>
    <member name="F:NHibernate.Engine.Status.Deleted">
      <summary>
            The Entity is in the Session and has been marked for deletion but not
            deleted from the database yet.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.Status.Gone">
      <summary>
            The Entity has been deleted from database.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.Status.Loading">
      <summary>
            The Entity is in the process of being loaded.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.Status.Saving">
      <summary>
            The Entity is in the process of being saved.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.Status.ReadOnly">
      <summary>
            The entity is read-only.
            </summary>
    </member>
    <member name="T:NHibernate.Engine.TransactionHelper">
      <summary>
            Allows work to be done outside the current transaction, by suspending it,
            and performing work in a new transaction
            </summary>
    </member>
    <member name="M:NHibernate.Engine.TransactionHelper.DoWorkInCurrentTransaction(NHibernate.Engine.ISessionImplementor,System.Data.IDbConnection,System.Data.IDbTransaction)">
      <summary> The work to be done</summary>
    </member>
    <member name="M:NHibernate.Engine.TransactionHelper.DoWorkInNewTransaction(NHibernate.Engine.ISessionImplementor)">
      <summary> Suspend the current transaction and perform work in a new transaction</summary>
    </member>
    <member name="T:NHibernate.Engine.TwoPhaseLoad">
      <summary> 
            Functionality relating to Hibernate's two-phase loading process,
            that may be reused by persisters that do not use the Loader
            framework
            </summary>
    </member>
    <member name="M:NHibernate.Engine.TwoPhaseLoad.PostHydrate(NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object[],System.Object,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Register the "hydrated" state of an entity instance, after the first step of 2-phase loading.
            
            Add the "hydrated state" (an array) of an uninitialized entity to the session. We don't try
            to resolve any associations yet, because there might be other entities waiting to be
            read from the JDBC result set we are currently processing
            </summary>
    </member>
    <member name="M:NHibernate.Engine.TwoPhaseLoad.InitializeEntity(System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor,NHibernate.Event.PreLoadEvent,NHibernate.Event.PostLoadEvent)">
      <summary> 
            Perform the second step of 2-phase load. Fully initialize the entity instance. 
            After processing a JDBC result set, we "resolve" all the associations
            between the entities which were instantiated and had their state
            "hydrated" into an array
            </summary>
    </member>
    <member name="M:NHibernate.Engine.TwoPhaseLoad.AddUninitializedEntity(NHibernate.Engine.EntityKey,System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.LockMode,System.Boolean,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Add an uninitialized instance of an entity class, as a placeholder to ensure object 
            identity. Must be called before <tt>postHydrate()</tt>.
             Create a "temporary" entry for a newly instantiated entity. The entity is uninitialized,
            but we need the mapping from id to instance in order to guarantee uniqueness.
            </summary>
    </member>
    <member name="T:NHibernate.Engine.TypedValue">
      <summary> An ordered pair of a value and its Hibernate type. </summary>
    </member>
    <member name="M:NHibernate.Engine.UnsavedValueFactory.GetUnsavedIdentifierValue(System.String,NHibernate.Properties.IGetter,NHibernate.Type.IType,System.Reflection.ConstructorInfo)">
      <summary>
            Return an IdentifierValue for the specified unsaved-value. If none is specified,
            guess the unsaved value by instantiating a test instance of the class and
            reading it's id property, or if that is not possible, using the java default
            value for the type
            </summary>
    </member>
    <member name="T:NHibernate.Engine.ValueInclusion">
      <summary>
            An enum of the different ways a value might be "included".
            </summary>
      <remarks>
            This is really an expanded true/false notion with Partial being the
            expansion. Partial deals with components in the cases where
            parts of the referenced component might define inclusion, but the
            component overall does not.
            </remarks>
    </member>
    <member name="T:NHibernate.Engine.Versioning">
      <summary>
            Utility methods for managing versions and timestamps
            </summary>
    </member>
    <member name="M:NHibernate.Engine.Versioning.Increment(System.Object,NHibernate.Type.IVersionType,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Increment the given version number
            </summary>
      <param name="version">The value of the current version.</param>
      <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType" /> of the versioned property.</param>
      <param name="session">The current <see cref="T:NHibernate.ISession" />.</param>
      <returns>Returns the next value for the version.</returns>
    </member>
    <member name="M:NHibernate.Engine.Versioning.Seed(NHibernate.Type.IVersionType,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Create an initial version number
            </summary>
      <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType" /> of the versioned property.</param>
      <param name="session">The current <see cref="T:NHibernate.ISession" />.</param>
      <returns>A seed value to initialize the versioned property with.</returns>
    </member>
    <member name="M:NHibernate.Engine.Versioning.SeedVersion(System.Object[],System.Int32,NHibernate.Type.IVersionType,System.Nullable{System.Boolean},NHibernate.Engine.ISessionImplementor)">
      <summary>
            Seed the given instance state snapshot with an initial version number
            </summary>
      <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
      <param name="versionProperty">The index of the version property in the <c>fields</c> parameter.</param>
      <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType" /> of the versioned property.</param>
      <param name="force">Force the version to initialize</param>
      <param name="session">The current session, if any.</param>
      <returns>
        <see langword="true" /> if the version property needs to be seeded with an initial value.</returns>
    </member>
    <member name="M:NHibernate.Engine.Versioning.SetVersion(System.Object[],System.Object,NHibernate.Persister.Entity.IEntityPersister)">
      <summary>
            Set the version number of the given instance state snapshot
            </summary>
      <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
      <param name="version">The value the version should be set to in the <c>fields</c> parameter.</param>
      <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> that is responsible for persisting the values of the <c>fields</c> parameter.</param>
    </member>
    <member name="M:NHibernate.Engine.Versioning.GetVersion(System.Object[],NHibernate.Persister.Entity.IEntityPersister)">
      <summary>
            Get the version number of the given instance state snapshot
            </summary>
      <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
      <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> that is responsible for persisting the values of the <c>fields</c> parameter.</param>
      <returns>
            The value of the version contained in the <c>fields</c> parameter or null if the
            Entity is not versioned.
            </returns>
    </member>
    <member name="M:NHibernate.Engine.Versioning.IsVersionIncrementRequired(System.Int32[],System.Boolean,System.Boolean[])">
      <summary> Do we need to increment the version number, given the dirty properties? </summary>
      <param name="dirtyProperties">The array of property indexes which were deemed dirty </param>
      <param name="hasDirtyCollections">Were any collections found to be dirty (structurally changed) </param>
      <param name="propertyVersionability">An array indicating versionability of each property. </param>
      <returns> True if a version increment is required; false otherwise. </returns>
    </member>
    <member name="T:NHibernate.Engine.VersionValue">
      <summary>
            A strategy for determining if a version value is an version of
            a new transient instance or a previously persistent transient instance.
            The strategy is determined by the <c>Unsaved-Value</c> attribute in the mapping file.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.VersionValue.VersionSaveNull">
      <summary>
            Assume the transient instance is newly instantiated if the version
            is null, otherwise assume it is a detached instance.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.VersionValue.VersionUndefined">
      <summary>
            Assume the transient instance is newly instantiated if the version
            is null, otherwise defer to the identifier unsaved-value.
            </summary>
    </member>
    <member name="F:NHibernate.Engine.VersionValue.VersionNegative">
      <summary>
            Assume the transient instance is newly instantiated if the identifier
            is null.
            </summary>
    </member>
    <member name="M:NHibernate.Engine.VersionValue.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Engine.VersionValue.#ctor(System.Object)">
      <summary>
            Assume the transient instance is newly instantiated if its version is null or
            equal to <c>Value</c></summary>
      <param name="value">
      </param>
    </member>
    <member name="M:NHibernate.Engine.VersionValue.IsUnsaved(System.Object)">
      <summary>
            Does the given identifier belong to a new instance
            </summary>
    </member>
    <member name="T:NHibernate.Event.Default.AbstractFlushingEventListener">
      <summary>
            A convenience base class for listeners whose functionality results in flushing.
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractFlushingEventListener.FlushEverythingToExecutions(NHibernate.Event.FlushEvent)">
      <summary> 
            Coordinates the processing necessary to get things ready for executions
            as db calls by preparing the session caches and moving the appropriate
            entities and collections to their respective execution queues. 
            </summary>
      <param name="event">The flush event.</param>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractFlushingEventListener.PerformExecutions(NHibernate.Event.IEventSource)">
      <summary> 
            Execute all SQL and second-level cache updates, in a
            special order so that foreign-key constraints cannot
            be violated:
            <list type="bullet"><item><description>Inserts, in the order they were performed</description></item><item><description>Updates</description></item><item><description>Deletion of collection elements</description></item><item><description>Insertion of collection elements</description></item><item><description>Deletes, in the order they were performed</description></item></list></summary>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractFlushingEventListener.PostFlush(NHibernate.Engine.ISessionImplementor)">
      <summary> 
            1. Recreate the collection key -&gt; collection map
            2. rebuild the collection entries
            3. call Interceptor.postFlush()
            </summary>
    </member>
    <member name="T:NHibernate.Event.Default.AbstractReassociateEventListener">
      <summary> 
            A convenience base class for listeners that respond to requests to reassociate an entity
            to a session ( such as through lock() or update() ). 
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractReassociateEventListener.Reassociate(NHibernate.Event.AbstractEvent,System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
      <summary> 
            Associates a given entity (either transient or associated with another session) to the given session. 
            </summary>
      <param name="event">The event triggering the re-association </param>
      <param name="entity">The entity to be associated </param>
      <param name="id">The id of the entity. </param>
      <param name="persister">The entity's persister instance. </param>
      <returns> An EntityEntry representing the entity within this session. </returns>
    </member>
    <member name="T:NHibernate.Event.Default.AbstractLockUpgradeEventListener">
      <summary> 
            A convenience base class for listeners that respond to requests to perform a
            pessimistic lock upgrade on an entity. 
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractLockUpgradeEventListener.UpgradeLock(System.Object,NHibernate.Engine.EntityEntry,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Performs a pessimistic lock upgrade on a given entity, if needed. 
            </summary>
      <param name="entity">The entity for which to upgrade the lock.</param>
      <param name="entry">The entity's EntityEntry instance.</param>
      <param name="requestedLockMode">The lock mode being requested for locking. </param>
      <param name="source">The session which is the source of the event being processed.</param>
    </member>
    <member name="T:NHibernate.Event.Default.AbstractSaveEventListener">
      <summary> 
            A convenience bas class for listeners responding to save events. 
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.SaveWithRequestedId(System.Object,System.Object,System.String,System.Object,NHibernate.Event.IEventSource)">
      <summary> 
            Prepares the save call using the given requested id. 
            </summary>
      <param name="entity">The entity to be saved. </param>
      <param name="requestedId">The id to which to associate the entity. </param>
      <param name="entityName">The name of the entity being saved. </param>
      <param name="anything">Generally cascade-specific information. </param>
      <param name="source">The session which is the source of this save event. </param>
      <returns> The id used to save the entity. </returns>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.SaveWithGeneratedId(System.Object,System.String,System.Object,NHibernate.Event.IEventSource,System.Boolean)">
      <summary> 
            Prepares the save call using a newly generated id. 
            </summary>
      <param name="entity">The entity to be saved </param>
      <param name="entityName">The entity-name for the entity to be saved </param>
      <param name="anything">Generally cascade-specific information. </param>
      <param name="source">The session which is the source of this save event. </param>
      <param name="requiresImmediateIdAccess">
            does the event context require
            access to the identifier immediately after execution of this method (if
            not, post-insert style id generators may be postponed if we are outside
            a transaction). 
            </param>
      <returns> 
            The id used to save the entity; may be null depending on the
            type of id generator used and the requiresImmediateIdAccess value
            </returns>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.PerformSave(System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister,System.Boolean,System.Object,NHibernate.Event.IEventSource,System.Boolean)">
      <summary> 
            Prepares the save call by checking the session caches for a pre-existing
            entity and performing any lifecycle callbacks. 
            </summary>
      <param name="entity">The entity to be saved. </param>
      <param name="id">The id by which to save the entity. </param>
      <param name="persister">The entity's persister instance. </param>
      <param name="useIdentityColumn">Is an identity column being used? </param>
      <param name="anything">Generally cascade-specific information. </param>
      <param name="source">The session from which the event originated. </param>
      <param name="requiresImmediateIdAccess">
            does the event context require
            access to the identifier immediately after execution of this method (if
            not, post-insert style id generators may be postponed if we are outside
            a transaction). 
            </param>
      <returns> 
            The id used to save the entity; may be null depending on the
            type of id generator used and the requiresImmediateIdAccess value
            </returns>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.PerformSaveOrReplicate(System.Object,NHibernate.Engine.EntityKey,NHibernate.Persister.Entity.IEntityPersister,System.Boolean,System.Object,NHibernate.Event.IEventSource,System.Boolean)">
      <summary> 
            Performs all the actual work needed to save an entity (well to get the save moved to
            the execution queue). 
            </summary>
      <param name="entity">The entity to be saved </param>
      <param name="key">The id to be used for saving the entity (or null, in the case of identity columns) </param>
      <param name="persister">The entity's persister instance. </param>
      <param name="useIdentityColumn">Should an identity column be used for id generation? </param>
      <param name="anything">Generally cascade-specific information. </param>
      <param name="source">The session which is the source of the current event. </param>
      <param name="requiresImmediateIdAccess">
            Is access to the identifier required immediately
            after the completion of the save?  persist(), for example, does not require this... 
            </param>
      <returns> 
            The id used to save the entity; may be null depending on the
            type of id generator used and the requiresImmediateIdAccess value
            </returns>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.SubstituteValuesIfNecessary(System.Object,System.Object,System.Object[],NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Perform any property value substitution that is necessary
            (interceptor callback, version initialization...) 
            </summary>
      <param name="entity">The entity </param>
      <param name="id">The entity identifier </param>
      <param name="values">The snapshot entity state </param>
      <param name="persister">The entity persister </param>
      <param name="source">The originating session </param>
      <returns> 
            True if the snapshot state changed such that
            reinjection of the values into the entity is required.
            </returns>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.CascadeBeforeSave(NHibernate.Event.IEventSource,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object)">
      <summary> Handles the calls needed to perform pre-save cascades for the given entity. </summary>
      <param name="source">The session from which the save event originated.</param>
      <param name="persister">The entity's persister instance. </param>
      <param name="entity">The entity to be saved. </param>
      <param name="anything">Generally cascade-specific data </param>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.CascadeAfterSave(NHibernate.Event.IEventSource,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object)">
      <summary> Handles to calls needed to perform post-save cascades. </summary>
      <param name="source">The session from which the event originated. </param>
      <param name="persister">The entity's persister instance. </param>
      <param name="entity">The entity being saved. </param>
      <param name="anything">Generally cascade-specific data </param>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractSaveEventListener.GetEntityState(System.Object,System.String,NHibernate.Engine.EntityEntry,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Determine whether the entity is persistent, detached, or transient 
            </summary>
      <param name="entity">The entity to check </param>
      <param name="entityName">The name of the entity </param>
      <param name="entry">The entity's entry in the persistence context </param>
      <param name="source">The originating session. </param>
      <returns> The state. </returns>
    </member>
    <member name="P:NHibernate.Event.Default.AbstractSaveEventListener.VersionIncrementDisabled">
      <summary> 
            After the save, will te version number be incremented
            if the instance is modified? 
            </summary>
      <returns> True if the version will be incremented on an entity change after save; false otherwise. </returns>
    </member>
    <member name="T:NHibernate.Event.Default.AbstractVisitor">
      <summary> 
            Abstract superclass of algorithms that walk a tree of property values of an entity, and
            perform specific functionality for collections, components and associated entities. 
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractVisitor.ProcessValues(System.Object[],NHibernate.Type.IType[])">
      <summary> Dispatch each property value to ProcessValue(). </summary>
      <param name="values">
      </param>
      <param name="types">
      </param>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractVisitor.ProcessValue(System.Object,NHibernate.Type.IType)">
      <summary> 
            Visit a property value. Dispatch to the correct handler for the property type.
            </summary>
      <param name="value">
      </param>
      <param name="type">
      </param>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractVisitor.ProcessComponent(System.Object,NHibernate.Type.IAbstractComponentType)">
      <summary>
            Visit a component. Dispatch each property to <see cref="M:NHibernate.Event.Default.AbstractVisitor.ProcessValues(System.Object[],NHibernate.Type.IType[])" /></summary>
      <param name="component">
      </param>
      <param name="componentType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractVisitor.ProcessEntity(System.Object,NHibernate.Type.EntityType)">
      <summary>
             Visit a many-to-one or one-to-one associated entity. Default superclass implementation is a no-op.
            </summary>
      <param name="value">
      </param>
      <param name="entityType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractVisitor.ProcessCollection(System.Object,NHibernate.Type.CollectionType)">
      <summary>
            Visit a collection. Default superclass implementation is a no-op.
            </summary>
      <param name="value">
      </param>
      <param name="collectionType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Event.Default.AbstractVisitor.Process(System.Object,NHibernate.Persister.Entity.IEntityPersister)">
      <summary>
            Walk the tree starting from the given entity.
            </summary>
      <param name="obj">
      </param>
      <param name="persister">
      </param>
    </member>
    <member name="T:NHibernate.Event.IAutoFlushEventListener">
      <summary> Defines the contract for handling of session auto-flush events. </summary>
    </member>
    <member name="M:NHibernate.Event.IAutoFlushEventListener.OnAutoFlush(NHibernate.Event.AutoFlushEvent)">
      <summary>
            Handle the given auto-flush event.
            </summary>
      <param name="event">The auto-flush event to be handled.</param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultAutoFlushEventListener">
      <summary> 
            Defines the default flush event listeners used by hibernate for 
            flushing session state in response to generated auto-flush events. 
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultAutoFlushEventListener.OnAutoFlush(NHibernate.Event.AutoFlushEvent)">
      <summary>
            Handle the given auto-flush event.
            </summary>
      <param name="event">The auto-flush event to be handled.</param>
    </member>
    <member name="T:NHibernate.Event.IDeleteEventListener">
      <summary> Defines the contract for handling of deletion events generated from a session. </summary>
    </member>
    <member name="M:NHibernate.Event.IDeleteEventListener.OnDelete(NHibernate.Event.DeleteEvent)">
      <summary>Handle the given delete event. </summary>
      <param name="event">The delete event to be handled. </param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultDeleteEventListener">
      <summary> 
            Defines the default delete event listener used by hibernate for deleting entities
            from the datastore in response to generated delete events. 
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultDeleteEventListener.OnDelete(NHibernate.Event.DeleteEvent)">
      <summary>Handle the given delete event. </summary>
      <param name="event">The delete event to be handled. </param>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultDeleteEventListener.PerformDetachedEntityDeletionCheck(NHibernate.Event.DeleteEvent)">
      <summary> Called when we have recognized an attempt to delete a detached entity. </summary>
      <param name="event">The event. </param>
      <remarks>
            This is perfectly valid in Hibernate usage; JPA, however, forbids this.
            Thus, this is a hook for HEM to affect this behavior.
            </remarks>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultDeleteEventListener.DeleteTransientEntity(NHibernate.Event.IEventSource,System.Object,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,Iesi.Collections.ISet)">
      <summary> 
            We encountered a delete request on a transient instance.
            <p />
            This is a deviation from historical Hibernate (pre-3.2) behavior to
            align with the JPA spec, which states that transient entities can be
            passed to remove operation in which case cascades still need to be
            performed.
             </summary>
      <param name="session">The session which is the source of the event </param>
      <param name="entity">The entity being delete processed </param>
      <param name="cascadeDeleteEnabled">Is cascading of deletes enabled</param>
      <param name="persister">The entity persister </param>
      <param name="transientEntities">
            A cache of already visited transient entities (to avoid infinite recursion).
            </param>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultDeleteEventListener.DeleteEntity(NHibernate.Event.IEventSource,System.Object,NHibernate.Engine.EntityEntry,System.Boolean,NHibernate.Persister.Entity.IEntityPersister,Iesi.Collections.ISet)">
      <summary> 
            Perform the entity deletion.  Well, as with most operations, does not
            really perform it; just schedules an action/execution with the
            <see cref="T:NHibernate.Engine.ActionQueue" /> for execution during flush. 
            </summary>
      <param name="session">The originating session </param>
      <param name="entity">The entity to delete </param>
      <param name="entityEntry">The entity's entry in the <see cref="T:NHibernate.ISession" /></param>
      <param name="isCascadeDeleteEnabled">Is delete cascading enabled? </param>
      <param name="persister">The entity persister. </param>
      <param name="transientEntities">A cache of already deleted entities. </param>
    </member>
    <member name="T:NHibernate.Event.IDirtyCheckEventListener">
      <summary> Defines the contract for handling of session dirty-check events.</summary>
    </member>
    <member name="M:NHibernate.Event.IDirtyCheckEventListener.OnDirtyCheck(NHibernate.Event.DirtyCheckEvent)">
      <summary>Handle the given dirty-check event. </summary>
      <param name="event">The dirty-check event to be handled. </param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultDirtyCheckEventListener">
      <summary> 
            Defines the default dirty-check event listener used by hibernate for
            checking the session for dirtiness in response to generated dirty-check events. 
            </summary>
    </member>
    <member name="T:NHibernate.Event.IEvictEventListener">
      <summary> Defines the contract for handling of evict events generated from a session. </summary>
    </member>
    <member name="M:NHibernate.Event.IEvictEventListener.OnEvict(NHibernate.Event.EvictEvent)">
      <summary> Handle the given evict event. </summary>
      <param name="event">The evict event to be handled.</param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultEvictEventListener">
      <summary> 
            Defines the default evict event listener used by hibernate for evicting entities
            in response to generated flush events.  In particular, this implementation will
            remove any hard references to the entity that are held by the infrastructure
            (references held by application or other persistent instances are okay) 
            </summary>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultFlushEntityEventListener">
      <summary> 
            An event that occurs for each entity instance at flush time 
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultFlushEntityEventListener.OnFlushEntity(NHibernate.Event.FlushEntityEvent)">
      <summary> 
            Flushes a single entity's state to the database, by scheduling an update action, if necessary
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultFlushEntityEventListener.CheckId(System.Object,NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.EntityMode)">
      <summary>
            make sure user didn't mangle the id
            </summary>
      <param name="obj">The obj.</param>
      <param name="persister">The persister.</param>
      <param name="id">The id.</param>
      <param name="entityMode">The entity mode.</param>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultFlushEntityEventListener.IsUpdateNecessary(NHibernate.Event.FlushEntityEvent)">
      <summary> 
            Performs all necessary checking to determine if an entity needs an SQL update
            to synchronize its state to the database. Modifies the event by side-effect!
            Note: this method is quite slow, avoid calling if possible!
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultFlushEntityEventListener.DirtyCheck(NHibernate.Event.FlushEntityEvent)">
      <summary> Perform a dirty check, and attach the results to the event</summary>
    </member>
    <member name="T:NHibernate.Event.IFlushEventListener">
      <summary> Defines the contract for handling of session flush events. </summary>
    </member>
    <member name="M:NHibernate.Event.IFlushEventListener.OnFlush(NHibernate.Event.FlushEvent)">
      <summary>Handle the given flush event. </summary>
      <param name="event">The flush event to be handled.</param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultFlushEventListener">
      <summary> 
            Defines the default flush event listeners used by hibernate for 
            flushing session state in response to generated flush events. 
            </summary>
    </member>
    <member name="T:NHibernate.Event.IInitializeCollectionEventListener">
      <summary> 
            Defines the contract for handling of collection initialization events 
            generated by a session. 
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultInitializeCollectionEventListener.OnInitializeCollection(NHibernate.Event.InitializeCollectionEvent)">
      <summary> called by a collection that wants to initialize itself</summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultInitializeCollectionEventListener.InitializeCollectionFromCache(System.Object,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,NHibernate.Engine.ISessionImplementor)">
      <summary> Try to initialize a collection from the cache</summary>
    </member>
    <member name="T:NHibernate.Event.ILoadEventListener">
      <summary>
            Defines the contract for handling of load events generated from a session. 
            </summary>
    </member>
    <member name="M:NHibernate.Event.ILoadEventListener.OnLoad(NHibernate.Event.LoadEvent,NHibernate.Event.LoadType)">
      <summary> 
            Handle the given load event. 
            </summary>
      <param name="event">The load event to be handled. </param>
      <param name="loadType">
      </param>
      <returns> The result (i.e., the loaded entity). </returns>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultLoadEventListener">
      <summary> 
            Defines the default load event listeners used by hibernate for loading entities
            in response to generated load events.
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.Load(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType)">
      <summary> Perfoms the load of an entity. </summary>
      <returns> The loaded entity. </returns>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.ProxyOrLoad(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType)">
      <summary> 
            Based on configured options, will either return a pre-existing proxy,
            generate a new proxy, or perform an actual load. 
            </summary>
      <returns> The result of the proxy/load operation.</returns>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.ReturnNarrowedProxy(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType,NHibernate.Engine.IPersistenceContext,System.Object)">
      <summary> 
            Given that there is a pre-existing proxy.
            Initialize it if necessary; narrow if necessary.
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.CreateProxyIfNecessary(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType,NHibernate.Engine.IPersistenceContext)">
      <summary> 
            Given that there is no pre-existing proxy.
            Check if the entity is already loaded. If it is, return the entity,
            otherwise create and return a proxy.
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.LockAndLoad(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            If the class to be loaded has been configured with a cache, then lock
            given id in that cache and then perform the load. 
            </summary>
      <returns> The loaded entity </returns>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.DoLoad(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType)">
      <summary> 
            Coordinates the efforts to load a given entity.  First, an attempt is
            made to load the entity from the session-level cache.  If not found there,
            an attempt is made to locate it in second-level cache.  Lastly, an
            attempt is made to load it directly from the datasource. 
            </summary>
      <param name="event">The load event </param>
      <param name="persister">The persister for the entity being requested for load </param>
      <param name="keyToLoad">The EntityKey representing the entity to be loaded. </param>
      <param name="options">The load options. </param>
      <returns> The loaded entity, or null. </returns>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.LoadFromDatasource(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType)">
      <summary> 
            Performs the process of loading an entity from the configured underlying datasource. 
            </summary>
      <param name="event">The load event </param>
      <param name="persister">The persister for the entity being requested for load </param>
      <param name="keyToLoad">The EntityKey representing the entity to be loaded. </param>
      <param name="options">The load options. </param>
      <returns> The object loaded from the datasource, or null if not found. </returns>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.LoadFromSessionCache(NHibernate.Event.LoadEvent,NHibernate.Engine.EntityKey,NHibernate.Event.LoadType)">
      <summary> 
            Attempts to locate the entity in the session-level cache. 
            </summary>
      <param name="event">The load event </param>
      <param name="keyToLoad">The EntityKey representing the entity to be loaded. </param>
      <param name="options">The load options. </param>
      <returns> The entity from the session-level cache, or null. </returns>
      <remarks>
            If allowed to return nulls, then if the entity happens to be found in
            the session cache, we check the entity type for proper handling
            of entity hierarchies.
            If checkDeleted was set to true, then if the entity is found in the
            session-level cache, it's current status within the session cache
            is checked to see if it has previously been scheduled for deletion.
            </remarks>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultLoadEventListener.LoadFromSecondLevelCache(NHibernate.Event.LoadEvent,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Event.LoadType)">
      <summary> Attempts to load the entity from the second-level cache. </summary>
      <param name="event">The load event </param>
      <param name="persister">The persister for the entity being requested for load </param>
      <param name="options">The load options. </param>
      <returns> The entity from the second-level cache, or null. </returns>
    </member>
    <member name="T:NHibernate.Event.ILockEventListener">
      <summary>
            Defines the contract for handling of lock events generated from a session.
            </summary>
    </member>
    <member name="M:NHibernate.Event.ILockEventListener.OnLock(NHibernate.Event.LockEvent)">
      <summary>Handle the given lock event. </summary>
      <param name="event">The lock event to be handled. </param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultLockEventListener">
      <summary> 
            Defines the default lock event listeners used by hibernate to lock entities
            in response to generated lock events. 
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultLockEventListener.OnLock(NHibernate.Event.LockEvent)">
      <summary>Handle the given lock event. </summary>
      <param name="event">The lock event to be handled.</param>
    </member>
    <member name="T:NHibernate.Event.IMergeEventListener">
      <summary>
            Defines the contract for handling of merge events generated from a session.
            </summary>
    </member>
    <member name="M:NHibernate.Event.IMergeEventListener.OnMerge(NHibernate.Event.MergeEvent)">
      <summary> Handle the given merge event. </summary>
      <param name="event">The merge event to be handled. </param>
    </member>
    <member name="M:NHibernate.Event.IMergeEventListener.OnMerge(NHibernate.Event.MergeEvent,System.Collections.IDictionary)">
      <summary> Handle the given merge event. </summary>
      <param name="event">The merge event to be handled. </param>
      <param name="copiedAlready">
      </param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultMergeEventListener">
      <summary> 
            Defines the default copy event listener used by hibernate for copying entities
            in response to generated copy events. 
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultMergeEventListener.CascadeOnMerge(NHibernate.Event.IEventSource,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Collections.IDictionary)">
      <summary> 
            Perform any cascades needed as part of this copy event.
            </summary>
      <param name="source">The merge event being processed. </param>
      <param name="persister">The persister of the entity being copied. </param>
      <param name="entity">The entity being copied. </param>
      <param name="copyCache">A cache of already copied instance. </param>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultMergeEventListener.CascadeAfterSave(NHibernate.Event.IEventSource,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object)">
      <summary> Cascade behavior is redefined by this subclass, disable superclass behavior</summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultMergeEventListener.CascadeBeforeSave(NHibernate.Event.IEventSource,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object)">
      <summary> Cascade behavior is redefined by this subclass, disable superclass behavior</summary>
    </member>
    <member name="T:NHibernate.Event.IPersistEventListener">
      <summary>
            Defines the contract for handling of create events generated from a session.
            </summary>
    </member>
    <member name="M:NHibernate.Event.IPersistEventListener.OnPersist(NHibernate.Event.PersistEvent)">
      <summary> Handle the given create event.</summary>
      <param name="event">The create event to be handled.</param>
    </member>
    <member name="M:NHibernate.Event.IPersistEventListener.OnPersist(NHibernate.Event.PersistEvent,System.Collections.IDictionary)">
      <summary> Handle the given create event. </summary>
      <param name="event">The create event to be handled.</param>
      <param name="createdAlready">
      </param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultPersistEventListener">
      <summary> 
            Defines the default create event listener used by hibernate for creating
            transient entities in response to generated create events. 
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultPersistEventListener.EntityIsTransient(NHibernate.Event.PersistEvent,System.Collections.IDictionary)">
      <summary> Handle the given create event. </summary>
      <param name="event">The save event to be handled. </param>
      <param name="createCache">
      </param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultPersistOnFlushEventListener">
      <summary>  When persist is used as the cascade action, persistOnFlush should be used</summary>
    </member>
    <member name="T:NHibernate.Event.IPostLoadEventListener">
      <summary>
            Occurs after an an entity instance is fully loaded.
            </summary>
    </member>
    <member name="M:NHibernate.Event.IPostLoadEventListener.OnPostLoad(NHibernate.Event.PostLoadEvent)">
      <summary>
      </summary>
      <param name="event">
      </param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultPostLoadEventListener">
      <summary> Call <see cref="T:NHibernate.Classic.ILifecycle" /> interface if necessary </summary>
    </member>
    <member name="T:NHibernate.Event.IPreLoadEventListener">
      <summary> 
            Called before injecting property values into a newly loaded entity instance.
            </summary>
    </member>
    <member name="M:NHibernate.Event.IPreLoadEventListener.OnPreLoad(NHibernate.Event.PreLoadEvent)">
      <summary>
      </summary>
      <param name="event">
      </param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultPreLoadEventListener">
      <summary> 
            Called before injecting property values into a newly 
            loaded entity instance. 
            </summary>
    </member>
    <member name="T:NHibernate.Event.IRefreshEventListener">
      <summary>
            Defines the contract for handling of refresh events generated from a session.
            </summary>
    </member>
    <member name="M:NHibernate.Event.IRefreshEventListener.OnRefresh(NHibernate.Event.RefreshEvent)">
      <summary> Handle the given refresh event. </summary>
      <param name="event">The refresh event to be handled.</param>
    </member>
    <member name="M:NHibernate.Event.IRefreshEventListener.OnRefresh(NHibernate.Event.RefreshEvent,System.Collections.IDictionary)">
      <summary>
      </summary>
      <param name="event">
      </param>
      <param name="refreshedAlready">
      </param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultRefreshEventListener">
      <summary> 
            Defines the default refresh event listener used by hibernate for refreshing entities
            in response to generated refresh events. 
            </summary>
    </member>
    <member name="T:NHibernate.Event.IReplicateEventListener">
      <summary>
            Defines the contract for handling of replicate events generated from a session.
            </summary>
    </member>
    <member name="M:NHibernate.Event.IReplicateEventListener.OnReplicate(NHibernate.Event.ReplicateEvent)">
      <summary>Handle the given replicate event. </summary>
      <param name="event">The replicate event to be handled.</param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultReplicateEventListener">
      <summary> 
            Defines the default replicate event listener used by Hibernate to replicate
            entities in response to generated replicate events. 
            </summary>
    </member>
    <member name="T:NHibernate.Event.ISaveOrUpdateEventListener">
      <summary>
            Defines the contract for handling of update events generated from a session.
            </summary>
    </member>
    <member name="M:NHibernate.Event.ISaveOrUpdateEventListener.OnSaveOrUpdate(NHibernate.Event.SaveOrUpdateEvent)">
      <summary> Handle the given update event. </summary>
      <param name="event">The update event to be handled.</param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultSaveOrUpdateEventListener">
      <summary> 
            Defines the default listener used by Hibernate for handling save-update events. 
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultSaveOrUpdateEventListener.EntityIsTransient(NHibernate.Event.SaveOrUpdateEvent)">
      <summary> 
            The given save-update event named a transient entity.
            Here, we will perform the save processing. 
            </summary>
      <param name="event">The save event to be handled. </param>
      <returns> The entity's identifier after saving. </returns>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultSaveOrUpdateEventListener.SaveWithGeneratedOrRequestedId(NHibernate.Event.SaveOrUpdateEvent)">
      <summary> 
            Save the transient instance, assigning the right identifier 
            </summary>
      <param name="event">The initiating event. </param>
      <returns> The entity's identifier value after saving.</returns>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultSaveOrUpdateEventListener.EntityIsDetached(NHibernate.Event.SaveOrUpdateEvent)">
      <summary> 
            The given save-update event named a detached entity.
            Here, we will perform the update processing. 
            </summary>
      <param name="event">The update event to be handled. </param>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultSaveOrUpdateEventListener.GetUpdateId(System.Object,NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.EntityMode)">
      <summary> Determine the id to use for updating. </summary>
      <param name="entity">The entity. </param>
      <param name="persister">The entity persister </param>
      <param name="requestedId">The requested identifier </param>
      <param name="entityMode">The entity mode. </param>
      <returns> The id. </returns>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultSaveOrUpdateEventListener.CascadeOnUpdate(NHibernate.Event.SaveOrUpdateEvent,NHibernate.Persister.Entity.IEntityPersister,System.Object)">
      <summary> 
            Handles the calls needed to perform cascades as part of an update request
            for the given entity. 
            </summary>
      <param name="event">The event currently being processed. </param>
      <param name="persister">The defined persister for the entity being updated. </param>
      <param name="entity">The entity being updated. </param>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultSaveEventListener">
      <summary> An event handler for save() events</summary>
    </member>
    <member name="T:NHibernate.Event.Default.DefaultUpdateEventListener">
      <summary> An event handler for update() events</summary>
    </member>
    <member name="M:NHibernate.Event.Default.DefaultUpdateEventListener.GetUpdateId(System.Object,NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.EntityMode)">
      <summary> 
            If the user specified an id, assign it to the instance and use that, 
            otherwise use the id already assigned to the instance
            </summary>
    </member>
    <member name="T:NHibernate.Event.Default.DirtyCollectionSearchVisitor">
      <summary>
            A Visitor that determines if a dirty collection was found.
            </summary>
      <remarks>
        <list type="number">
          <listheader>
            <description>Reason for dirty collection</description>
          </listheader>
          <item>
            <description>
            		If it is a new application-instantiated collection, return true (does not occur anymore!)
            		</description>
          </item>
          <item>
            <description>
            		If it is a component, recurse.
            		</description>
          </item>
          <item>
            <description>
            		If it is a wrapped collection, ask the collection entry.
            		</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:NHibernate.Event.Default.DirtyCollectionSearchVisitor.WasDirtyCollectionFound">
      <summary>
            Gets a <see cref="T:System.Boolean" /> indicating if a dirty collection was found.
            </summary>
      <value>
        <see langword="true" /> if a dirty collection was found.</value>
    </member>
    <member name="T:NHibernate.Event.Default.EvictVisitor">
      <summary> 
            Evict any collections referenced by the object from the session cache.
            This will NOT pick up any collections that were dereferenced, so they
            will be deleted (suboptimal but not exactly incorrect). 
            </summary>
    </member>
    <member name="T:NHibernate.Event.Default.FlushVisitor">
      <summary> 
            Process collections reachable from an entity. 
            This visitor assumes that wrap was already performed for the entity.
            </summary>
    </member>
    <member name="T:NHibernate.Event.Default.ProxyVisitor">
      <summary>
            Reassociates uninitialized proxies with the session
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.ProxyVisitor.ProcessEntity(System.Object,NHibernate.Type.EntityType)">
      <summary>
             Visit a many-to-one or one-to-one associated entity. Default superclass implementation is a no-op.
            </summary>
      <param name="value">
      </param>
      <param name="entityType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Event.Default.ProxyVisitor.IsOwnerUnchanged(NHibernate.Collection.IPersistentCollection,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary> 
            Has the owner of the collection changed since the collection was snapshotted and detached?
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.ProxyVisitor.ReattachCollection(NHibernate.Collection.IPersistentCollection,NHibernate.Type.CollectionType)">
      <summary> 
            Reattach a detached (disassociated) initialized or uninitialized
            collection wrapper, using a snapshot carried with the collection wrapper
            </summary>
    </member>
    <member name="T:NHibernate.Event.Default.ReattachVisitor">
      <summary>
            Abstract superclass of visitors that reattach collections
            </summary>
    </member>
    <member name="M:NHibernate.Event.Default.ReattachVisitor.RemoveCollection(NHibernate.Persister.Collection.ICollectionPersister,System.Object,NHibernate.Event.IEventSource)">
      <summary> 
            Schedules a collection for deletion. 
            </summary>
      <param name="role">The persister representing the collection to be removed. </param>
      <param name="collectionKey">The collection key (differs from owner-id in the case of property-refs). </param>
      <param name="source">The session from which the request originated. </param>
    </member>
    <member name="M:NHibernate.Event.Default.ReattachVisitor.ExtractCollectionKeyFromOwner(NHibernate.Persister.Collection.ICollectionPersister)">
      <summary> 
            This version is slightly different in that here we need to assume that
            the owner is not yet associated with the session, and thus we cannot
            rely on the owner's EntityEntry snapshot... 
            </summary>
      <param name="role">The persister for the collection role being processed. </param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Event.Default.OnLockVisitor">
      <summary> 
            When a transient entity is passed to lock(), we must inspect all its collections and
            1. associate any uninitialized PersistentCollections with this session
            2. associate any initialized PersistentCollections with this session, using the existing snapshot
            3. throw an exception for each "new" collection 
            </summary>
    </member>
    <member name="T:NHibernate.Event.Default.OnReplicateVisitor">
      <summary> 
            When an entity is passed to replicate(), and there is an existing row, we must
            inspect all its collections and
            1. associate any uninitialized PersistentCollections with this session
            2. associate any initialized PersistentCollections with this session, using the existing snapshot
            3. execute a collection removal (SQL DELETE) for each null collection property or "new" collection 
            </summary>
    </member>
    <member name="T:NHibernate.Event.Default.OnUpdateVisitor">
      <summary> 
            When an entity is passed to update(), we must inspect all its collections and
            1. associate any uninitialized PersistentCollections with this session
            2. associate any initialized PersistentCollections with this session, using the existing snapshot
            3. execute a collection removal (SQL DELETE) for each null collection property or "new" collection 
            </summary>
    </member>
    <member name="T:NHibernate.Event.Default.WrapVisitor">
      <summary> 
            Wrap collections in a Hibernate collection wrapper.
            </summary>
    </member>
    <member name="T:NHibernate.Event.AbstractEvent">
      <summary> 
            Defines a base class for Session generated events.
            </summary>
    </member>
    <member name="M:NHibernate.Event.AbstractEvent.#ctor(NHibernate.Event.IEventSource)">
      <summary> 
            Constructs an event from the given event session.
            </summary>
      <param name="source">The session event source. </param>
    </member>
    <member name="P:NHibernate.Event.AbstractEvent.Session">
      <summary> 
            Returns the session event source for this event.  
            This is the underlying session from which this event was generated.
            </summary>
    </member>
    <member name="T:NHibernate.Event.AbstractCollectionEvent">
      <summary> Defines a base class for events involving collections. </summary>
    </member>
    <member name="M:NHibernate.Event.AbstractCollectionEvent.#ctor(NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Collection.IPersistentCollection,NHibernate.Event.IEventSource,System.Object,System.Object)">
      <summary> Constructs an AbstractCollectionEvent object. </summary>
      <param name="collectionPersister">The collection persister.</param>
      <param name="collection">The collection </param>
      <param name="source">The Session source </param>
      <param name="affectedOwner">The owner that is affected by this event; can be null if unavailable </param>
      <param name="affectedOwnerId">
            The ID for the owner that is affected by this event; can be null if unavailable
            that is affected by this event; can be null if unavailable
            </param>
    </member>
    <member name="M:NHibernate.Event.AbstractCollectionEvent.GetAffectedOwnerEntityName">
      <summary> Get the entity name for the collection owner entity that is affected by this event. </summary>
      <returns> 
            The entity name; if the owner is not in the PersistenceContext, the
            returned value may be a superclass name, instead of the actual class name
            </returns>
    </member>
    <member name="P:NHibernate.Event.AbstractCollectionEvent.AffectedOwnerOrNull">
      <summary> The collection owner entity that is affected by this event. </summary>
      <value> 
            Returns null if the entity is not in the persistence context
            (e.g., because the collection from a detached entity was moved to a new owner)
            </value>
    </member>
    <member name="P:NHibernate.Event.AbstractCollectionEvent.AffectedOwnerIdOrNull">
      <summary> Get the ID for the collection owner entity that is affected by this event. </summary>
      <value>
            Returns null if the ID cannot be obtained
            from the collection's loaded key (e.g., a property-ref is used for the
            collection and does not include the entity's ID)
            </value>
    </member>
    <member name="T:NHibernate.Event.AbstractPreDatabaseOperationEvent">
      <summary> 
            Represents an operation we are about to perform against the database. 
            </summary>
    </member>
    <member name="M:NHibernate.Event.AbstractPreDatabaseOperationEvent.#ctor(NHibernate.Event.IEventSource,System.Object,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
      <summary> Constructs an event containing the pertinent information. </summary>
      <param name="source">The session from which the event originated. </param>
      <param name="entity">The entity to be invloved in the database operation. </param>
      <param name="id">The entity id to be invloved in the database operation. </param>
      <param name="persister">The entity's persister. </param>
    </member>
    <member name="P:NHibernate.Event.AbstractPreDatabaseOperationEvent.Entity">
      <summary> The entity involved in the database operation. </summary>
    </member>
    <member name="P:NHibernate.Event.AbstractPreDatabaseOperationEvent.Id">
      <summary> The id to be used in the database operation. </summary>
    </member>
    <member name="P:NHibernate.Event.AbstractPreDatabaseOperationEvent.Persister">
      <summary> 
            The persister for the <see cref="P:NHibernate.Event.AbstractPreDatabaseOperationEvent.Entity" />. 
            </summary>
    </member>
    <member name="T:NHibernate.Event.FlushEvent">
      <summary> Defines an event class for the flushing of a session. </summary>
    </member>
    <member name="T:NHibernate.Event.AutoFlushEvent">
      <summary>Defines an event class for the auto-flushing of a session. </summary>
    </member>
    <member name="T:NHibernate.Event.DeleteEvent">
      <summary>Defines an event class for the deletion of an entity. </summary>
    </member>
    <member name="M:NHibernate.Event.DeleteEvent.#ctor(System.Object,NHibernate.Event.IEventSource)">
      <summary> Constructs a new DeleteEvent instance. </summary>
      <param name="entity">The entity to be deleted.</param>
      <param name="source">The session from which the delete event was generated.
            </param>
    </member>
    <member name="P:NHibernate.Event.DeleteEvent.Entity">
      <summary>
            Returns the encapsulated entity to be deleed.
            </summary>
    </member>
    <member name="T:NHibernate.Event.DirtyCheckEvent">
      <summary>Defines an event class for the dirty-checking of a session. </summary>
    </member>
    <member name="T:NHibernate.Event.EventListeners">
      <summary> 
            A convience holder for all defined session event listeners.
            </summary>
    </member>
    <member name="M:NHibernate.Event.EventListeners.InitializeListeners(NHibernate.Cfg.Configuration)">
      <summary> 
            Call <see cref="M:NHibernate.Event.IInitializable.Initialize(NHibernate.Cfg.Configuration)" /> on any listeners that implement 
            <see cref="T:NHibernate.Event.IInitializable" />.
            </summary>
      <seealso cref="T:NHibernate.Event.IInitializable" />
    </member>
    <member name="T:NHibernate.Event.EvictEvent">
      <summary>  Defines an event class for the evicting of an entity. </summary>
    </member>
    <member name="T:NHibernate.Event.IDestructible">
      <summary> 
            Contract for listeners which require notification of SessionFactory closing,
            presumably to destroy internal state.
            </summary>
    </member>
    <member name="M:NHibernate.Event.IDestructible.Cleanup">
      <summary>
            Notification of <see cref="T:NHibernate.ISessionFactory" /> shutdown.
            </summary>
    </member>
    <member name="T:NHibernate.ISession">
      <summary>
            The main runtime interface between a .NET application and NHibernate. This is the central
            API class abstracting the notion of a persistence service.
            </summary>
      <remarks>
        <para>
            The lifecycle of a <c>ISession</c> is bounded by the beginning and end of a logical
            transaction. (Long transactions might span several database transactions.)
            </para>
        <para>
            The main function of the <c>ISession</c> is to offer create, find and delete operations
            for instances of mapped entity classes. Instances may exist in one of two states:
            <list><item>transient: not associated with any <c>ISession</c></item><item>persistent: associated with a <c>ISession</c></item></list></para>
        <para>
            Transient instances may be made persistent by calling <c>Save()</c>, <c>Insert()</c>,
            or <c>Update()</c>. Persistent instances may be made transient by calling <c>Delete()</c>.
            Any instance returned by a <c>List()</c>, <c>Iterate()</c>, <c>Load()</c>, or <c>Create</c>
            method is persistent.
            </para>
        <para>
          <c>Save()</c> results in an SQL <c>INSERT</c>, <c>Delete()</c>
            in an SQL <c>DELETE</c> and <c>Update()</c> in an SQL <c>UPDATE</c>. Changes to
            <em>persistent</em> instances are detected at flush time and also result in an SQL
            <c>UPDATE</c>.
            </para>
        <para>
            It is not intended that implementors be threadsafe. Instead each thread/transaction should obtain
            its own instance from an <c>ISessionFactory</c>.
            </para>
        <para>
            A <c>ISession</c> instance is serializable if its persistent classes are serializable
            </para>
        <para>
            A typical transaction should use the following idiom:
            	<code>
            		ISession sess = factory.OpenSession();
            		ITransaction tx;
            		try {
            			tx = sess.BeginTransaction();
            			//do some work
            			...
            			tx.Commit();
            		} catch (Exception e) {
            			if (tx != null) tx.Rollback();
            			throw;
            		} finally {
            			sess.Close();
            		}
            	</code></para>
        <para>
            If the <c>ISession</c> throws an exception, the transaction must be rolled back and the session
            discarded. The internal state of the <c>ISession</c> might not be consistent with the database
            after the exception occurs.
            </para>
        <seealso cref="T:NHibernate.ISessionFactory" />
      </remarks>
    </member>
    <member name="M:NHibernate.ISession.Flush">
      <summary>
            Force the <c>ISession</c> to flush.
            </summary>
      <remarks>
            Must be called at the end of a unit of work, before commiting the transaction and closing
            the session (<c>Transaction.Commit()</c> calls this method). <i>Flushing</i> if the process
            of synchronising the underlying persistent store with persistable state held in memory.
            </remarks>
    </member>
    <member name="M:NHibernate.ISession.Disconnect">
      <summary>
            Disconnect the <c>ISession</c> from the current ADO.NET connection.
            </summary>
      <remarks>
            If the connection was obtained by Hibernate, close it or return it to the connection
            pool. Otherwise return it to the application. This is used by applications which require
            long transactions.
            </remarks>
      <returns>The connection provided by the application or <see langword="null" /></returns>
    </member>
    <member name="M:NHibernate.ISession.Reconnect">
      <summary>
            Obtain a new ADO.NET connection.
            </summary>
      <remarks>
            This is used by applications which require long transactions
            </remarks>
    </member>
    <member name="M:NHibernate.ISession.Reconnect(System.Data.IDbConnection)">
      <summary>
            Reconnect to the given ADO.NET connection.
            </summary>
      <remarks>This is used by applications which require long transactions</remarks>
      <param name="connection">An ADO.NET connection</param>
    </member>
    <member name="M:NHibernate.ISession.Close">
      <summary>
            End the <c>ISession</c> by disconnecting from the ADO.NET connection and cleaning up.
            </summary>
      <remarks>
            It is not strictly necessary to <c>Close()</c> the <c>ISession</c> but you must
            at least <c>Disconnect()</c> it.
            </remarks>
      <returns>The connection provided by the application or <see langword="null" /></returns>
    </member>
    <member name="M:NHibernate.ISession.CancelQuery">
      <summary>
            Cancel execution of the current query.
            </summary>
      <remarks>
            May be called from one thread to stop execution of a query in another thread.
            Use with care!
            </remarks>
    </member>
    <member name="M:NHibernate.ISession.IsDirty">
      <summary>
            Does this <c>ISession</c> contain any changes which must be
            synchronized with the database? Would any SQL be executed if
            we flushed this session?
            </summary>
    </member>
    <member name="M:NHibernate.ISession.GetIdentifier(System.Object)">
      <summary>
            Return the identifier of an entity instance cached by the <c>ISession</c></summary>
      <remarks>
            Throws an exception if the instance is transient or associated with a different
            <c>ISession</c></remarks>
      <param name="obj">a persistent instance</param>
      <returns>the identifier</returns>
    </member>
    <member name="M:NHibernate.ISession.Contains(System.Object)">
      <summary>
            Is this instance associated with this Session?
            </summary>
      <param name="obj">an instance of a persistent class</param>
      <returns>true if the given instance is associated with this Session</returns>
    </member>
    <member name="M:NHibernate.ISession.Evict(System.Object)">
      <summary>
            Remove this instance from the session cache.
            </summary>
      <remarks>
            Changes to the instance will not be synchronized with the database.
            This operation cascades to associated instances if the association is mapped
            with <c>cascade="all"</c> or <c>cascade="all-delete-orphan"</c>.
            </remarks>
      <param name="obj">a persistent instance</param>
    </member>
    <member name="M:NHibernate.ISession.Load(System.Type,System.Object,NHibernate.LockMode)">
      <summary>
            Return the persistent instance of the given entity class with the given identifier,
            obtaining the specified lock mode.
            </summary>
      <param name="theType">A persistent class</param>
      <param name="id">A valid identifier of an existing persistent instance of the class</param>
      <param name="lockMode">The lock level</param>
      <returns>the persistent instance</returns>
    </member>
    <member name="M:NHibernate.ISession.Load(System.String,System.Object,NHibernate.LockMode)">
      <summary> 
            Return the persistent instance of the given entity class with the given identifier,
            obtaining the specified lock mode, assuming the instance exists. 
            </summary>
      <param name="entityName">The entity-name of a persistent class</param>
      <param name="id">a valid identifier of an existing persistent instance of the class </param>
      <param name="lockMode">the lock level </param>
      <returns> the persistent instance or proxy </returns>
    </member>
    <member name="M:NHibernate.ISession.Load(System.Type,System.Object)">
      <summary>
            Return the persistent instance of the given entity class with the given identifier,
            assuming that the instance exists.
            </summary>
      <remarks>
            You should not use this method to determine if an instance exists (use a query or
            <see cref="M:NHibernate.ISession.Get(System.Type,System.Object)" /> instead). Use this only to retrieve an instance
            that you assume exists, where non-existence would be an actual error.
            </remarks>
      <param name="theType">A persistent class</param>
      <param name="id">A valid identifier of an existing persistent instance of the class</param>
      <returns>The persistent instance or proxy</returns>
    </member>
    <member name="M:NHibernate.ISession.Load``1(System.Object,NHibernate.LockMode)">
      <summary>
            Return the persistent instance of the given entity class with the given identifier,
            obtaining the specified lock mode.
            </summary>
      <typeparam name="T">A persistent class</typeparam>
      <param name="id">A valid identifier of an existing persistent instance of the class</param>
      <param name="lockMode">The lock level</param>
      <returns>the persistent instance</returns>
    </member>
    <member name="M:NHibernate.ISession.Load``1(System.Object)">
      <summary>
            Return the persistent instance of the given entity class with the given identifier,
            assuming that the instance exists.
            </summary>
      <remarks>
            You should not use this method to determine if an instance exists (use a query or
            <see cref="M:NHibernate.ISession.Get``1(System.Object)" /> instead). Use this only to retrieve an instance that you
            assume exists, where non-existence would be an actual error.
            </remarks>
      <typeparam name="T">A persistent class</typeparam>
      <param name="id">A valid identifier of an existing persistent instance of the class</param>
      <returns>The persistent instance or proxy</returns>
    </member>
    <member name="M:NHibernate.ISession.Load(System.String,System.Object)">
      <summary> 
            Return the persistent instance of the given <paramref name="entityName" /> with the given identifier,
            assuming that the instance exists.
            </summary>
      <param name="entityName">The entity-name of a persistent class</param>
      <param name="id">a valid identifier of an existing persistent instance of the class </param>
      <returns> The persistent instance or proxy </returns>
      <remarks>
            You should not use this method to determine if an instance exists (use <see cref="M:NHibernate.ISession.Get(System.String,System.Object)" />
            instead). Use this only to retrieve an instance that you assume exists, where non-existence
            would be an actual error.
            </remarks>
    </member>
    <member name="M:NHibernate.ISession.Load(System.Object,System.Object)">
      <summary>
            Read the persistent state associated with the given identifier into the given transient 
            instance.
            </summary>
      <param name="obj">An "empty" instance of the persistent class</param>
      <param name="id">A valid identifier of an existing persistent instance of the class</param>
    </member>
    <member name="M:NHibernate.ISession.Replicate(System.Object,NHibernate.ReplicationMode)">
      <summary>
            Persist all reachable transient objects, reusing the current identifier 
            values. Note that this will not trigger the Interceptor of the Session.
            </summary>
      <param name="obj">a detached instance of a persistent class</param>
      <param name="replicationMode">
      </param>
    </member>
    <member name="M:NHibernate.ISession.Replicate(System.String,System.Object,NHibernate.ReplicationMode)">
      <summary> 
            Persist the state of the given detached instance, reusing the current
            identifier value.  This operation cascades to associated instances if
            the association is mapped with <tt>cascade="replicate"</tt>. 
            </summary>
      <param name="entityName">
      </param>
      <param name="obj">a detached instance of a persistent class </param>
      <param name="replicationMode">
      </param>
    </member>
    <member name="M:NHibernate.ISession.Save(System.Object)">
      <summary>
            Persist the given transient instance, first assigning a generated identifier.
            </summary>
      <remarks>
            Save will use the current value of the identifier property if the <c>Assigned</c>
            generator is used.
            </remarks>
      <param name="obj">A transient instance of a persistent class</param>
      <returns>The generated identifier</returns>
    </member>
    <member name="M:NHibernate.ISession.Save(System.Object,System.Object)">
      <summary>
            Persist the given transient instance, using the given identifier.
            </summary>
      <param name="obj">A transient instance of a persistent class</param>
      <param name="id">An unused valid identifier</param>
    </member>
    <member name="M:NHibernate.ISession.Save(System.String,System.Object)">
      <summary>
            Persist the given transient instance, first assigning a generated identifier. (Or
            using the current value of the identifier property if the <tt>assigned</tt>
            generator is used.)
            </summary>
      <param name="entityName">The Entity name.</param>
      <param name="obj">a transient instance of a persistent class </param>
      <returns> the generated identifier </returns>
      <remarks>
            This operation cascades to associated instances if the
            association is mapped with <tt>cascade="save-update"</tt>. 
            </remarks>
    </member>
    <member name="M:NHibernate.ISession.SaveOrUpdate(System.Object)">
      <summary>
            Either <c>Save()</c> or <c>Update()</c> the given instance, depending upon the value of
            its identifier property.
            </summary>
      <remarks>
            By default the instance is always saved. This behaviour may be adjusted by specifying
            an <c>unsaved-value</c> attribute of the identifier property mapping
            </remarks>
      <param name="obj">A transient instance containing new or updated state</param>
    </member>
    <member name="M:NHibernate.ISession.SaveOrUpdate(System.String,System.Object)">
      <summary> 
            Either <see cref="M:NHibernate.ISession.Save(System.String,System.Object)" /> or <see cref="M:NHibernate.ISession.Update(System.String,System.Object)" />
            the given instance, depending upon resolution of the unsaved-value checks
            (see the manual for discussion of unsaved-value checking).
            </summary>
      <param name="entityName">The name of the entity </param>
      <param name="obj">a transient or detached instance containing new or updated state </param>
      <seealso cref="M:NHibernate.ISession.Save(System.String,System.Object)" />
      <seealso cref="M:NHibernate.ISession.Update(System.String,System.Object)" />
      <remarks>
            This operation cascades to associated instances if the association is mapped
            with <tt>cascade="save-update"</tt>. 
            </remarks>
    </member>
    <member name="M:NHibernate.ISession.Update(System.Object)">
      <summary>
            Update the persistent instance with the identifier of the given transient instance.
            </summary>
      <remarks>
            If there is a persistent instance with the same identifier, an exception is thrown. If
            the given transient instance has a <see langword="null" /> identifier, an exception will be thrown.
            </remarks>
      <param name="obj">A transient instance containing updated state</param>
    </member>
    <member name="M:NHibernate.ISession.Update(System.Object,System.Object)">
      <summary>
            Update the persistent state associated with the given identifier.
            </summary>
      <remarks>
            An exception is thrown if there is a persistent instance with the same identifier
            in the current session.
            </remarks>
      <param name="obj">A transient instance containing updated state</param>
      <param name="id">Identifier of persistent instance</param>
    </member>
    <member name="M:NHibernate.ISession.Update(System.String,System.Object)">
      <summary> 
            Update the persistent instance with the identifier of the given detached
            instance. 
            </summary>
      <param name="entityName">The Entity name.</param>
      <param name="obj">a detached instance containing updated state </param>
      <remarks>
            If there is a persistent instance with the same identifier,
            an exception is thrown. This operation cascades to associated instances
            if the association is mapped with <tt>cascade="save-update"</tt>. 
            </remarks>
    </member>
    <member name="M:NHibernate.ISession.Merge(System.Object)">
      <summary> 
            Copy the state of the given object onto the persistent object with the same
            identifier. If there is no persistent instance currently associated with
            the session, it will be loaded. Return the persistent instance. If the
            given instance is unsaved, save a copy of and return it as a newly persistent
            instance. The given instance does not become associated with the session.
            This operation cascades to associated instances if the association is mapped
            with <tt>cascade="merge"</tt>.<br />
            The semantics of this method are defined by JSR-220. 
            </summary>
      <param name="obj">a detached instance with state to be copied </param>
      <returns> an updated persistent instance </returns>
    </member>
    <member name="M:NHibernate.ISession.Merge(System.String,System.Object)">
      <summary>
            Copy the state of the given object onto the persistent object with the same
            identifier. If there is no persistent instance currently associated with
            the session, it will be loaded. Return the persistent instance. If the
            given instance is unsaved, save a copy of and return it as a newly persistent
            instance. The given instance does not become associated with the session.
            This operation cascades to associated instances if the association is mapped
            with <tt>cascade="merge"</tt>.<br />
            The semantics of this method are defined by JSR-220.
            <param name="entityName">Name of the entity.</param><param name="obj">a detached instance with state to be copied </param><returns> an updated persistent instance </returns></summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ISession.Persist(System.Object)">
      <summary> 
            Make a transient instance persistent. This operation cascades to associated
            instances if the association is mapped with <tt>cascade="persist"</tt>.<br />
            The semantics of this method are defined by JSR-220. 
            </summary>
      <param name="obj">a transient instance to be made persistent </param>
    </member>
    <member name="M:NHibernate.ISession.Persist(System.String,System.Object)">
      <summary>
            Make a transient instance persistent. This operation cascades to associated
            instances if the association is mapped with <tt>cascade="persist"</tt>.<br />
            The semantics of this method are defined by JSR-220.
            </summary>
      <param name="entityName">Name of the entity.</param>
      <param name="obj">a transient instance to be made persistent</param>
    </member>
    <member name="M:NHibernate.ISession.SaveOrUpdateCopy(System.Object)">
      <summary>
            Copy the state of the given object onto the persistent object with the same
            identifier. If there is no persistent instance currently associated with 
            the session, it will be loaded. Return the persistent instance. If the 
            given instance is unsaved or does not exist in the database, save it and 
            return it as a newly persistent instance. Otherwise, the given instance
            does not become associated with the session.
            </summary>
      <param name="obj">a transient instance with state to be copied</param>
      <returns>an updated persistent instance</returns>
    </member>
    <member name="M:NHibernate.ISession.SaveOrUpdateCopy(System.Object,System.Object)">
      <summary>
            Copy the state of the given object onto the persistent object with the 
            given identifier. If there is no persistent instance currently associated 
            with the session, it will be loaded. Return the persistent instance. If
            there is no database row with the given identifier, save the given instance
            and return it as a newly persistent instance. Otherwise, the given instance
            does not become associated with the session.
            </summary>
      <param name="obj">a persistent or transient instance with state to be copied</param>
      <param name="id">the identifier of the instance to copy to</param>
      <returns>an updated persistent instance</returns>
    </member>
    <member name="M:NHibernate.ISession.Delete(System.Object)">
      <summary>
            Remove a persistent instance from the datastore.
            </summary>
      <remarks>
            The argument may be an instance associated with the receiving <c>ISession</c> or a
            transient instance with an identifier associated with existing persistent state.
            </remarks>
      <param name="obj">The instance to be removed</param>
    </member>
    <member name="M:NHibernate.ISession.Delete(System.String,System.Object)">
      <summary>
            Remove a persistent instance from the datastore. The <b>object</b> argument may be
            an instance associated with the receiving <see cref="T:NHibernate.ISession" /> or a transient
            instance with an identifier associated with existing persistent state.
            This operation cascades to associated instances if the association is mapped
            with <tt>cascade="delete"</tt>. 
            </summary>
      <param name="entityName">The entity name for the instance to be removed. </param>
      <param name="obj">the instance to be removed </param>
    </member>
    <member name="M:NHibernate.ISession.Find(System.String)">
      <summary>
            Execute a query
            </summary>
      <param name="query">A query expressed in Hibernate's query language</param>
      <returns>A distinct list of instances</returns>
      <remarks>See <see cref="M:NHibernate.IQuery.List" /> for implications of <c>cache</c> usage.</remarks>
    </member>
    <member name="M:NHibernate.ISession.Find(System.String,System.Object,NHibernate.Type.IType)">
      <summary>
            Execute a query, binding a value to a "?" parameter in the query string.
            </summary>
      <param name="query">The query string</param>
      <param name="value">A value to be bound to a "?" placeholder</param>
      <param name="type">The Hibernate type of the value</param>
      <returns>A distinct list of instances</returns>
      <remarks>See <see cref="M:NHibernate.IQuery.List" /> for implications of <c>cache</c> usage.</remarks>
    </member>
    <member name="M:NHibernate.ISession.Find(System.String,System.Object[],NHibernate.Type.IType[])">
      <summary>
            Execute a query, binding an array of values to a "?" parameters in the query string.
            </summary>
      <param name="query">The query string</param>
      <param name="values">An array of values to be bound to the "?" placeholders</param>
      <param name="types">An array of Hibernate types of the values</param>
      <returns>A distinct list of instances</returns>
      <remarks>See <see cref="M:NHibernate.IQuery.List" /> for implications of <c>cache</c> usage.</remarks>
    </member>
    <member name="M:NHibernate.ISession.Enumerable(System.String)">
      <summary>
            Execute a query and return the results in an interator.
            </summary>
      <remarks>
        <para>
            If the query has multiple return values, values will be returned in an array of 
            type <c>object[]</c>.
            </para>
        <para>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only. So <c>Enumerator()</c> is usually a less efficient way to retrieve
            object than <c>List()</c>.
            </para>
      </remarks>
      <param name="query">The query string</param>
      <returns>An enumerator</returns>
    </member>
    <member name="M:NHibernate.ISession.Enumerable(System.String,System.Object,NHibernate.Type.IType)">
      <summary>
            Execute a query and return the results in an interator, 
            binding a value to a "?" parameter in the query string.
            </summary>
      <remarks>
        <para>
            If the query has multiple return values, values will be returned in an array of 
            type <c>object[]</c>.
            </para>
        <para>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only. So <c>Enumerator()</c> is usually a less efficient way to retrieve
            object than <c>List()</c>.
            </para>
      </remarks>
      <param name="query">The query string</param>
      <param name="value">A value to be written to a "?" placeholder in the query string</param>
      <param name="type">The hibernate type of the value</param>
      <returns>An enumerator</returns>
    </member>
    <member name="M:NHibernate.ISession.Enumerable(System.String,System.Object[],NHibernate.Type.IType[])">
      <summary>
            Execute a query and return the results in an interator, 
            binding the values to "?"s parameters in the query string.
            </summary>
      <remarks>
        <para>
            If the query has multiple return values, values will be returned in an array of 
            type <c>object[]</c>.
            </para>
        <para>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only. So <c>Enumerator()</c> is usually a less efficient way to retrieve
            object than <c>List()</c>.
            </para>
      </remarks>
      <param name="query">The query string</param>
      <param name="values">A list of values to be written to "?" placeholders in the query</param>
      <param name="types">A list of hibernate types of the values</param>
      <returns>An enumerator</returns>
    </member>
    <member name="M:NHibernate.ISession.Filter(System.Object,System.String)">
      <summary>
            Apply a filter to a persistent collection.
            </summary>
      <remarks>
            A filter is a Hibernate query that may refer to <c>this</c>, the collection element.
            Filters allow efficient access to very large lazy collections. (Executing the filter
            does not initialize the collection.)
            </remarks>
      <param name="collection">A persistent collection to filter</param>
      <param name="filter">A filter query string</param>
      <returns>The resulting collection</returns>
    </member>
    <member name="M:NHibernate.ISession.Filter(System.Object,System.String,System.Object,NHibernate.Type.IType)">
      <summary>
            Apply a filter to a persistent collection, binding the given parameter to a "?" placeholder
            </summary>
      <remarks>
            A filter is a Hibernate query that may refer to <c>this</c>, the collection element.
            Filters allow efficient access to very large lazy collections. (Executing the filter
            does not initialize the collection.)
            </remarks>
      <param name="collection">A persistent collection to filter</param>
      <param name="filter">A filter query string</param>
      <param name="value">A value to be written to a "?" placeholder in the query</param>
      <param name="type">The hibernate type of value</param>
      <returns>A collection</returns>
    </member>
    <member name="M:NHibernate.ISession.Filter(System.Object,System.String,System.Object[],NHibernate.Type.IType[])">
      <summary>
            Apply a filter to a persistent collection, binding the given parameters to "?" placeholders.
            </summary>
      <remarks>
            A filter is a Hibernate query that may refer to <c>this</c>, the collection element.
            Filters allow efficient access to very large lazy collections. (Executing the filter
            does not initialize the collection.)
            </remarks>
      <param name="collection">A persistent collection to filter</param>
      <param name="filter">A filter query string</param>
      <param name="values">The values to be written to "?" placeholders in the query</param>
      <param name="types">The hibernate types of the values</param>
      <returns>A collection</returns>
    </member>
    <member name="M:NHibernate.ISession.Delete(System.String)">
      <summary>
            Delete all objects returned by the query.
            </summary>
      <param name="query">The query string</param>
      <returns>Returns the number of objects deleted.</returns>
    </member>
    <member name="M:NHibernate.ISession.Delete(System.String,System.Object,NHibernate.Type.IType)">
      <summary>
            Delete all objects returned by the query.
            </summary>
      <param name="query">The query string</param>
      <param name="value">A value to be written to a "?" placeholer in the query</param>
      <param name="type">The hibernate type of value.</param>
      <returns>The number of instances deleted</returns>
    </member>
    <member name="M:NHibernate.ISession.Delete(System.String,System.Object[],NHibernate.Type.IType[])">
      <summary>
            Delete all objects returned by the query.
            </summary>
      <param name="query">The query string</param>
      <param name="values">A list of values to be written to "?" placeholders in the query</param>
      <param name="types">A list of Hibernate types of the values</param>
      <returns>The number of instances deleted</returns>
    </member>
    <member name="M:NHibernate.ISession.Lock(System.Object,NHibernate.LockMode)">
      <summary>
            Obtain the specified lock level upon the given object.
            </summary>
      <param name="obj">A persistent instance</param>
      <param name="lockMode">The lock level</param>
    </member>
    <member name="M:NHibernate.ISession.Lock(System.String,System.Object,NHibernate.LockMode)">
      <summary> 
            Obtain the specified lock level upon the given object. 
            </summary>
      <param name="entityName">The Entity name.</param>
      <param name="obj">a persistent or transient instance </param>
      <param name="lockMode">the lock level </param>
      <remarks>
            This may be used to perform a version check (<see cref="F:NHibernate.LockMode.Read" />), to upgrade to a pessimistic
            lock (<see cref="F:NHibernate.LockMode.Upgrade" />), or to simply reassociate a transient instance
            with a session (<see cref="F:NHibernate.LockMode.None" />). This operation cascades to associated
            instances if the association is mapped with <tt>cascade="lock"</tt>.
            </remarks>
    </member>
    <member name="M:NHibernate.ISession.Refresh(System.Object)">
      <summary>
            Re-read the state of the given instance from the underlying database.
            </summary>
      <remarks>
        <para>
            It is inadvisable to use this to implement long-running sessions that span many
            business tasks. This method is, however, useful in certain special circumstances.
            </para>
        <para>
            For example,
            <list><item>Where a database trigger alters the object state upon insert or update</item><item>After executing direct SQL (eg. a mass update) in the same session</item><item>After inserting a <c>Blob</c> or <c>Clob</c></item></list></para>
      </remarks>
      <param name="obj">A persistent instance</param>
    </member>
    <member name="M:NHibernate.ISession.Refresh(System.Object,NHibernate.LockMode)">
      <summary>
            Re-read the state of the given instance from the underlying database, with
            the given <c>LockMode</c>.
            </summary>
      <remarks>
            It is inadvisable to use this to implement long-running sessions that span many
            business tasks. This method is, however, useful in certain special circumstances.
            </remarks>
      <param name="obj">a persistent or transient instance</param>
      <param name="lockMode">the lock mode to use</param>
    </member>
    <member name="M:NHibernate.ISession.GetCurrentLockMode(System.Object)">
      <summary>
            Determine the current lock mode of the given object
            </summary>
      <param name="obj">A persistent instance</param>
      <returns>The current lock mode</returns>
    </member>
    <member name="M:NHibernate.ISession.BeginTransaction">
      <summary>
            Begin a unit of work and return the associated <c>ITransaction</c> object.
            </summary>
      <remarks>
            If a new underlying transaction is required, begin the transaction. Otherwise
            continue the new work in the context of the existing underlying transaction.
            The class of the returned <see cref="T:NHibernate.ITransaction" /> object is determined by
            the property <c>transaction_factory</c></remarks>
      <returns>A transaction instance</returns>
    </member>
    <member name="M:NHibernate.ISession.BeginTransaction(System.Data.IsolationLevel)">
      <summary>
            Begin a transaction with the specified <c>isolationLevel</c></summary>
      <param name="isolationLevel">Isolation level for the new transaction</param>
      <returns>A transaction instance having the specified isolation level</returns>
    </member>
    <member name="M:NHibernate.ISession.CreateCriteria``1">
      <summary>
            Creates a new <c>Criteria</c> for the entity class.
            </summary>
      <typeparam name="T">The entity class</typeparam>
      <returns>An ICriteria object</returns>
    </member>
    <member name="M:NHibernate.ISession.CreateCriteria``1(System.String)">
      <summary>
            Creates a new <c>Criteria</c> for the entity class with a specific alias
            </summary>
      <typeparam name="T">The entity class</typeparam>
      <param name="alias">The alias of the entity</param>
      <returns>An ICriteria object</returns>
    </member>
    <member name="M:NHibernate.ISession.CreateCriteria(System.Type)">
      <summary>
            Creates a new <c>Criteria</c> for the entity class.
            </summary>
      <param name="persistentClass">The class to Query</param>
      <returns>An ICriteria object</returns>
    </member>
    <member name="M:NHibernate.ISession.CreateCriteria(System.Type,System.String)">
      <summary>
            Creates a new <c>Criteria</c> for the entity class with a specific alias
            </summary>
      <param name="persistentClass">The class to Query</param>
      <param name="alias">The alias of the entity</param>
      <returns>An ICriteria object</returns>
    </member>
    <member name="M:NHibernate.ISession.CreateCriteria(System.String)">
      <summary> 
            Create a new <c>Criteria</c> instance, for the given entity name. 
            </summary>
      <param name="entityName">The name of the entity to Query</param>
      <returns>An ICriteria object</returns>
    </member>
    <member name="M:NHibernate.ISession.CreateCriteria(System.String,System.String)">
      <summary>
            Create a new <c>Criteria</c> instance, for the given entity name,
            with the given alias. 
            </summary>
      <param name="entityName">The name of the entity to Query</param>
      <param name="alias">The alias of the entity</param>
      <returns>An ICriteria object</returns>
    </member>
    <member name="M:NHibernate.ISession.CreateQuery(System.String)">
      <summary>
            Create a new instance of <c>Query</c> for the given query string
            </summary>
      <param name="queryString">A hibernate query string</param>
      <returns>The query</returns>
    </member>
    <member name="M:NHibernate.ISession.CreateFilter(System.Object,System.String)">
      <summary>
            Create a new instance of <c>Query</c> for the given collection and filter string
            </summary>
      <param name="collection">A persistent collection</param>
      <param name="queryString">A hibernate query</param>
      <returns>A query</returns>
    </member>
    <member name="M:NHibernate.ISession.GetNamedQuery(System.String)">
      <summary>
            Obtain an instance of <see cref="T:NHibernate.IQuery" /> for a named query string defined in the
            mapping file.
            </summary>
      <param name="queryName">The name of a query defined externally.</param>
      <returns>An <see cref="T:NHibernate.IQuery" /> from a named query string.</returns>
      <remarks>
            The query can be either in <c>HQL</c> or <c>SQL</c> format.
            </remarks>
    </member>
    <member name="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String,System.Type)">
      <summary>
            Create a new instance of <c>IQuery</c> for the given SQL string.
            </summary>
      <param name="sql">a query expressed in SQL</param>
      <param name="returnAlias">a table alias that appears inside <c>{}</c> in the SQL string</param>
      <param name="returnClass">the returned persistent class</param>
      <returns>An <see cref="T:NHibernate.IQuery" /> from the SQL string</returns>
    </member>
    <member name="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String[],System.Type[])">
      <summary>
            Create a new instance of <see cref="T:NHibernate.IQuery" /> for the given SQL string.
            </summary>
      <param name="sql">a query expressed in SQL</param>
      <param name="returnAliases">an array of table aliases that appear inside <c>{}</c> in the SQL string</param>
      <param name="returnClasses">the returned persistent classes</param>
      <returns>An <see cref="T:NHibernate.IQuery" /> from the SQL string</returns>
    </member>
    <member name="M:NHibernate.ISession.CreateSQLQuery(System.String)">
      <summary>
            Create a new instance of <see cref="T:NHibernate.ISQLQuery" /> for the given SQL query string.
            </summary>
      <param name="queryString">a query expressed in SQL</param>
      <returns>An <see cref="T:NHibernate.ISQLQuery" /> from the SQL string</returns>
    </member>
    <member name="M:NHibernate.ISession.Clear">
      <summary>
            Completely clear the session. Evict all loaded instances and cancel all pending
            saves, updates and deletions. Do not close open enumerables or instances of
            <c>ScrollableResults</c>.
            </summary>
    </member>
    <member name="M:NHibernate.ISession.Get(System.Type,System.Object)">
      <summary>
            Return the persistent instance of the given entity class with the given identifier, or null
            if there is no such persistent instance. (If the instance, or a proxy for the instance, is
            already associated with the session, return that instance or proxy.)
            </summary>
      <param name="clazz">a persistent class</param>
      <param name="id">an identifier</param>
      <returns>a persistent instance or null</returns>
    </member>
    <member name="M:NHibernate.ISession.Get(System.Type,System.Object,NHibernate.LockMode)">
      <summary>
            Return the persistent instance of the given entity class with the given identifier, or null
            if there is no such persistent instance. Obtain the specified lock mode if the instance
            exists.
            </summary>
      <param name="clazz">a persistent class</param>
      <param name="id">an identifier</param>
      <param name="lockMode">the lock mode</param>
      <returns>a persistent instance or null</returns>
    </member>
    <member name="M:NHibernate.ISession.Get(System.String,System.Object)">
      <summary> 
            Return the persistent instance of the given named entity with the given identifier,
            or null if there is no such persistent instance. (If the instance, or a proxy for the
            instance, is already associated with the session, return that instance or proxy.) 
            </summary>
      <param name="entityName">the entity name </param>
      <param name="id">an identifier </param>
      <returns> a persistent instance or null </returns>
    </member>
    <member name="M:NHibernate.ISession.Get``1(System.Object)">
      <summary>
            Strongly-typed version of <see cref="M:NHibernate.ISession.Get(System.Type,System.Object)" /></summary>
    </member>
    <member name="M:NHibernate.ISession.Get``1(System.Object,NHibernate.LockMode)">
      <summary>
            Strongly-typed version of <see cref="M:NHibernate.ISession.Get(System.Type,System.Object,NHibernate.LockMode)" /></summary>
    </member>
    <member name="M:NHibernate.ISession.GetEntityName(System.Object)">
      <summary> 
            Return the entity name for a persistent entity
            </summary>
      <param name="obj">a persistent entity</param>
      <returns> the entity name </returns>
    </member>
    <member name="M:NHibernate.ISession.EnableFilter(System.String)">
      <summary>
            Enable the named filter for this current session.
            </summary>
      <param name="filterName">The name of the filter to be enabled.</param>
      <returns>The Filter instance representing the enabled filter.</returns>
    </member>
    <member name="M:NHibernate.ISession.GetEnabledFilter(System.String)">
      <summary>
            Retrieve a currently enabled filter by name.
            </summary>
      <param name="filterName">The name of the filter to be retrieved.</param>
      <returns>The Filter instance representing the enabled filter.</returns>
    </member>
    <member name="M:NHibernate.ISession.DisableFilter(System.String)">
      <summary>
            Disable the named filter for the current session.
            </summary>
      <param name="filterName">The name of the filter to be disabled.</param>
    </member>
    <member name="M:NHibernate.ISession.CreateMultiQuery">
      <summary>
            Create a multi query, a query that can send several
            queries to the server, and return all their results in a single
            call.
            </summary>
      <returns>
            An <see cref="T:NHibernate.IMultiQuery" /> that can return
            a list of all the results of all the queries.
            Note that each query result is itself usually a list.
            </returns>
    </member>
    <member name="M:NHibernate.ISession.SetBatchSize(System.Int32)">
      <summary>
            Sets the batch size of the session
            </summary>
      <param name="batchSize">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ISession.GetSessionImplementation">
      <summary>
            Gets the session implementation.
            </summary>
      <remarks>
            This method is provided in order to get the <b>NHibernate</b> implementation of the session from wrapper implementions.
            Implementors of the <seealso cref="T:NHibernate.ISession" /> interface should return the NHibernate implementation of this method.
            </remarks>
      <returns>
            An NHibernate implementation of the <seealso cref="T:NHibernate.Engine.ISessionImplementor" /> interface 
            </returns>
    </member>
    <member name="M:NHibernate.ISession.CreateMultiCriteria">
      <summary>
            An <see cref="T:NHibernate.IMultiCriteria" /> that can return a list of all the results
            of all the criterias.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ISession.GetSession(NHibernate.EntityMode)">
      <summary>
            Starts a new Session with the given entity mode in effect. This secondary
            Session inherits the connection, transaction, and other context
            information from the primary Session. It doesn't need to be flushed
            or closed by the developer.
            </summary>
      <param name="entityMode">The entity mode to use for the new session.</param>
      <returns>The new session</returns>
    </member>
    <member name="P:NHibernate.ISession.ActiveEntityMode">
      <summary> The entity mode in effect for this session.</summary>
    </member>
    <member name="P:NHibernate.ISession.FlushMode">
      <summary>
            Determines at which points Hibernate automatically flushes the session.
            </summary>
      <remarks>
            For a readonly session, it is reasonable to set the flush mode to <c>FlushMode.Never</c>
            at the start of the session (in order to achieve some extra performance).
            </remarks>
    </member>
    <member name="P:NHibernate.ISession.CacheMode">
      <summary> The current cache mode. </summary>
      <remarks>
            Cache mode determines the manner in which this session can interact with
            the second level cache.
            </remarks>
    </member>
    <member name="P:NHibernate.ISession.SessionFactory">
      <summary>
            Get the <see cref="T:NHibernate.ISessionFactory" /> that created this instance.
            </summary>
    </member>
    <member name="P:NHibernate.ISession.Connection">
      <summary>
            Gets the ADO.NET connection.
            </summary>
      <remarks>
            Applications are responsible for calling commit/rollback upon the connection before
            closing the <c>ISession</c>.
            </remarks>
    </member>
    <member name="P:NHibernate.ISession.IsOpen">
      <summary>
            Is the <c>ISession</c> still open?
            </summary>
    </member>
    <member name="P:NHibernate.ISession.IsConnected">
      <summary>
            Is the <c>ISession</c> currently connected?
            </summary>
    </member>
    <member name="P:NHibernate.ISession.Transaction">
      <summary>
            Get the current Unit of Work and return the associated <c>ITransaction</c> object.
            </summary>
    </member>
    <member name="P:NHibernate.ISession.Statistics">
      <summary> Get the statistics for this session.</summary>
    </member>
    <member name="M:NHibernate.Event.IEventSource.Instantiate(NHibernate.Persister.Entity.IEntityPersister,System.Object)">
      <summary> 
            Instantiate an entity instance, using either an interceptor,
            or the given persister
            </summary>
    </member>
    <member name="M:NHibernate.Event.IEventSource.ForceFlush(NHibernate.Engine.EntityEntry)">
      <summary> Force an immediate flush</summary>
    </member>
    <member name="M:NHibernate.Event.IEventSource.Merge(System.String,System.Object,System.Collections.IDictionary)">
      <summary> Cascade merge an entity instance</summary>
    </member>
    <member name="M:NHibernate.Event.IEventSource.Persist(System.String,System.Object,System.Collections.IDictionary)">
      <summary> Cascade persist an entity instance</summary>
    </member>
    <member name="M:NHibernate.Event.IEventSource.PersistOnFlush(System.String,System.Object,System.Collections.IDictionary)">
      <summary> Cascade persist an entity instance during the flush process</summary>
    </member>
    <member name="M:NHibernate.Event.IEventSource.Refresh(System.Object,System.Collections.IDictionary)">
      <summary> Cascade refresh an entity instance</summary>
    </member>
    <member name="M:NHibernate.Event.IEventSource.SaveOrUpdateCopy(System.String,System.Object,System.Collections.IDictionary)">
      <summary> Cascade copy an entity instance</summary>
    </member>
    <member name="M:NHibernate.Event.IEventSource.Delete(System.String,System.Object,System.Boolean,Iesi.Collections.ISet)">
      <summary> Cascade delete an entity instance</summary>
    </member>
    <member name="P:NHibernate.Event.IEventSource.ActionQueue">
      <summary> Get the ActionQueue for this session</summary>
    </member>
    <member name="T:NHibernate.Event.IInitializable">
      <summary> 
            An event listener that requires access to mappings to
            initialize state at initialization time.
            </summary>
    </member>
    <member name="T:NHibernate.Event.InitializeCollectionEvent">
      <summary> 
            An event that occurs when a collection wants to be initialized
            </summary>
    </member>
    <member name="T:NHibernate.Event.IPostCollectionRecreateEventListener">
      <summary> Called after recreating a collection </summary>
    </member>
    <member name="T:NHibernate.Event.IPostCollectionRemoveEventListener">
      <summary> Called after removing a collection </summary>
    </member>
    <member name="T:NHibernate.Event.IPostCollectionUpdateEventListener">
      <summary> Called after updating a collection </summary>
    </member>
    <member name="T:NHibernate.Event.IPostDeleteEventListener">
      <summary> Called after deleting an item from the datastore </summary>
    </member>
    <member name="M:NHibernate.Event.IPostDeleteEventListener.OnPostDelete(NHibernate.Event.PostDeleteEvent)">
      <summary>
      </summary>
      <param name="event">
      </param>
    </member>
    <member name="T:NHibernate.Event.IPostInsertEventListener">
      <summary> Called after inserting an item in the datastore </summary>
    </member>
    <member name="M:NHibernate.Event.IPostInsertEventListener.OnPostInsert(NHibernate.Event.PostInsertEvent)">
      <summary>
      </summary>
      <param name="event">
      </param>
    </member>
    <member name="T:NHibernate.Event.IPostUpdateEventListener">
      <summary>
            Called after updating the datastore
            </summary>
    </member>
    <member name="M:NHibernate.Event.IPostUpdateEventListener.OnPostUpdate(NHibernate.Event.PostUpdateEvent)">
      <summary>
      </summary>
      <param name="event">
      </param>
    </member>
    <member name="T:NHibernate.Event.IPreCollectionRecreateEventListener">
      <summary> Called before recreating a collection </summary>
    </member>
    <member name="T:NHibernate.Event.IPreCollectionRemoveEventListener">
      <summary> Called before removing a collection </summary>
    </member>
    <member name="T:NHibernate.Event.IPreCollectionUpdateEventListener">
      <summary> Called before updating a collection </summary>
    </member>
    <member name="T:NHibernate.Event.IPreDeleteEventListener">
      <summary>
            Called before deleting an item from the datastore
            </summary>
    </member>
    <member name="M:NHibernate.Event.IPreDeleteEventListener.OnPreDelete(NHibernate.Event.PreDeleteEvent)">
      <summary> Return true if the operation should be vetoed</summary>
      <param name="event">
      </param>
    </member>
    <member name="T:NHibernate.Event.IPreInsertEventListener">
      <summary>
            Called before inserting an item in the datastore
            </summary>
    </member>
    <member name="M:NHibernate.Event.IPreInsertEventListener.OnPreInsert(NHibernate.Event.PreInsertEvent)">
      <summary> Return true if the operation should be vetoed</summary>
      <param name="event">
      </param>
    </member>
    <member name="T:NHibernate.Event.IPreUpdateEventListener">
      <summary>
            Called before updating the datastore
            </summary>
    </member>
    <member name="M:NHibernate.Event.IPreUpdateEventListener.OnPreUpdate(NHibernate.Event.PreUpdateEvent)">
      <summary> Return true if the operation should be vetoed</summary>
      <param name="event">
      </param>
    </member>
    <member name="T:NHibernate.Event.ListenerType">
      <summary>
            Values for listener type property.
            </summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.NotValidType">
      <summary>Not allowed in Xml. It represents the default value when an explicit type is assigned.</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.Autoflush">
      <summary>Xml value: auto-flush</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.Merge">
      <summary>Xml value: merge</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.Create">
      <summary>Xml value: create</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.CreateOnFlush">
      <summary>Xml value: create-onflush</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.Delete">
      <summary>Xml value: delete</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.DirtyCheck">
      <summary>Xml value: dirty-check</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.Evict">
      <summary>Xml value: evict</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.Flush">
      <summary>Xml value: flush</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.FlushEntity">
      <summary>Xml value: flush-entity</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.Load">
      <summary>Xml value: load</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.LoadCollection">
      <summary>Xml value: load-collection</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.Lock">
      <summary>Xml value: lock</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.Refresh">
      <summary>Xml value: refresh</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.Replicate">
      <summary>Xml value: replicate</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.SaveUpdate">
      <summary>Xml value: save-update</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.Save">
      <summary>Xml value: save</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PreUpdate">
      <summary>Xml value: pre-update</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.Update">
      <summary>Xml value: update</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PreLoad">
      <summary>Xml value: pre-load</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PreDelete">
      <summary>Xml value: pre-delete</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PreInsert">
      <summary>Xml value: pre-insert</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PreCollectionRecreate">
      <summary>Xml value: pre-collection-recreate </summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PreCollectionRemove">
      <summary>Xml value: pre-collection-remove </summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PreCollectionUpdate">
      <summary>Xml value: pre-collection-update </summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PostLoad">
      <summary>Xml value: post-load</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PostInsert">
      <summary>Xml value: post-insert</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PostUpdate">
      <summary>Xml value: post-update</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PostDelete">
      <summary>Xml value: post-delete</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PostCommitUpdate">
      <summary>Xml value: post-commit-update</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PostCommitInsert">
      <summary>Xml value: post-commit-insert</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PostCommitDelete">
      <summary>Xml value: post-commit-delete</summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PostCollectionRecreate">
      <summary>Xml value: post-collection-recreate </summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PostCollectionRemove">
      <summary>Xml value: post-collection-remove </summary>
    </member>
    <member name="F:NHibernate.Event.ListenerType.PostCollectionUpdate">
      <summary>Xml value: post-collection-update </summary>
    </member>
    <member name="T:NHibernate.Event.LoadEvent">
      <summary>Defines an event class for the loading of an entity. </summary>
    </member>
    <member name="T:NHibernate.Event.LockEvent">
      <summary>
            Defines an event class for the locking of an entity.
            </summary>
    </member>
    <member name="T:NHibernate.Event.MergeEvent">
      <summary> 
            An event class for merge() and saveOrUpdateCopy()
            </summary>
    </member>
    <member name="T:NHibernate.Event.PersistEvent">
      <summary> An event class for persist() </summary>
    </member>
    <member name="T:NHibernate.Event.PostCollectionRecreateEvent">
      <summary> An event that occurs after a collection is recreated </summary>
    </member>
    <member name="T:NHibernate.Event.PostCollectionRemoveEvent">
      <summary> An event that occurs after a collection is removed </summary>
    </member>
    <member name="T:NHibernate.Event.PostCollectionUpdateEvent">
      <summary> An event that occurs after a collection is updated </summary>
    </member>
    <member name="T:NHibernate.Event.PostDeleteEvent">
      <summary> 
            Occurs after deleting an item from the datastore 
            </summary>
    </member>
    <member name="T:NHibernate.Event.PostInsertEvent">
      <summary> 
            Occurs after inserting an item in the datastore 
            </summary>
    </member>
    <member name="T:NHibernate.Event.PostLoadEvent">
      <summary> 
            Occurs after an an entity instance is fully loaded.
            </summary>
    </member>
    <member name="T:NHibernate.Event.PostUpdateEvent">
      <summary> 
            Occurs after the datastore is updated
            </summary>
    </member>
    <member name="T:NHibernate.Event.PreCollectionRecreateEvent">
      <summary> An event that occurs before a collection is recreated </summary>
    </member>
    <member name="T:NHibernate.Event.PreCollectionRemoveEvent">
      <summary> An event that occurs before a collection is removed </summary>
    </member>
    <member name="T:NHibernate.Event.PreCollectionUpdateEvent">
      <summary> An event that occurs before a collection is updated </summary>
    </member>
    <member name="T:NHibernate.Event.PreDeleteEvent">
      <summary>
            Represents a <tt>pre-delete</tt> event, which occurs just prior to
            performing the deletion of an entity from the database.
            </summary>
    </member>
    <member name="M:NHibernate.Event.PreDeleteEvent.#ctor(System.Object,System.Object,System.Object[],NHibernate.Persister.Entity.IEntityPersister,NHibernate.Event.IEventSource)">
      <summary> 
            Constructs an event containing the pertinent information. 
            </summary>
      <param name="entity">The entity to be deleted. </param>
      <param name="id">The id to use in the deletion. </param>
      <param name="deletedState">The entity's state at deletion time. </param>
      <param name="persister">The entity's persister. </param>
      <param name="source">The session from which the event originated. </param>
    </member>
    <member name="P:NHibernate.Event.PreDeleteEvent.DeletedState">
      <summary> 
            This is the entity state at the
            time of deletion (useful for optomistic locking and such). 
            </summary>
    </member>
    <member name="T:NHibernate.Event.PreInsertEvent">
      <summary> 
            Represents a <tt>pre-insert</tt> event, which occurs just prior to
            performing the insert of an entity into the database.
            </summary>
    </member>
    <member name="P:NHibernate.Event.PreInsertEvent.State">
      <summary> 
            These are the values to be inserted. 
            </summary>
    </member>
    <member name="T:NHibernate.Event.PreLoadEvent">
      <summary> 
            Called before injecting property values into a newly loaded entity instance.
            </summary>
    </member>
    <member name="T:NHibernate.Event.PreUpdateEvent">
      <summary> 
            Represents a <tt>pre-update</tt> event, which occurs just prior to
            performing the update of an entity in the database.
            </summary>
    </member>
    <member name="P:NHibernate.Event.PreUpdateEvent.State">
      <summary>
            Retrieves the state to be used in the update.
            </summary>
    </member>
    <member name="P:NHibernate.Event.PreUpdateEvent.OldState">
      <summary>
            The old state of the entity at the time it was last loaded from the
            database; can be null in the case of detached entities.
            </summary>
    </member>
    <member name="T:NHibernate.Event.RefreshEvent">
      <summary>  
            Defines an event class for the refreshing of an object.
            </summary>
    </member>
    <member name="T:NHibernate.Event.ReplicateEvent">
      <summary>  
            Defines an event class for the replication of an entity.
            </summary>
    </member>
    <member name="T:NHibernate.Event.SaveOrUpdateEvent">
      <summary> 
            An event class for saveOrUpdate()
            </summary>
    </member>
    <member name="T:NHibernate.ADOException">
      <summary>
            Wraps exceptions that occur during ADO.NET calls.
            </summary>
      <remarks>
            Exceptions thrown by various ADO.NET providers are not derived from
            a common base class (<c>SQLException</c> in Java), so <see cref="T:System.Exception" />
            is used instead in NHibernate.
            </remarks>
    </member>
    <member name="M:NHibernate.ADOException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ADOException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.ADOException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ADOException" /> class.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.Exceptions.ADOConnectionException">
      <summary> 
            Implementation of ADOException indicating problems with communicating with the
            database (can also include incorrect ADO setup). 
            </summary>
    </member>
    <member name="T:NHibernate.Exceptions.AdoExceptionContextInfo">
      <summary>
            Collect data of an <see cref="T:NHibernate.ADOException" /> to be converted.
            </summary>
    </member>
    <member name="P:NHibernate.Exceptions.AdoExceptionContextInfo.SqlException">
      <summary>
            The <see cref="T:System.Data.Common.DbException" /> to be converted.
            </summary>
    </member>
    <member name="P:NHibernate.Exceptions.AdoExceptionContextInfo.Message">
      <summary>
            An optional error message.
            </summary>
    </member>
    <member name="P:NHibernate.Exceptions.AdoExceptionContextInfo.Sql">
      <summary>
            The SQL that generate the exception
            </summary>
    </member>
    <member name="P:NHibernate.Exceptions.AdoExceptionContextInfo.EntityName">
      <summary>
            Optional EntityName where available in the original exception context.
            </summary>
    </member>
    <member name="P:NHibernate.Exceptions.AdoExceptionContextInfo.EntityId">
      <summary>
            Optional EntityId where available in the original exception context.
            </summary>
    </member>
    <member name="M:NHibernate.Exceptions.ADOExceptionHelper.Convert(NHibernate.Exceptions.ISQLExceptionConverter,System.Exception,System.String,NHibernate.SqlCommand.SqlString)">
      <summary> 
            Converts the given SQLException into Exception hierarchy, as well as performing
            appropriate logging. 
            </summary>
      <param name="converter">The converter to use.</param>
      <param name="sqlException">The exception to convert.</param>
      <param name="message">An optional error message.</param>
      <param name="sql">The SQL executed.</param>
      <returns> The converted <see cref="T:NHibernate.ADOException" />.</returns>
    </member>
    <member name="M:NHibernate.Exceptions.ADOExceptionHelper.Convert(NHibernate.Exceptions.ISQLExceptionConverter,System.Exception,System.String)">
      <summary> 
            Converts the given SQLException into Exception hierarchy, as well as performing
            appropriate logging. 
            </summary>
      <param name="converter">The converter to use.</param>
      <param name="sqlException">The exception to convert.</param>
      <param name="message">An optional error message.</param>
      <returns> The converted <see cref="T:NHibernate.ADOException" />.</returns>
    </member>
    <member name="M:NHibernate.Exceptions.ADOExceptionHelper.ExtractDbException(System.Exception)">
      <summary> For the given <see cref="T:System.Exception" />, locates the <see cref="T:System.Data.Common.DbException" />. </summary>
      <param name="sqlException">The exception from which to extract the <see cref="T:System.Data.Common.DbException" /></param>
      <returns> The <see cref="T:System.Data.Common.DbException" />, or null. </returns>
    </member>
    <member name="T:NHibernate.Exceptions.ConstraintViolationException">
      <summary> 
            Implementation of ADOException indicating that the requested DML operation
            resulted in a violation of a defined integrity constraint. 
            </summary>
    </member>
    <member name="P:NHibernate.Exceptions.ConstraintViolationException.ConstraintName">
      <summary> 
            Returns the name of the violated constraint, if known. 
            </summary>
      <returns> The name of the violated constraint, or null if not known. </returns>
    </member>
    <member name="T:NHibernate.Exceptions.DataException">
      <summary> 
            Implementation of ADOException indicating that evaluation of the
            valid SQL statement against the given data resulted in some
            illegal operation, mismatched types or incorrect cardinality. 
            </summary>
    </member>
    <member name="T:NHibernate.Exceptions.IConfigurable">
      <summary> 
            The Configurable interface defines the contract for <see cref="T:NHibernate.Exceptions.ISQLExceptionConverter" /> impls that
            want to be configured prior to usage given the currently defined Hibernate properties. 
            </summary>
    </member>
    <member name="M:NHibernate.Exceptions.IConfigurable.Configure(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary> Configure the component, using the given settings and properties. </summary>
      <param name="properties">All defined startup properties. </param>
    </member>
    <member name="T:NHibernate.Exceptions.ISQLExceptionConverter">
      <summary> 
            Defines a contract for implementations that know how to convert a <see cref="T:System.Data.Common.DbException" />
            into NHibernate's <see cref="T:NHibernate.ADOException" /> hierarchy. 
            </summary>
      <remarks>
            Inspired by Spring's SQLExceptionTranslator.
            
            Implementations <b>must</b> have a constructor which takes a
            <see cref="T:NHibernate.Exceptions.IViolatedConstraintNameExtracter" /> parameter.
            <para />
            Implementations may implement <see cref="T:NHibernate.Exceptions.IConfigurable" /> if they need to perform
            configuration steps prior to first use.
            </remarks>
      <seealso cref="T:NHibernate.Exceptions.SQLExceptionConverterFactory" />
    </member>
    <member name="M:NHibernate.Exceptions.ISQLExceptionConverter.Convert(NHibernate.Exceptions.AdoExceptionContextInfo)">
      <summary> 
            Convert the given <see cref="T:System.Data.Common.DbException" /> into custom Exception. 
            </summary>
      <param name="adoExceptionContextInfo">Available information during exception throw.</param>
      <returns> The resulting Exception to throw. </returns>
    </member>
    <member name="T:NHibernate.Exceptions.LockAcquisitionException">
      <summary> 
            Implementation of ADOException indicating a problem acquiring lock
            on the database. 
            </summary>
    </member>
    <member name="T:NHibernate.Exceptions.SQLExceptionConverterFactory">
      <summary> A factory for building SQLExceptionConverter instances. </summary>
    </member>
    <member name="M:NHibernate.Exceptions.SQLExceptionConverterFactory.BuildSQLExceptionConverter(NHibernate.Dialect.Dialect,System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary> Build a SQLExceptionConverter instance. </summary>
      <param name="dialect">The defined dialect. </param>
      <param name="properties">The configuration properties. </param>
      <returns> An appropriate <see cref="T:NHibernate.Exceptions.ISQLExceptionConverter" /> instance. </returns>
      <remarks>
            First, looks for a <see cref="F:NHibernate.Cfg.Environment.SqlExceptionConverter" /> property to see
            if the configuration specified the class of a specific converter to use.  If this
            property is set, attempt to construct an instance of that class.  If not set, or
            if construction fails, the converter specific to the dialect will be used.
            </remarks>
    </member>
    <member name="M:NHibernate.Exceptions.SQLExceptionConverterFactory.BuildMinimalSQLExceptionConverter">
      <summary> 
            Builds a minimal converter.  The instance returned here just always converts to <see cref="T:NHibernate.Exceptions.GenericADOException" />. 
            </summary>
      <returns> The minimal converter. </returns>
    </member>
    <member name="T:NHibernate.Exceptions.SQLGrammarException">
      <summary> 
            Implementation of ADOException indicating that the SQL sent to the database
            server was invalid (syntax error, invalid object references, etc). 
            </summary>
    </member>
    <member name="T:NHibernate.Exceptions.SQLStateConverter">
      <summary> 
            A SQLExceptionConverter implementation which performs no conversion of
            the underlying <see cref="T:System.Data.Common.DbException" />. 
            Interpretation of a SQL error based on <see cref="T:System.Data.Common.DbException" />
            is not possible as using the ErrorCode (which is, however, vendor-
            specific). Use of a ErrorCode-based converter should be preferred approach
            for converting/interpreting SQLExceptions. 
            </summary>
    </member>
    <member name="M:NHibernate.Exceptions.SQLStateConverter.HandledNonSpecificException(System.Exception,System.String,System.String)">
      <summary> Handle an exception not converted to a specific type based on the SQLState. </summary>
      <param name="sqlException">The exception to be handled. </param>
      <param name="message">An optional message </param>
      <param name="sql">Optionally, the sql being performed when the exception occurred. </param>
      <returns> The converted exception; should <b>never</b> be null. </returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Exec.IStatementExecutor">
      <summary> 
            Encapsulates the strategy required to execute various types of update, delete,
            and insert statements issued through HQL. 
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Exec.IStatementExecutor.Execute(NHibernate.Engine.QueryParameters,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Execute the sql managed by this executor using the given parameters. 
            </summary>
      <param name="parameters">Essentially bind information for this processing. </param>
      <param name="session">The session originating the request. </param>
      <returns> The number of entities updated/deleted. </returns>
      <exception cref="T:NHibernate.HibernateException" />
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.HqlParser.filter">
            True if this is a filter query (allow no FROM clause). *
        </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.HqlSqlWalker.PopFromClause">
      <summary>
            Returns to the previous 'FROM' context.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.IErrorReporter">
      <summary>
            Implementations will report or handle errors invoked by an ANTLR base parser.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.SqlGenerator.ISqlWriter">
      <summary>
            Writes SQL fragments.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SqlGenerator.ISqlWriter.CommaBetweenParameters(System.String)">
             todo remove this hack
             The parameter is either ", " or " , ". This is needed to pass sql generating tests as the old
             sql generator uses " , " in the WHERE and ", " in SELECT.
            
             @param comma either " , " or ", "
        </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.SqlGenerator.DefaultWriter">
      <summary>
            The default SQL writer.
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.SqlGenerator.outputStack">
            all append invocations on the buf should go through this Output instance variable.
            The value of this variable may be temporarily substitued by sql function processing code
            to catch generated arguments.
            This is because sql function templates need arguments as seperate string chunks
            that will be assembled into the target dialect-specific function call.
        </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.SqlGenerator.parseErrorHandler">
      <summary>
            Handles parser errors.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SqlGenerator.OptionalSpace">
      <summary>
            Add a aspace if the previous token was not a space or a parenthesis.
            </summary>
    </member>
    <member name="T:NHibernate.Loader.Loader">
      <summary>
            Abstract superclass of object loading (and querying) strategies.
            </summary>
      <remarks>
        <p>
            This class implements useful common functionality that concrete loaders would delegate to.
            It is not intended that this functionality would be directly accessed by client code (Hence,
            all methods of this class are declared <c>protected</c> or <c>private</c>.) This class relies heavily upon the
            <see cref="T:NHibernate.Persister.Entity.ILoadable" /> interface, which is the contract between this class and 
            <see cref="T:NHibernate.Persister.Entity.IEntityPersister" />s that may be loaded by it.
            </p>
        <p>
            The present implementation is able to load any number of columns of entities and at most 
            one collection role per query.
            </p>
      </remarks>
      <seealso cref="T:NHibernate.Persister.Entity.ILoadable" />
    </member>
    <member name="M:NHibernate.Loader.Loader.GetLockModes(System.Collections.Generic.IDictionary{System.String,NHibernate.LockMode})">
      <summary>
            What lock mode does this load entities with?
            </summary>
      <param name="lockModes">A Collection of lock modes specified dynamically via the Query Interface</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Loader.Loader.ApplyLocks(NHibernate.SqlCommand.SqlString,System.Collections.Generic.IDictionary{System.String,NHibernate.LockMode},NHibernate.Dialect.Dialect)">
      <summary>
            Append <c>FOR UPDATE OF</c> clause, if necessary. This
            empty superclass implementation merely returns its first
            argument.
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.UpgradeLocks">
      <summary>
            Does this query return objects that might be already cached by 
            the session, whose lock mode may need upgrading.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Loader.Loader.PreprocessSQL(NHibernate.SqlCommand.SqlString,NHibernate.Engine.QueryParameters,NHibernate.Dialect.Dialect)">
      <summary>
            Modify the SQL, adding lock hints and comments, if necessary
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.DoQueryAndInitializeNonLazyCollections(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters,System.Boolean)">
      <summary>
            Execute an SQL query and attempt to instantiate instances of the class mapped by the given
            persister from each row of the <c>DataReader</c>. If an object is supplied, will attempt to
            initialize that object. If a collection is supplied, attempt to initialize that collection.
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.LoadSingleRow(System.Data.IDataReader,NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters,System.Boolean)">
      <summary>
            Loads a single row from the result set.  This is the processing used from the
            ScrollableResults where no collection fetches were encountered.
            </summary>
      <param name="resultSet">The result set from which to do the load.</param>
      <param name="session">The session from which the request originated.</param>
      <param name="queryParameters">The query parameters specified by the user.</param>
      <param name="returnProxies">Should proxies be generated</param>
      <returns>The loaded "row".</returns>
      <exception cref="T:NHibernate.HibernateException" />
    </member>
    <member name="M:NHibernate.Loader.Loader.ReadCollectionElements(System.Object[],System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Read any collection elements contained in a single row of the result set
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.GetResultColumnOrRow(System.Object[],NHibernate.Transform.IResultTransformer,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Get the actual object that is returned in the user-visible result list.
            </summary>
      <remarks>
            This empty implementation merely returns its first argument. This is
            overridden by some subclasses.
            </remarks>
    </member>
    <member name="M:NHibernate.Loader.Loader.RegisterNonExists(NHibernate.Engine.EntityKey[],NHibernate.Engine.ISessionImplementor)">
      <summary>
            For missing objects associated by one-to-one with another object in the
            result set, register the fact that the the object is missing with the
            session.
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.ReadCollectionElement(System.Object,System.Object,NHibernate.Persister.Collection.ICollectionPersister,NHibernate.Loader.ICollectionAliases,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Read one collection element from the current row of the ADO.NET result set
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.HandleEmptyCollections(System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            If this is a collection initializer, we need to tell the session that a collection
            is being initilized, to account for the possibility of the collection having
            no elements (hence no rows in the result set).
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.GetKeyFromResultSet(System.Int32,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Read a row of <c>EntityKey</c>s from the <c>IDataReader</c> into the given array.
            </summary>
      <remarks>
            Warning: this method is side-effecty. If an <c>id</c> is given, don't bother going
            to the <c>IDataReader</c></remarks>
    </member>
    <member name="M:NHibernate.Loader.Loader.CheckVersion(System.Int32,NHibernate.Persister.Entity.IEntityPersister,System.Object,System.Object,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Check the version of the object in the <c>IDataReader</c> against
            the object version in the session cache, throwing an exception
            if the version numbers are different.
            </summary>
      <exception cref="T:NHibernate.StaleObjectStateException">
      </exception>
    </member>
    <member name="M:NHibernate.Loader.Loader.GetRow(System.Data.IDataReader,NHibernate.Persister.Entity.ILoadable[],NHibernate.Engine.EntityKey[],System.Object,NHibernate.Engine.EntityKey,NHibernate.LockMode[],System.Collections.IList,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Resolve any ids for currently loaded objects, duplications within the <c>IDataReader</c>,
            etc. Instanciate empty objects to be initialized from the <c>IDataReader</c>. Return an
            array of objects (a row of results) and an array of booleans (by side-effect) that determine
            wheter the corresponding object should be initialized
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.InstanceAlreadyLoaded(System.Data.IDataReader,System.Int32,NHibernate.Persister.Entity.IEntityPersister,NHibernate.Engine.EntityKey,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
      <summary>
            The entity instance is already in the session cache
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.InstanceNotYetLoaded(System.Data.IDataReader,System.Int32,NHibernate.Persister.Entity.ILoadable,NHibernate.Engine.EntityKey,NHibernate.LockMode,System.String,NHibernate.Engine.EntityKey,System.Object,System.Collections.IList,NHibernate.Engine.ISessionImplementor)">
      <summary>
            The entity instance is not in the session cache
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.LoadFromResultSet(System.Data.IDataReader,System.Int32,System.Object,System.String,NHibernate.Engine.EntityKey,System.String,NHibernate.LockMode,NHibernate.Persister.Entity.ILoadable,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Hydrate the state of an object from the SQL <c>IDataReader</c>, into
            an array of "hydrated" values (do not resolve associations yet),
            and pass the hydrated state to the session.
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.GetInstanceClass(System.Data.IDataReader,System.Int32,NHibernate.Persister.Entity.ILoadable,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Determine the concrete class of an instance for the <c>IDataReader</c></summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.Advance(System.Data.IDataReader,NHibernate.Engine.RowSelection)">
      <summary>
            Advance the cursor to the first required row of the <c>IDataReader</c></summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.UseLimit(NHibernate.Engine.RowSelection,NHibernate.Dialect.Dialect)">
      <summary>
            Should we pre-process the SQL string, adding a dialect-specific
            LIMIT clause.
            </summary>
      <param name="selection">
      </param>
      <param name="dialect">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Loader.Loader.PrepareQueryCommand(NHibernate.Engine.QueryParameters,System.Boolean,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Obtain an <c>IDbCommand</c> with all parameters pre-bound. Bind positional parameters,
            named parameters, and limit parameters.
            </summary>
      <remarks>
            Creates an IDbCommand object and populates it with the values necessary to execute it against the 
            database to Load an Entity.
            </remarks>
      <param name="queryParameters">The <see cref="T:NHibernate.Engine.QueryParameters" /> to use for the IDbCommand.</param>
      <param name="scroll">TODO: find out where this is used...</param>
      <param name="session">The SessionImpl this Command is being prepared in.</param>
      <returns>A CommandWrapper wrapping an IDbCommand that is ready to be executed.</returns>
    </member>
    <member name="M:NHibernate.Loader.Loader.GetMaxOrLimit(NHibernate.Dialect.Dialect,NHibernate.Engine.RowSelection)">
      <summary> 
            Some dialect-specific LIMIT clauses require the maximium last row number
            (aka, first_row_number + total_row_count), while others require the maximum
            returned row count (the total maximum number of rows to return). 
            </summary>
      <param name="selection">The selection criteria </param>
      <param name="dialect">The dialect </param>
      <returns> The appropriate value to bind into the limit clause. </returns>
    </member>
    <member name="M:NHibernate.Loader.Loader.BindLimitParameters(System.Data.IDbCommand,System.Int32,NHibernate.Engine.RowSelection,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Bind parameters needed by the dialect-specific LIMIT clause
            </summary>
      <returns>The number of parameters bound</returns>
    </member>
    <member name="M:NHibernate.Loader.Loader.SetMaxRows(System.Data.IDbCommand,NHibernate.Engine.RowSelection)">
      <summary>
            Limits the number of rows returned by the Sql query if necessary.
            </summary>
      <param name="st">The IDbCommand to limit.</param>
      <param name="selection">The RowSelection that contains the MaxResults info.</param>
      <remarks>TODO: This does not apply to ADO.NET at all</remarks>
    </member>
    <member name="M:NHibernate.Loader.Loader.BindParameterValues(System.Data.IDbCommand,NHibernate.Engine.QueryParameters,System.Int32,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Bind all parameter values into the prepared statement in preparation for execution. 
            </summary>
      <param name="statement">The ADO prepared statement </param>
      <param name="queryParameters">The encapsulation of the parameter values to be bound. </param>
      <param name="startIndex">The position from which to start binding parameter values. </param>
      <param name="session">The originating session. </param>
      <returns> The number of ADO bind positions actually bound during this method execution. </returns>
    </member>
    <member name="M:NHibernate.Loader.Loader.GetResultSet(System.Data.IDbCommand,System.Boolean,System.Boolean,NHibernate.Engine.RowSelection,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Fetch a <c>IDbCommand</c>, call <c>SetMaxRows</c> and then execute it,
            advance to the first result and return an SQL <c>IDataReader</c></summary>
      <param name="st">The <see cref="T:System.Data.IDbCommand" /> to execute.</param>
      <param name="selection">The <see cref="T:NHibernate.Engine.RowSelection" /> to apply to the <see cref="T:System.Data.IDbCommand" /> and <see cref="T:System.Data.IDataReader" />.</param>
      <param name="autoDiscoverTypes">true if result types need to be auto-discovered by the loader; false otherwise.</param>
      <param name="session">The <see cref="T:NHibernate.ISession" /> to load in.</param>
      <param name="callable">
      </param>
      <returns>An IDataReader advanced to the first record in RowSelection.</returns>
    </member>
    <member name="M:NHibernate.Loader.Loader.LoadEntity(NHibernate.Engine.ISessionImplementor,System.Object,NHibernate.Type.IType,System.Object,System.String,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
      <summary>
            Called by subclasses that load entities
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.LoadEntityBatch(NHibernate.Engine.ISessionImplementor,System.Object[],NHibernate.Type.IType,System.Object,System.String,System.Object,NHibernate.Persister.Entity.IEntityPersister)">
      <summary>
            Called by subclasses that batch load entities
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.LoadCollection(NHibernate.Engine.ISessionImplementor,System.Object,NHibernate.Type.IType)">
      <summary>
            Called by subclasses that load collections
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.LoadCollectionBatch(NHibernate.Engine.ISessionImplementor,System.Object[],NHibernate.Type.IType)">
      <summary>
            Called by wrappers that batch initialize collections
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.LoadCollectionSubselect(NHibernate.Engine.ISessionImplementor,System.Object[],System.Object[],NHibernate.Type.IType[],System.Collections.Generic.IDictionary{System.String,NHibernate.Engine.TypedValue},NHibernate.Type.IType)">
      <summary>
            Called by subclasses that batch initialize collections
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.List(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters,Iesi.Collections.Generic.ISet{System.String},NHibernate.Type.IType[])">
      <summary>
            Return the query results, using the query cache, called
            by subclasses that implement cacheable queries
            </summary>
      <param name="session">
      </param>
      <param name="queryParameters">
      </param>
      <param name="querySpaces">
      </param>
      <param name="resultTypes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Loader.Loader.DoList(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters)">
      <summary>
            Actually execute a query, ignoring the query cache
            </summary>
      <param name="session">
      </param>
      <param name="queryParameters">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Loader.Loader.PostInstantiate">
      <summary>
            Calculate and cache select-clause suffixes. Must be
            called by subclasses after instantiation.
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Loader.GetParameterTypes(NHibernate.Engine.QueryParameters,System.Boolean,System.Boolean)">
      <returns>
        <see cref="T:System.Collections.IList" /> of <see cref="T:NHibernate.Type.IType" /></returns>
    </member>
    <member name="P:NHibernate.Loader.Loader.EntityEagerPropertyFetches">
      <summary> 
            An array indicating whether the entities have eager property fetching
            enabled. 
            </summary>
      <value> Eager property fetching indicators. </value>
    </member>
    <member name="P:NHibernate.Loader.Loader.Owners">
      <summary>
            An array of indexes of the entity that owns a one-to-one association
            to the entity at the given index (-1 if there is no "owner")
            </summary>
      <remarks>
            The indexes contained here are relative to the result of <see cref="P:NHibernate.Loader.Loader.EntityPersisters" />.
            </remarks>
    </member>
    <member name="P:NHibernate.Loader.Loader.OwnerAssociationTypes">
      <summary> 
            An array of the owner types corresponding to the <see cref="P:NHibernate.Loader.Loader.Owners" />
            returns.  Indices indicating no owner would be null here. 
            </summary>
    </member>
    <member name="P:NHibernate.Loader.Loader.CollectionOwners">
      <summary>
            Get the index of the entity that owns the collection, or -1
            if there is no owner in the query results (i.e. in the case of a 
            collection initializer) or no collection.
            </summary>
    </member>
    <member name="P:NHibernate.Loader.Loader.IsSingleRowLoader">
      <summary>
            Return false is this loader is a batch entity loader
            </summary>
    </member>
    <member name="P:NHibernate.Loader.Loader.EntityAliases">
      <summary>
            Get the result set descriptor
            </summary>
    </member>
    <member name="P:NHibernate.Loader.Loader.SqlString">
      <summary>
            The SqlString to be called; implemented by all subclasses
            </summary>
      <remarks>
        <para>
            The <c>setter</c> was added so that class inheriting from Loader could write a 
            value using the Property instead of directly to the field.
            </para>
        <para>
            The scope is <c>protected internal</c> because the <see cref="T:NHibernate.Hql.Classic.WhereParser" /> needs to
            be able to <c>get</c> the SqlString of the <see cref="T:NHibernate.Hql.Classic.QueryTranslator" /> when
            it is parsing a subquery.
            </para>
      </remarks>
    </member>
    <member name="P:NHibernate.Loader.Loader.EntityPersisters">
      <summary>
            An array of persisters of entity classes contained in each row of results;
            implemented by all subclasses
            </summary>
      <remarks>
            The <c>setter</c> was added so that classes inheriting from Loader could write a 
            value using the Property instead of directly to the field.
            </remarks>
    </member>
    <member name="P:NHibernate.Loader.Loader.CollectionPersisters">
      <summary>
            An (optional) persister for a collection to be initialized; only collection loaders
            return a non-null value
            </summary>
    </member>
    <member name="P:NHibernate.Loader.Loader.Aliases">
      <summary>
            Get the SQL table aliases of entities whose
            associations are subselect-loadable, returning
            null if this loader does not support subselect
            loading
            </summary>
    </member>
    <member name="P:NHibernate.Loader.Loader.QueryIdentifier">
      <summary> 
            Identifies the query for statistics reporting, if null,
            no statistics will be reported
            </summary>
    </member>
    <member name="M:NHibernate.Loader.BasicLoader.GenerateSuffixes(System.Int32)">
      <summary>
            Utility method that generates 0_, 1_ suffixes. Subclasses don't
            necessarily need to use this algorithm, but it is intended that
            they will in most cases.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Loader.QueryLoader.GetNamedParameterLocs(System.String)">
      <summary>
            Returns the locations of all occurrences of the named parameter.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Loader.QueryLoader.GetLockModes(System.Collections.Generic.IDictionary{System.String,NHibernate.LockMode})">
      <summary>
      </summary>
      <param name="lockModes">a collection of lock modes specified dynamically via the Query interface</param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.SqlNode">
      <summary>
            A base AST node for the intermediate tree.
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.SqlNode._originalText">
            The original text for the node, mostly for debugging.
        </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.SqlNode._dataType">
            The data type of this node.  Null for 'no type'.
        </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.SqlNode.RenderText(NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Retrieve the text to be used for rendering this particular node.
            </summary>
      <param name="sessionFactory">The session factory</param>
      <returns>The text to use for rendering</returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IInitializableNode">
      <summary>
            An interface for initializeable AST nodes.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IInitializableNode.Initialize(System.Object)">
      <summary>
            Initializes the node with the parameter.
            </summary>
      <param name="param">the initialization parameter.</param>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.HqlSqlWalkerNode">
      <summary>
            A semantic analysis node, that points back to the main analyzer.
            Authoer: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.HqlSqlWalkerNode._walker">
            A pointer back to the phase 2 processor.
        </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IOperatorNode">
      <summary>
            Contract for nodes representing operators (logic or arithmetic).
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IOperatorNode.Initialize">
      <summary>
            Called by the tree walker during hql-sql semantic analysis
            after the operator sub-tree is completely built.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IOperatorNode.DataType">
      <summary>
            Retrieves the data type for the overall operator expression.
            </summary>
      <returns>The expression's data type.</returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IUnaryOperatorNode">
      <summary>
            Contract for nodes representing unary operators.
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IUnaryOperatorNode.Operand">
      <summary>
            Retrieves the node representing the operator's single operand.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.UnaryLogicOperatorNode">
      <summary>
            Represents a unary operator node.
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.AbstractNullnessCheckNode">
      <summary>
            Base class for nodes dealing 'is null' and 'is not null' operators.
            todo : a good deal of this is copied from BinaryLogicOperatorNode; look at consolidating these code fragments
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.AbstractNullnessCheckNode.ExpansionConnectorType">
      <summary>
            When (if) we need to expand a row value constructor, what is the type of connector to use between the
            expansion fragments.
            </summary>
      <returns>The expansion connector type.</returns>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.AbstractNullnessCheckNode.ExpansionConnectorText">
      <summary>
            When (if) we need to expand a row value constructor, what is the text of connector to use between the
            expansion fragments.
            </summary>
      <returns>The expansion connector text.</returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IDisplayableNode">
      <summary>
            Implementors will return additional display text, which will be used
            by the ASTPrinter to display information (besides the node type and node
            text).
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IDisplayableNode.GetDisplayText">
      <summary>
            Returns additional display text for the AST node.
            </summary>
      <returns>The additional display text.</returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IStatement">
      <summary>
            Common interface modeling the different HQL statements (i.e., INSERT, UPDATE, DELETE, SELECT).
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IStatement.Walker">
      <summary>
            The "phase 2" walker which generated this statement tree.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IStatement.StatementType">
      <summary>
            The main token type representing the type of this statement.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IStatement.NeedsExecutor">
      <summary>
            Does this statement require the StatementExecutor?
            Essentially, at the JDBC level, does this require an executeUpdate()?
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.AbstractStatement">
      <summary>
            Convenience implementation of Statement to centralize common functionality.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.AbstractStatement.GetDisplayText">
      <summary>
            Returns additional display text for the AST node.
            </summary>
      <returns>The additional display text.</returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IRestrictableStatement">
      <summary>
            Type definition for Statements which are restrictable via a where-clause (and
            thus also having a from-clause).
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IRestrictableStatement.FromClause">
      <summary>
            Retreives the from-clause in effect for this statement; could be null if the from-clause
            has not yet been parsed/generated.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IRestrictableStatement.HasWhereClause">
      <summary>
            Does this statement tree currently contain a where clause?
            Returns True if a where-clause is found in the statement tree and
            that where clause actually defines restrictions; false otherwise.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IRestrictableStatement.WhereClause">
      <summary>
            Retreives the where-clause defining the restriction(s) in effect for
            this statement.
            Note that this will generate a where-clause if one was not found, so caution
            needs to taken prior to calling this that restrictions will actually exist
            in the resulting statement tree (otherwise "unexpected end of subtree" errors
            might occur during rendering).
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression">
      <summary>
            Represents an element of a projection list, i.e. a select expression.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression.SetScalarColumnText(System.Int32)">
      <summary>
            Appends AST nodes that represent the columns after the current AST node.
            (e.g. 'as col0_O_')
            </summary>
      <param name="i">The index of the select expression in the projection list.</param>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression.DataType">
      <summary>
            Returns the data type of the select expression.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression.FromElement">
      <summary>
            Returns the FROM element that this expression refers to.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression.IsConstructor">
      <summary>
            Returns true if the element is a constructor (e.g. new Foo).
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression.IsReturnableEntity">
      <summary>
            Returns true if this select expression represents an entity that can be returned.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.ISelectExpression.Text">
      <summary>
            Sets the text of the node.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.AggregateNode">
      <summary>
            Represents an aggregate function i.e. min, max, sum, avg.
            
            Author: Joshua Davis
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.AssignmentSpecification">
      <summary> 
            Encapsulates the information relating to an individual assignment within the
            set clause of an HQL update statement.  This information is used during execution
            of the update statements when the updates occur against "multi-table" stuff. 
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.BetweenOperatorNode">
      <summary>
            Contract for nodes representing logcial BETWEEN (ternary) operators.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IBinaryOperatorNode">
      <summary>
            Contract for nodes representing binary operators.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IBinaryOperatorNode.LeftHandOperand">
      <summary>
            The left-hand operand of the operator.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IBinaryOperatorNode.RightHandOperand">
      <summary>
            The right-hand operand of the operator.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.BinaryArithmeticOperatorNode">
      <summary>
            Nodes which represent binary arithmetic operators.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.BinaryArithmeticOperatorNode.LeftHandOperand">
             Retrieves the left-hand operand of the operator.
            
             @return The left-hand operand
        </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.BinaryArithmeticOperatorNode.RightHandOperand">
             Retrieves the right-hand operand of the operator.
            
             @return The right-hand operand
        </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.BinaryLogicOperatorNode">
      <summary>
            Contract for nodes representing binary operators.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.BinaryLogicOperatorNode.Initialize">
      <summary>
            Performs the operator node initialization by seeking out any parameter
            nodes and setting their expected type, if possible.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.BinaryLogicOperatorNode.MutateRowValueConstructorSyntax(System.Int32)">
             Mutate the subtree relating to a row-value-constructor to instead use
             a series of ANDed predicates.  This allows multi-column type comparisons
             and explicit row-value-constructor syntax even on databases which do
             not support row-value-constructor.
             <p />
             For example, here we'd mutate "... where (col1, col2) = ('val1', 'val2) ..." to
             "... where col1 = 'val1' and col2 = 'val2' ..."
            
             @param valueElements The number of elements in the row value constructor list.
        </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.LiteralNode">
      <summary>
            Represents a literal.
            
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IExpectedTypeAwareNode">
      <summary>
            Interface for nodes which wish to be made aware of any determined "expected
            type" based on the context within they appear in the query.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.BooleanLiteralNode">
      <summary>
             Represents a boolean literal within a query.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.BooleanLiteralNode.ExpectedType">
             Expected-types really only pertinent here for boolean literals...
            
             @param expectedType
        </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.Case2Node">
      <summary>
            Represents a case ... when .. then ... else ... end expression in a select.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.CaseNode">
      <summary>
            Represents a case ... when .. then ... else ... end expression in a select.
            
            Author: Gavin King
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.MethodNode">
      <summary>
            Represents a method call
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.CollectionFunction">
      <summary>
            Represents 'elements()' or 'indices()'.
            Author: josh
            Ported by: Steve strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionList">
      <summary>
            Common behavior - a node that contains a list of select expressions.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionList.CollectSelectExpressions">
      <summary>
            Returns an array of SelectExpressions gathered from the children of the given parent AST node.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionList.CollectSelectExpressions(System.Boolean)">
      <summary>
            Returns an array of SelectExpressions gathered from the children of the given parent AST node.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionList.GetFirstSelectExpression">
      <summary>
            Returns the first select expression node that should be considered when building the array of select
            expressions.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.CountNode">
      <summary>
            Represents a COUNT expression in a select.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.DeleteStatement">
      <summary>
            Defines a top-level AST node representing an HQL delete statement. 
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode">
      <summary>
            The contract for expression sub-trees that can resolve themselves.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode.Resolve(System.Boolean,System.Boolean,System.String,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
      <summary>
            Does the work of resolving an identifier or a dot
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode.Resolve(System.Boolean,System.Boolean,System.String)">
      <summary>
            Does the work of resolving an identifier or a dot, but without a parent node
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode.Resolve(System.Boolean,System.Boolean)">
      <summary>
            Does the work of resolving an identifier or a dot, but without a parent node or alias
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode.ResolveInFunctionCall(System.Boolean,System.Boolean)">
      <summary>
            Does the work of resolving inside of the scope of a function call
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IResolvableNode.ResolveIndex(NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
      <summary>
            Does the work of resolving an an index [].
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IPathNode">
      <summary>
            An AST node with a path property.  This path property will be the fully qualified name.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IPathNode.Path">
      <summary>
            Returns the full path name represented by the node.
            </summary>
      <returns>the full path name represented by the node.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromReferenceNode.GetImpliedJoin">
      <summary>
            Sub-classes can override this method if they produce implied joins (e.g. DotNode).
            </summary>
      <returns>an implied join created by this from reference.</returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.DotNode">
      <summary>
            Represents a reference to a property or alias expression.  This should duplicate the relevant behaviors in
            PathExpressionParser.
            Author: Joshua Davis
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._path">
      <summary>
            The full path, to the root alias of this dot node.
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._dereferenceType">
      <summary>
            The type of dereference that hapened (DEREF_xxx).
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._propertyName">
      <summary>
            The identifier that is the name of the property.
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._propertyPath">
      <summary>
            The unresolved property path relative to this dot node.
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._columns">
      <summary>
            The column names that this resolves to.
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._fetch">
      <summary>
            Fetch join or not.
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.DotNode._joinType">
      <summary>
            The type of join to create.   Default is an inner join.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.DotNode.IsReferenceToPrimaryKey(System.String,NHibernate.Type.EntityType)">
      <summary>
            Is the given property name a reference to the primary key of the associated
            entity construed by the given entity type?
            For example, consider a fragment like order.customer.id
            (where order is a from-element alias).  Here, we'd have:
            propertyName = "id" AND
            owningType = ManyToOneType(Customer)
            and are being asked to determine whether "customer.id" is a reference
            to customer's PK...
            </summary>
      <param name="propertyName">The name of the property to check.</param>
      <param name="owningType">The type represeting the entity "owning" the property</param>
      <returns>True if propertyName references the entity's (owningType-&gt;associatedEntity) primary key; false otherwise.</returns>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.DotNode.JoinType">
      <summary>
            Sets the join type for this '.' node structure.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.DotNode.Path">
      <summary>
            Returns the full path of the node.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.FromClause">
      <summary>
            Represents the 'FROM' part of a query or subquery, containing all mapped class references.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.FromClause._fromElementCounter">
      <summary>
            Counts the from elements as they are added.
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.FromClause._collectionJoinFromElementsByPath">
      <summary>
            All of the implicit FROM xxx JOIN yyy elements that are the destination of a collection.  These are created from
            index operators on collection property references.
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.FromClause._parentFromClause">
      <summary>
            Pointer to the parent FROM clause, if there is one.
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Tree.FromClause._childFromClauses">
      <summary>
            Collection of FROM clauses of which this is the parent.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.IsFromElementAlias(System.String)">
      <summary>
            Convenience method to check whether a given token represents a from-element alias.
            </summary>
      <param name="possibleAlias">The potential from-element alias to check.</param>
      <returns>True if the possibleAlias is an alias to a from-element visible from this point in the query graph.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.ContainsClassAlias(System.String)">
      <summary>
            Returns true if the from node contains the class alias name.
            </summary>
      <param name="alias">The HQL class alias name.</param>
      <returns>true if the from node contains the class alias name.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.ContainsTableAlias(System.String)">
      <summary>
            Returns true if the from node contains the table alias name.
            </summary>
      <param name="alias">The SQL table alias name.</param>
      <returns>true if the from node contains the table alias name.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.AddFromElement(System.String,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
      <summary>
            Adds a new from element to the from node.
            </summary>
      <param name="path">The reference to the class.</param>
      <param name="alias">The alias AST.</param>
      <returns>The new FROM element.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.GetFromElement(System.String)">
      <summary>
            Retreives the from-element represented by the given alias.
            </summary>
      <param name="aliasOrClassName">The alias by which to locate the from-element.</param>
      <returns>The from-element assigned the given alias, or null if none.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.GetFromElements">
      <summary>
            Returns the list of from elements in order.
            </summary>
      <returns>The list of from elements (instances of FromElement).</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.GetProjectionList">
      <summary>
            Returns the list of from elements that will be part of the result set.
            </summary>
      <returns>the list of from elements that will be part of the result set.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromClause.FindJoinByPath(System.String)">
      <summary>
            Look for an existing implicit or explicit join by the given path.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IParameterContainer">
      <summary>
            Currently this is needed in order to deal with {@link FromElement FromElements} which
            contain "hidden" JDBC parameters from applying filters.
            Would love for this to go away, but that would require that Hibernate's
            internal {@link org.hibernate.engine.JoinSequence join handling} be able to either:<ul><li>render the same AST structures</li><li>render structures capable of being converted to these AST structures</li></ul>
            In the interim, this allows us to at least treat these "hidden" parameters properly which is
            the most pressing need.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IParameterContainer.AddEmbeddedParameter(NHibernate.Param.IParameterSpecification)">
      <summary>
            Adds a parameter specification for a parameter encountered within this node.  We use the term 'embedded' here
            because of the fact that the parameter was simply encountered as part of the node's text; it does not exist
            as part of a subtree as it might in a true AST.
            </summary>
      <param name="specification">The generated specification.</param>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IParameterContainer.GetEmbeddedParameters">
      <summary>
            Retrieve all embedded parameter specifications.
            </summary>
      <returns>All embedded parameter specifications; may return null.</returns>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IParameterContainer.Text">
      <summary>
            Set the renderable text of this node.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.IParameterContainer.HasEmbeddedParameters">
      <summary>
            Determine whether this node contans embedded parameters.  The implication is that
            {@link #getEmbeddedParameters()} is allowed to return null if this method returns false.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElement.RenderIdentifierSelect(System.Int32,System.Int32)">
      <summary>
            Returns the identifier select SQL fragment.
            </summary>
      <param name="size">The total number of returned types.</param>
      <param name="k">The sequence of the current returned type.</param>
      <returns>the identifier select SQL fragment.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElement.RenderPropertySelect(System.Int32,System.Int32)">
      <summary>
            Returns the property select SQL fragment.
            </summary>
      <param name="size">The total number of returned types.</param>
      <param name="k">The sequence of the current returned type.</param>
      <returns>the property select SQL fragment.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElement.RenderScalarIdentifierSelect(System.Int32)">
      <summary>
            Render the identifier select, but in a 'scalar' context (i.e. generate the column alias).
            </summary>
      <param name="i">the sequence of the returned type</param>
      <returns>the identifier select with the column alias.</returns>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.FromElement.IsImplied">
      <summary>
            Returns true if this FromElement was implied by a path, or false if this FROM element is explicitly declared in
            the FROM clause.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementFactory.#ctor(NHibernate.Hql.Ast.ANTLR.Tree.FromClause,NHibernate.Hql.Ast.ANTLR.Tree.FromElement,System.String)">
      <summary>
            Creates entity from elements.
            </summary>
      <param name="fromClause">
      </param>
      <param name="origin">
      </param>
      <param name="path">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementFactory.#ctor(NHibernate.Hql.Ast.ANTLR.Tree.FromClause,NHibernate.Hql.Ast.ANTLR.Tree.FromElement,System.String,System.String,System.String[],System.Boolean)">
      <summary>
            Creates collection from elements.
            </summary>
      <param name="fromClause">
      </param>
      <param name="origin">
      </param>
      <param name="path">
      </param>
      <param name="classAlias">
      </param>
      <param name="columns">
      </param>
      <param name="implied">
      </param>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType">
      <summary>
            Delegate that handles the type and join sequence information for a FromElement.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType.RenderIdentifierSelect(System.Int32,System.Int32)">
      <summary>
            Returns the identifier select SQL fragment.
            </summary>
      <param name="size">The total number of returned types.</param>
      <param name="k">The sequence of the current returned type.</param>
      <returns>the identifier select SQL fragment.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType.RenderScalarIdentifierSelect(System.Int32)">
      <summary>
            Render the identifier select, but in a 'scalar' context (i.e. generate the column alias).
            </summary>
      <param name="i">the sequence of the returned type</param>
      <returns>the identifier select with the column alias.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType.RenderPropertySelect(System.Int32,System.Int32,System.Boolean)">
      <summary>
            Returns the property select SQL fragment.
            </summary>
      <param name="size">The total number of returned types.</param>
      <param name="k">The sequence of the current returned type.</param>
      <param name="allProperties">
      </param>
      <returns>the property select SQL fragment.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType.GetPropertyType(System.String,System.String)">
      <summary>
            Returns the type of a property, given it's name (the last part) and the full path.
            </summary>
      <param name="propertyName">The last part of the full path to the property.</param>
      <param name="propertyPath">The full property path.</param>
      <returns>The type</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType.TrimLeadingCommaAndSpaces(System.String)">
      <summary>
            This accounts for a quirk in Queryable, where it sometimes generates ',  ' in front of the
            SQL fragment.  :-P
            </summary>
      <param name="fragment">A SQL fragment.</param>
      <returns>The fragment, without the leading comma and spaces.</returns>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.FromElementType.Queryable">
      <summary>
            Returns the Hibernate queryable implementation for the HQL class.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.HqlSqlWalkerTreeNodeStream.InsertChild(NHibernate.Hql.Ast.ANTLR.Tree.IASTNode,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
      <summary>
            Insert a new node into both the Tree and the Node Array. Add DOWN and UP nodes if needed.
            </summary>
      <param name="parent">The parent node</param>
      <param name="child">The child node</param>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.HqlSqlWalkerTreeNodeStream.NumberOfChildNodes(System.Int32)">
      <summary>
            Count the number of child nodes (including DOWNs and UPs) of a parent node
            </summary>
      <param name="parentIndex">The index of the parent in the node array</param>
      <returns>The number of child nodes</returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IndexNode">
      <summary>
            Represents the [] operator and provides it's semantics.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.InLogicOperatorNode">
      <summary>
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.InsertStatement">
      <summary> 
            Defines a top-level AST node representing an HQL "insert select" statement. 
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.InsertStatement.Validate">
      <summary> Performs detailed semantic validation on this insert statement tree. </summary>
      <exception cref="T:NHibernate.QueryException">Indicates validation failure.</exception>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.InsertStatement.IntoClause">
      <summary> Retreive this insert statement's into-clause. </summary>
      <returns> The into-clause </returns>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.InsertStatement.SelectClause">
      <summary> Retreive this insert statement's select-clause.</summary>
      <returns> The select-clause. </returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IntoClause">
      <summary>
            Represents an entity referenced in the INTO clause of an HQL
            INSERT statement.
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IntoClause.GetDisplayText">
      <summary>
            Returns additional display text for the AST node.
            </summary>
      <returns>The additional display text.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.IntoClause.AreCompatible(NHibernate.Type.IType,NHibernate.Type.IType)">
      <summary>
            Determine whether the two types are "assignment compatible".
            </summary>
      <param name="target">The type defined in the into-clause.</param>
      <param name="source">The type defined in the select clause.</param>
      <returns>True if they are assignment compatible.</returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.ISessionFactoryAwareNode">
      <summary>
            Interface for nodes which require access to the SessionFactory
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IsNotNullLogicOperatorNode">
      <summary>
            IsNotNullLogicOperatorNode implementation
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.IsNullLogicOperatorNode">
      <summary>
            Represents a 'is null' check.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.JavaConstantNode">
      <summary>
            A node representing a static Java constant.
            
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.OrderByClause">
      <summary>
            Implementation of OrderByClause.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.ParameterNode">
      <summary>
            Implementation of ParameterNode.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.QueryNode.GetSelectClause">
      <summary>
            Locate the select clause that is part of this select statement.
            Note, that this might return null as derived select clauses (i.e., no
            select clause at the HQL-level) get generated much later than when we
            get created; thus it depends upon lifecycle.
            </summary>
      <returns>Our select clause, or null.</returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause">
      <summary>
            Represents the list of expressions in a SELECT clause.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.InitializeDerivedSelectClause(NHibernate.Hql.Ast.ANTLR.Tree.FromClause)">
             Prepares a derived (i.e., not explicitly defined in the query) select clause.
            
             @param fromClause The from clause to which this select clause is linked.
        </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.InitializeExplicitSelectClause(NHibernate.Hql.Ast.ANTLR.Tree.FromClause)">
             Prepares an explicitly defined select clause.
            
             @param fromClause The from clause linked to this select clause.
             @throws SemanticException
        </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.FromElementsForLoad">
      <summary>
            FromElements which need to be accounted for in the load phase (either for return or for fetch).
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.ColumnNames">
      <summary>
            The column alias names being used in the generated SQL.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.Constructor">
      <summary>
            The constructor to use for dynamic instantiation queries.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.QueryReturnAliases">
      <summary>
            The HQL aliases, or generated aliases
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.Tree.SelectClause.QueryReturnTypes">
      <summary>
            The types actually being returned from this query at the "object level".
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.SelectExpressionImpl">
      <summary>
            A select expression that was generated by a FROM element.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.SqlFragment">
      <summary>
            Represents an SQL fragment in the AST.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Tree.UpdateStatement">
      <summary> 
            Defines a top-level AST node representing an HQL update statement. 
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Util.AliasGenerator">
      <summary>
            Generates class/table/column aliases during semantic analysis and SQL rendering.
            Its essential purpose is to keep an internal counter to ensure that the
            generated aliases are unique.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Util.ASTAppender">
      <summary>
            Appends child nodes to a parent efficiently.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Util.ASTIterator">
      <summary>
            Depth first iteration of an ANTLR AST.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Util.ASTUtil.GetDebugstring(NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
      <summary>
            Returns the 'list' representation with some brackets around it for debugging.
            </summary>
      <param name="n">The tree.</param>
      <returns>The list representation of the tree.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Util.ASTUtil.IsSubtreeChild(NHibernate.Hql.Ast.ANTLR.Tree.IASTNode,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
      <summary>
            Determine if a given node (test) is contained anywhere in the subtree
            of another given node (fixture).
            </summary>
      <param name="fixture">The node against which to be checked for children.</param>
      <param name="test">The node to be tested as being a subtree child of the parent.</param>
      <returns>True if child is contained in the parent's collection of children.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Util.ASTUtil.FindTypeInChildren(NHibernate.Hql.Ast.ANTLR.Tree.IASTNode,System.Int32)">
      <summary>
            Finds the first node of the specified type in the chain of children.
            </summary>
      <param name="parent">The parent</param>
      <param name="type">The type to find.</param>
      <returns>The first node of the specified type, or null if not found.</returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Util.FilterPredicate">
      <summary>
            Filters nodes in/out of a tree.
            </summary>
      <param name="node">The node to check.</param>
      <returns>true to keep the node, false if the node should be filtered out.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Util.ColumnHelper.GenerateScalarColumns(NHibernate.Hql.Ast.ANTLR.Tree.IASTFactory,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode,System.String[],System.Int32)">
      <summary>
            Generates the scalar column AST nodes for a given array of SQL columns
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Util.JoinProcessor">
      <summary>
            Performs the post-processing of the join information gathered during semantic analysis.
            The join generating classes are complex, this encapsulates some of the JoinSequence-related
            code.
            Author: Joshua Davis
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Util.JoinProcessor.#ctor(NHibernate.Hql.Ast.ANTLR.HqlSqlWalker)">
      <summary>
            Constructs a new JoinProcessor.
            </summary>
      <param name="walker">The walker to which we are bound, giving us access to needed resources.</param>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Util.JoinProcessor.ToHibernateJoinType(System.Int32)">
      <summary>
            Translates an AST join type (i.e., the token type) into a JoinFragment.XXX join type.
            </summary>
      <param name="astJoinType">The AST join type (from HqlSqlWalker)</param>
      <returns>a JoinType.XXX join type.</returns>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Util.LiteralProcessor.EXACT">
      <summary>
             Indicates that Float and Double literal values should
            be treated using the SQL "exact" format (i.e., '.001')
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Util.LiteralProcessor.APPROXIMATE">
      <summary>
            Indicates that Float and Double literal values should
            be treated using the SQL "approximate" format (i.e., '1E-3')
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.Util.LiteralProcessor.DECIMAL_LITERAL_FORMAT">
      <summary>
            In what format should Float and Double literal values be sent
            to the database?
            See #EXACT, #APPROXIMATE
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Util.NodeTraverser.TraverseDepthFirst(NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
      <summary>
            Traverse the AST tree depth first. Note that the AST passed in is not visited itself.  Visitation starts
            with its children.
            </summary>
      <param name="ast">ast</param>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.Util.PathHelper.ParsePath(System.String,NHibernate.Hql.Ast.ANTLR.Tree.IASTFactory)">
      <summary>
            Turns a path into an AST.
            </summary>
      <param name="path">The path.</param>
      <param name="factory">The AST factory to use.</param>
      <returns>An HQL AST representing the path.</returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.Util.SyntheticAndFactory">
      <summary>
            Creates synthetic and nodes based on the where fragment part of a JoinSequence.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.IQueryTranslatorFactory">
      <summary>
            Facade for generation of <see cref="T:NHibernate.Hql.IQueryTranslator" /> 
            and <see cref="T:NHibernate.Hql.IFilterTranslator" /> instances.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.IQueryTranslatorFactory.CreateQueryTranslator(System.String,System.String,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter},NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Construct a <see cref="T:NHibernate.Hql.IQueryTranslator" /> instance 
            capable of translating an HQL query string.
            </summary>
      <param name="queryIdentifier">
            The query-identifier (used in <see cref="T:NHibernate.Stat.QueryStatistics" /> collection). 
            This is typically the same as the queryString parameter except for the case of
            split polymorphic queries which result in multiple physical sql queries.
            </param>
      <param name="queryString">The query string to be translated</param>
      <param name="filters">Currently enabled filters</param>
      <param name="factory">The session factory</param>
      <returns>An appropriate translator.</returns>
    </member>
    <member name="M:NHibernate.Hql.IQueryTranslatorFactory.CreateFilterTranslator(System.String,System.String,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter},NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Construct a <see cref="T:NHibernate.Hql.IFilterTranslator" /> instance capable of 
            translating an HQL filter string.
            </summary>
      <param name="queryIdentifier">
            The query-identifier (used in <see cref="T:NHibernate.Stat.QueryStatistics" /> collection). 
            This is typically the same as the queryString parameter except for the case of
            split polymorphic queries which result in multiple physical sql queries.
            </param>
      <param name="queryString">The query string to be translated</param>
      <param name="filters">Currently enabled filters</param>
      <param name="factory">The session factory</param>
      <returns>An appropriate translator.</returns>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.ASTQueryTranslatorFactory">
      <summary>
            Generates translators which uses the Antlr-based parser to perform
            the translation.
            
            Author: Gavin King
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.CaseInsensitiveStringStream">
      <summary>
             Look ahead for tokenizing is all lowercase, whereas the original case of an input stream is preserved.
             Copied from http://www.antlr.org/wiki/pages/viewpage.action?pageId=1782
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.CollectionProperties">
      <summary>
            Provides a map of collection function names to the corresponding property names.
            Authoer: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.QueryException">
      <summary>
            A problem occurred translating a Hibernate query to SQL due to invalid query syntax, etc.
            </summary>
    </member>
    <member name="M:NHibernate.QueryException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.QueryException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.QueryException.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="queryString">The query that contains the error.</param>
    </member>
    <member name="M:NHibernate.QueryException.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException" /> class.
            </summary>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.QueryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="M:NHibernate.QueryException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Sets the serialization info for <see cref="T:NHibernate.QueryException" /> after 
            getting the info from the base Exception.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="P:NHibernate.QueryException.QueryString">
      <summary>
            Gets or sets the <see cref="T:System.String" /> of HQL that caused the Exception.
            </summary>
    </member>
    <member name="P:NHibernate.QueryException.Message">
      <summary>
            Gets a message that describes the current <see cref="T:NHibernate.QueryException" />.
            </summary>
      <value>The error message that explains the reason for this exception including the HQL.</value>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.IParseErrorHandler">
      <summary>
            Defines the behavior of an error handler for the HQL parsers.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.ErrorCounter">
      <summary>
            An error handler that counts parsing errors and warnings.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.HqlToken">
      <summary>
            A custom token class for the HQL grammar.
            </summary>
    </member>
    <member name="F:NHibernate.Hql.Ast.ANTLR.HqlToken._previousTokenType">
      <summary>
            The previous token type.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.HqlToken.#ctor(Antlr.Runtime.ICharStream,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Public constructor
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.HqlToken.ToString">
      <summary>
            Returns a string representation of the object.
            </summary>
      <returns>The debug string</returns>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.HqlToken.PossibleId">
      <summary>
            Indicates if the token could be an identifier.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.HqlToken.Type">
      <summary>
            Gets or Sets the type of the token, remembering the previous type on Sets.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Ast.ANTLR.HqlToken.PreviousType">
      <summary>
            Returns the previous token type.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Ast.ANTLR.InvalidPathException">
      <summary>
            Exception thrown when an invalid path is found in a query.
            Author: josh
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Hql.IQueryTranslator">
      <summary>
            Defines the constract of an HQL-&gt;SQL translator.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.IQueryTranslator.Compile(System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
      <summary>
            Compile a "normal" query. This method may be called multiple times. Subsequent invocations are no-ops.
            </summary>
      <param name="replacements">Defined query substitutions.</param>
      <param name="shallow">Does this represent a shallow (scalar or entity-id) select?</param>
      <exception cref="T:NHibernate.QueryException">There was a problem parsing the query string.</exception>
      <exception cref="T:NHibernate.MappingException">There was a problem querying defined mappings.</exception>
    </member>
    <member name="M:NHibernate.Hql.IQueryTranslator.List(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters)">
      <summary>
            Perform a list operation given the underlying query definition.
            </summary>
      <param name="session">The session owning this query.</param>
      <param name="queryParameters">The query bind parameters.</param>
      <returns>The query list results.</returns>
      <exception cref="T:NHibernate.HibernateException">
      </exception>
    </member>
    <member name="M:NHibernate.Hql.IQueryTranslator.ExecuteUpdate(NHibernate.Engine.QueryParameters,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Perform a bulk update/delete operation given the underlying query defintion.
            </summary>
      <param name="queryParameters">The query bind parameters.</param>
      <param name="session">The session owning this query.</param>
      <returns>The number of entities updated or deleted.</returns>
      <exception cref="T:NHibernate.HibernateException">
      </exception>
    </member>
    <member name="M:NHibernate.Hql.IQueryTranslator.GetColumnNames">
      <summary>
            Returns the column names in the generated SQL.
            </summary>
      <returns>the column names in the generated SQL.</returns>
    </member>
    <member name="M:NHibernate.Hql.IQueryTranslator.GetParameterTranslations">
      <summary>
            Information about any parameters encountered during translation.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.IQueryTranslator.QuerySpaces">
      <summary>
            The set of query spaces (table names) that the query referrs to.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.IQueryTranslator.SQLString">
      <summary>
            The SQL string generated by the translator.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.IQueryTranslator.QueryString">
      <summary>
            The HQL string processed by the translator.
            </summary>
    </member>
    <member name="P:NHibernate.Hql.IQueryTranslator.EnabledFilters">
      <summary>
            Returns the filters enabled for this query translator.
            </summary>
      <returns>Filters enabled for this query execution.</returns>
    </member>
    <member name="P:NHibernate.Hql.IQueryTranslator.ReturnTypes">
      <summary>
            Returns an array of Types represented in the query result.
            </summary>
      <returns>Query return types.</returns>
    </member>
    <member name="P:NHibernate.Hql.IQueryTranslator.ReturnAliases">
      <summary>
            Returns an array of HQL aliases
            </summary>
      <returns>Returns an array of HQL aliases</returns>
    </member>
    <member name="P:NHibernate.Hql.IQueryTranslator.ContainsCollectionFetches">
      <summary>
            Does the translated query contain collection fetches?
            </summary>
      <returns>True if the query does contain collection fetched; false otherwise.</returns>
    </member>
    <member name="T:NHibernate.Hql.IFilterTranslator">
      <summary> 
            Specialized interface for filters.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.IFilterTranslator.Compile(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
      <summary> 
            Compile a filter. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
      <param name="collectionRole">the role name of the collection used as the basis for the filter.</param>
      <param name="replacements">Defined query substitutions.</param>
      <param name="shallow">Does this represent a shallow (scalar or entity-id) select?</param>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.QueryTranslatorImpl.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter},NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Creates a new AST-based query translator.
            </summary>
      <param name="queryIdentifier">The query-identifier (used in stats collection)</param>
      <param name="query">The hql query to translate</param>
      <param name="enabledFilters">Currently enabled filters</param>
      <param name="factory">The session factory constructing this translator instance.</param>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.QueryTranslatorImpl.Compile(System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
      <summary>
            Compile a "normal" query. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
      <param name="replacements">Defined query substitutions.</param>
      <param name="shallow">Does this represent a shallow (scalar or entity-id) select?</param>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.QueryTranslatorImpl.Compile(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
      <summary>
            Compile a filter. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
      <param name="collectionRole">the role name of the collection used as the basis for the filter.</param>
      <param name="replacements">Defined query substitutions.</param>
      <param name="shallow">Does this represent a shallow (scalar or entity-id) select?</param>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.QueryTranslatorImpl.DoCompile(System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean,System.String)">
      <summary>
            Performs both filter and non-filter compiling.
            </summary>
      <param name="replacements">Defined query substitutions.</param>
      <param name="shallow">Does this represent a shallow (scalar or entity-id) select?</param>
      <param name="collectionRole">the role name of the collection used as the basis for the filter, NULL if this is not a filter.</param>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.#ctor(NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Construct a new SessionFactoryHelperExtensions instance.
            </summary>
      <param name="sfi">The SessionFactory impl to be encapsulated.</param>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.FindSQLFunction(System.String)">
      <summary>
            Locate a registered sql function by name.
            </summary>
      <param name="functionName">The name of the function to locate</param>
      <returns>The sql function, or null if not found.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.RequireSQLFunction(System.String)">
      <summary>
            Locate a registered sql function by name.
            </summary>
      <param name="functionName">The name of the function to locate</param>
      <returns>The sql function, or throws QueryException if no matching sql functions could be found.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.FindFunctionReturnType(System.String,NHibernate.Hql.Ast.ANTLR.Tree.IASTNode)">
      <summary>
            Find the function return type given the function name and the first argument expression node.
            </summary>
      <param name="functionName">The function name.</param>
      <param name="first">The first argument expression.</param>
      <returns>the function return type given the function name and the first argument expression node.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetImportedClassName(System.String)">
      <summary>
            Given a (potentially unqualified) class name, locate its imported qualified name.
            </summary>
      <param name="className">The potentially unqualified class name</param>
      <returns>The qualified class name.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.HasPhysicalDiscriminatorColumn(NHibernate.Persister.Entity.IQueryable)">
      <summary>
            Does the given persister define a physical discriminator column
            for the purpose of inheritence discrimination?
            </summary>
      <param name="persister">The persister to be checked.</param>
      <returns>True if the persister does define an actual discriminator column.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetCollectionPersister(System.String)">
      <summary>
            Locate the collection persister by the collection role.
            </summary>
      <param name="collectionFilterRole">The collection role name.</param>
      <returns>The defined CollectionPersister for this collection role, or null.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetIdentifierOrUniqueKeyPropertyName(NHibernate.Type.EntityType)">
      <summary>
            Determine the name of the property for the entity encapsulated by the
            given type which represents the id or unique-key.
            </summary>
      <param name="entityType">The type representing the entity.</param>
      <returns>The corresponding property name</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetCollectionElementColumns(System.String,System.String)">
      <summary>
            Retrieves the column names corresponding to the collection elements for the given
            collection role.
            </summary>
      <param name="role">The collection role</param>
      <param name="roleAlias">The sql column-qualification alias (i.e., the table alias)</param>
      <returns>the collection element columns</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetElementAssociationType(NHibernate.Type.CollectionType)">
      <summary>
            Essentially the same as GetElementType, but requiring that the
            element type be an association type.
            </summary>
      <param name="collectionType">The collection type to be checked.</param>
      <returns>The AssociationType of the elements of the collection.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.RequireQueryableCollection(System.String)">
      <summary>
            Locate the collection persister by the collection role, requiring that
            such a persister exist.
            </summary>
      <param name="role">The collection role name.</param>
      <returns>The defined CollectionPersister for this collection role.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.RequireClassPersister(System.String)">
      <summary>
            Locate the persister by class or entity name, requiring that such a persister
            exist.
            </summary>
      <param name="name">The class or entity name</param>
      <returns>The defined persister for this entity</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.FindQueryableUsingImports(System.String)">
      <summary>
            Given a (potentially unqualified) class name, locate its persister.
            </summary>
      <param name="className">The (potentially unqualified) class name.</param>
      <returns>The defined persister for this class, or null if none found.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.FindQueryableUsingImports(NHibernate.Engine.ISessionFactoryImplementor,System.String)">
      <summary>
            Given a (potentially unqualified) class name, locate its persister.
            </summary>
      <param name="sfi">The session factory implementor.</param>
      <param name="className">The (potentially unqualified) class name.</param>
      <returns>The defined persister for this class, or null if none found.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.FindEntityPersisterByName(System.String)">
      <summary>
            Locate the persister by class or entity name.
            </summary>
      <param name="name">The class or entity name</param>
      <returns>The defined persister for this entity, or null if none found.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.CreateCollectionJoinSequence(NHibernate.Persister.Collection.IQueryableCollection,System.String)">
      <summary>
            Create a join sequence rooted at the given collection.
            </summary>
      <param name="collPersister">The persister for the collection at which the join should be rooted.</param>
      <param name="collectionName">The alias to use for qualifying column references.</param>
      <returns>The generated join sequence.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.CreateJoinSequence">
      <summary>
            Generate an empty join sequence instance.
            </summary>
      <returns>The generated join sequence.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.CreateJoinSequence(System.Boolean,NHibernate.Type.IAssociationType,System.String,NHibernate.SqlCommand.JoinType,System.String[])">
      <summary>
            Generate a join sequence representing the given association type.
            </summary>
      <param name="implicitJoin">Should implicit joins (theta-style) or explicit joins (ANSI-style) be rendered</param>
      <param name="associationType">The type representing the thing to be joined into.</param>
      <param name="tableAlias">The table alias to use in qualifing the join conditions</param>
      <param name="joinType">The type of join to render (inner, outer, etc)</param>
      <param name="columns">The columns making up the condition of the join.</param>
      <returns>The generated join sequence.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetCollectionPropertyMapping(System.String)">
      <summary>
            Retreive a PropertyMapping describing the given collection role.
            </summary>
      <param name="role">The collection role for whcih to retrieve the property mapping.</param>
      <returns>The property mapping.</returns>
    </member>
    <member name="M:NHibernate.Hql.Ast.ANTLR.SessionFactoryHelperExtensions.GetElementType(NHibernate.Type.CollectionType)">
      <summary>
            Given a collection type, determine the Type representing elements
            within instances of that collection.
            </summary>
      <param name="collectionType">The collection type to be checked.</param>
      <returns>The Type of the elements of the collection.</returns>
    </member>
    <member name="T:NHibernate.Hql.Classic.ClassicQueryTranslatorFactory">
      <summary>
            Generates translators which uses the older hand-written parser to perform the translation.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Classic.IParser">
      <summary> 
            A parser is a state machine that accepts a string of tokens,
            bounded by start() and end() and modifies a QueryTranslator. Parsers
            are NOT intended to be threadsafe. They SHOULD be reuseable
            for more than one token stream.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.IParser.Token(System.String,NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="token">
      </param>
      <param name="q">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.IParser.Start(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="q">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.IParser.End(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="q">
      </param>
    </member>
    <member name="T:NHibernate.Hql.Classic.ClauseParser">
      <summary> 
            Parses the hibernate query into its constituent clauses.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Classic.FromParser">
      <summary> 
            Parses the from clause of a hibernate query, looking for tables and
            aliases for the SQL query.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Classic.PathExpressionParser">
      <summary> 
            Parses an expression of the form foo.bar.baz and builds up an expression
            involving two less table joins than there are path components.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Classic.PathExpressionParser.CollectionElement">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.PathExpressionParser.DereferenceEntity(System.String,NHibernate.Type.EntityType,NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="propertyName">
      </param>
      <param name="propertyType">
      </param>
      <param name="q">
      </param>
      <remarks>NOTE: we avoid joining to the next table if the named property is just the foreign key value</remarks>
    </member>
    <member name="M:NHibernate.Hql.Classic.PathExpressionParser.CurrentColumns">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Hql.Classic.PathExpressionParser.Start(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="q">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.PathExpressionParser.End(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="q">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.PathExpressionParser.LastCollectionElement">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.PathExpressionParser.SetLastCollectionElementIndexValue(NHibernate.SqlCommand.SqlString)">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.PathExpressionParser.SetExpectingCollectionIndex">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.PathExpressionParser.GetCollectionSubquery(System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.PathExpressionParser.AddAssociation(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="q">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.PathExpressionParser.AddFromAssociation(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="q">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Hql.Classic.PathExpressionParser.AddFromCollection(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="q">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Hql.Classic.PathExpressionParser.Fetch(NHibernate.Hql.Classic.QueryTranslator,System.String)">
      <summary>
      </summary>
      <param name="q">
      </param>
      <param name="entityName">
      </param>
    </member>
    <member name="P:NHibernate.Hql.Classic.PathExpressionParser.PropertyType">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Hql.Classic.PathExpressionParser.IsExpectingCollectionIndex">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.PathExpressionParser.WhereColumn">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.PathExpressionParser.WhereColumns">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.PathExpressionParser.WhereColumnType">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.PathExpressionParser.Name">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.PathExpressionParser.IsCollectionValued">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.PathExpressionParser.CollectionName">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.PathExpressionParser.CollectionRole">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.PathExpressionParser.CollectionOwnerName">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.PathExpressionParser.CurrentName">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.PathExpressionParser.CurrentProperty">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Hql.Classic.FromPathExpressionParser">
      <summary>
            FromPathExpressionParser
            </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.FunctionStack.FunctionHolder.FirstValidColumnType">
      <summary>
            Used to hold column type in nested functions.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Classic.GroupByParser">
      <summary> 
            Parses the GROUP BY clause of an aggregate query
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Classic.WhereParser">
      <summary> Parses the where clause of a hibernate query and translates it to an
            SQL where clause.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.WhereParser.Token(System.String,NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="token">
      </param>
      <param name="q">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.WhereParser.Start(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="q">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.WhereParser.End(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="q">
      </param>
    </member>
    <member name="T:NHibernate.Hql.Classic.HavingParser">
      <summary> 
            Parses the having clause of a hibernate query and translates it to an
            SQL having clause.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Classic.OrderByParser">
      <summary> 
            Parses the ORDER BY clause of a query
            </summary>
    </member>
    <member name="T:NHibernate.Hql.Classic.ParserHelper">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Hql.Classic.PreprocessingParser">
      <summary>HQL lexical analyzer (not really a parser)</summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.PreprocessingParser.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
      </summary>
      <param name="replacements">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.PreprocessingParser.Token(System.String,NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="token">
      </param>
      <param name="q">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.PreprocessingParser.Start(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="q">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.PreprocessingParser.End(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="q">
      </param>
    </member>
    <member name="T:NHibernate.Hql.Classic.QueryTranslator">
      <summary> 
            An instance of <c>QueryTranslator</c> translates a Hibernate query string to SQL.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.QueryTranslator.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter},NHibernate.Engine.ISessionFactoryImplementor)">
      <summary> Construct a query translator </summary>
      <param name="queryIdentifier">
            A unique identifier for the query of which this
            translation is part; typically this is the original, user-supplied query string.
            </param>
      <param name="queryString">
            The "preprocessed" query string; at the very least
            already processed by {@link org.hibernate.hql.QuerySplitter}.
            </param>
      <param name="enabledFilters">Any enabled filters.</param>
      <param name="factory">The session factory. </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.QueryTranslator.#ctor(NHibernate.Engine.ISessionFactoryImplementor,System.String,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
      <summary> 
            Construct a query translator
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.QueryTranslator.Compile(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
            Compile a subquery
            </summary>
      <param name="superquery">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.QueryTranslator.Compile(System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
      <summary>
            Compile a "normal" query. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.QueryTranslator.Compile(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Boolean)">
      <summary>
            Compile a filter. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.QueryTranslator.Compile">
      <summary> 
            Compile the query (generate the SQL).
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.QueryTranslator.RenderScalarSelect">
      <summary> 
            WARNING: side-effecty
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.QueryTranslator.ExtractFunctionClause(System.Collections.Generic.IList{NHibernate.SqlCommand.SqlString},System.Int32@)">
      <summary>
            Extract the complete clause of function.
            </summary>
      <param name="tokens">The list of tokens</param>
      <param name="tokenIdx">The index of the list that represent the founded function.</param>
      <returns>String trepresentation of each token.</returns>
      <remarks>Each token can be string or SqlString </remarks>
    </member>
    <member name="M:NHibernate.Hql.Classic.QueryTranslator.AddFromAssociation(System.String,System.String)">
      <remarks>Used for collection filters</remarks>
    </member>
    <member name="P:NHibernate.Hql.Classic.QueryTranslator.EntityPersisters">
      <summary>
            Persisters for the return values of a <c>List</c> style query
            </summary>
      <remarks>
            The <c>Persisters</c> stored by QueryTranslator have to be <see cref="T:NHibernate.Persister.Entity.IQueryable" />.  The
            <c>setter</c> will attempt to cast the <c>ILoadable</c> array passed in into an 
            <c>IQueryable</c> array.
            </remarks>
    </member>
    <member name="P:NHibernate.Hql.Classic.QueryTranslator.ReturnTypes">
      <summary>
            Types of the return values of an <c>Enumerate()</c> style query.
            Return an array of <see cref="T:NHibernate.Type.IType" />s.
             </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.QueryTranslator.SqlString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.QueryTranslator.IsShallowQuery">
      <summary>
            Is this query called by Scroll() or Iterate()?
            </summary>
      <value>true if it is, false if it is called by find() or list()</value>
    </member>
    <member name="P:NHibernate.Hql.Classic.QueryTranslator.IsSubquery">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.QueryTranslator.Owners">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Hql.Classic.SelectParser">
      <summary>
            Parsers the select clause of a hibernate query, looking
            for a table (well, really class) alias.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.SelectParser.#ctor">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Hql.Classic.SelectPathExpressionParser">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Hql.Classic.SelectPathExpressionParser.End(NHibernate.Hql.Classic.QueryTranslator)">
      <summary>
      </summary>
      <param name="q">
      </param>
    </member>
    <member name="M:NHibernate.Hql.Classic.SelectPathExpressionParser.SetExpectingCollectionIndex">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Hql.Classic.SelectPathExpressionParser.SelectName">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Hql.Util.SessionFactoryHelper">
      <summary>
            Wraps SessionFactoryImpl, adding more lookup behaviors and encapsulating some of the error handling.
            </summary>
    </member>
    <member name="T:NHibernate.Hql.NameGenerator">
      <summary>
            Provides utility methods for generating HQL / SQL names.
            Shared by both the 'classic' and 'new' query translators.
            </summary>
    </member>
    <member name="M:NHibernate.Hql.QuerySplitter.ConcreteQueries(System.String,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Handle Hibernate "implicit" polymorphism, by translating the query string into 
            several "concrete" queries against mapped classes.
            </summary>
      <param name="query">
      </param>
      <param name="factory">
      </param>
      <returns>
      </returns>
      <exception cref="T:NHibernate.MappingException" />
    </member>
    <member name="T:NHibernate.Id.Enhanced.IAccessCallback">
      <summary>
            Contract for providing callback access to a <see cref="T:NHibernate.Id.Enhanced.IDatabaseStructure" />,
            typically from the <see cref="T:NHibernate.Id.Enhanced.IOptimizer" />.
            </summary>
    </member>
    <member name="P:NHibernate.Id.Enhanced.IAccessCallback.NextValue">
      <summary> Retrieve the next value from the underlying source. </summary>
    </member>
    <member name="T:NHibernate.Id.Enhanced.IDatabaseStructure">
      <summary> 
            Encapsulates definition of the underlying data structure backing a sequence-style generator. 
            </summary>
    </member>
    <member name="M:NHibernate.Id.Enhanced.IDatabaseStructure.BuildCallback(NHibernate.Engine.ISessionImplementor)">
      <summary> 
            A callback to be able to get the next value from the underlying
            structure as needed.
             </summary>
      <param name="session">The session. </param>
      <returns> The next value. </returns>
    </member>
    <member name="M:NHibernate.Id.Enhanced.IDatabaseStructure.Prepare(NHibernate.Id.Enhanced.IOptimizer)">
      <summary> 
            Prepare this structure for use.  Called sometime after instantiation,
            but before first use. 
            </summary>
      <param name="optimizer">The optimizer being applied to the generator. </param>
    </member>
    <member name="M:NHibernate.Id.Enhanced.IDatabaseStructure.SqlCreateStrings(NHibernate.Dialect.Dialect)">
      <summary> Commands needed to create the underlying structures.</summary>
      <param name="dialect">The database dialect being used. </param>
      <returns> The creation commands. </returns>
    </member>
    <member name="M:NHibernate.Id.Enhanced.IDatabaseStructure.SqlDropStrings(NHibernate.Dialect.Dialect)">
      <summary> Commands needed to drop the underlying structures.</summary>
      <param name="dialect">The database dialect being used. </param>
      <returns> The drop commands. </returns>
    </member>
    <member name="P:NHibernate.Id.Enhanced.IDatabaseStructure.Name">
      <summary> The name of the database structure (table or sequence).</summary>
    </member>
    <member name="P:NHibernate.Id.Enhanced.IDatabaseStructure.TimesAccessed">
      <summary> How many times has this structure been accessed through this reference?</summary>
    </member>
    <member name="P:NHibernate.Id.Enhanced.IDatabaseStructure.IncrementSize">
      <summary> The configured increment size</summary>
    </member>
    <member name="T:NHibernate.Id.Enhanced.IOptimizer">
      <summary>
            Performs optimization on an optimizable identifier generator.  Typically
            this optimization takes the form of trying to ensure we do not have to
            hit the database on each and every request to get an identifier value.
            </summary>
      <remarks>
        <para>
            Optimizers work on constructor injection.  They should provide
            a constructor with the following arguments.
            </para>
            - <see cref="T:System.Type" /> The return type for the generated values.
            - <langword>int</langword> The increment size.
            </remarks>
    </member>
    <member name="M:NHibernate.Id.Enhanced.IOptimizer.Generate(NHibernate.Id.Enhanced.IAccessCallback)">
      <summary> 
            Generate an identifier value accounting for this specific optimization. 
            </summary>
      <param name="callback">Callback to access the underlying value source. </param>
      <returns> The generated identifier value. </returns>
    </member>
    <member name="P:NHibernate.Id.Enhanced.IOptimizer.LastSourceValue">
      <summary> 
            A common means to access the last value obtained from the underlying
            source.  This is intended for testing purposes, since accessing the
            unerlying database source directly is much more difficult.
             </summary>
      <value> 
            The last value we obtained from the underlying source;
            -1 indicates we have not yet consulted with the source.
            </value>
    </member>
    <member name="P:NHibernate.Id.Enhanced.IOptimizer.IncrementSize">
      <summary> 
            Defined increment size. 
            </summary>
      <value> The increment size.
            </value>
    </member>
    <member name="P:NHibernate.Id.Enhanced.IOptimizer.ApplyIncrementSizeToSourceValues">
      <summary> 
            Are increments to be applied to the values stored in the underlying
            value source? 
            </summary>
      <returns> 
            True if the values in the source are to be incremented
            according to the defined increment size; false otherwise, in which
            case the increment is totally an in memory construct.
            </returns>
    </member>
    <member name="T:NHibernate.Id.Enhanced.SequenceStructure">
      <summary>
            Describes a sequence.
            </summary>
    </member>
    <member name="T:NHibernate.Id.IIdentifierGenerator">
      <summary>
            The general contract between a class that generates unique
            identifiers and the <see cref="T:NHibernate.ISession" />.
            </summary>
      <remarks>
        <para>
            It is not intended that this interface ever be exposed to the 
            application.  It <b>is</b> intended that users implement this interface
            to provide custom identifier generation strategies.
            </para>
        <para>
            Implementors should provide a public default constructor.
            </para>
        <para>
            Implementations that accept configuration parameters should also
            implement <see cref="T:NHibernate.Id.IConfigurable" />.
            </para>
        <para>
            Implementors <b>must</b> be threadsafe.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Id.IIdentifierGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Generate a new identifier
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this id is being generated in.</param>
      <param name="obj">The entity for which the id is being generated.</param>
      <returns>The new identifier</returns>
    </member>
    <member name="T:NHibernate.Id.IPersistentIdentifierGenerator">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that requires creation of database objects
            All <see cref="T:NHibernate.Id.IPersistentIdentifierGenerator" />s that also implement 
            An <see cref="T:NHibernate.Id.IConfigurable" />  have access to a special mapping parameter: schema
            </summary>
    </member>
    <member name="M:NHibernate.Id.IPersistentIdentifierGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
      <summary>
            The SQL required to create the underlying database objects
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to help with creating the sql.</param>
      <returns>
            An array of <see cref="T:System.String" /> objects that contain the sql to create the 
            necessary database objects.
            </returns>
    </member>
    <member name="M:NHibernate.Id.IPersistentIdentifierGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
      <summary>
            The SQL required to remove the underlying database objects
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to help with creating the sql.</param>
      <returns>
            A <see cref="T:System.String" /> that will drop the database objects.
            </returns>
    </member>
    <member name="M:NHibernate.Id.IPersistentIdentifierGenerator.GeneratorKey">
      <summary>
            Return a key unique to the underlying database objects.
            </summary>
      <returns>
            A key unique to the underlying database objects.
            </returns>
      <remarks>
            Prevents us from trying to create/remove them multiple times
            </remarks>
    </member>
    <member name="T:NHibernate.Id.IConfigurable">
      <summary>
            An <c>IdentiferGenerator</c> that supports "configuration".
            </summary>
    </member>
    <member name="M:NHibernate.Id.IConfigurable.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
      <summary>
            Configure this instance, given the values of parameters
            specified by the user as <c>&lt;param&gt;</c> elements.
            This method is called just once, followed by instantiation.
            </summary>
      <param name="type">The <see cref="T:NHibernate.Type.IType" /> the identifier should be.</param>
      <param name="parms">An <see cref="T:System.Collections.IDictionary" /> of Param values that are keyed by parameter name.</param>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to help with Configuration.</param>
    </member>
    <member name="T:NHibernate.Id.Enhanced.TableStructure">
      <summary>
            Describes a table used to mimic sequence behavior
            </summary>
    </member>
    <member name="T:NHibernate.Id.Insert.IInsertGeneratedIdentifierDelegate">
      <summary> 
            Responsible for handling delegation relating to variants in how
            insert-generated-identifier generator strategies dictate processing:
            <ul><li>building the sql insert statement</li><li>determination of the generated identifier value</li></ul></summary>
    </member>
    <member name="M:NHibernate.Id.Insert.IInsertGeneratedIdentifierDelegate.PrepareIdentifierGeneratingInsert">
      <summary> 
            Build a <see cref="T:NHibernate.SqlCommand.SqlInsertBuilder" /> specific to the delegate's mode
            of handling generated key values. 
            </summary>
      <returns> The insert object. </returns>
    </member>
    <member name="M:NHibernate.Id.Insert.IInsertGeneratedIdentifierDelegate.PerformInsert(NHibernate.SqlCommand.SqlCommandInfo,NHibernate.Engine.ISessionImplementor,NHibernate.Id.Insert.IBinder)">
      <summary> 
            Perform the indicated insert SQL statement and determine the identifier value generated. 
            </summary>
      <param name="insertSQL">
      </param>
      <param name="session">
      </param>
      <param name="binder">
      </param>
      <returns> The generated identifier value. </returns>
    </member>
    <member name="T:NHibernate.Id.Insert.AbstractReturningDelegate">
      <summary> 
            Abstract InsertGeneratedIdentifierDelegate implementation where the
            underlying strategy causes the generated identitifer to be returned as an
            effect of performing the insert statement.  Thus, there is no need for an
            additional sql statement to determine the generated identitifer. 
            </summary>
    </member>
    <member name="T:NHibernate.Id.Insert.AbstractSelectingDelegate">
      <summary> 
            Abstract InsertGeneratedIdentifierDelegate implementation where the
            underlying strategy requires an subsequent select after the insert
            to determine the generated identifier. 
            </summary>
    </member>
    <member name="M:NHibernate.Id.Insert.AbstractSelectingDelegate.GetResult(NHibernate.Engine.ISessionImplementor,System.Data.IDataReader,System.Object)">
      <summary> Extract the generated key value from the given result set. </summary>
      <param name="session">The session </param>
      <param name="rs">The result set containing the generated primay key values. </param>
      <param name="entity">The entity being saved. </param>
      <returns> The generated identifier </returns>
    </member>
    <member name="M:NHibernate.Id.Insert.AbstractSelectingDelegate.BindParameters(NHibernate.Engine.ISessionImplementor,System.Data.IDbCommand,System.Object)">
      <summary> Bind any required parameter values into the SQL command <see cref="P:NHibernate.Id.Insert.AbstractSelectingDelegate.SelectSQL" />. </summary>
      <param name="session">The session </param>
      <param name="ps">The prepared <see cref="P:NHibernate.Id.Insert.AbstractSelectingDelegate.SelectSQL" /> command </param>
      <param name="entity">The entity being saved. </param>
    </member>
    <member name="P:NHibernate.Id.Insert.AbstractSelectingDelegate.SelectSQL">
      <summary> Get the SQL statement to be used to retrieve generated key values. </summary>
      <returns> The SQL command string </returns>
    </member>
    <member name="P:NHibernate.Id.Insert.AbstractSelectingDelegate.ParametersTypes">
      <summary>
            Types of any required parameter values into the SQL command <see cref="P:NHibernate.Id.Insert.AbstractSelectingDelegate.SelectSQL" />.
            </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.ISqlStringBuilder">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.ISqlStringBuilder.ToSqlString">
      <summary>
            Builds a SqlString from the internal data.
            </summary>
      <returns>A valid SqlString that can be converted into an IDbCommand</returns>
    </member>
    <member name="T:NHibernate.SqlCommand.SqlInsertBuilder">
      <summary>
            A class that builds an <c>INSERT</c> sql statement.
            </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.AddColumn(System.String,NHibernate.Type.IType)">
      <summary>
            Adds the Property's columns to the INSERT sql
            </summary>
      <param name="columnName">The column name for the Property</param>
      <param name="propertyType">The IType of the property.</param>
      <returns>The SqlInsertBuilder.</returns>
      <remarks>The column will be associated with a parameter.</remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.AddColumn(System.String,System.Object,NHibernate.Type.ILiteralType)">
      <summary>
            Add a column with a specific value to the INSERT sql
            </summary>
      <param name="columnName">The name of the Column to add.</param>
      <param name="val">The value to set for the column.</param>
      <param name="literalType">The NHibernateType to use to convert the value to a sql string.</param>
      <returns>The SqlInsertBuilder.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.AddColumn(System.String,System.String)">
      <summary>
            Add a column with a specific value to the INSERT sql
            </summary>
      <param name="columnName">The name of the Column to add.</param>
      <param name="val">A valid sql string to set as the value of the column.</param>
      <returns>The SqlInsertBuilder.</returns>
    </member>
    <member name="T:NHibernate.Id.Insert.IdentifierGeneratingInsert">
      <summary> 
            Nothing more than a distinguishing subclass of Insert used to indicate
            intent.  
            Some subclasses of this also provided some additional
            functionality or semantic to the genernated SQL statement string.
             </summary>
    </member>
    <member name="T:NHibernate.Id.Insert.InsertSelectIdentityInsert">
      <summary> 
            Specialized IdentifierGeneratingInsert which appends the database
            specific clause which signifies to return generated IDENTITY values
            to the end of the insert statement. 
            </summary>
    </member>
    <member name="T:NHibernate.Id.Insert.NoCommentsInsert">
      <summary>
            Disable comments on insert.
            </summary>
    </member>
    <member name="T:NHibernate.Id.Insert.OutputParamReturningDelegate">
      <summary>
        <see cref="T:NHibernate.Id.Insert.IInsertGeneratedIdentifierDelegate" /> implementation where the
            underlying strategy causes the generated identitifer to be returned, as an
            effect of performing the insert statement, in a Output parameter.
            Thus, there is no need for an additional sql statement to determine the generated identitifer. 
            </summary>
    </member>
    <member name="T:NHibernate.Id.Insert.ReturningIdentifierInsert">
      <summary> 
            Specialized IdentifierGeneratingInsert which appends the database
            specific clause which signifies to return generated identifier values
            to the end of the insert statement. 
            </summary>
      <remarks>
      </remarks>
    </member>
    <member name="M:NHibernate.Id.AbstractPostInsertGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            The IdentityGenerator for autoincrement/identity key generation. 
            </summary>
      <param name="s">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this id is being generated in.</param>
      <param name="obj">The entity the id is being generated for.</param>
      <returns>
        <c>IdentityColumnIndicator</c> Indicates to the Session that identity (i.e. identity/autoincrement column)
            key generation should be used.
            </returns>
    </member>
    <member name="T:NHibernate.Id.Assigned">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that returns the current identifier
            assigned to an instance.
            </summary>
      <remarks>
        <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="assigned" /&gt;</code></p>
      </remarks>
    </member>
    <member name="M:NHibernate.Id.Assigned.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Generates a new identifier by getting the value of the identifier
            for the <c>obj</c> parameter.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this id is being generated in.</param>
      <param name="obj">The entity for which the id is being generated.</param>
      <returns>The value that was assigned to the mapped <c>id</c>'s property.</returns>
      <exception cref="T:NHibernate.Id.IdentifierGenerationException">
            Thrown when a <see cref="T:NHibernate.Collection.IPersistentCollection" /> is passed in as the <c>obj</c> or
            if the identifier of <c>obj</c> is null.
            </exception>
    </member>
    <member name="T:NHibernate.Id.CounterGenerator">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that returns a <c>Int64</c> constructed from the system
            time and a counter value. Not safe for use in a clustser!
            </summary>
    </member>
    <member name="T:NHibernate.Id.ForeignGenerator">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that uses the value of 
            the id property of an associated object
            </summary>
      <remarks>
        <para>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="foreign"&gt;
            	&lt;param name="property"&gt;AssociatedObject&lt;/param&gt;
            &lt;/generator&gt;
            </code></para>
            The mapping parameter <c>property</c> is required.
            </remarks>
    </member>
    <member name="M:NHibernate.Id.ForeignGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Generates an identifer from the value of a Property. 
            </summary>
      <param name="sessionImplementor">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this id is being generated in.</param>
      <param name="obj">The entity for which the id is being generated.</param>
      <returns>
            The identifier value from the associated object or  
            <see cref="F:NHibernate.Id.IdentifierGeneratorFactory.ShortCircuitIndicator" /> if the <c>session</c>
            already contains <c>obj</c>.
            </returns>
    </member>
    <member name="M:NHibernate.Id.ForeignGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
      <summary>
            Configures the ForeignGenerator by reading the value of <c>property</c> 
            from the <c>parms</c> parameter.
            </summary>
      <param name="type">The <see cref="T:NHibernate.Type.IType" /> the identifier should be.</param>
      <param name="parms">An <see cref="T:System.Collections.IDictionary" /> of Param values that are keyed by parameter name.</param>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to help with Configuration.</param>
      <exception cref="T:NHibernate.MappingException">
            Thrown if the key <c>property</c> is not found in the <c>parms</c> parameter.
            </exception>
    </member>
    <member name="T:NHibernate.Id.GuidCombGenerator">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that generates <see cref="T:System.Guid" /> values 
            using a strategy suggested Jimmy Nilsson's 
            <a href="http://www.informit.com/articles/article.asp?p=25862">article</a>
            on <a href="http://www.informit.com">informit.com</a>. 
            </summary>
      <remarks>
        <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="guid.comb" /&gt;</code></p>
        <p>
            The <c>comb</c> algorithm is designed to make the use of GUIDs as Primary Keys, Foreign Keys, 
            and Indexes nearly as efficient as ints.
            </p>
        <p>
            This code was contributed by Donald Mull.
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.Id.GuidCombGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Generate a new <see cref="T:System.Guid" /> using the comb algorithm.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this id is being generated in.</param>
      <param name="obj">The entity for which the id is being generated.</param>
      <returns>The new identifier as a <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:NHibernate.Id.GuidCombGenerator.GenerateComb">
      <summary>
            Generate a new <see cref="T:System.Guid" /> using the comb algorithm.
            </summary>
    </member>
    <member name="T:NHibernate.Id.GuidGenerator">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that generates <see cref="T:System.Guid" /> values 
            using <see cref="M:System.Guid.NewGuid">Guid.NewGuid()</see>. 
            </summary>
      <remarks>
        <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="guid" /&gt;</code></p>
      </remarks>
    </member>
    <member name="M:NHibernate.Id.GuidGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Generate a new <see cref="T:System.Guid" /> for the identifier.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this id is being generated in.</param>
      <param name="obj">The entity for which the id is being generated.</param>
      <returns>The new identifier as a <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:NHibernate.Id.IdentifierGenerationException">
      <summary>
            Thrown by <see cref="T:NHibernate.Id.IIdentifierGenerator" /> implementation class when ID generation fails
            </summary>
    </member>
    <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException" /> class.
            </summary>
      <param name="message">The message that describes the error.</param>
    </member>
    <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException" /> class.
            </summary>
      <param name="message">The message that describes the error.</param>
      <param name="e">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.Id.IdentifierGeneratorFactory">
      <summary>
            Factory methods for <c>IdentifierGenerator</c> framework.
            </summary>
      <remarks>
        <p>The built in strategies for identifier generation in NHibernate are:</p>
        <list type="table">
          <listheader>
            <term>strategy</term>
            <description>Implementation of strategy</description>
          </listheader>
          <item>
            <term>assigned</term>
            <description>
              <see cref="T:NHibernate.Id.Assigned" />
            </description>
          </item>
          <item>
            <term>counter</term>
            <description>
              <see cref="T:NHibernate.Id.CounterGenerator" />
            </description>
          </item>
          <item>
            <term>foreign</term>
            <description>
              <see cref="T:NHibernate.Id.ForeignGenerator" />
            </description>
          </item>
          <item>
            <term>guid</term>
            <description>
              <see cref="T:NHibernate.Id.GuidGenerator" />
            </description>
          </item>
          <item>
            <term>guid.comb</term>
            <description>
              <see cref="T:NHibernate.Id.GuidCombGenerator" />
            </description>
          </item>
          <item>
            <term>guid.native</term>
            <description>
              <see cref="T:NHibernate.Id.NativeGuidGenerator" />
            </description>
          </item>
          <item>
            <term>hilo</term>
            <description>
              <see cref="T:NHibernate.Id.TableHiLoGenerator" />
            </description>
          </item>
          <item>
            <term>identity</term>
            <description>
              <see cref="T:NHibernate.Id.IdentityGenerator" />
            </description>
          </item>
          <item>
            <term>native</term>
            <description>
            			Chooses between <see cref="T:NHibernate.Id.IdentityGenerator" />, <see cref="T:NHibernate.Id.SequenceGenerator" />
            			, and <see cref="T:NHibernate.Id.TableHiLoGenerator" /> based on the 
            			<see cref="T:NHibernate.Dialect.Dialect" />'s capabilities.
            		</description>
          </item>
          <item>
            <term>seqhilo</term>
            <description>
              <see cref="T:NHibernate.Id.SequenceHiLoGenerator" />
            </description>
          </item>
          <item>
            <term>sequence</term>
            <description>
              <see cref="T:NHibernate.Id.SequenceGenerator" />
            </description>
          </item>
          <item>
            <term>uuid.hex</term>
            <description>
              <see cref="T:NHibernate.Id.UUIDHexGenerator" />
            </description>
          </item>
          <item>
            <term>uuid.string</term>
            <description>
              <see cref="T:NHibernate.Id.UUIDStringGenerator" />
            </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="F:NHibernate.Id.IdentifierGeneratorFactory.idgenerators">
      <summary>
            An <see cref="T:System.Collections.Hashtable" /> where the <c>key</c> is the strategy and 
            the <c>value</c> is the <see cref="T:System.Type" /> for the strategy.
            </summary>
    </member>
    <member name="F:NHibernate.Id.IdentifierGeneratorFactory.ShortCircuitIndicator">
      <summary>
            When this is returned by <c>Generate()</c> it indicates that the object
            has already been saved.
            </summary>
      <value>
        <see cref="F:System.String.Empty">String.Empty</see>
      </value>
    </member>
    <member name="F:NHibernate.Id.IdentifierGeneratorFactory.PostInsertIndicator">
      <summary>
            When this is return
            </summary>
    </member>
    <member name="M:NHibernate.Id.IdentifierGeneratorFactory.GetGeneratedIdentity(System.Data.IDataReader,NHibernate.Type.IType,NHibernate.Engine.ISessionImplementor)">
      <summary> Get the generated identifier when using identity columns</summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> to read the identifier value from.</param>
      <param name="type">The <see cref="T:NHibernate.Type.IIdentifierType" /> the value should be converted to.</param>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> the value is retrieved in.</param>
      <returns> The value for the identifier. </returns>
    </member>
    <member name="M:NHibernate.Id.IdentifierGeneratorFactory.Get(System.Data.IDataReader,NHibernate.Type.IType,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Gets the value of the identifier from the <see cref="T:System.Data.IDataReader" /> and
            ensures it is the correct <see cref="T:System.Type" />.
            </summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> to read the identifier value from.</param>
      <param name="type">The <see cref="T:NHibernate.Type.IIdentifierType" /> the value should be converted to.</param>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> the value is retrieved in.</param>
      <returns>
            The value for the identifier.
            </returns>
      <exception cref="T:NHibernate.Id.IdentifierGenerationException">
            Thrown if there is any problem getting the value from the <see cref="T:System.Data.IDataReader" />
            or with converting it to the <see cref="T:System.Type" />.
            </exception>
    </member>
    <member name="M:NHibernate.Id.IdentifierGeneratorFactory.Create(System.String,NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
      <summary>
            Creates an <see cref="T:NHibernate.Id.IIdentifierGenerator" /> from the named strategy.
            </summary>
      <param name="strategy">
            The name of the generator to create.  This can be one of the NHibernate abbreviations (ie - <c>native</c>, 
            <c>sequence</c>, <c>guid.comb</c>, etc...), a full class name if the Type is in the NHibernate assembly, or
            a full type name if the strategy is in an external assembly.
            </param>
      <param name="type">The <see cref="T:NHibernate.Type.IType" /> that the retured identifier should be.</param>
      <param name="parms">An <see cref="T:System.Collections.IDictionary" /> of <c>&lt;param&gt;</c> values from the mapping.</param>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to help with Configuration.</param>
      <returns>
            An instantiated and configured <see cref="T:NHibernate.Id.IIdentifierGenerator" />.
            </returns>
      <exception cref="T:NHibernate.MappingException">
            Thrown if there are any exceptions while creating the <see cref="T:NHibernate.Id.IIdentifierGenerator" />.
            </exception>
    </member>
    <member name="M:NHibernate.Id.IdentifierGeneratorFactory.CreateNumber(System.Int64,System.Type)">
      <summary>
            Create the correct boxed <see cref="T:System.Type" /> for the identifier.
            </summary>
      <param name="value">The value of the new identifier.</param>
      <param name="type">The <see cref="T:NHibernate.Type.IType" /> the identifier should be.</param>
      <returns>
            The identifier value converted to the <see cref="T:System.Type" />.
            </returns>
      <exception cref="T:NHibernate.Id.IdentifierGenerationException">
            The <c>type</c> parameter must be an <see cref="T:System.Int16" />, <see cref="T:System.Int32" />,
            or <see cref="T:System.Int64" />.
            </exception>
    </member>
    <member name="T:NHibernate.Id.IdentityGenerator">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that indicates to the <see cref="T:NHibernate.ISession" /> that identity
            (ie. identity/autoincrement column) key generation should be used.
            </summary>
      <remarks>
        <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="identity" /&gt;</code> 
            or if the database natively supports identity columns 
            <code>&lt;generator class="native" /&gt;</code></p>
        <p>
            This indicates to NHibernate that the database generates the id when
            the entity is inserted.
            </p>
      </remarks>
    </member>
    <member name="T:NHibernate.Id.IdentityGenerator.InsertSelectDelegate">
      <summary> 
            Delegate for dealing with IDENTITY columns where the dialect supports returning
            the generated IDENTITY value directly from the insert statement.
            </summary>
    </member>
    <member name="T:NHibernate.Id.IdentityGenerator.BasicDelegate">
      <summary> 
            Delegate for dealing with IDENTITY columns where the dialect requires an
            additional command execution to retrieve the generated IDENTITY value
            </summary>
    </member>
    <member name="F:NHibernate.Id.IdGeneratorParmsNames.EntityName">
      <summary> The configuration parameter holding the entity name</summary>
    </member>
    <member name="T:NHibernate.Id.IncrementGenerator">
      <summary>
            An <c>IIdentifierGenerator</c> that returns a <c>Int64</c>, constructed by
            counting from the maximum primary key value at startup. Not safe for use in a
            cluster!
            </summary>
      <remarks>
        <para>
            java author Gavin King, .NET port Mark Holden
            </para>
        <para>
            Mapping parameters supported, but not usually needed: table, column.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Id.IncrementGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
      <summary>
      </summary>
      <param name="type">
      </param>
      <param name="parms">
      </param>
      <param name="dialect">
      </param>
    </member>
    <member name="M:NHibernate.Id.IncrementGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
      </summary>
      <param name="session">
      </param>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="F:NHibernate.Id.PersistentIdGeneratorParmsNames.Schema">
      <summary> The configuration parameter holding the schema name</summary>
    </member>
    <member name="F:NHibernate.Id.PersistentIdGeneratorParmsNames.Table">
      <summary> 
            The configuration parameter holding the table name for the
            generated id
            </summary>
    </member>
    <member name="F:NHibernate.Id.PersistentIdGeneratorParmsNames.Tables">
      <summary> 
            The configuration parameter holding the table names for all
            tables for which the id must be unique
            </summary>
    </member>
    <member name="F:NHibernate.Id.PersistentIdGeneratorParmsNames.PK">
      <summary> 
            The configuration parameter holding the primary key column
            name of the generated id
            </summary>
    </member>
    <member name="F:NHibernate.Id.PersistentIdGeneratorParmsNames.Catalog">
      <summary> The configuration parameter holding the catalog name</summary>
    </member>
    <member name="T:NHibernate.Id.IPostInsertIdentityPersister">
      <summary> 
            A persister that may have an identity assigned by execution of a SQL <tt>INSERT</tt>. 
            </summary>
    </member>
    <member name="M:NHibernate.Id.IPostInsertIdentityPersister.GetSelectByUniqueKeyString(System.String)">
      <summary> 
            Get a SQL select string that performs a select based on a unique
            key determined by the given property name). 
            </summary>
      <param name="propertyName">
            The name of the property which maps to the
            column(s) to use in the select statement restriction.
            </param>
      <returns> The SQL select string </returns>
    </member>
    <member name="P:NHibernate.Id.IPostInsertIdentityPersister.IdentitySelectString">
      <summary> 
            Get the database-specific SQL command to retrieve the last
            generated IDENTITY value.
            </summary>
    </member>
    <member name="P:NHibernate.Id.IPostInsertIdentityPersister.RootTableKeyColumnNames">
      <summary> The names of the primary key columns in the root table. </summary>
      <returns> The primary key column names. </returns>
    </member>
    <member name="P:NHibernate.Id.IPostInsertIdentityPersister.IdentifierType">
      <summary>
            Get the identifier type
            </summary>
    </member>
    <member name="T:NHibernate.Id.NativeGuidGenerator">
      <summary>
            Generates Guid values using the server side Guid function.
            </summary>
    </member>
    <member name="T:NHibernate.Id.SelectGenerator">
      <summary> 
            A generator that selects the just inserted row to determine the identifier
            value assigned by the database. The correct row is located using a unique key.
            </summary>
      <remarks>One mapping parameter is required: key (unless a natural-id is defined in the mapping).</remarks>
    </member>
    <member name="T:NHibernate.Id.SelectGenerator.SelectGeneratorDelegate">
      <summary> The delegate for the select generation strategy.</summary>
    </member>
    <member name="T:NHibernate.Id.SequenceGenerator">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that generates <c>Int64</c> values using an 
            oracle-style sequence. A higher performance algorithm is 
            <see cref="T:NHibernate.Id.SequenceHiLoGenerator" />.
            </summary>
      <remarks>
        <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="sequence"&gt;
            	&lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
            	&lt;param name="schema"&gt;db_schema&lt;/param&gt;
            &lt;/generator&gt;
            </code></p>
        <p>
            The <c>sequence</c> parameter is required while the <c>schema</c> is optional.
            </p>
      </remarks>
    </member>
    <member name="F:NHibernate.Id.SequenceGenerator.Sequence">
      <summary>
            The name of the sequence parameter.
            </summary>
    </member>
    <member name="F:NHibernate.Id.SequenceGenerator.Parameters">
      <summary> 
            The parameters parameter, appended to the create sequence DDL.
            For example (Oracle): <tt>INCREMENT BY 1 START WITH 1 MAXVALUE 100 NOCACHE</tt>.
            </summary>
    </member>
    <member name="M:NHibernate.Id.SequenceGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
      <summary>
            Configures the SequenceGenerator by reading the value of <c>sequence</c> and
            <c>schema</c> from the <c>parms</c> parameter.
            </summary>
      <param name="type">The <see cref="T:NHibernate.Type.IType" /> the identifier should be.</param>
      <param name="parms">An <see cref="T:System.Collections.IDictionary" /> of Param values that are keyed by parameter name.</param>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to help with Configuration.</param>
    </member>
    <member name="M:NHibernate.Id.SequenceGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Generate an <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, or <see cref="T:System.Int64" /> 
            for the identifier by using a database sequence.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this id is being generated in.</param>
      <param name="obj">The entity for which the id is being generated.</param>
      <returns>The new identifier as a <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, or <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:NHibernate.Id.SequenceGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
      <summary>
            The SQL required to create the database objects for a SequenceGenerator.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to help with creating the sql.</param>
      <returns>
            An array of <see cref="T:System.String" /> objects that contain the Dialect specific sql to 
            create the necessary database objects for the SequenceGenerator.
            </returns>
    </member>
    <member name="M:NHibernate.Id.SequenceGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
      <summary>
            The SQL required to remove the underlying database objects for a SequenceGenerator.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to help with creating the sql.</param>
      <returns>
            A <see cref="T:System.String" /> that will drop the database objects for the SequenceGenerator.
            </returns>
    </member>
    <member name="M:NHibernate.Id.SequenceGenerator.GeneratorKey">
      <summary>
            Return a key unique to the underlying database objects for a SequenceGenerator.
            </summary>
      <returns>
            The configured sequence name.
            </returns>
    </member>
    <member name="T:NHibernate.Id.SequenceHiLoGenerator">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that combines a hi/lo algorithm with an underlying
            oracle-style sequence that generates hi values.
            </summary>
      <remarks>
        <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="seqhilo"&gt;
            	&lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
            	&lt;param name="max_lo"&gt;max_lo_value&lt;/param&gt;
            	&lt;param name="schema"&gt;db_schema&lt;/param&gt;
            &lt;/generator&gt;
            </code></p>
        <p>
            The <c>sequence</c> parameter is required, the <c>max_lo</c> and <c>schema</c> are optional.
            </p>
        <p>
            The user may specify a <c>max_lo</c> value to determine how often new hi values are
            fetched. If sequences are not avaliable, <c>TableHiLoGenerator</c> might be an
            alternative.
            </p>
      </remarks>
    </member>
    <member name="F:NHibernate.Id.SequenceHiLoGenerator.MaxLo">
      <summary>
            The name of the maximum low value parameter.
            </summary>
    </member>
    <member name="M:NHibernate.Id.SequenceHiLoGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
      <summary>
            Configures the SequenceHiLoGenerator by reading the value of <c>sequence</c>, <c>max_lo</c>, 
            and <c>schema</c> from the <c>parms</c> parameter.
            </summary>
      <param name="type">The <see cref="T:NHibernate.Type.IType" /> the identifier should be.</param>
      <param name="parms">An <see cref="T:System.Collections.IDictionary" /> of Param values that are keyed by parameter name.</param>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to help with Configuration.</param>
    </member>
    <member name="M:NHibernate.Id.SequenceHiLoGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Generate an <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, or <see cref="T:System.Int64" /> 
            for the identifier by using a database sequence.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this id is being generated in.</param>
      <param name="obj">The entity for which the id is being generated.</param>
      <returns>The new identifier as a <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, or <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="T:NHibernate.Id.SequenceIdentityGenerator">
      <summary>
            A generator which combines sequence generation with immediate retrieval
            by attaching a output parameter to the SQL command
            In this respect it works much like ANSI-SQL IDENTITY generation.
            </summary>
    </member>
    <member name="T:NHibernate.Id.TableGenerator">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that uses a database table to store the last
            generated value.
            </summary>
      <remarks>
        <p>
            It is not intended that applications use this strategy directly. However,
            it may be used to build other (efficient) strategies. The return type is
            <c>System.Int32</c></p>
        <p>
            The hi value MUST be fetched in a seperate transaction to the <c>ISession</c>
            transaction so the generator must be able to obtain a new connection and commit it.
            Hence this implementation may not be used when the user is supplying connections.
            </p>
        <p>
            The mapping parameters <c>table</c> and <c>column</c> are required.
            </p>
      </remarks>
    </member>
    <member name="F:NHibernate.Id.TableGenerator.Where">
      <summary>
            An additional where clause that is added to 
            the queries against the table.
            </summary>
    </member>
    <member name="F:NHibernate.Id.TableGenerator.ColumnParamName">
      <summary>
            The name of the column parameter.
            </summary>
    </member>
    <member name="F:NHibernate.Id.TableGenerator.TableParamName">
      <summary>
            The name of the table parameter.
            </summary>
    </member>
    <member name="F:NHibernate.Id.TableGenerator.DefaultColumnName">
      <summary>Default column name </summary>
    </member>
    <member name="F:NHibernate.Id.TableGenerator.DefaultTableName">
      <summary>Default table name </summary>
    </member>
    <member name="M:NHibernate.Id.TableGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
      <summary>
            Configures the TableGenerator by reading the value of <c>table</c>, 
            <c>column</c>, and <c>schema</c> from the <c>parms</c> parameter.
            </summary>
      <param name="type">The <see cref="T:NHibernate.Type.IType" /> the identifier should be.</param>
      <param name="parms">An <see cref="T:System.Collections.IDictionary" /> of Param values that are keyed by parameter name.</param>
      <param name="dialect">The <see cref="N:NHibernate.Dialect" /> to help with Configuration.</param>
    </member>
    <member name="M:NHibernate.Id.TableGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Generate a <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, or <see cref="T:System.Int64" /> 
            for the identifier by selecting and updating a value in a table.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this id is being generated in.</param>
      <param name="obj">The entity for which the id is being generated.</param>
      <returns>The new identifier as a <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, or <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:NHibernate.Id.TableGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
      <summary>
            The SQL required to create the database objects for a TableGenerator.
            </summary>
      <param name="dialect">The <see cref="N:NHibernate.Dialect" /> to help with creating the sql.</param>
      <returns>
            An array of <see cref="T:System.String" /> objects that contain the Dialect specific sql to 
            create the necessary database objects and to create the first value as <c>1</c> 
            for the TableGenerator.
            </returns>
    </member>
    <member name="M:NHibernate.Id.TableGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
      <summary>
            The SQL required to remove the underlying database objects for a TableGenerator.
            </summary>
      <param name="dialect">The <see cref="N:NHibernate.Dialect" /> to help with creating the sql.</param>
      <returns>
            A <see cref="T:System.String" /> that will drop the database objects for the TableGenerator.
            </returns>
    </member>
    <member name="M:NHibernate.Id.TableGenerator.GeneratorKey">
      <summary>
            Return a key unique to the underlying database objects for a TableGenerator.
            </summary>
      <returns>
            The configured table name.
            </returns>
    </member>
    <member name="T:NHibernate.Id.TableHiLoGenerator">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that returns an <c>Int64</c>, constructed using
            a hi/lo algorithm.
            </summary>
      <remarks>
        <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="hilo"&gt;
            	&lt;param name="table"&gt;table&lt;/param&gt;
            	&lt;param name="column"&gt;id_column&lt;/param&gt;
            	&lt;param name="max_lo"&gt;max_lo_value&lt;/param&gt;
            	&lt;param name="schema"&gt;db_schema&lt;/param&gt;
            &lt;/generator&gt;
            </code></p>
        <p>
            The <c>table</c> and <c>column</c> parameters are required, the <c>max_lo</c> and 
            <c>schema</c> are optional.
            </p>
        <p>
            The hi value MUST be fecthed in a seperate transaction to the <c>ISession</c>
            transaction so the generator must be able to obtain a new connection and 
            commit it. Hence this implementation may not be used when the user is supplying
            connections.  In that case a <see cref="T:NHibernate.Id.SequenceHiLoGenerator" /> would be a 
            better choice (where supported).
            </p>
      </remarks>
    </member>
    <member name="F:NHibernate.Id.TableHiLoGenerator.MaxLo">
      <summary>
            The name of the max lo parameter.
            </summary>
    </member>
    <member name="M:NHibernate.Id.TableHiLoGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
      <summary>
            Configures the TableHiLoGenerator by reading the value of <c>table</c>, 
            <c>column</c>, <c>max_lo</c>, and <c>schema</c> from the <c>parms</c> parameter.
            </summary>
      <param name="type">The <see cref="T:NHibernate.Type.IType" /> the identifier should be.</param>
      <param name="parms">An <see cref="T:System.Collections.IDictionary" /> of Param values that are keyed by parameter name.</param>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to help with Configuration.</param>
    </member>
    <member name="M:NHibernate.Id.TableHiLoGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Generate a <see cref="T:System.Int64" /> for the identifier by selecting and updating a value in a table.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this id is being generated in.</param>
      <param name="obj">The entity for which the id is being generated.</param>
      <returns>The new identifier as a <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="T:NHibernate.Id.UUIDHexGenerator">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that returns a string of length
            32, 36, or 38 depending on the configuration.  
            </summary>
      <remarks>
        <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="uuid.hex"&gt;
            	&lt;param name="format"&gt;format_string&lt;/param&gt;
            	&lt;param name="seperator"&gt;seperator_string&lt;/param&gt;
            &lt;/generator&gt;
            </code></p>
        <p>
            The <c>format</c> and <c>seperator</c> parameters are optional.
            </p>
        <p>
            The identifier string will consist of only hex digits.  Optionally, the identifier string
            may be generated with enclosing characters and seperators between each component 
            of the UUID.  If there are seperators then the string length will be 36.  If a format
            that has enclosing brackets is used, then the string length will be 38.
            </p>
        <p>
          <c>format</c> is either 
            "N" (<c>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</c>), 
            "D" (<c>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</c>), 
            "B" (<c>{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}</c>), 
            or "P" (<c>(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)</c>).  These formats are described in
            the <see cref="M:System.Guid.ToString(System.String)">Guid.ToString(String)</see> method.
            If no <c>format</c> is specified the default is "N".
            </p>
        <p>
          <c>seperator</c> is the char that will replace the "-" if specified.  If no value is
            configured then the default seperator for the format will be used.  If the format "D", "B", or
            "P" is specified, then the seperator will replace the "-".  If the format is "N" then this
            parameter will be ignored.
            </p>
        <p>
            This class is based on <see cref="T:System.Guid" /></p>
      </remarks>
    </member>
    <member name="M:NHibernate.Id.UUIDHexGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Generate a new <see cref="T:System.String" /> for the identifier using the "uuid.hex" algorithm.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this id is being generated in.</param>
      <param name="obj">The entity for which the id is being generated.</param>
      <returns>The new identifier as a <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:NHibernate.Id.UUIDHexGenerator.Configure(NHibernate.Type.IType,System.Collections.Generic.IDictionary{System.String,System.String},NHibernate.Dialect.Dialect)">
      <summary>
            Configures the UUIDHexGenerator by reading the value of <c>format</c> and
            <c>seperator</c> from the <c>parms</c> parameter.
            </summary>
      <param name="type">The <see cref="T:NHibernate.Type.IType" /> the identifier should be.</param>
      <param name="parms">An <see cref="T:System.Collections.IDictionary" /> of Param values that are keyed by parameter name.</param>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to help with Configuration.</param>
    </member>
    <member name="M:NHibernate.Id.UUIDHexGenerator.GenerateNewGuid">
      <summary>
            Generate a Guid into a string using the <c>format</c>.
            </summary>
      <returns>A new Guid string</returns>
    </member>
    <member name="T:NHibernate.Id.UUIDStringGenerator">
      <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator" /> that returns a string of length
            16.  
            </summary>
      <remarks>
        <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="uuid.string" /&gt;</code></p>
        <para>
            The identifier string will NOT consist of only alphanumeric characters.  Use
            this only if you don't mind unreadable identifiers.
            </para>
        <para>
            This impelementation was known to be incompatible with Postgres.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Id.UUIDStringGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Generate a new <see cref="T:System.String" /> for the identifier using the "uuid.string" algorithm.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this id is being generated in.</param>
      <param name="obj">The entity for which the id is being generated.</param>
      <returns>The new identifier as a <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:NHibernate.IDetachedQuery">
      <summary>
            Interface  to create queries in "detached mode" where the NHibernate session is not available.
            All methods have the same semantics as the corresponding methods of the <see cref="T:NHibernate.IQuery" /> interface.
            </summary>
    </member>
    <member name="M:NHibernate.IDetachedQuery.GetExecutableQuery(NHibernate.ISession)">
      <summary>
            Get an executable instance of <see cref="T:NHibernate.IQuery" />,
            to actually run the query.</summary>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetMaxResults(System.Int32)">
      <summary>
            Set the maximum number of rows to retrieve.
            </summary>
      <param name="maxResults">The maximum number of rows to retreive.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetFirstResult(System.Int32)">
      <summary>
            Sets the first row to retrieve.
            </summary>
      <param name="firstResult">The first row to retreive.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetCacheable(System.Boolean)">
      <summary>
            Enable caching of this query result set.
            </summary>
      <param name="cacheable">Should the query results be cacheable?</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetCacheRegion(System.String)">
            Set the name of the cache region.
            <param name="cacheRegion">The name of a query cache region, or <see langword="null" />
            for the default query cache</param></member>
    <member name="M:NHibernate.IDetachedQuery.SetReadOnly(System.Boolean)">
      <summary> 
            Entities retrieved by this query will be loaded in 
            a read-only mode where Hibernate will never dirty-check
            them or make changes persistent. 
            </summary>
      <param name="readOnly">Enable/Disable read -only mode</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetTimeout(System.Int32)">
      <summary>
            The timeout for the underlying ADO query
            </summary>
      <param name="timeout">
      </param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetFetchSize(System.Int32)">
      <summary> Set a fetch size for the underlying ADO query.</summary>
      <param name="fetchSize">the fetch size </param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetLockMode(System.String,NHibernate.LockMode)">
      <summary>
            Set the lockmode for the objects idententified by the
            given alias that appears in the <c>FROM</c> clause.
            </summary>
      <param name="alias">alias a query alias, or <c>this</c> for a collection filter</param>
      <param name="lockMode">
      </param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetComment(System.String)">
      <summary> Add a comment to the generated SQL.</summary>
      <param name="comment">a human-readable string </param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetParameter(System.Int32,System.Object,NHibernate.Type.IType)">
      <summary>
            Bind a value to an indexed parameter.
            </summary>
      <param name="position">Position of the parameter in the query, numbered from <c>0</c></param>
      <param name="val">The possibly null parameter value</param>
      <param name="type">The Hibernate type</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetParameter(System.String,System.Object,NHibernate.Type.IType)">
      <summary>
            Bind a value to a named query parameter
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">The possibly null parameter value</param>
      <param name="type">The NHibernate <see cref="T:NHibernate.Type.IType" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetParameter(System.Int32,System.Object)">
      <summary>
            Bind a value to an indexed parameter, guessing the Hibernate type from
            the class of the given object.
            </summary>
      <param name="position">The position of the parameter in the query, numbered from <c>0</c></param>
      <param name="val">The non-null parameter value</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetParameter(System.String,System.Object)">
      <summary>
            Bind a value to a named query parameter, guessing the NHibernate <see cref="T:NHibernate.Type.IType" />
            from the class of the given object.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">The non-null parameter value</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetParameterList(System.String,System.Collections.ICollection,NHibernate.Type.IType)">
      <summary>
            Bind multiple values to a named query parameter. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c></summary>
      <param name="name">The name of the parameter</param>
      <param name="vals">A collection of values to list</param>
      <param name="type">The Hibernate type of the values</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetParameterList(System.String,System.Collections.ICollection)">
      <summary>
            Bind multiple values to a named query parameter, guessing the Hibernate
            type from the class of the first object in the collection. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c></summary>
      <param name="name">The name of the parameter</param>
      <param name="vals">A collection of values to list</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetProperties(System.Object)">
      <summary>
            Bind the property values of the given object to named parameters of the query,
            matching property names with parameter names and mapping property types to
            Hibernate types using heuristics.
            </summary>
      <param name="obj">Any POCO</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetAnsiString(System.Int32,System.String)">
      <summary>
            Bind an instance of a <see cref="T:System.String" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.String" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetAnsiString(System.String,System.String)">
      <summary>
            Bind an instance of a <see cref="T:System.String" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.String" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetBinary(System.Int32,System.Byte[])">
      <summary>
            Bind an instance of a <see cref="T:System.Byte" /> array to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Byte" /> array.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetBinary(System.String,System.Byte[])">
      <summary>
            Bind an instance of a <see cref="T:System.Byte" /> array to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Byte" /> array.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetBoolean(System.Int32,System.Boolean)">
      <summary>
            Bind an instance of a <see cref="T:System.Boolean" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Boolean" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetBoolean(System.String,System.Boolean)">
      <summary>
            Bind an instance of a <see cref="T:System.Boolean" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Boolean" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetByte(System.Int32,System.Byte)">
      <summary>
            Bind an instance of a <see cref="T:System.Byte" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Byte" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetByte(System.String,System.Byte)">
      <summary>
            Bind an instance of a <see cref="T:System.Byte" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Byte" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetCharacter(System.Int32,System.Char)">
      <summary>
            Bind an instance of a <see cref="T:System.Char" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Char" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetCharacter(System.String,System.Char)">
      <summary>
            Bind an instance of a <see cref="T:System.Char" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Char" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetDateTime(System.Int32,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetDateTime(System.String,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType" />.
            </summary>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
      <param name="name">The name of the parameter</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetDecimal(System.Int32,System.Decimal)">
      <summary>
            Bind an instance of a <see cref="T:System.Decimal" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Decimal" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetDecimal(System.String,System.Decimal)">
      <summary>
            Bind an instance of a <see cref="T:System.Decimal" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Decimal" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetDouble(System.Int32,System.Double)">
      <summary>
            Bind an instance of a <see cref="T:System.Double" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Double" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetDouble(System.String,System.Double)">
      <summary>
            Bind an instance of a <see cref="T:System.Double" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Double" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetEntity(System.Int32,System.Object)">
      <summary>
            Bind an instance of a mapped persistent class to an indexed parameter.
            </summary>
      <param name="position">Position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a persistent class</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetEntity(System.String,System.Object)">
      <summary>
            Bind an instance of a mapped persistent class to a named parameter.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a persistent class</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetEnum(System.Int32,System.Enum)">
      <summary>
            Bind an instance of a persistent enumeration class to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a persistent enumeration</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetEnum(System.String,System.Enum)">
      <summary>
            Bind an instance of a persistent enumeration class to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a persistent enumeration</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetInt16(System.Int32,System.Int16)">
      <summary>
            Bind an instance of a <see cref="T:System.Int16" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Int16" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetInt16(System.String,System.Int16)">
      <summary>
            Bind an instance of a <see cref="T:System.Int16" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Int16" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetInt32(System.Int32,System.Int32)">
      <summary>
            Bind an instance of a <see cref="T:System.Int32" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetInt32(System.String,System.Int32)">
      <summary>
            Bind an instance of a <see cref="T:System.Int32" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetInt64(System.Int32,System.Int64)">
      <summary>
            Bind an instance of a <see cref="T:System.Int64" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Int64" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetInt64(System.String,System.Int64)">
      <summary>
            Bind an instance of a <see cref="T:System.Int64" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Int64" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetSingle(System.Int32,System.Single)">
      <summary>
            Bind an instance of a <see cref="T:System.Single" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Single" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetSingle(System.String,System.Single)">
      <summary>
            Bind an instance of a <see cref="T:System.Single" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Single" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetString(System.Int32,System.String)">
      <summary>
            Bind an instance of a <see cref="T:System.String" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.String" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetString(System.String,System.String)">
      <summary>
            Bind an instance of a <see cref="T:System.String" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.String" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetTime(System.Int32,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetTime(System.String,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetTimestamp(System.Int32,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetTimestamp(System.String,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetGuid(System.Int32,System.Guid)">
      <summary>
            Bind an instance of a <see cref="T:System.Guid" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.GuidType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">An instance of a <see cref="T:System.Guid" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetGuid(System.String,System.Guid)">
      <summary>
            Bind an instance of a <see cref="T:System.Guid" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.GuidType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">An instance of a <see cref="T:System.Guid" />.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetFlushMode(NHibernate.FlushMode)">
      <summary>
            Override the current session flush mode, just for this query.
            </summary>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
      <summary>
            Set a strategy for handling the query results. This can be used to change
            "shape" of the query result.
            </summary>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetIgnoreUknownNamedParameters(System.Boolean)">
      <summary>
            Set the value to ignore unknown parameters names.
            </summary>
      <param name="ignoredUnknownNamedParameters">True to ignore unknown parameters names.</param>
    </member>
    <member name="M:NHibernate.IDetachedQuery.SetCacheMode(NHibernate.CacheMode)">
      <summary> Override the current session cache mode, just for this query. </summary>
      <param name="cacheMode">The cache mode to use. </param>
      <returns> this (for method chaining) </returns>
    </member>
    <member name="T:NHibernate.Impl.IDetachedQueryImplementor">
      <summary>
            Interface for DetachedQuery implementors.
            </summary>
      <remarks>
            When you are working with queries in "detached mode" you may need some additional services like clone, 
            copy of parameters from another query and so on.
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.IDetachedQueryImplementor.CopyTo(NHibernate.IDetachedQuery)">
      <summary>
            Copy all properties to a given <see cref="T:NHibernate.IDetachedQuery" />.
            </summary>
      <param name="destination">The given <see cref="T:NHibernate.IDetachedQuery" />.</param>
      <remarks>
            Usually the implementation use <see cref="T:NHibernate.IDetachedQuery" /> to set properties to the <paramref name="destination" />.
            This mean that existing properties are merged/overriden.
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.IDetachedQueryImplementor.SetParametersTo(NHibernate.IDetachedQuery)">
      <summary>
            Set only parameters to a given <see cref="T:NHibernate.IDetachedQuery" />.
            </summary>
      <param name="destination">The given <see cref="T:NHibernate.IDetachedQuery" />.</param>
      <remarks>
            Existing parameters are merged/overriden.
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.IDetachedQueryImplementor.OverrideInfoFrom(NHibernate.Impl.IDetachedQueryImplementor)">
      <summary>
            Override all properties reading new values from a given <see cref="T:NHibernate.Impl.IDetachedQueryImplementor" />.
            </summary>
      <param name="origin">The given origin.</param>
    </member>
    <member name="M:NHibernate.Impl.IDetachedQueryImplementor.OverrideParametersFrom(NHibernate.Impl.IDetachedQueryImplementor)">
      <summary>
            Override all parameters reading new values from a given <see cref="T:NHibernate.Impl.IDetachedQueryImplementor" />.
            </summary>
      <param name="origin">The given origin.</param>
    </member>
    <member name="T:NHibernate.Impl.AbstractDetachedQuery">
      <summary>
            Base class to create queries in "detached mode" where the NHibernate session is not available.
            </summary>
      <seealso cref="T:NHibernate.IDetachedQuery" />
      <seealso cref="T:NHibernate.Impl.AbstractQueryImpl" />
      <remarks>
            The behaviour of each method is basically the same of <see cref="T:NHibernate.Impl.AbstractQueryImpl" /> methods.
            The main difference is on <see cref="M:NHibernate.Impl.AbstractDetachedQuery.SetProperties(System.Object)" />:
            If you mix <see cref="T:System.Object" /> with named parameters setter, if same param name are found,
            the value of the parameter setter override the value read from the POCO.
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.AbstractDetachedQuery.SetCacheMode(NHibernate.CacheMode)">
      <summary> Override the current session cache mode, just for this query. </summary>
      <param name="cacheMode">The cache mode to use. </param>
      <returns> this (for method chaining) </returns>
    </member>
    <member name="M:NHibernate.Impl.AbstractDetachedQuery.SetQueryProperties(NHibernate.IQuery)">
      <summary>
            Fill all <see cref="T:NHibernate.IQuery" /> properties.
            </summary>
      <param name="q">The <see cref="T:NHibernate.IQuery" />.</param>
      <remarks>
            Query properties are overriden/merged.
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.AbstractDetachedQuery.CopyTo(NHibernate.IDetachedQuery)">
      <summary>
            Copy all properties to a given <see cref="T:NHibernate.IDetachedQuery" />.
            </summary>
      <param name="destination">The given <see cref="T:NHibernate.IDetachedQuery" />.</param>
      <remarks>
            The method use <see cref="T:NHibernate.IDetachedQuery" /> to set properties of <paramref name="destination" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.AbstractDetachedQuery.SetParametersTo(NHibernate.IDetachedQuery)">
      <summary>
            Set only parameters to a given <see cref="T:NHibernate.IDetachedQuery" />.
            </summary>
      <param name="destination">The given <see cref="T:NHibernate.IDetachedQuery" />.</param>
      <remarks>
            The method use <see cref="T:NHibernate.IDetachedQuery" /> to set properties of <paramref name="destination" />.
            Existing parameters in <paramref name="destination" /> are merged/overriden.
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.AbstractDetachedQuery.CopyParametersFrom(NHibernate.Impl.IDetachedQueryImplementor)">
      <summary>
            Clear all existing parameters and copy new parameters from a given origin.
            </summary>
      <param name="origin">The origin of parameters.</param>
      <returns>The current instance</returns>
      <exception cref="T:System.ArgumentNullException">If <paramref name="origin" /> is null.</exception>
    </member>
    <member name="T:NHibernate.IQuery">
      <summary>
            An object-oriented representation of a NHibernate query.
            </summary>
      <remarks>
            An <c>IQuery</c> instance is obtained by calling <c>ISession.CreateQuery()</c>. This interface
            exposes some extra functionality beyond that provided by <c>ISession.Iterate()</c> and
            <c>ISession.List()</c>;
            <list><item>
            		A particulare page of the result set may be selected by calling 
            		<c>SetMaxResults()</c>, <c>SetFirstResult()</c>.  The generated sql
            		depends on the capabilities of the <see cref="T:NHibernate.Dialect.Dialect" />.  Some
            		Dialects are for databases that have built in paging (LIMIT) and those capabilities
            		will be used to limit the number of records returned by the sql statement. 
            		If the database does not support LIMITs then all of the records will be returned,
            		but the objects created will be limited to the specific results requested.
            	</item><item>Named query parameters may be used</item></list><para>
            Named query parameters are tokens of the form <c>:name</c> in the query string. A value is bound
            to the <c>Int32</c> parameter <c>:foo</c> by calling
            <code>
            	SetParameter("foo", foo, NHibernateUtil.Int32);
            </code>
            for example. A name may appear multiple times in the query string.
            </para><para>
            Unnamed parameters <c>?</c> are also supported. To bind a value to an unnamed
            parameter use a Set method that accepts an <c>Int32</c> positional argument - numbered from
            zero.
            </para><para>
            You may not mix and match unnamed parameters and named parameters in the same query.
            </para><para>
            Queries are executed by calling <c>List()</c> or <c>Iterate()</c>. A query
            may be re-executed by subsequent invocations. Its lifespan is, however, bounded by the lifespan
            of the <c>ISession</c> that created it.
            </para><para>
            Implementors are not intended to be threadsafe.
            </para></remarks>
    </member>
    <member name="M:NHibernate.IQuery.Enumerable">
      <summary>
            Return the query results as an <see cref="T:System.Collections.IEnumerable" />. If the query contains multiple results
            per row, the results are returned in an instance of <c>object[]</c>.
            </summary>
      <remarks>
        <p>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only.  
            </p>
        <p>
            This is a good strategy to use if you expect a high number of the objects
            returned to be already loaded in the <see cref="T:NHibernate.ISession" /> or in the 2nd level cache.
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.IQuery.Enumerable``1">
      <summary>
            Strongly-typed version of <see cref="M:NHibernate.IQuery.Enumerable" />.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IQuery.List">
      <summary>
            Return the query results as an <see cref="T:System.Collections.IList" />. If the query contains multiple results per row,
            the results are returned in an instance of <c>object[]</c>.
            </summary>
      <returns>The <see cref="T:System.Collections.IList" /> filled with the results.</returns>
      <remarks>
            This is a good strategy to use if you expect few of the objects being returned are already loaded
            or if you want to fill the 2nd level cache.
            </remarks>
    </member>
    <member name="M:NHibernate.IQuery.List(System.Collections.IList)">
      <summary>
            Return the query results an place them into the <see cref="T:System.Collections.IList" />.
            </summary>
      <param name="results">The <see cref="T:System.Collections.IList" /> to place the results in.</param>
    </member>
    <member name="M:NHibernate.IQuery.List``1">
      <summary>
            Strongly-typed version of <see cref="M:NHibernate.IQuery.List" />.
            </summary>
    </member>
    <member name="M:NHibernate.IQuery.UniqueResult">
      <summary>
            Convenience method to return a single instance that matches
            the query, or null if the query returns no results.
            </summary>
      <returns>the single result or <see langword="null" /></returns>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when there is more than one matching result.
            </exception>
    </member>
    <member name="M:NHibernate.IQuery.UniqueResult``1">
      <summary>
            Strongly-typed version of <see cref="M:NHibernate.IQuery.UniqueResult" />.
            </summary>
    </member>
    <member name="M:NHibernate.IQuery.ExecuteUpdate">
      <summary> 
            Execute the update or delete statement.
            </summary>
      <returns> The number of entities updated or deleted. </returns>
    </member>
    <member name="M:NHibernate.IQuery.SetMaxResults(System.Int32)">
      <summary>
            Set the maximum number of rows to retrieve.
            </summary>
      <param name="maxResults">The maximum number of rows to retreive.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetFirstResult(System.Int32)">
      <summary>
            Sets the first row to retrieve.
            </summary>
      <param name="firstResult">The first row to retreive.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetReadOnly(System.Boolean)">
      <summary> 
            Entities retrieved by this query will be loaded in 
            a read-only mode where Hibernate will never dirty-check
            them or make changes persistent. 
            </summary>
    </member>
    <member name="M:NHibernate.IQuery.SetCacheable(System.Boolean)">
      <summary>
            Enable caching of this query result set.
            </summary>
      <param name="cacheable">Should the query results be cacheable?</param>
    </member>
    <member name="M:NHibernate.IQuery.SetCacheRegion(System.String)">
            Set the name of the cache region.
            <param name="cacheRegion">The name of a query cache region, or <see langword="null" />
            for the default query cache</param></member>
    <member name="M:NHibernate.IQuery.SetTimeout(System.Int32)">
      <summary>
            The timeout for the underlying ADO query
            </summary>
      <param name="timeout">
      </param>
    </member>
    <member name="M:NHibernate.IQuery.SetFetchSize(System.Int32)">
      <summary> Set a fetch size for the underlying ADO query.</summary>
      <param name="fetchSize">the fetch size </param>
    </member>
    <member name="M:NHibernate.IQuery.SetLockMode(System.String,NHibernate.LockMode)">
      <summary>
            Set the lockmode for the objects idententified by the
            given alias that appears in the <c>FROM</c> clause.
            </summary>
      <param name="alias">alias a query alias, or <c>this</c> for a collection filter</param>
      <param name="lockMode">
      </param>
    </member>
    <member name="M:NHibernate.IQuery.SetComment(System.String)">
      <summary> Add a comment to the generated SQL.</summary>
      <param name="comment">a human-readable string </param>
    </member>
    <member name="M:NHibernate.IQuery.SetFlushMode(NHibernate.FlushMode)">
      <summary>
            Override the current session flush mode, just for this query.
            </summary>
    </member>
    <member name="M:NHibernate.IQuery.SetCacheMode(NHibernate.CacheMode)">
      <summary> Override the current session cache mode, just for this query. </summary>
      <param name="cacheMode">The cache mode to use. </param>
      <returns> this (for method chaining) </returns>
    </member>
    <member name="M:NHibernate.IQuery.SetParameter(System.Int32,System.Object,NHibernate.Type.IType)">
      <summary>
            Bind a value to an indexed parameter.
            </summary>
      <param name="position">Position of the parameter in the query, numbered from <c>0</c></param>
      <param name="val">The possibly null parameter value</param>
      <param name="type">The Hibernate type</param>
    </member>
    <member name="M:NHibernate.IQuery.SetParameter(System.String,System.Object,NHibernate.Type.IType)">
      <summary>
            Bind a value to a named query parameter
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">The possibly null parameter value</param>
      <param name="type">The NHibernate <see cref="T:NHibernate.Type.IType" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetParameter``1(System.Int32,``0)">
      <summary>
            Bind a value to an indexed parameter.
            </summary>
      <param name="position">Position of the parameter in the query, numbered from <c>0</c></param>
      <param name="val">The possibly null parameter value</param>
      <typeparam name="T">The parameter's <see cref="N:NHibernate.Type" /></typeparam>
    </member>
    <member name="M:NHibernate.IQuery.SetParameter``1(System.String,``0)">
      <summary>
            Bind a value to a named query parameter
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">The possibly null parameter value</param>
      <typeparam name="T">The parameter's <see cref="N:NHibernate.Type" /></typeparam>
    </member>
    <member name="M:NHibernate.IQuery.SetParameter(System.Int32,System.Object)">
      <summary>
            Bind a value to an indexed parameter, guessing the Hibernate type from
            the class of the given object.
            </summary>
      <param name="position">The position of the parameter in the query, numbered from <c>0</c></param>
      <param name="val">The non-null parameter value</param>
    </member>
    <member name="M:NHibernate.IQuery.SetParameter(System.String,System.Object)">
      <summary>
            Bind a value to a named query parameter, guessing the NHibernate <see cref="T:NHibernate.Type.IType" />
            from the class of the given object.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">The non-null parameter value</param>
    </member>
    <member name="M:NHibernate.IQuery.SetParameterList(System.String,System.Collections.ICollection,NHibernate.Type.IType)">
      <summary>
            Bind multiple values to a named query parameter. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c></summary>
      <param name="name">The name of the parameter</param>
      <param name="vals">A collection of values to list</param>
      <param name="type">The Hibernate type of the values</param>
    </member>
    <member name="M:NHibernate.IQuery.SetParameterList(System.String,System.Collections.ICollection)">
      <summary>
            Bind multiple values to a named query parameter, guessing the Hibernate
            type from the class of the first object in the collection. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c></summary>
      <param name="name">The name of the parameter</param>
      <param name="vals">A collection of values to list</param>
    </member>
    <member name="M:NHibernate.IQuery.SetParameterList(System.String,System.Object[],NHibernate.Type.IType)">
      <summary> 
            Bind multiple values to a named query parameter. This is useful for binding
            a list of values to an expression such as <tt>foo.bar in (:value_list)</tt>.
            </summary>
      <param name="name">the name of the parameter </param>
      <param name="vals">a collection of values to list </param>
      <param name="type">the Hibernate type of the values </param>
    </member>
    <member name="M:NHibernate.IQuery.SetParameterList(System.String,System.Object[])">
      <summary> 
            Bind multiple values to a named query parameter. The Hibernate type of the parameter is
            first detected via the usage/position in the query and if not sufficient secondly 
            guessed from the class of the first object in the array. This is useful for binding a list of values
            to an expression such as <tt>foo.bar in (:value_list)</tt>.
            </summary>
      <param name="name">the name of the parameter </param>
      <param name="vals">a collection of values to list </param>
    </member>
    <member name="M:NHibernate.IQuery.SetProperties(System.Object)">
      <summary>
            Bind the property values of the given object to named parameters of the query,
            matching property names with parameter names and mapping property types to
            Hibernate types using heuristics.
            </summary>
      <param name="obj">Any PONO</param>
    </member>
    <member name="M:NHibernate.IQuery.SetAnsiString(System.Int32,System.String)">
      <summary>
            Bind an instance of a <see cref="T:System.String" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.String" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetAnsiString(System.String,System.String)">
      <summary>
            Bind an instance of a <see cref="T:System.String" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.String" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetBinary(System.Int32,System.Byte[])">
      <summary>
            Bind an instance of a <see cref="T:System.Byte" /> array to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Byte" /> array.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetBinary(System.String,System.Byte[])">
      <summary>
            Bind an instance of a <see cref="T:System.Byte" /> array to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Byte" /> array.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetBoolean(System.Int32,System.Boolean)">
      <summary>
            Bind an instance of a <see cref="T:System.Boolean" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Boolean" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetBoolean(System.String,System.Boolean)">
      <summary>
            Bind an instance of a <see cref="T:System.Boolean" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Boolean" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetByte(System.Int32,System.Byte)">
      <summary>
            Bind an instance of a <see cref="T:System.Byte" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Byte" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetByte(System.String,System.Byte)">
      <summary>
            Bind an instance of a <see cref="T:System.Byte" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Byte" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetCharacter(System.Int32,System.Char)">
      <summary>
            Bind an instance of a <see cref="T:System.Char" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Char" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetCharacter(System.String,System.Char)">
      <summary>
            Bind an instance of a <see cref="T:System.Char" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Char" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetDateTime(System.Int32,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetDateTime(System.String,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType" />.
            </summary>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
      <param name="name">The name of the parameter</param>
    </member>
    <member name="M:NHibernate.IQuery.SetDecimal(System.Int32,System.Decimal)">
      <summary>
            Bind an instance of a <see cref="T:System.Decimal" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Decimal" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetDecimal(System.String,System.Decimal)">
      <summary>
            Bind an instance of a <see cref="T:System.Decimal" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Decimal" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetDouble(System.Int32,System.Double)">
      <summary>
            Bind an instance of a <see cref="T:System.Double" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Double" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetDouble(System.String,System.Double)">
      <summary>
            Bind an instance of a <see cref="T:System.Double" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Double" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetEnum(System.Int32,System.Enum)">
      <summary>
            Bind an instance of a persistent enumeration class to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a persistent enumeration</param>
    </member>
    <member name="M:NHibernate.IQuery.SetEnum(System.String,System.Enum)">
      <summary>
            Bind an instance of a persistent enumeration class to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a persistent enumeration</param>
    </member>
    <member name="M:NHibernate.IQuery.SetInt16(System.Int32,System.Int16)">
      <summary>
            Bind an instance of a <see cref="T:System.Int16" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Int16" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetInt16(System.String,System.Int16)">
      <summary>
            Bind an instance of a <see cref="T:System.Int16" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Int16" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetInt32(System.Int32,System.Int32)">
      <summary>
            Bind an instance of a <see cref="T:System.Int32" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetInt32(System.String,System.Int32)">
      <summary>
            Bind an instance of a <see cref="T:System.Int32" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetInt64(System.Int32,System.Int64)">
      <summary>
            Bind an instance of a <see cref="T:System.Int64" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Int64" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetInt64(System.String,System.Int64)">
      <summary>
            Bind an instance of a <see cref="T:System.Int64" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Int64" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetSingle(System.Int32,System.Single)">
      <summary>
            Bind an instance of a <see cref="T:System.Single" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.Single" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetSingle(System.String,System.Single)">
      <summary>
            Bind an instance of a <see cref="T:System.Single" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Single" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetString(System.Int32,System.String)">
      <summary>
            Bind an instance of a <see cref="T:System.String" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.String" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetString(System.String,System.String)">
      <summary>
            Bind an instance of a <see cref="T:System.String" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.String" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetTime(System.Int32,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetTime(System.String,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetTimestamp(System.Int32,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetTimestamp(System.String,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetGuid(System.Int32,System.Guid)">
      <summary>
            Bind an instance of a <see cref="T:System.Guid" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.GuidType" />.
            </summary>
      <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">An instance of a <see cref="T:System.Guid" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetGuid(System.String,System.Guid)">
      <summary>
            Bind an instance of a <see cref="T:System.Guid" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.GuidType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">An instance of a <see cref="T:System.Guid" />.</param>
    </member>
    <member name="M:NHibernate.IQuery.SetEntity(System.Int32,System.Object)">
      <summary>
            Bind an instance of a mapped persistent class to an indexed parameter.
            </summary>
      <param name="position">Position of the parameter in the query string, numbered from <c>0</c></param>
      <param name="val">A non-null instance of a persistent class</param>
    </member>
    <member name="M:NHibernate.IQuery.SetEntity(System.String,System.Object)">
      <summary>
            Bind an instance of a mapped persistent class to a named parameter.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a persistent class</param>
    </member>
    <member name="M:NHibernate.IQuery.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
      <summary>
            Set a strategy for handling the query results. This can be used to change
            "shape" of the query result.
            </summary>
    </member>
    <member name="M:NHibernate.IQuery.Future``1">
      <summary>
            Get a enumerable that when enumerated will execute
            a batch of queries in a single database roundtrip
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IQuery.FutureValue``1">
      <summary>
            Get an IFutureValue instance, whose value can be retrieved through
            its Value property. The query is not executed until the Value property
            is retrieved, which will execute other Future queries as well in a
            single roundtrip
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.IQuery.QueryString">
      <summary>
            The query string
            </summary>
    </member>
    <member name="P:NHibernate.IQuery.ReturnTypes">
      <summary>
            The Hibernate types of the query result set.
            </summary>
    </member>
    <member name="P:NHibernate.IQuery.ReturnAliases">
      <summary> Return the HQL select clause aliases (if any)</summary>
      <returns> an array of aliases as strings </returns>
    </member>
    <member name="P:NHibernate.IQuery.NamedParameters">
      <summary>
            The names of all named parameters of the query
            </summary>
      <value>The parameter names, in no particular order</value>
    </member>
    <member name="T:NHibernate.Impl.AbstractQueryImpl">
      <summary>
            Abstract implementation of the IQuery interface.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.AbstractQueryImpl.VerifyParameters(System.Boolean)">
      <summary> 
            Perform parameter validation.  Used prior to executing the encapsulated query. 
            </summary>
      <param name="reserveFirstParameter">
            if true, the first ? will not be verified since
            its needed for e.g. callable statements returning a out parameter
            </param>
    </member>
    <member name="M:NHibernate.Impl.AbstractQueryImpl.GuessType(System.Object)">
      <summary>
            Guesses the <see cref="T:NHibernate.Type.IType" /> from the <c>param</c>'s value.
            </summary>
      <param name="param">The object to guess the <see cref="T:NHibernate.Type.IType" /> of.</param>
      <returns>An <see cref="T:NHibernate.Type.IType" /> for the object.</returns>
      <exception cref="T:System.ArgumentNullException">
            Thrown when the <c>param</c> is null because the <see cref="T:NHibernate.Type.IType" />
            can't be guess from a null value.
            </exception>
    </member>
    <member name="M:NHibernate.Impl.AbstractQueryImpl.GuessType(System.Type)">
      <summary>
            Guesses the <see cref="T:NHibernate.Type.IType" /> from the <see cref="T:System.Type" />.
            </summary>
      <param name="clazz">The <see cref="T:System.Type" /> to guess the <see cref="T:NHibernate.Type.IType" /> of.</param>
      <returns>An <see cref="T:NHibernate.Type.IType" /> for the <see cref="T:System.Type" />.</returns>
      <exception cref="T:System.ArgumentNullException">
            Thrown when the <c>clazz</c> is null because the <see cref="T:NHibernate.Type.IType" />
            can't be guess from a null type.
            </exception>
    </member>
    <member name="M:NHibernate.Impl.AbstractQueryImpl.ExpandParameterLists(System.Collections.Generic.IDictionary{System.String,NHibernate.Engine.TypedValue})">
      <summary> 
            Warning: adds new parameters to the argument by side-effect, as well as mutating the query string!
            </summary>
    </member>
    <member name="M:NHibernate.Impl.AbstractQueryImpl.ExpandParameterList(System.String,System.String,NHibernate.Engine.TypedValue,System.Collections.Generic.IDictionary{System.String,NHibernate.Engine.TypedValue})">
      <summary> 
            Warning: adds new parameters to the argument by side-effect, as well as mutating the query string!
            </summary>
    </member>
    <member name="M:NHibernate.Impl.AbstractQueryImpl.SetCacheMode(NHibernate.CacheMode)">
      <summary> Override the current session cache mode, just for this query.
            </summary>
      <param name="cacheMode">The cache mode to use. </param>
      <returns> this (for method chaining) </returns>
    </member>
    <member name="T:NHibernate.Impl.AbstractSessionImpl">
      <summary> Functionality common to stateless and stateful sessions </summary>
    </member>
    <member name="T:NHibernate.Impl.QueryImpl">
      <summary> 
            Default implementation of the <see cref="T:NHibernate.IQuery" />,
            for "ordinary" HQL queries (not collection filters)
            </summary>
      <seealso cref="T:NHibernate.Impl.CollectionFilterImpl" />
    </member>
    <member name="T:NHibernate.Impl.CollectionFilterImpl">
      <summary>
            Implementation of the <see cref="T:NHibernate.IQuery" /> interface for collection filters.
            </summary>
    </member>
    <member name="T:NHibernate.ICriteria">
      <summary>
            Criteria is a simplified API for retrieving entities by composing
            <see cref="T:NHibernate.Criterion.Expression" /> objects.
            </summary>
      <remarks>
        <para>
            Using criteria is a very convenient approach for functionality like "search" screens
            where there is a variable number of conditions to be placed upon the result set.
            </para>
        <para>
            The Session is a factory for ICriteria. Expression instances are usually obtained via 
            the factory methods on <see cref="T:NHibernate.Criterion.Expression" />. eg:
            </para>
        <code>
            IList cats = session.CreateCriteria(typeof(Cat)) 
                .Add( Expression.Like("name", "Iz%") ) 
                .Add( Expression.Gt( "weight", minWeight ) ) 
                .AddOrder( Order.Asc("age") ) 
                .List(); 
            </code>
            You may navigate associations using <see cref="M:NHibernate.ICriteria.CreateAlias(System.String,System.String)" /> or <see cref="M:NHibernate.ICriteria.CreateCriteria(System.String)" />.
            <code>
            IList cats = session.CreateCriteria(typeof(Cat))
            	.CreateCriteria("kittens")
            		.Add( Expression.like("name", "Iz%") )
            		.List();
            </code><para>
            You may specify projection and aggregation using <tt>Projection</tt>
            instances obtained via the factory methods on <tt>Projections</tt>.
            <code>
            IList cats = session.CreateCriteria(typeof(Cat))
            .setProjection( Projections.ProjectionList()
            .Add( Projections.RowCount() )
            .Add( Projections.Avg("weight") )
            .Add( Projections.Max("weight") )
            .Add( Projections.Min("weight") )
            .Add( Projections.GroupProperty("color") )
            )
            .AddOrder( Order.Asc("color") )
            .List();	
            </code></para></remarks>
    </member>
    <member name="M:NHibernate.ICriteria.SetProjection(NHibernate.Criterion.IProjection[])">
      <summary>
            Used to specify that the query results will be a projection (scalar in
            nature).  Implicitly specifies the projection result transformer.
            </summary>
      <param name="projection">The projection representing the overall "shape" of the
            query results.</param>
      <returns>This instance (for method chaining)</returns>
      <remarks>
        <para>
            The individual components contained within the given <see cref="T:NHibernate.Criterion.IProjection" />
            determines the overall "shape" of the query result.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.ICriteria.Add(NHibernate.Criterion.ICriterion)">
      <summary>
            Add an Expression to constrain the results to be retrieved.
            </summary>
      <param name="expression">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.AddOrder(NHibernate.Criterion.Order)">
      <summary>
            An an Order to the result set 
            </summary>
      <param name="order">
      </param>
    </member>
    <member name="M:NHibernate.ICriteria.SetFetchMode(System.String,NHibernate.FetchMode)">
      <summary>
            Specify an association fetching strategy.  Currently, only
            one-to-many and one-to-one associations are supported.
            </summary>
      <param name="associationPath">A dot seperated property path.</param>
      <param name="mode">The Fetch mode.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.SetLockMode(NHibernate.LockMode)">
      <summary>
            Set the lock mode of the current entity
            </summary>
      <param name="lockMode">the lock mode</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.SetLockMode(System.String,NHibernate.LockMode)">
      <summary>
            Set the lock mode of the aliased entity
            </summary>
      <param name="alias">an alias</param>
      <param name="lockMode">the lock mode</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.CreateAlias(System.String,System.String)">
      <summary>
            Join an association, assigning an alias to the joined entity
            </summary>
      <param name="associationPath">
      </param>
      <param name="alias">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.CreateAlias(System.String,System.String,NHibernate.SqlCommand.JoinType)">
      <summary>
            Join an association using the specified join-type, assigning an alias to the joined
            association
            </summary>
      <param name="associationPath">
      </param>
      <param name="alias">
      </param>
      <param name="joinType">The type of join to use.</param>
      <returns>this (for method chaining)</returns>
    </member>
    <member name="M:NHibernate.ICriteria.CreateCriteria(System.String)">
      <summary>
            Create a new <see cref="T:NHibernate.ICriteria" />, "rooted" at the associated entity
            </summary>
      <param name="associationPath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.CreateCriteria(System.String,NHibernate.SqlCommand.JoinType)">
      <summary>
            Create a new <see cref="T:NHibernate.ICriteria" />, "rooted" at the associated entity, 
            using the specified join type.
            </summary>
      <param name="associationPath">A dot-seperated property path</param>
      <param name="joinType">The type of join to use</param>
      <returns>The created "sub criteria"</returns>
    </member>
    <member name="M:NHibernate.ICriteria.CreateCriteria(System.String,System.String)">
      <summary>
            Create a new <see cref="T:NHibernate.ICriteria" />, "rooted" at the associated entity,
            assigning the given alias
            </summary>
      <param name="associationPath">
      </param>
      <param name="alias">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.CreateCriteria(System.String,System.String,NHibernate.SqlCommand.JoinType)">
      <summary>
            Create a new <see cref="T:NHibernate.ICriteria" />, "rooted" at the associated entity,
            assigning the given alias and using the specified join type.
            </summary>
      <param name="associationPath">A dot-separated property path</param>
      <param name="alias">The alias to assign to the joined association (for later reference).</param>
      <param name="joinType">The type of join to use.</param>
      <returns>The created "sub criteria"</returns>
    </member>
    <member name="M:NHibernate.ICriteria.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
      <summary>
            Set a strategy for handling the query results. This determines the
            "shape" of the query result set.
            <seealso cref="F:NHibernate.Criterion.CriteriaSpecification.RootEntity" /><seealso cref="F:NHibernate.Criterion.CriteriaSpecification.DistinctRootEntity" /><seealso cref="F:NHibernate.Criterion.CriteriaSpecification.AliasToEntityMap" /></summary>
      <param name="resultTransformer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.SetMaxResults(System.Int32)">
      <summary>
            Set a limit upon the number of objects to be retrieved
            </summary>
      <param name="maxResults">
      </param>
    </member>
    <member name="M:NHibernate.ICriteria.SetFirstResult(System.Int32)">
      <summary>
            Set the first result to be retrieved
            </summary>
      <param name="firstResult">
      </param>
    </member>
    <member name="M:NHibernate.ICriteria.SetFetchSize(System.Int32)">
      <summary> Set a fetch size for the underlying ADO query. </summary>
      <param name="fetchSize">the fetch size </param>
      <returns> this (for method chaining) </returns>
    </member>
    <member name="M:NHibernate.ICriteria.SetTimeout(System.Int32)">
      <summary>
            Set a timeout for the underlying ADO.NET query
            </summary>
      <param name="timeout">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.SetCacheable(System.Boolean)">
      <summary>
            Enable caching of this query result set
            </summary>
      <param name="cacheable">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.SetCacheRegion(System.String)">
      <summary>
            Set the name of the cache region.
            </summary>
      <param name="cacheRegion">the name of a query cache region, or <see langword="null" />
            for the default query cache</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.SetComment(System.String)">
      <summary> Add a comment to the generated SQL. </summary>
      <param name="comment">a human-readable string </param>
      <returns> this (for method chaining) </returns>
    </member>
    <member name="M:NHibernate.ICriteria.SetFlushMode(NHibernate.FlushMode)">
      <summary> Override the flush mode for this particular query. </summary>
      <param name="flushMode">The flush mode to use. </param>
      <returns> this (for method chaining) </returns>
    </member>
    <member name="M:NHibernate.ICriteria.SetCacheMode(NHibernate.CacheMode)">
      <summary> Override the cache mode for this particular query. </summary>
      <param name="cacheMode">The cache mode to use. </param>
      <returns> this (for method chaining) </returns>
    </member>
    <member name="M:NHibernate.ICriteria.List">
      <summary>
            Get the results
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.UniqueResult">
      <summary>
            Convenience method to return a single instance that matches
            the query, or null if the query returns no results.
            </summary>
      <returns>the single result or <see langword="null" /></returns>
      <exception cref="T:NHibernate.HibernateException">
            If there is more than one matching result
            </exception>
    </member>
    <member name="M:NHibernate.ICriteria.Future``1">
      <summary>
            Get a enumerable that when enumerated will execute
            a batch of queries in a single database roundtrip
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.FutureValue``1">
      <summary>
            Get an IFutureValue instance, whose value can be retrieved through
            its Value property. The query is not executed until the Value property
            is retrieved, which will execute other Future queries as well in a
            single roundtrip
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.List(System.Collections.IList)">
      <summary>
            Get the results and fill the <see cref="T:System.Collections.IList" /></summary>
      <param name="results">The list to fill with the results.</param>
    </member>
    <member name="M:NHibernate.ICriteria.List``1">
      <summary>
            Strongly-typed version of <see cref="M:NHibernate.ICriteria.List" />.
            </summary>
    </member>
    <member name="M:NHibernate.ICriteria.UniqueResult``1">
      <summary>
            Strongly-typed version of <see cref="M:NHibernate.ICriteria.UniqueResult" />.
            </summary>
    </member>
    <member name="M:NHibernate.ICriteria.ClearOrders">
      <summary>
            Clear all orders from criteria.
            </summary>
    </member>
    <member name="M:NHibernate.ICriteria.GetCriteriaByPath(System.String)">
      <summary>
            Allows to get a sub criteria by path.
            Will return null if the criteria does not exists.
            </summary>
      <param name="path">The path.</param>
    </member>
    <member name="M:NHibernate.ICriteria.GetCriteriaByAlias(System.String)">
      <summary>
            Alows to get a sub criteria by alias.
            Will return null if the criteria does not exists
            </summary>
      <param name="alias">The alias.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.ICriteria.GetRootEntityTypeIfAvailable">
      <summary>
            Gets the root entity type if available, throws otherwise
            </summary>
      <remarks>
            This is an NHibernate specific method, used by several dependent 
            frameworks for advance integration with NHibernate.
            </remarks>
    </member>
    <member name="P:NHibernate.ICriteria.Alias">
      <summary>
            Get the alias of the entity encapsulated by this criteria instance.
            </summary>
      <value>The alias for the encapsulated entity.</value>
    </member>
    <member name="T:NHibernate.Impl.CriteriaImpl">
      <summary>
            Implementation of the <see cref="T:NHibernate.ICriteria" /> interface
            </summary>
    </member>
    <member name="M:NHibernate.Impl.CriteriaImpl.Subcriteria.SetCacheMode(NHibernate.CacheMode)">
      <summary> Override the cache mode for this particular query. </summary>
      <param name="cacheMode">The cache mode to use. </param>
      <returns> this (for method chaining) </returns>
    </member>
    <member name="M:NHibernate.Impl.CriteriaImpl.Subcriteria.Clone">
      <summary>
            The Clone is supported only by a root criteria.
            </summary>
      <returns>The clone of the root criteria.</returns>
    </member>
    <member name="M:NHibernate.Impl.CriteriaImpl.SetCacheMode(NHibernate.CacheMode)">
      <summary> Override the cache mode for this particular query. </summary>
      <param name="cacheMode">The cache mode to use. </param>
      <returns> this (for method chaining) </returns>
    </member>
    <member name="M:NHibernate.Impl.IDbCommandSet.Append(System.Data.IDbCommand)">
      <summary>
            Append a command to the batch
            </summary>
      <param name="command">
      </param>
    </member>
    <member name="M:NHibernate.Impl.IDbCommandSet.ExecuteNonQuery">
      <summary>
            Executes the batch
            </summary>
      <returns>
            This seems to be returning the total number of affected rows in all queries
            </returns>
    </member>
    <member name="P:NHibernate.Impl.IDbCommandSet.BatchCommand">
      <summary>
            Return the batch command to be executed
            </summary>
    </member>
    <member name="P:NHibernate.Impl.IDbCommandSet.CountOfCommands">
      <summary>
            The number of commands batched in this instance
            </summary>
    </member>
    <member name="T:NHibernate.Impl.DbCommandSet`2">
      <summary>
            Expose the batch functionality in ADO.Net 2.0
            Microsoft in its wisdom decided to make my life hard and mark it internal.
            Through the use of Reflection and some delegates magic, I opened up the functionality.
            
            Observable performance benefits are 50%+ when used, so it is really worth it.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.DbCommandSet`2.Append(System.Data.IDbCommand)">
      <summary>
            Append a command to the batch
            </summary>
      <param name="command">
      </param>
    </member>
    <member name="M:NHibernate.Impl.DbCommandSet`2.AssertHasParameters(System.Data.IDbCommand)">
      <summary>
            This is required because SqlClient.SqlCommandSet will throw if 
            the command has no parameters.
            </summary>
      <param name="command">
      </param>
    </member>
    <member name="M:NHibernate.Impl.DbCommandSet`2.ExecuteNonQuery">
      <summary>
            Executes the batch
            </summary>
      <returns>
            This seems to be returning the total number of affected rows in all queries
            </returns>
    </member>
    <member name="M:NHibernate.Impl.DbCommandSet`2.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:NHibernate.Impl.DbCommandSet`2.BatchCommand">
      <summary>
            Return the batch command to be executed
            </summary>
    </member>
    <member name="P:NHibernate.Impl.DbCommandSet`2.CountOfCommands">
      <summary>
            The number of commands batched in this instance
            </summary>
    </member>
    <member name="T:NHibernate.Impl.DetachedNamedQuery">
      <summary>
            Named query in "detached mode" where the NHibernate session is not available.
            </summary>
      <seealso cref="T:NHibernate.Impl.AbstractDetachedQuery" />
      <seealso cref="T:NHibernate.IDetachedQuery" />
      <seealso cref="T:NHibernate.IQuery" />
      <seealso cref="M:NHibernate.ISession.GetNamedQuery(System.String)" />
    </member>
    <member name="M:NHibernate.Impl.DetachedNamedQuery.#ctor(System.String)">
      <summary>
            Create a new instance of <see cref="T:NHibernate.Impl.DetachedNamedQuery" /> for a named query string defined in the mapping file.
            </summary>
      <param name="queryName">The name of a query defined externally.</param>
      <remarks>
            The query can be either in HQL or SQL format.
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.DetachedNamedQuery.GetExecutableQuery(NHibernate.ISession)">
      <summary>
            Get an executable instance of <see cref="T:NHibernate.IQuery" />, to actually run the query.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.DetachedNamedQuery.Clone">
      <summary>
            Creates a new DetachedNamedQuery that is a deep copy of the current instance.
            </summary>
      <returns>The clone.</returns>
    </member>
    <member name="P:NHibernate.Impl.DetachedNamedQuery.QueryName">
      <summary>
            Get the query name.
            </summary>
    </member>
    <member name="T:NHibernate.Impl.DetachedQuery">
      <summary>
            Query in "detached mode" where the NHibernate session is not available.
            </summary>
      <seealso cref="T:NHibernate.Impl.AbstractDetachedQuery" />
      <seealso cref="T:NHibernate.IDetachedQuery" />
      <seealso cref="T:NHibernate.IQuery" />
    </member>
    <member name="M:NHibernate.Impl.DetachedQuery.#ctor(System.String)">
      <summary>
            Create a new instance of <see cref="T:NHibernate.Impl.DetachedQuery" /> for the given query string.
            </summary>
      <param name="hql">A hibernate query string</param>
    </member>
    <member name="M:NHibernate.Impl.DetachedQuery.GetExecutableQuery(NHibernate.ISession)">
      <summary>
            Get an executable instance of <see cref="T:NHibernate.IQuery" />, to actually run the query.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.DetachedQuery.Clone">
      <summary>
            Creates a new DetachedQuery that is a deep copy of the current instance.
            </summary>
      <returns>The clone.</returns>
    </member>
    <member name="P:NHibernate.Impl.DetachedQuery.Hql">
      <summary>
            Get the HQL string.
            </summary>
    </member>
    <member name="T:NHibernate.Impl.EnumerableImpl">
      <summary>
            Provides an <see cref="T:System.Collections.IEnumerable" /> wrapper over the results of an <see cref="T:NHibernate.IQuery" />.
            </summary>
      <remarks>
            This is the IteratorImpl in H2.0.3
            </remarks>
    </member>
    <member name="F:NHibernate.Impl.EnumerableImpl._isAlreadyDisposed">
      <summary>
            A flag to indicate if <c>Dispose()</c> has been called.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.EnumerableImpl.#ctor(System.Data.IDataReader,System.Data.IDbCommand,NHibernate.Engine.ISessionImplementor,NHibernate.Type.IType[],System.String[][],NHibernate.Engine.RowSelection,NHibernate.Hql.HolderInstantiator)">
      <summary>
            Create an <see cref="T:System.Collections.IEnumerable" /> wrapper over an <see cref="T:System.Data.IDataReader" />.
            </summary>
      <param name="reader">The <see cref="T:System.Data.IDataReader" /> to enumerate over.</param>
      <param name="cmd">The <see cref="T:System.Data.IDbCommand" /> used to create the <see cref="T:System.Data.IDataReader" />.</param>
      <param name="sess">The <see cref="T:NHibernate.ISession" /> to use to load objects.</param>
      <param name="types">The <see cref="T:NHibernate.Type.IType" />s contained in the <see cref="T:System.Data.IDataReader" />.</param>
      <param name="columnNames">The names of the columns in the <see cref="T:System.Data.IDataReader" />.</param>
      <param name="selection">The <see cref="T:NHibernate.Engine.RowSelection" /> that should be applied to the <see cref="T:System.Data.IDataReader" />.</param>
      <param name="holderInstantiator">Instantiator of the result holder (used for "select new SomeClass(...)" queries).</param>
      <remarks>
            The <see cref="T:System.Data.IDataReader" /> should already be positioned on the first record in <see cref="T:NHibernate.Engine.RowSelection" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.EnumerableImpl.GetEnumerator">
      <summary>
            Returns an enumerator that can iterate through the query results.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> that can be used to iterate through the query results.
            </returns>
    </member>
    <member name="M:NHibernate.Impl.EnumerableImpl.MoveNext">
      <summary>
             Advances the enumerator to the next element of the query results.
             </summary>
      <returns>
        <see langword="true" /> if the enumerator was successfully advanced to the next query results
             ; <see langword="false" /> if the enumerator has passed the end of the query results.
            </returns>
    </member>
    <member name="M:NHibernate.Impl.EnumerableImpl.Reset">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Impl.EnumerableImpl.Finalize">
      <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.EnumerableImpl.Dispose">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.EnumerableImpl.Dispose(System.Boolean)">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
      <param name="isDisposing">Indicates if this EnumerableImpl is being Disposed of or Finalized.</param>
      <remarks>
            The command is closed and the reader is disposed.  This allows other ADO.NET
            related actions to occur without needing to move all the way through the
            EnumerableImpl.
            </remarks>
    </member>
    <member name="P:NHibernate.Impl.EnumerableImpl.Current">
      <summary>
            Gets the current element in the query results.
            </summary>
      <value>
            The current element in the query results which is either an object or 
            an object array.
            </value>
      <remarks>
            If the <see cref="T:NHibernate.IQuery" /> only returns one type of Entity then an object will
            be returned.  If this is a multi-column resultset then an object array will be
            returned.
            </remarks>
    </member>
    <member name="T:NHibernate.IFilter">
      <summary>
            Type definition of Filter.  Filter defines the user's view into enabled dynamic filters,
            allowing them to set filter parameter values.
            </summary>
    </member>
    <member name="M:NHibernate.IFilter.SetParameter(System.String,System.Object)">
      <summary>
            Set the named parameter's value list for this filter. 
            </summary>
      <param name="name">The parameter's name.</param>
      <param name="value">The values to be applied.</param>
      <returns>This FilterImpl instance (for method chaining).</returns>
    </member>
    <member name="M:NHibernate.IFilter.SetParameterList(System.String,System.Collections.ICollection)">
      <summary>
            Set the named parameter's value list for this filter.  Used
            in conjunction with IN-style filter criteria.        
            </summary>
      <param name="name">The parameter's name.</param>
      <param name="values">The values to be expanded into an SQL IN list.</param>
      <returns>This FilterImpl instance (for method chaining).</returns>
    </member>
    <member name="M:NHibernate.IFilter.SetParameterList(System.String,System.Object[])">
      <summary>
            Set the named parameter's value list for this filter.  Used
            in conjunction with IN-style filter criteria.        
            </summary>
      <param name="name">The parameter's name.</param>
      <param name="values">The values to be expanded into an SQL IN list.</param>
      <returns>This FilterImpl instance (for method chaining).</returns>
    </member>
    <member name="M:NHibernate.IFilter.Validate">
      <summary>
            Perform validation of the filter state.  This is used to verify the
            state of the filter after its enablement and before its use.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.IFilter.Name">
      <summary>
            Get the name of this filter. 
            </summary>
      <returns>This filter's name.</returns>
    </member>
    <member name="P:NHibernate.IFilter.FilterDefinition">
      <summary>
            Get the filter definition containing additional information about the
            filter (such as default-condition and expected parameter names/types).
            </summary>
      <returns>The filter definition</returns>
    </member>
    <member name="T:NHibernate.Impl.FilterImpl">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Impl.FilterImpl.SetParameter(System.String,System.Object)">
      <summary>
            Set the named parameter's value for this filter.
            </summary>
      <param name="name">The parameter's name.</param>
      <param name="value">The value to be applied.</param>
      <returns>This FilterImpl instance (for method chaining).</returns>
    </member>
    <member name="M:NHibernate.Impl.FilterImpl.SetParameterList(System.String,System.Collections.ICollection)">
      <summary>
            Set the named parameter's value list for this filter.  Used
            in conjunction with IN-style filter criteria.
            </summary>
      <param name="name">The parameter's name.</param>
      <param name="values">The values to be expanded into an SQL IN list.</param>
      <returns>This FilterImpl instance (for method chaining).</returns>
    </member>
    <member name="M:NHibernate.Impl.FilterImpl.SetParameterList(System.String,System.Object[])">
      <summary>
            Set the named parameter's value list for this filter.  Used
            in conjunction with IN-style filter criteria.        
            </summary>
      <param name="name">The parameter's name.</param>
      <param name="values">The values to be expanded into an SQL IN list.</param>
      <returns>This FilterImpl instance (for method chaining).</returns>
    </member>
    <member name="M:NHibernate.Impl.FilterImpl.Validate">
      <summary>
            Perform validation of the filter state.  This is used to verify the
            state of the filter after its enablement and before its use.
            </summary>
    </member>
    <member name="P:NHibernate.Impl.FilterImpl.Name">
      <summary>
            Get the name of this filter.
            </summary>
    </member>
    <member name="T:NHibernate.Impl.MessageHelper">
      <summary>
            Helper methods for rendering log messages and exception messages
            </summary>
    </member>
    <member name="M:NHibernate.Impl.MessageHelper.InfoString(System.Type,System.Object)">
      <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
      <param name="clazz">The <see cref="T:System.Type" /> to create the string from.</param>
      <param name="id">The identifier of the object.</param>
      <returns>A descriptive <see cref="T:System.String" /> in the format of <c>[classname#id]</c></returns>
    </member>
    <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
      <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> for the class in question.</param>
      <param name="id">The identifier of the object.</param>
      <param name="factory">The <see cref="T:NHibernate.ISessionFactory" />.</param>
      <returns>A descriptive <see cref="T:System.String" /> in the format of <c>[classname#id]</c></returns>
    </member>
    <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Entity.IEntityPersister,System.Object,NHibernate.Type.IType,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
      <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> for the class in question.</param>
      <param name="id">The identifier of the object.</param>
      <param name="factory">The <see cref="T:NHibernate.ISessionFactory" />.</param>
      <param name="identifierType">The NHibernate type of the identifier.</param>
      <returns>A descriptive <see cref="T:System.String" /> in the format of <c>[classname#id]</c></returns>
    </member>
    <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Entity.IEntityPersister,System.Object)">
      <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
      <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> for the class in question</param>
      <param name="id">The id</param>
      <returns>A descriptive <see cref="T:System.String" /> in the form <c>[FooBar#id]</c></returns>
    </member>
    <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Entity.IEntityPersister)">
      <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
      <param name="persister">The <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> for the class in question</param>
      <returns>A descriptive <see cref="T:System.String" /> in the form <c>[FooBar]</c></returns>
    </member>
    <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
      <param name="persister">The <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> for the class in question</param>
      <param name="id">The id</param>
      <returns>A descriptive <see cref="T:System.String" /> in the form <c>[collectionrole#id]</c></returns>
    </member>
    <member name="M:NHibernate.Impl.MessageHelper.InfoString(System.String,System.String,System.Object)">
      <summary> 
            Generate an info message string relating to a given property value
            for an entity. 
            </summary>
      <param name="entityName">The entity name </param>
      <param name="propertyName">The name of the property </param>
      <param name="key">The property value. </param>
      <returns> An info string, in the form [Foo.bars#1] </returns>
    </member>
    <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.Collection.ICollectionPersister,System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary> 
            Generate an info message string relating to a particular managed
            collection.
            </summary>
      <param name="persister">The persister for the collection </param>
      <param name="id">The id value of the owner </param>
      <param name="factory">The session factory </param>
      <returns> An info string, in the form [Foo.bars#1] </returns>
    </member>
    <member name="M:NHibernate.Impl.MessageHelper.InfoString(System.String,System.Object)">
      <summary> 
            Generate an info message string relating to a particular entity,
            based on the given entityName and id. 
            </summary>
      <param name="entityName">The defined entity name. </param>
      <param name="id">The entity id value. </param>
      <returns> An info string, in the form [FooBar#1]. </returns>
    </member>
    <member name="T:NHibernate.IMultiCriteria">
      <summary>
            Combines several queries into a single DB call
            </summary>
    </member>
    <member name="M:NHibernate.IMultiCriteria.List">
      <summary>
            Get all the results
            </summary>
    </member>
    <member name="M:NHibernate.IMultiCriteria.Add(System.Type,NHibernate.ICriteria)">
      <summary>
            Adds the specified criteria to the query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1" /></summary>
      <param name="resultGenericListType">Return results in a <see cref="T:System.Collections.Generic.List`1" /></param>
      <param name="criteria">The criteria.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiCriteria.Add``1(NHibernate.ICriteria)">
      <summary>
            Adds the specified criteria to the query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1" /></summary>
      <param name="criteria">The criteria.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiCriteria.Add``1(System.String,NHibernate.ICriteria)">
      <summary>
            Adds the specified criteria to the query, and associates it with the given key. The result will be contained in a <see cref="T:System.Collections.Generic.List`1" /></summary>
      <param name="key">The key</param>
      <param name="criteria">The criteria</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiCriteria.Add``1(NHibernate.Criterion.DetachedCriteria)">
      <summary>
            Adds the specified detached criteria. The result will be contained in a <see cref="T:System.Collections.Generic.List`1" /></summary>
      <param name="detachedCriteria">The detached criteria.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiCriteria.Add``1(System.String,NHibernate.Criterion.DetachedCriteria)">
      <summary>
            Adds the specified detached criteria, and associates it with the given key. The result will be contained in a <see cref="T:System.Collections.Generic.List`1" /></summary>
      <param name="key">The key</param>
      <param name="detachedCriteria">The detached criteria</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiCriteria.Add(NHibernate.ICriteria)">
      <summary>
            Adds the specified criteria to the query
            </summary>
      <param name="criteria">The criteria.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiCriteria.Add(System.String,NHibernate.ICriteria)">
      <summary>
            Adds the specified criteria to the query, and associates it with the given key
            </summary>
      <param name="key">The key</param>
      <param name="criteria">The criteria</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiCriteria.Add(NHibernate.Criterion.DetachedCriteria)">
      <summary>
            Adds the specified detached criteria.
            </summary>
      <param name="detachedCriteria">The detached criteria.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiCriteria.Add(System.String,NHibernate.Criterion.DetachedCriteria)">
      <summary>
            Adds the specified detached criteria, and associates it with the given key
            </summary>
      <param name="key">The key</param>
      <param name="detachedCriteria">The detached criteria</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiCriteria.SetCacheable(System.Boolean)">
      <summary>
            Sets whatevert this criteria is cacheable.
            </summary>
      <param name="cachable">if set to <c>true</c> [cachable].</param>
    </member>
    <member name="M:NHibernate.IMultiCriteria.SetCacheRegion(System.String)">
      <summary>
             Set the cache region for thie criteria
            </summary>
      <param name="region">The region</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiCriteria.ForceCacheRefresh(System.Boolean)">
      <summary>
             Force a cache refresh
            </summary>
      <param name="forceRefresh">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiCriteria.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
      <summary>
            Sets the result transformer for all the results in this mutli criteria instance
            </summary>
      <param name="resultTransformer">The result transformer.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiCriteria.GetResult(System.String)">
      <summary>
            Returns the result of one of the Criteria based on the key
            </summary>
      <param name="key">The key</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Impl.MultiCriteriaImpl.#ctor(NHibernate.Impl.SessionImpl,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Impl.MultiCriteriaImpl" /> class.
            </summary>
      <param name="session">The session.</param>
      <param name="factory">The factory.</param>
    </member>
    <member name="T:NHibernate.IMultiQuery">
      <summary>
            Combines sevaral queries into a single database call
            </summary>
    </member>
    <member name="M:NHibernate.IMultiQuery.List">
      <summary>
            Get all the results
            </summary>
    </member>
    <member name="M:NHibernate.IMultiQuery.Add(System.Type,NHibernate.IQuery)">
      <summary>
            Adds the specified criteria to the query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1" /></summary>
      <param name="resultGenericListType">Return results in a <see cref="T:System.Collections.Generic.List`1" /></param>
      <param name="criteria">The criteria.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiQuery.Add``1(NHibernate.IQuery)">
      <summary>
            Add the specified HQL query to the multi query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1" /></summary>
    </member>
    <member name="M:NHibernate.IMultiQuery.Add``1(System.String,NHibernate.IQuery)">
      <summary>
            Add the specified HQL query to the multi query, and associate it with the given key. The result will be contained in a <see cref="T:System.Collections.Generic.List`1" /></summary>
      <param name="key">
      </param>
      <param name="query">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiQuery.Add``1(System.String,System.String)">
      <summary>
            Add the specified HQL Query to the multi query, and associate it with the given key. The result will be contained in a <see cref="T:System.Collections.Generic.List`1" /></summary>
      <param name="key">
      </param>
      <param name="hql">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiQuery.Add``1(System.String)">
      <summary>
            Add the specified HQL query to the multi query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1" /></summary>
    </member>
    <member name="M:NHibernate.IMultiQuery.AddNamedQuery``1(System.String)">
      <summary>
            Add a named query to the multi query. The result will be contained in a <see cref="T:System.Collections.Generic.List`1" /></summary>
    </member>
    <member name="M:NHibernate.IMultiQuery.AddNamedQuery``1(System.String,System.String)">
      <summary>
            Add a named query to the multi query, and associate it with the given key. The result will be contained in a <see cref="T:System.Collections.Generic.List`1" /></summary>
      <param name="key">
      </param>
      <param name="namedKey">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiQuery.Add(System.String,NHibernate.IQuery)">
      <summary>
            Add the specified HQL query to the multi query, and associate it with the given key
            </summary>
      <param name="key">
      </param>
      <param name="query">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiQuery.Add(NHibernate.IQuery)">
      <summary>
            Add the specified HQL query to the multi query
            </summary>
    </member>
    <member name="M:NHibernate.IMultiQuery.Add(System.String,System.String)">
      <summary>
            Add the specified HQL Query to the multi query, and associate it with the given key
            </summary>
      <param name="key">
      </param>
      <param name="hql">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiQuery.Add(System.String)">
      <summary>
            Add the specified HQL query to the multi query
            </summary>
    </member>
    <member name="M:NHibernate.IMultiQuery.AddNamedQuery(System.String)">
      <summary>
            Add a named query to the multi query
            </summary>
    </member>
    <member name="M:NHibernate.IMultiQuery.AddNamedQuery(System.String,System.String)">
      <summary>
            Add a named query to the multi query, and associate it with the given key
            </summary>
      <param name="key">
      </param>
      <param name="namedKey">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetCacheable(System.Boolean)">
      <summary>
            Enable caching of this query result set.
            </summary>
      <param name="cacheable">Should the query results be cacheable?</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetCacheRegion(System.String)">
            Set the name of the cache region.
            <param name="region">The name of a query cache region, or <see langword="null" />
            for the default query cache</param></member>
    <member name="M:NHibernate.IMultiQuery.SetForceCacheRefresh(System.Boolean)">
            Should the query force a refresh of the specified query cache region?
            This is particularly useful in cases where underlying data may have been
            updated via a seperate process (i.e., not modified through Hibernate) and
            allows the application to selectively refresh the query cache regions
            based on its knowledge of those events.
            <param name="forceCacheRefresh">Should the query result in a forcible refresh of
            the query cache?</param></member>
    <member name="M:NHibernate.IMultiQuery.SetTimeout(System.Int32)">
      <summary>
            The timeout for the underlying ADO query
            </summary>
      <param name="timeout">
      </param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetParameter(System.String,System.Object,NHibernate.Type.IType)">
      <summary>
            Bind a value to a named query parameter
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">The possibly null parameter value</param>
      <param name="type">The NHibernate <see cref="T:NHibernate.Type.IType" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetParameter(System.String,System.Object)">
      <summary>
            Bind a value to a named query parameter, guessing the NHibernate <see cref="T:NHibernate.Type.IType" />
            from the class of the given object.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">The non-null parameter value</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetParameterList(System.String,System.Collections.ICollection,NHibernate.Type.IType)">
      <summary>
            Bind multiple values to a named query parameter. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c></summary>
      <param name="name">The name of the parameter</param>
      <param name="vals">A collection of values to list</param>
      <param name="type">The Hibernate type of the values</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetParameterList(System.String,System.Collections.ICollection)">
      <summary>
            Bind multiple values to a named query parameter, guessing the Hibernate
            type from the class of the first object in the collection. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c></summary>
      <param name="name">The name of the parameter</param>
      <param name="vals">A collection of values to list</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetAnsiString(System.String,System.String)">
      <summary>
            Bind an instance of a <see cref="T:System.String" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.String" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetBinary(System.String,System.Byte[])">
      <summary>
            Bind an instance of a <see cref="T:System.Byte" /> array to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Byte" /> array.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetBoolean(System.String,System.Boolean)">
      <summary>
            Bind an instance of a <see cref="T:System.Boolean" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Boolean" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetByte(System.String,System.Byte)">
      <summary>
            Bind an instance of a <see cref="T:System.Byte" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Byte" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetCharacter(System.String,System.Char)">
      <summary>
            Bind an instance of a <see cref="T:System.Char" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Char" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetDateTime(System.String,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType" />.
            </summary>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
      <param name="name">The name of the parameter</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetDecimal(System.String,System.Decimal)">
      <summary>
            Bind an instance of a <see cref="T:System.Decimal" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Decimal" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetDouble(System.String,System.Double)">
      <summary>
            Bind an instance of a <see cref="T:System.Double" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Double" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetEntity(System.String,System.Object)">
      <summary>
            Bind an instance of a mapped persistent class to a named parameter.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a persistent class</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetEnum(System.String,System.Enum)">
      <summary>
            Bind an instance of a persistent enumeration class to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a persistent enumeration</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetInt16(System.String,System.Int16)">
      <summary>
            Bind an instance of a <see cref="T:System.Int16" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Int16" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetInt32(System.String,System.Int32)">
      <summary>
            Bind an instance of a <see cref="T:System.Int32" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Int32" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetInt64(System.String,System.Int64)">
      <summary>
            Bind an instance of a <see cref="T:System.Int64" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Int64" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetSingle(System.String,System.Single)">
      <summary>
            Bind an instance of a <see cref="T:System.Single" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.Single" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetString(System.String,System.String)">
      <summary>
            Bind an instance of a <see cref="T:System.String" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.String" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetGuid(System.String,System.Guid)">
      <summary>
            Bind an instance of a <see cref="T:System.Guid" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.GuidType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">An instance of a <see cref="T:System.Guid" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetTime(System.String,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetTimestamp(System.String,System.DateTime)">
      <summary>
            Bind an instance of a <see cref="T:System.DateTime" /> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType" />.
            </summary>
      <param name="name">The name of the parameter</param>
      <param name="val">A non-null instance of a <see cref="T:System.DateTime" />.</param>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetFlushMode(NHibernate.FlushMode)">
      <summary>
            Override the current session flush mode, just for this query.
            </summary>
    </member>
    <member name="M:NHibernate.IMultiQuery.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
      <summary>
            Set a strategy for handling the query results. This can be used to change
            "shape" of the query result.
            </summary>
    </member>
    <member name="M:NHibernate.IMultiQuery.GetResult(System.String)">
      <summary>
            Returns the result of one of the Criteria based on the key
            </summary>
      <param name="key">The key</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Impl.MultiQueryImpl.List">
      <summary>
            Return the query results of all the queries
            </summary>
    </member>
    <member name="M:NHibernate.Impl.Printer.ToString(System.Object,NHibernate.EntityMode)">
      <summary>
      </summary>
      <param name="entity">an actual entity object, not a proxy!</param>
      <param name="entityMode">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Impl.SessionFactoryImpl">
      <summary>
             Concrete implementation of a SessionFactory.
            </summary>
      <remarks>
            Has the following responsibilities:
            <list type=""><item>
            Caches configuration settings (immutably)</item><item>
            Caches "compiled" mappings - ie. <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> 
            and <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /></item><item>
            Caches "compiled" queries (memory sensitive cache)
            </item><item>
            Manages <c>PreparedStatements/IDbCommands</c> - how true in NH?
            </item><item>
            Delegates <c>IDbConnection</c> management to the <see cref="T:NHibernate.Connection.IConnectionProvider" /></item><item>
            Factory for instances of <see cref="T:NHibernate.ISession" /></item></list><para>
            This class must appear immutable to clients, even if it does all kinds of caching
            and pooling under the covers.  It is crucial that the class is not only thread safe
            , but also highly concurrent.  Synchronization must be used extremely sparingly.
            </para></remarks>
      <seealso cref="T:NHibernate.Connection.IConnectionProvider" />
      <seealso cref="T:NHibernate.ISession" />
      <seealso cref="T:NHibernate.Hql.IQueryTranslator" />
      <seealso cref="T:NHibernate.Persister.Entity.IEntityPersister" />
      <seealso cref="T:NHibernate.Persister.Collection.ICollectionPersister" />
    </member>
    <member name="F:NHibernate.Impl.SessionFactoryImpl.implementorToEntityName">
      <summary>
            NH specific : to avoid the use of entityName for generic implementation
            </summary>
      <remarks>this is a shortcut.</remarks>
    </member>
    <member name="M:NHibernate.Impl.SessionFactoryImpl.GetNamedQuery(System.String)">
      <summary>
            Gets the <c>hql</c> query identified by the <c>name</c>.
            </summary>
      <param name="queryName">The name of that identifies the query.</param>
      <returns>
            A <c>hql</c> query or <see langword="null" /> if the named
            query does not exist.
            </returns>
    </member>
    <member name="M:NHibernate.Impl.SessionFactoryImpl.GetReturnAliases(System.String)">
      <summary> Get the return aliases of a query</summary>
    </member>
    <member name="M:NHibernate.Impl.SessionFactoryImpl.GetImplementors(System.String)">
      <summary>
            Return the names of all persistent (mapped) classes that extend or implement the
            given class or interface, accounting for implicit/explicit polymorphism settings
            and excluding mapped subclasses/joined-subclasses of other classes in the result.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.SessionFactoryImpl.GetAllClassMetadata">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Impl.SessionFactoryImpl.GetAllCollectionMetadata">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Impl.SessionFactoryImpl.Close">
      <summary>
            Closes the session factory, releasing all held resources.
            <list><item>cleans up used cache regions and "stops" the cache provider.</item><item>close the ADO.NET connection</item></list></summary>
    </member>
    <member name="M:NHibernate.Impl.SessionFactoryImpl.OpenStatelessSession">
      <summary> Get a new stateless session.</summary>
    </member>
    <member name="M:NHibernate.Impl.SessionFactoryImpl.OpenStatelessSession(System.Data.IDbConnection)">
      <summary> Get a new stateless session for the given ADO.NET connection.</summary>
    </member>
    <member name="P:NHibernate.Impl.SessionFactoryImpl.Dialect">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Impl.SessionFactoryImpl.TransactionFactory">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Impl.SessionFactoryImpl.StatisticsImplementor">
      <summary> Statistics SPI</summary>
    </member>
    <member name="P:NHibernate.Impl.SessionFactoryImpl.Statistics">
      <summary> Get the statistics for this session factory</summary>
    </member>
    <member name="P:NHibernate.Impl.SessionFactoryImpl.CurrentSessionContext">
      <summary>
            Gets the ICurrentSessionContext instance attached to this session factory.
            </summary>
    </member>
    <member name="T:NHibernate.Proxy.IEntityNotFoundDelegate">
      <summary> 
            Delegate to handle the scenario of an entity not found by a specified id. 
            </summary>
    </member>
    <member name="M:NHibernate.Proxy.IEntityNotFoundDelegate.HandleEntityNotFound(System.String,System.Object)">
      <summary>
            Delegate method to handle the scenario of an entity not found.
            </summary>
      <param name="entityName">The entityName (may be the class fullname)</param>
      <param name="id">The requested id not founded.</param>
    </member>
    <member name="T:NHibernate.Impl.SessionFactoryObjectFactory">
      <summary>
            Resolves <see cref="T:NHibernate.ISessionFactory" /> lookups and deserialization.
            </summary>
      <remarks>
        <para>
            This is used heavily be Deserialization.  Currently a SessionFactory is not really serialized. 
            All that is serialized is it's name and uid.  During Deserializaiton the serialized SessionFactory
            is converted to the one contained in this object.  So if you are serializing across AppDomains
            you should make sure that "name" is specified for the SessionFactory in the hbm.xml file and that the
            other AppDomain has a configured SessionFactory with the same name.  If
            you are serializing in the same AppDomain then there will be no problem because the uid will
            be in this object.
            </para>
        <para>
            TODO: verify that the AppDomain statements are correct.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.AddInstance(System.String,System.String,NHibernate.ISessionFactory,System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Adds an Instance of the SessionFactory to the local "cache".
            </summary>
      <param name="uid">The identifier of the ISessionFactory.</param>
      <param name="name">The name of the ISessionFactory.</param>
      <param name="instance">The ISessionFactory.</param>
      <param name="properties">The configured properties for the ISessionFactory.</param>
    </member>
    <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.RemoveInstance(System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Removes the Instance of the SessionFactory from the local "cache".
            </summary>
      <param name="uid">The identifier of the ISessionFactory.</param>
      <param name="name">The name of the ISessionFactory.</param>
      <param name="properties">The configured properties for the ISessionFactory.</param>
    </member>
    <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.GetNamedInstance(System.String)">
      <summary>
            Returns a Named Instance of the SessionFactory from the local "cache" identified by name.
            </summary>
      <param name="name">The name of the ISessionFactory.</param>
      <returns>An instantiated ISessionFactory.</returns>
    </member>
    <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.GetInstance(System.String)">
      <summary>
            Returns an Instance of the SessionFactory from the local "cache" identified by UUID.
            </summary>
      <param name="uid">The identifier of the ISessionFactory.</param>
      <returns>An instantiated ISessionFactory.</returns>
    </member>
    <member name="P:NHibernate.Impl.SessionIdLoggingContext.SessionId">
      <summary>
            Error handling in this case will only kick in if we cannot set values on the TLS
            this is usally the case if we are called from the finalizer, since this is something
            that we do only for logging, we ignore the error.
            </summary>
    </member>
    <member name="T:NHibernate.Impl.SessionImpl">
      <summary>
            Concrete implementation of a Session, also the central, organizing component
            of Hibernate's internal implementation.
            </summary>
      <remarks>
            Exposes two interfaces: ISession itself, to the application and ISessionImplementor
            to other components of hibernate. This is where the hard stuff is...
            NOT THREADSAFE
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor used to recreate the Session during the deserialization.
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
      <remarks>
            This is needed because we have to do some checking before the serialization process
            begins.  I don't know how to add logic in ISerializable.GetObjectData and have .net
            write all of the serializable fields out.
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.#ctor(System.Data.IDbConnection,NHibernate.Impl.SessionFactoryImpl,System.Boolean,System.Int64,NHibernate.IInterceptor,NHibernate.EntityMode,System.Boolean,System.Boolean,NHibernate.ConnectionReleaseMode)">
      <summary>
            Constructor used for OpenSession(...) processing, as well as construction
            of sessions for GetCurrentSession().
            </summary>
      <param name="connection">The user-supplied connection to use for this session.</param>
      <param name="factory">The factory from which this session was obtained</param>
      <param name="autoclose">NOT USED</param>
      <param name="timestamp">The timestamp for this session</param>
      <param name="interceptor">The interceptor to be applied to this session</param>
      <param name="entityMode">The entity-mode for this session</param>
      <param name="flushBeforeCompletionEnabled">Should we auto flush before completion of transaction</param>
      <param name="autoCloseSessionEnabled">Should we auto close after completion of transaction</param>
      <param name="connectionReleaseMode">The mode by which we should release JDBC connections.</param>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.#ctor(NHibernate.Impl.SessionImpl,NHibernate.EntityMode)">
      <summary>
            Constructor used in building "child sessions".
            </summary>
      <param name="parent">The parent Session</param>
      <param name="entityMode">The entity mode</param>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Close">
      <summary>
            Close the session and release all resources
            <remarks>
            Do not call this method inside a transaction scope, use <c>Dispose</c> instead, since
            Close() is not aware of distributed transactions
            </remarks></summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.AfterTransactionCompletion(System.Boolean,NHibernate.ITransaction)">
      <summary>
            Ensure that the locks are downgraded to <see cref="F:NHibernate.LockMode.None" />
            and that all of the softlocks in the <see cref="N:NHibernate.Cache" /> have
            been released.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Save(System.Object)">
      <summary>
            Save a transient object. An id is generated, assigned to the object and returned
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Save(System.Object,System.Object)">
      <summary>
            Save a transient object with a manually assigned ID
            </summary>
      <param name="obj">
      </param>
      <param name="id">
      </param>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Delete(System.Object)">
      <summary>
            Delete a persistent object
            </summary>
      <param name="obj">
      </param>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Delete(System.String,System.Object)">
      <summary> Delete a persistent object (by explicit entity name)</summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Find(System.String)">
      <summary>
            Retrieve a list of persistent objects using a Hibernate query
            </summary>
      <param name="query">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.CreateFilter(System.Object,System.String)">
      <summary>
      </summary>
      <param name="collection">
      </param>
      <param name="queryString">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Instantiate(NHibernate.Persister.Entity.IEntityPersister,System.Object)">
      <summary>
            Give the interceptor an opportunity to override the default instantiation
            </summary>
      <param name="persister">
      </param>
      <param name="id">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.ForceFlush(NHibernate.Engine.EntityEntry)">
      <summary> Force an immediate flush</summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Merge(System.String,System.Object,System.Collections.IDictionary)">
      <summary> Cascade merge an entity instance</summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Persist(System.String,System.Object,System.Collections.IDictionary)">
      <summary> Cascade persist an entity instance</summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.PersistOnFlush(System.String,System.Object,System.Collections.IDictionary)">
      <summary> Cascade persist an entity instance during the flush process</summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Refresh(System.Object,System.Collections.IDictionary)">
      <summary> Cascade refresh an entity instance</summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.SaveOrUpdateCopy(System.String,System.Object,System.Collections.IDictionary)">
      <summary> Cascade copy an entity instance</summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Delete(System.String,System.Object,System.Boolean,Iesi.Collections.ISet)">
      <summary> Cascade delete an entity instance</summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.AutoFlushIfRequired(Iesi.Collections.Generic.ISet{System.String})">
      <summary>
            detect in-memory changes, determine if the changes are to tables
            named in the query and, if so, complete execution the flush
            </summary>
      <param name="querySpaces">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Load(System.Type,System.Object,NHibernate.LockMode)">
      <summary>
            Load the data for the object with the specified id into a newly created object
            using "for update", if supported. A new key will be assigned to the object.
            This should return an existing proxy where appropriate.
            
            If the object does not exist in the database, an exception is thrown.
            </summary>
      <param name="entityClass">
      </param>
      <param name="id">
      </param>
      <param name="lockMode">
      </param>
      <returns>
      </returns>
      <exception cref="T:NHibernate.ObjectNotFoundException">
            Thrown when the object with the specified id does not exist in the database.
            </exception>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Get(System.Type,System.Object,NHibernate.LockMode)">
      <summary>
            Load the data for the object with the specified id into a newly created object
            using "for update", if supported. A new key will be assigned to the object.
            This should return an existing proxy where appropriate.
            
            If the object does not exist in the database, null is returned.
            </summary>
      <param name="clazz">
      </param>
      <param name="id">
      </param>
      <param name="lockMode">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.ImmediateLoad(System.String,System.Object)">
      <summary> 
            Load the data for the object with the specified id into a newly created object.
            This is only called when lazily initializing a proxy.
            Do NOT return a proxy.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.InternalLoad(System.String,System.Object,System.Boolean,System.Boolean)">
      <summary>
            Return the object with the specified id or throw exception if no row with that id exists. Defer the load,
            return a new proxy or return an existing proxy if possible. Do not check if the object was deleted.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Flush">
      <summary>
      </summary>
      <remarks>
            This can be called from commit() or at the start of a List() method.
            <para>
            Perform all the necessary SQL statements in a sensible order, to allow
            users to repect foreign key constraints:
            <list type=""><item>Inserts, in the order they were performed</item><item>Updates</item><item>Deletion of collection elements</item><item>Insertion of collection elements</item><item>Deletes, in the order they were performed</item></list></para><para>
            Go through all the persistent objects and look for collections they might be
            holding. If they had a nonpersistable collection, substitute a persistable one
            </para></remarks>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.GetIdentifier(System.Object)">
      <summary>
            Not for internal use
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.GetContextEntityIdentifier(System.Object)">
      <summary>
            Get the id value for an object that is actually associated with the session.
            This is a bit stricter than GetEntityIdentifierIfNotUnsaved().
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.InitializeCollection(NHibernate.Collection.IPersistentCollection,System.Boolean)">
      <summary>
            called by a collection that wants to initialize itself
            </summary>
      <param name="collection">
      </param>
      <param name="writing">
      </param>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Disconnect">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Finalize">
      <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Dispose">
      <summary>
            Perform a soft (distributed transaction aware) close of the session
            </summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Dispose(System.Boolean)">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
      <param name="isDisposing">Indicates if this Session is being Disposed of or Finalized.</param>
      <remarks>
            If this Session is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this Session back to life.
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Evict(System.Object)">
      <summary>
            remove any hard references to the entity that are held by the infrastructure
            (references held by application or other persistant instances are okay)
            </summary>
      <param name="obj">
      </param>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.Clear">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Impl.SessionImpl.SaveOrUpdateCopy(System.Object)">
      <summary>
      </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Impl.SessionImpl.Batcher">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Impl.SessionImpl.Timestamp">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Impl.SessionImpl.ActionQueue">
      <summary> Get the ActionQueue for this session</summary>
    </member>
    <member name="P:NHibernate.Impl.SessionImpl.FlushMode">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Impl.SessionImpl.IsConnected">
      <summary>
            Gets if the ISession is connected.
            </summary>
      <value>
        <see langword="true" /> if the ISession is connected.
            </value>
      <remarks>
            An ISession is considered connected if there is an <see cref="T:System.Data.IDbConnection" /> (regardless
            of its state) or if it the field <c>connect</c> is true.  Meaning that it will connect
            at the next operation that requires a connection.
            </remarks>
    </member>
    <member name="P:NHibernate.Impl.SessionImpl.Statistics">
      <summary> Get the statistics for this session.</summary>
    </member>
    <member name="P:NHibernate.Impl.SessionImpl.Listeners">
      <summary> Retrieves the configured event listeners from this event source. </summary>
    </member>
    <member name="M:NHibernate.ISQLQuery.AddEntity(System.String)">
      <summary>
            Declare a "root" entity, without specifying an alias
            </summary>
    </member>
    <member name="M:NHibernate.ISQLQuery.AddEntity(System.String,System.String)">
      <summary>
            Declare a "root" entity
            </summary>
    </member>
    <member name="M:NHibernate.ISQLQuery.AddEntity(System.String,System.String,NHibernate.LockMode)">
      <summary>
            Declare a "root" entity, specifying a lock mode
            </summary>
    </member>
    <member name="M:NHibernate.ISQLQuery.AddEntity(System.Type)">
      <summary>
            Declare a "root" entity, without specifying an alias
            </summary>
    </member>
    <member name="M:NHibernate.ISQLQuery.AddEntity(System.String,System.Type)">
      <summary>
            Declare a "root" entity
            </summary>
    </member>
    <member name="M:NHibernate.ISQLQuery.AddEntity(System.String,System.Type,NHibernate.LockMode)">
      <summary>
            Declare a "root" entity, specifying a lock mode
            </summary>
    </member>
    <member name="M:NHibernate.ISQLQuery.AddJoin(System.String,System.String)">
      <summary>
            Declare a "joined" entity
            </summary>
    </member>
    <member name="M:NHibernate.ISQLQuery.AddJoin(System.String,System.String,NHibernate.LockMode)">
      <summary>
            Declare a "joined" entity, specifying a lock mode
            </summary>
    </member>
    <member name="M:NHibernate.ISQLQuery.AddScalar(System.String,NHibernate.Type.IType)">
      <summary>
            Declare a scalar query result
            </summary>
    </member>
    <member name="M:NHibernate.ISQLQuery.SetResultSetMapping(System.String)">
      <summary>
            Use a predefined named ResultSetMapping
            </summary>
    </member>
    <member name="T:NHibernate.Impl.SqlQueryImpl">
      <summary>
            Implements SQL query passthrough
            </summary>
      <example>
            An example mapping is:
            <code>
            &lt;sql-query-name name="mySqlQuery"&gt;
            &lt;return alias="person" class="eg.Person" /&gt;
            	SELECT {person}.NAME AS {person.name}, {person}.AGE AS {person.age}, {person}.SEX AS {person.sex}
            	FROM PERSON {person} WHERE {person}.NAME LIKE 'Hiber%'
            &lt;/sql-query-name&gt;
            </code></example>
    </member>
    <member name="M:NHibernate.Impl.SqlQueryImpl.#ctor(NHibernate.Engine.NamedSQLQueryDefinition,NHibernate.Engine.ISessionImplementor,NHibernate.Engine.Query.ParameterMetadata)">
      <summary> Constructs a SQLQueryImpl given a sql query defined in the mappings. </summary>
      <param name="queryDef">The representation of the defined sql-query. </param>
      <param name="session">The session to which this SQLQueryImpl belongs. </param>
      <param name="parameterMetadata">Metadata about parameters found in the query. </param>
    </member>
    <member name="T:NHibernate.IStatelessSession">
      <summary> 
            A command-oriented API for performing bulk operations against a database. 
            </summary>
      <remarks>
            A stateless session does not implement a first-level cache nor
            interact with any second-level cache, nor does it implement
            transactional write-behind or automatic dirty checking, nor do
            operations cascade to associated instances. Collections are
            ignored by a stateless session. Operations performed via a
            stateless session bypass Hibernate's event model and
            interceptors. Stateless sessions are vulnerable to data
            aliasing effects, due to the lack of a first-level cache.
            <para />
            For certain kinds of transactions, a stateless session may
            perform slightly faster than a stateful session. 
            </remarks>
    </member>
    <member name="M:NHibernate.IStatelessSession.Close">
      <summary> Close the stateless session and release the ADO.NET connection.</summary>
    </member>
    <member name="M:NHibernate.IStatelessSession.Insert(System.Object)">
      <summary> Insert a entity.</summary>
      <param name="entity">A new transient instance </param>
      <returns> the identifier of the instance </returns>
    </member>
    <member name="M:NHibernate.IStatelessSession.Insert(System.String,System.Object)">
      <summary> Insert a row. </summary>
      <param name="entityName">The entityName for the entity to be inserted </param>
      <param name="entity">a new transient instance </param>
      <returns> the identifier of the instance </returns>
    </member>
    <member name="M:NHibernate.IStatelessSession.Update(System.Object)">
      <summary> Update a entity.</summary>
      <param name="entity">a detached entity instance </param>
    </member>
    <member name="M:NHibernate.IStatelessSession.Update(System.String,System.Object)">
      <summary>Update a entity.</summary>
      <param name="entityName">The entityName for the entity to be updated </param>
      <param name="entity">a detached entity instance </param>
    </member>
    <member name="M:NHibernate.IStatelessSession.Delete(System.Object)">
      <summary> Delete a entity. </summary>
      <param name="entity">a detached entity instance </param>
    </member>
    <member name="M:NHibernate.IStatelessSession.Delete(System.String,System.Object)">
      <summary> Delete a entity. </summary>
      <param name="entityName">The entityName for the entity to be deleted </param>
      <param name="entity">a detached entity instance </param>
    </member>
    <member name="M:NHibernate.IStatelessSession.Get(System.String,System.Object)">
      <summary> Retrieve a entity. </summary>
      <returns> a detached entity instance </returns>
    </member>
    <member name="M:NHibernate.IStatelessSession.Get``1(System.Object)">
      <summary> Retrieve a entity.
            
            </summary>
      <returns> a detached entity instance
            </returns>
    </member>
    <member name="M:NHibernate.IStatelessSession.Get(System.String,System.Object,NHibernate.LockMode)">
      <summary> 
            Retrieve a entity, obtaining the specified lock mode. 
            </summary>
      <returns> a detached entity instance </returns>
    </member>
    <member name="M:NHibernate.IStatelessSession.Get``1(System.Object,NHibernate.LockMode)">
      <summary> 
            Retrieve a entity, obtaining the specified lock mode. 
            </summary>
      <returns> a detached entity instance </returns>
    </member>
    <member name="M:NHibernate.IStatelessSession.Refresh(System.Object)">
      <summary> 
            Refresh the entity instance state from the database. 
            </summary>
      <param name="entity">The entity to be refreshed. </param>
    </member>
    <member name="M:NHibernate.IStatelessSession.Refresh(System.String,System.Object)">
      <summary> 
            Refresh the entity instance state from the database. 
            </summary>
      <param name="entityName">The entityName for the entity to be refreshed. </param>
      <param name="entity">The entity to be refreshed.</param>
    </member>
    <member name="M:NHibernate.IStatelessSession.Refresh(System.Object,NHibernate.LockMode)">
      <summary> 
            Refresh the entity instance state from the database. 
            </summary>
      <param name="entity">The entity to be refreshed. </param>
      <param name="lockMode">The LockMode to be applied.</param>
    </member>
    <member name="M:NHibernate.IStatelessSession.Refresh(System.String,System.Object,NHibernate.LockMode)">
      <summary> 
            Refresh the entity instance state from the database. 
            </summary>
      <param name="entityName">The entityName for the entity to be refreshed. </param>
      <param name="entity">The entity to be refreshed. </param>
      <param name="lockMode">The LockMode to be applied. </param>
    </member>
    <member name="M:NHibernate.IStatelessSession.CreateQuery(System.String)">
      <summary>
            Create a new instance of <tt>Query</tt> for the given HQL query string.
            </summary>
      <remarks>Entities returned by the query are detached.</remarks>
    </member>
    <member name="M:NHibernate.IStatelessSession.GetNamedQuery(System.String)">
      <summary> 
            Obtain an instance of <see cref="T:NHibernate.IQuery" /> for a named query string defined in
            the mapping file.
            </summary>
      <remarks>
            The query can be either in <c>HQL</c> or <c>SQL</c> format.
            Entities returned by the query are detached.
            </remarks>
    </member>
    <member name="M:NHibernate.IStatelessSession.CreateCriteria``1">
      <summary>
            Create a new <see cref="T:NHibernate.ICriteria" /> instance, for the given entity class,
            or a superclass of an entity class. 
            </summary>
      <typeparam name="T">A class, which is persistent, or has persistent subclasses</typeparam>
      <returns> The <see cref="T:NHibernate.ICriteria" />. </returns>
      <remarks>Entities returned by the query are detached.</remarks>
    </member>
    <member name="M:NHibernate.IStatelessSession.CreateCriteria``1(System.String)">
      <summary>
            Create a new <see cref="T:NHibernate.ICriteria" /> instance, for the given entity class,
            or a superclass of an entity class, with the given alias. 
            </summary>
      <typeparam name="T">A class, which is persistent, or has persistent subclasses</typeparam>
      <param name="alias">The alias of the entity</param>
      <returns> The <see cref="T:NHibernate.ICriteria" />. </returns>
      <remarks>Entities returned by the query are detached.</remarks>
    </member>
    <member name="M:NHibernate.IStatelessSession.CreateCriteria(System.Type)">
      <summary>
            Create a new <see cref="T:NHibernate.ICriteria" /> instance, for the given entity class,
            or a superclass of an entity class. 
            </summary>
      <param name="entityType">A class, which is persistent, or has persistent subclasses</param>
      <returns> The <see cref="T:NHibernate.ICriteria" />. </returns>
      <remarks>Entities returned by the query are detached.</remarks>
    </member>
    <member name="M:NHibernate.IStatelessSession.CreateCriteria(System.Type,System.String)">
      <summary>
            Create a new <see cref="T:NHibernate.ICriteria" /> instance, for the given entity class,
            or a superclass of an entity class, with the given alias. 
            </summary>
      <param name="entityType">A class, which is persistent, or has persistent subclasses</param>
      <param name="alias">The alias of the entity</param>
      <returns> The <see cref="T:NHibernate.ICriteria" />. </returns>
      <remarks>Entities returned by the query are detached.</remarks>
    </member>
    <member name="M:NHibernate.IStatelessSession.CreateCriteria(System.String)">
      <summary> 
            Create a new <see cref="T:NHibernate.ICriteria" /> instance, for the given entity name.
            </summary>
      <param name="entityName">The entity name. </param>
      <returns> The <see cref="T:NHibernate.ICriteria" />. </returns>
      <remarks>Entities returned by the query are detached.</remarks>
    </member>
    <member name="M:NHibernate.IStatelessSession.CreateCriteria(System.String,System.String)">
      <summary> 
            Create a new <see cref="T:NHibernate.ICriteria" /> instance, for the given entity name,
            with the given alias.  
            </summary>
      <param name="entityName">The entity name. </param>
      <param name="alias">The alias of the entity</param>
      <returns> The <see cref="T:NHibernate.ICriteria" />. </returns>
      <remarks>Entities returned by the query are detached.</remarks>
    </member>
    <member name="M:NHibernate.IStatelessSession.CreateSQLQuery(System.String)">
      <summary> 
            Create a new instance of <see cref="T:NHibernate.ISQLQuery" /> for the given SQL query string.
            Entities returned by the query are detached.
            </summary>
      <param name="queryString">a SQL query </param>
      <returns> The <see cref="T:NHibernate.ISQLQuery" /></returns>
    </member>
    <member name="M:NHibernate.IStatelessSession.BeginTransaction">
      <summary> Begin a NHibernate transaction.</summary>
    </member>
    <member name="P:NHibernate.IStatelessSession.Transaction">
      <summary> Get the current Hibernate transaction.</summary>
    </member>
    <member name="P:NHibernate.IStatelessSession.Connection">
      <summary> 
            Returns the current ADO.NET connection associated with this instance.
            </summary>
      <remarks>
            If the session is using aggressive connection release (as in a
            CMT environment), it is the application's responsibility to
            close the connection returned by this call. Otherwise, the
            application should not close the connection.
            </remarks>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Close">
      <summary> Close the stateless session and release the ADO.NET connection.</summary>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Insert(System.Object)">
      <summary> Insert a entity.</summary>
      <param name="entity">A new transient instance </param>
      <returns> the identifier of the instance </returns>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Insert(System.String,System.Object)">
      <summary> Insert a row. </summary>
      <param name="entityName">The entityName for the entity to be inserted </param>
      <param name="entity">a new transient instance </param>
      <returns> the identifier of the instance </returns>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Update(System.Object)">
      <summary> Update a entity.</summary>
      <param name="entity">a detached entity instance </param>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Update(System.String,System.Object)">
      <summary>Update a entity.</summary>
      <param name="entityName">The entityName for the entity to be updated </param>
      <param name="entity">a detached entity instance </param>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Delete(System.Object)">
      <summary> Delete a entity. </summary>
      <param name="entity">a detached entity instance </param>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Delete(System.String,System.Object)">
      <summary> Delete a entity. </summary>
      <param name="entityName">The entityName for the entity to be deleted </param>
      <param name="entity">a detached entity instance </param>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Get(System.String,System.Object)">
      <summary> Retrieve a entity. </summary>
      <returns> a detached entity instance </returns>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Get``1(System.Object)">
      <summary> Retrieve a entity.
            
            </summary>
      <returns> a detached entity instance
            </returns>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Get(System.String,System.Object,NHibernate.LockMode)">
      <summary> 
            Retrieve a entity, obtaining the specified lock mode. 
            </summary>
      <returns> a detached entity instance </returns>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Get``1(System.Object,NHibernate.LockMode)">
      <summary> 
            Retrieve a entity, obtaining the specified lock mode. 
            </summary>
      <returns> a detached entity instance </returns>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Refresh(System.Object)">
      <summary> 
            Refresh the entity instance state from the database. 
            </summary>
      <param name="entity">The entity to be refreshed. </param>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Refresh(System.String,System.Object)">
      <summary> 
            Refresh the entity instance state from the database. 
            </summary>
      <param name="entityName">The entityName for the entity to be refreshed. </param>
      <param name="entity">The entity to be refreshed.</param>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Refresh(System.Object,NHibernate.LockMode)">
      <summary> 
            Refresh the entity instance state from the database. 
            </summary>
      <param name="entity">The entity to be refreshed. </param>
      <param name="lockMode">The LockMode to be applied.</param>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Refresh(System.String,System.Object,NHibernate.LockMode)">
      <summary> 
            Refresh the entity instance state from the database. 
            </summary>
      <param name="entityName">The entityName for the entity to be refreshed. </param>
      <param name="entity">The entity to be refreshed. </param>
      <param name="lockMode">The LockMode to be applied. </param>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.CreateCriteria``1">
      <summary>
            Create a new <see cref="T:NHibernate.ICriteria" /> instance, for the given entity class,
            or a superclass of an entity class. 
            </summary>
      <typeparam name="T">A class, which is persistent, or has persistent subclasses</typeparam>
      <returns> The <see cref="T:NHibernate.ICriteria" />. </returns>
      <remarks>Entities returned by the query are detached.</remarks>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.CreateCriteria``1(System.String)">
      <summary>
            Create a new <see cref="T:NHibernate.ICriteria" /> instance, for the given entity class,
            or a superclass of an entity class, with the given alias. 
            </summary>
      <typeparam name="T">A class, which is persistent, or has persistent subclasses</typeparam>
      <param name="alias">The alias of the entity</param>
      <returns> The <see cref="T:NHibernate.ICriteria" />. </returns>
      <remarks>Entities returned by the query are detached.</remarks>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.CreateCriteria(System.String)">
      <summary> 
            Create a new <see cref="T:NHibernate.ICriteria" /> instance, for the given entity name.
            </summary>
      <param name="entityName">The entity name. </param>
      <returns> The <see cref="T:NHibernate.ICriteria" />. </returns>
      <remarks>Entities returned by the query are detached.</remarks>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.CreateCriteria(System.String,System.String)">
      <summary> 
            Create a new <see cref="T:NHibernate.ICriteria" /> instance, for the given entity name,
            with the given alias.  
            </summary>
      <param name="entityName">The entity name. </param>
      <param name="alias">The alias of the entity</param>
      <returns> The <see cref="T:NHibernate.ICriteria" />. </returns>
      <remarks>Entities returned by the query are detached.</remarks>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.BeginTransaction">
      <summary> Begin a NHibernate transaction.</summary>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Finalize">
      <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
    </member>
    <member name="M:NHibernate.Impl.StatelessSessionImpl.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:NHibernate.Impl.StatelessSessionImpl.Transaction">
      <summary> Get the current Hibernate transaction.</summary>
    </member>
    <member name="T:NHibernate.Intercept.IFieldInterceptor">
      <summary> Contract for field interception handlers. </summary>
    </member>
    <member name="M:NHibernate.Intercept.IFieldInterceptor.SetSession(NHibernate.Engine.ISessionImplementor)">
      <summary> Use to associate the entity to which we are bound to the given session. </summary>
      <param name="session">The session to which we are now associated. </param>
    </member>
    <member name="M:NHibernate.Intercept.IFieldInterceptor.IsInitializedField(System.String)">
      <summary> The the given field initialized for the entity to which we are bound? </summary>
      <param name="field">The name of the field to check </param>
      <returns> True if the given field is initialized; otherwise false.</returns>
    </member>
    <member name="M:NHibernate.Intercept.IFieldInterceptor.MarkDirty">
      <summary> Forcefully mark the entity as being dirty.</summary>
    </member>
    <member name="M:NHibernate.Intercept.IFieldInterceptor.ClearDirty">
      <summary> Clear the internal dirty flag.</summary>
    </member>
    <member name="P:NHibernate.Intercept.IFieldInterceptor.IsDirty">
      <summary> Is the entity considered dirty? </summary>
      <value> True if the entity is dirty; otherwise false. </value>
    </member>
    <member name="P:NHibernate.Intercept.IFieldInterceptor.IsInitialized">
      <summary> Is the entity to which we are bound completely initialized? </summary>
    </member>
    <member name="T:NHibernate.Intercept.FieldInterceptionHelper">
      <summary> Helper class for dealing with enhanced entity classes. </summary>
    </member>
    <member name="F:NHibernate.Intercept.LazyPropertyInitializer.UnfetchedProperty">
      <summary> Marker value for uninitialized properties</summary>
    </member>
    <member name="T:NHibernate.Intercept.ILazyPropertyInitializer">
      <summary> Contract for controlling how lazy properties get initialized. </summary>
    </member>
    <member name="M:NHibernate.Intercept.ILazyPropertyInitializer.InitializeLazyProperty(System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> Initialize the property, and return its new value</summary>
    </member>
    <member name="T:NHibernate.Loader.JoinWalker.AssociationKey">
      <summary>
            Uniquely identifier a foreign key, so that we don't
            join it more than once, and create circularities
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.AddAssociationToJoinTreeIfNecessary(NHibernate.Type.IAssociationType,System.String[],System.String,System.String,System.Int32,NHibernate.SqlCommand.JoinType)">
      <summary>
            Add on association (one-to-one, many-to-one, or a collection) to a list
            of associations to be fetched by outerjoin (if necessary)
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.AddAssociationToJoinTree(NHibernate.Type.IAssociationType,System.String[],System.String,System.String,System.Int32,NHibernate.SqlCommand.JoinType)">
      <summary>
            Add on association (one-to-one, many-to-one, or a collection) to a list
            of associations to be fetched by outerjoin
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.WalkEntityTree(NHibernate.Persister.Entity.IOuterJoinLoadable,System.String)">
      <summary>
            For an entity class, return a list of associations to be fetched by outerjoin
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.WalkCollectionTree(NHibernate.Persister.Collection.IQueryableCollection,System.String)">
      <summary>
            For a collection role, return a list of associations to be fetched by outerjoin
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.WalkCollectionTree(NHibernate.Persister.Collection.IQueryableCollection,System.String,System.String,System.Int32)">
      <summary>
            For a collection role, return a list of associations to be fetched by outerjoin
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.WalkEntityTree(NHibernate.Persister.Entity.IOuterJoinLoadable,System.String,System.String,System.Int32)">
      <summary>
            For an entity class, add to a list of associations to be fetched
            by outerjoin
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.WalkComponentTree(NHibernate.Type.IAbstractComponentType,System.Int32,System.Int32,NHibernate.Persister.Entity.IOuterJoinLoadable,System.String,System.String,System.Int32)">
      <summary>
            For a component, add to a list of associations to be fetched by outerjoin
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.WalkCompositeElementTree(NHibernate.Type.IAbstractComponentType,System.String[],NHibernate.Persister.Collection.IQueryableCollection,System.String,System.String,System.Int32)">
      <summary>
            For a composite element, add to a list of associations to be fetched by outerjoin
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.SubPath(System.String,System.String)">
      <summary>
            Extend the path by the given property name
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.GetJoinType(NHibernate.Type.IAssociationType,NHibernate.FetchMode,System.String,System.String,System.String[],System.Boolean,System.Int32,NHibernate.Engine.CascadeStyle)">
      <summary>
            Get the join type (inner, outer, etc) or -1 if the
            association should not be joined. Override on
            subclasses.
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.GetJoinType(System.Boolean,System.Int32)">
      <summary>
            Use an inner join if it is a non-null association and this
            is the "first" join in a series
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.IsJoinedFetchEnabledInMapping(NHibernate.FetchMode,NHibernate.Type.IAssociationType)">
      <summary>
            Does the mapping, and Hibernate default semantics, specify that
            this association should be fetched by outer joining
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.IsJoinedFetchEnabled(NHibernate.Type.IAssociationType,NHibernate.FetchMode,NHibernate.Engine.CascadeStyle)">
      <summary>
            Override on subclasses to enable or suppress joining
            of certain association types
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.IsDuplicateAssociation(System.String,System.String[])">
      <summary>
            Used to detect circularities in the joined graph, note that
            this method is side-effecty
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.IsDuplicateAssociation(System.String,System.String[],NHibernate.Type.IAssociationType)">
      <summary>
            Used to detect circularities in the joined graph, note that
            this method is side-effecty
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.IsJoinable(NHibernate.SqlCommand.JoinType,Iesi.Collections.Generic.ISet{NHibernate.Loader.JoinWalker.AssociationKey},System.String,System.String[],NHibernate.Type.IAssociationType,System.Int32)">
      <summary>
            Should we join this association?
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.MergeOuterJoins(System.Collections.Generic.IList{NHibernate.Loader.OuterJoinableAssociation})">
      <summary>
            Generate a sequence of <c>LEFT OUTER JOIN</c> clauses for the given associations.
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.CountEntityPersisters(System.Collections.Generic.IList{NHibernate.Loader.OuterJoinableAssociation})">
      <summary>
            Count the number of instances of IJoinable which are actually
            also instances of ILoadable, or are one-to-many associations
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.CountCollectionPersisters(System.Collections.Generic.IList{NHibernate.Loader.OuterJoinableAssociation})">
      <summary>
            Count the number of instances of <see cref="T:NHibernate.Persister.Entity.IJoinable" /> which
            are actually also instances of <see cref="T:NHibernate.Collection.IPersistentCollection" />
            which are being fetched by outer join
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.OrderBy(System.Collections.Generic.IList{NHibernate.Loader.OuterJoinableAssociation})">
      <summary>
            Get the order by string required for collection fetching
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.WhereString(System.String,System.String[],System.Int32)">
      <summary>
            Render the where condition for a (batch) load by identifier / collection key
            </summary>
    </member>
    <member name="M:NHibernate.Loader.JoinWalker.SelectString(System.Collections.Generic.IList{NHibernate.Loader.OuterJoinableAssociation})">
      <summary>
            Generate a select list of columns containing all properties of the entity classes
            </summary>
    </member>
    <member name="T:NHibernate.Loader.Collection.CollectionJoinWalker">
      <summary>
            Superclass of walkers for collection initializers
            <seealso cref="T:NHibernate.Loader.Collection.CollectionLoader" /><seealso cref="T:NHibernate.Loader.Collection.OneToManyJoinWalker" /><seealso cref="T:NHibernate.Loader.Collection.BasicCollectionJoinWalker" /></summary>
    </member>
    <member name="T:NHibernate.Loader.Collection.BasicCollectionJoinWalker">
      <summary>
            Walker for collections of values and many-to-many associations
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Collection.BasicCollectionJoinWalker.GetJoinType(NHibernate.Type.IAssociationType,NHibernate.FetchMode,System.String,Iesi.Collections.ISet,System.String,System.String[],System.Boolean,System.Int32)">
      <summary>
            We can use an inner join for first many-to-many association
            </summary>
    </member>
    <member name="T:NHibernate.Loader.OuterJoinLoader">
      <summary>
            Implements logic for walking a tree of associated classes.
            </summary>
      <remarks>
            Generates an SQL select string containing all properties of those classes.
            Tablse are joined using an ANSI-style left outer join.
            </remarks>
    </member>
    <member name="T:NHibernate.Loader.Collection.ICollectionInitializer">
      <summary>
            An interface for collection loaders
            </summary>
      <seealso cref="T:NHibernate.Loader.Collection.BasicCollectionLoader" />
      <seealso cref="T:NHibernate.Loader.Collection.OneToManyLoader" />
    </member>
    <member name="M:NHibernate.Loader.Collection.ICollectionInitializer.Initialize(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Initialize the given collection
            </summary>
    </member>
    <member name="T:NHibernate.Loader.Collection.CollectionLoader">
      <summary>
            Superclass for loaders that initialize collections
            <seealso cref="T:NHibernate.Loader.Collection.OneToManyLoader" /><seealso cref="T:NHibernate.Loader.Collection.BasicCollectionLoader" /></summary>
    </member>
    <member name="T:NHibernate.Loader.Collection.BasicCollectionLoader">
      <summary> 
            Loads a collection of values or a many-to-many association.
            </summary>
      <remarks>
            The collection persister must implement <seealso cref="T:NHibernate.Persister.Collection.IQueryableCollection" />. For
            other collections, create a customized subclass of <seealso cref="T:NHibernate.Loader.Loader" /></remarks>
      <seealso cref="T:NHibernate.Loader.Collection.OneToManyLoader" />
    </member>
    <member name="T:NHibernate.Loader.Collection.BatchingCollectionInitializer">
      <summary>
            "Batch" loads collections, using multiple foreign key values in the SQL Where clause
            </summary>
      <seealso cref="T:NHibernate.Loader.Collection.BasicCollectionLoader" />
      <seealso cref="T:NHibernate.Loader.Collection.OneToManyLoader" />
    </member>
    <member name="T:NHibernate.Loader.Collection.OneToManyJoinWalker">
      <summary>
            Walker for one-to-many associations
            </summary>
      <seealso cref="T:NHibernate.Loader.Collection.OneToManyLoader" />
    </member>
    <member name="T:NHibernate.Loader.Collection.OneToManyLoader">
      <summary>
            Loads one-to-many associations
            </summary>
      <remarks>
            The collection persister must implement <see cref="T:NHibernate.Persister.Collection.IQueryableCollection" />.
            For other collections, create a customized subclass of <see cref="T:NHibernate.Loader.Loader" />.
            </remarks>
      <seealso cref="T:NHibernate.Loader.Collection.BasicCollectionLoader" />
    </member>
    <member name="T:NHibernate.Loader.Collection.SubselectCollectionLoader">
      <summary> Implements subselect fetching for a collection</summary>
    </member>
    <member name="T:NHibernate.Loader.Collection.SubselectOneToManyLoader">
      <summary>
            Implements subselect fetching for a one to many association
            </summary>
    </member>
    <member name="M:NHibernate.Loader.AbstractEntityJoinWalker.IsJoinedFetchEnabled(NHibernate.Type.IAssociationType,NHibernate.FetchMode,NHibernate.Engine.CascadeStyle)">
      <summary>
            The superclass deliberately excludes collections
            </summary>
    </member>
    <member name="P:NHibernate.Loader.AbstractEntityJoinWalker.WhereFragment">
      <summary>
            Don't bother with the discriminator, unless overridden by subclass
            </summary>
    </member>
    <member name="T:NHibernate.Loader.Criteria.CriteriaJoinWalker">
      <summary>
            A <see cref="T:NHibernate.Loader.JoinWalker" /> for <see cref="T:NHibernate.ICriteria" /> queries.
            </summary>
      <seealso cref="T:NHibernate.Loader.Criteria.CriteriaLoader" />
    </member>
    <member name="P:NHibernate.Loader.Criteria.CriteriaJoinWalker.WhereFragment">
      <summary>
            Use the discriminator, to narrow the select to instances
            of the queried subclass, also applying any filters.
            </summary>
    </member>
    <member name="T:NHibernate.Loader.Criteria.CriteriaLoader">
      <summary>
            A <c>Loader</c> for <see cref="T:NHibernate.ICriteria" /> queries. 
            </summary>
      <remarks>
            Note that criteria
            queries are more like multi-object <c>Load()</c>s than like HQL queries.
            </remarks>
    </member>
    <member name="M:NHibernate.Loader.Criteria.CriteriaQueryTranslator.GetColumnsUsingProjection(NHibernate.ICriteria,System.String)">
      <summary>
            Get the names of the columns constrained
            by this criterion.
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Criteria.CriteriaQueryTranslator.GetTypedValue(NHibernate.ICriteria,System.String,System.Object)">
      <summary>
            Get the a typed value for the given property value.
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Criteria.CriteriaQueryTranslator.GetColumnAliasesUsingProjection(NHibernate.ICriteria,System.String)">
      <summary>
            Get the aliases of the columns constrained
            by this criterion (for use in ORDER BY clause).
            </summary>
    </member>
    <member name="T:NHibernate.Loader.Custom.ICustomQuery">
      <summary> 
            Extension point allowing any SQL query with named and positional parameters
            to be executed by Hibernate, returning managed entities, collections and
            simple scalar values. 
            </summary>
    </member>
    <member name="P:NHibernate.Loader.Custom.ICustomQuery.SQL">
      <summary> The SQL query string to be performed. </summary>
    </member>
    <member name="P:NHibernate.Loader.Custom.ICustomQuery.QuerySpaces">
      <summary> 
            Any query spaces to apply to the query execution.  Query spaces are
            used in Hibernate's auto-flushing mechanism to determine which
            entities need to be checked for pending changes. 
            </summary>
    </member>
    <member name="P:NHibernate.Loader.Custom.ICustomQuery.NamedParameterBindPoints">
      <summary>
            A map representing positions within the supplied <see cref="P:NHibernate.Loader.Custom.ICustomQuery.SQL" /> query to
            which we need to bind named parameters.
            </summary>
      <remarks>
            Optional, may return null if no named parameters.
            The structure of the returned map (if one) as follows:
            <ol><li>The keys into the map are the named parameter names</li><li>The corresponding value is either an if the
            parameter occurs only once in the query; or a List of int if the
            parameter occurs more than once</li></ol></remarks>
    </member>
    <member name="P:NHibernate.Loader.Custom.ICustomQuery.CustomQueryReturns">
      <summary> 
            A collection of <see cref="T:NHibernate.Loader.Custom.IReturn" /> descriptors describing the
            ADO result set to be expected and how to map this result set. 
            </summary>
    </member>
    <member name="T:NHibernate.Loader.Custom.Sql.SQLCustomQuery">
      <summary> Implements Hibernate's built-in support for native SQL queries. </summary>
      <remarks>This support is built on top of the notion of "custom queries"...</remarks>
    </member>
    <member name="M:NHibernate.Loader.Custom.Sql.SQLQueryParser.SubstituteParams(System.String)">
      <summary> 
            Substitues ADO parameter placeholders (?) for all encountered
            parameter specifications.  It also tracks the positions of these
            parameter specifications within the query string.  This accounts for
            ordinal-params, named-params, and ejb3-positional-params.
             </summary>
      <param name="sqlString">The query string. </param>
      <returns> The SQL query with parameter substitution complete. </returns>
    </member>
    <member name="T:NHibernate.Loader.Custom.IReturn">
      <summary> Represents a return in a custom query. </summary>
    </member>
    <member name="T:NHibernate.Loader.Custom.NonScalarReturn">
      <summary> Represents some non-scalar (entity/collection) return within the query result. </summary>
    </member>
    <member name="T:NHibernate.Loader.Custom.FetchReturn">
      <summary> Represents a return which names a fetched association. </summary>
    </member>
    <member name="P:NHibernate.Loader.Custom.FetchReturn.Owner">
      <summary> Retrieves the return descriptor for the owner of this fetch. </summary>
    </member>
    <member name="P:NHibernate.Loader.Custom.FetchReturn.OwnerProperty">
      <summary> The name of the property on the owner which represents this association. </summary>
    </member>
    <member name="T:NHibernate.Loader.Custom.CollectionFetchReturn">
      <summary> Spefically a fetch return that refers to a collection association. </summary>
    </member>
    <member name="T:NHibernate.Loader.Custom.CollectionReturn">
      <summary> 
            Represents a return which names a collection role; it
            is used in defining a custom query for loading an entity's
            collection in non-fetching scenarios (i.e., loading the collection
            itself as the "root" of the result). 
            </summary>
    </member>
    <member name="P:NHibernate.Loader.Custom.CollectionReturn.OwnerEntityName">
      <summary> Returns the class owning the collection. </summary>
    </member>
    <member name="P:NHibernate.Loader.Custom.CollectionReturn.OwnerProperty">
      <summary> Returns the name of the property representing the collection from the <see cref="P:NHibernate.Loader.Custom.CollectionReturn.OwnerEntityName" />. </summary>
    </member>
    <member name="T:NHibernate.Loader.ICollectionAliases">
      <summary>
            Type definition of CollectionAliases.
            </summary>
    </member>
    <member name="P:NHibernate.Loader.ICollectionAliases.SuffixedKeyAliases">
      <summary>
            Returns the suffixed result-set column-aliases for columns making
            up the key for this collection (i.e., its FK to its owner).
            </summary>
      <value>The key result-set column aliases.</value>
    </member>
    <member name="P:NHibernate.Loader.ICollectionAliases.SuffixedIndexAliases">
      <summary>
            Returns the suffixed result-set column-aliases for the columns
            making up the collection's index (map or list).
            </summary>
      <value>The index result-set column aliases.</value>
    </member>
    <member name="P:NHibernate.Loader.ICollectionAliases.SuffixedElementAliases">
      <summary>
            Returns the suffixed result-set column-aliases for the columns
            making up the collection's elements.
            </summary>
      <value>The element result-set column aliases.</value>
    </member>
    <member name="P:NHibernate.Loader.ICollectionAliases.SuffixedIdentifierAlias">
      <summary>
            Returns the suffixed result-set column-aliases for the column
            defining the collection's identifier (if any).
            </summary>
      <value>The identifier result-set column aliases.</value>
    </member>
    <member name="P:NHibernate.Loader.ICollectionAliases.Suffix">
      <summary>
            Returns the suffix used to unique the column aliases for this
            particular alias set.
            </summary>
      <value>The uniqued column alias suffix.</value>
    </member>
    <member name="T:NHibernate.Loader.Custom.ColumnCollectionAliases">
      <summary>
        <see cref="T:NHibernate.Loader.ICollectionAliases" /> that uses columnnames instead of generated aliases.
            Aliases can still be overwritten via <c>&lt;return-property&gt;</c></summary>
    </member>
    <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.SuffixedKeyAliases">
      <summary>
            Returns the suffixed result-set column-aliases for columns making up the key for this collection (i.e., its FK to
            its owner).
            </summary>
      <value>The key result-set column aliases.</value>
    </member>
    <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.SuffixedIndexAliases">
      <summary>
            Returns the suffixed result-set column-aliases for the columns making up the collection's index (map or list).
            </summary>
      <value>The index result-set column aliases.</value>
    </member>
    <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.SuffixedElementAliases">
      <summary>
            Returns the suffixed result-set column-aliases for the columns making up the collection's elements.
            </summary>
      <value>The element result-set column aliases.</value>
    </member>
    <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.SuffixedIdentifierAlias">
      <summary>
            Returns the suffixed result-set column-aliases for the column defining the collection's identifier (if any).
            </summary>
      <value>The identifier result-set column aliases.</value>
    </member>
    <member name="P:NHibernate.Loader.Custom.ColumnCollectionAliases.Suffix">
      <summary>
            Returns the suffix used to unique the column aliases for this particular alias set.
            </summary>
      <value>The uniqued column alias suffix.</value>
    </member>
    <member name="T:NHibernate.Loader.IEntityAliases">
      <summary>
            Metadata describing the SQL result set column aliases
            for a particular entity
            </summary>
    </member>
    <member name="M:NHibernate.Loader.IEntityAliases.GetSuffixedPropertyAliases(NHibernate.Persister.Entity.ILoadable)">
      <summary>
            The result set column aliases for the property columns of a subclass
            </summary>
    </member>
    <member name="P:NHibernate.Loader.IEntityAliases.SuffixedKeyAliases">
      <summary>
            The result set column aliases for the primary key columns
            </summary>
    </member>
    <member name="P:NHibernate.Loader.IEntityAliases.SuffixedDiscriminatorAlias">
      <summary>
            The result set column aliases for the discriminator columns
            </summary>
    </member>
    <member name="P:NHibernate.Loader.IEntityAliases.SuffixedVersionAliases">
      <summary>
            The result set column aliases for the version columns
            </summary>
    </member>
    <member name="P:NHibernate.Loader.IEntityAliases.RowIdAlias">
      <summary>
            The result set column alias for the Oracle row id
            </summary>
    </member>
    <member name="P:NHibernate.Loader.IEntityAliases.SuffixedPropertyAliases">
      <summary>
            The result set column aliases for the property columns
            </summary>
    </member>
    <member name="T:NHibernate.Loader.DefaultEntityAliases">
      <summary>
            EntityAliases which handles the logic of selecting user provided aliases (via return-property),
            before using the default aliases.
            </summary>
    </member>
    <member name="M:NHibernate.Loader.DefaultEntityAliases.#ctor(System.Collections.Generic.IDictionary{System.String,System.String[]},NHibernate.Persister.Entity.ILoadable,System.String)">
      <summary>
            Calculate and cache select-clause suffixes.
            </summary>
    </member>
    <member name="T:NHibernate.Loader.Custom.ColumnEntityAliases">
      <summary>
        <see cref="T:NHibernate.Loader.IEntityAliases" /> that chooses the column names over the alias names.
            </summary>
    </member>
    <member name="T:NHibernate.Loader.Custom.CustomLoader">
      <summary> 
            Extension point for loaders which use a SQL result set with "unexpected" column aliases. 
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Custom.CustomLoader.ResultRowProcessor.BuildResultRow(System.Object[],System.Data.IDataReader,System.Boolean,NHibernate.Engine.ISessionImplementor)">
      <summary> Build a logical result row. </summary>
      <param name="data">
            Entity data defined as "root returns" and already handled by the normal Loader mechanism.
            </param>
      <param name="resultSet">The ADO result set (positioned at the row currently being processed). </param>
      <param name="hasTransformer">Does this query have an associated <see cref="T:NHibernate.Transform.IResultTransformer" />. </param>
      <param name="session">The session from which the query request originated.</param>
      <returns> The logical result row </returns>
      <remarks>
            At this point, Loader has already processed all non-scalar result data.  We
            just need to account for scalar result data here...
            </remarks>
    </member>
    <member name="T:NHibernate.Loader.Custom.CustomLoader.MetaData">
      <summary>
            Encapsulates the metadata available from the database result set.
            </summary>
    </member>
    <member name="M:NHibernate.Loader.Custom.CustomLoader.MetaData.#ctor(System.Data.IDataReader)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Loader.Custom.CustomLoader.MetaData" /> class.
            </summary>
      <param name="resultSet">The result set.</param>
    </member>
    <member name="M:NHibernate.Loader.Custom.CustomLoader.MetaData.GetColumnCount">
      <summary>
            Gets the column count in the result set.
            </summary>
      <returns>The column count.</returns>
    </member>
    <member name="M:NHibernate.Loader.Custom.CustomLoader.MetaData.GetColumnPosition(System.String)">
      <summary>
            Gets the (zero-based) position of the column with the specified name.
            </summary>
      <param name="columnName">Name of the column.</param>
      <returns>The column position.</returns>
    </member>
    <member name="M:NHibernate.Loader.Custom.CustomLoader.MetaData.GetColumnName(System.Int32)">
      <summary>
            Gets the name of the column at the specified position.
            </summary>
      <param name="position">The (zero-based) position.</param>
      <returns>The column name.</returns>
    </member>
    <member name="M:NHibernate.Loader.Custom.CustomLoader.MetaData.GetHibernateType(System.Int32)">
      <summary>
            Gets the Hibernate type of the specified column.
            </summary>
      <param name="columnPos">The column position.</param>
      <returns>The Hibernate type.</returns>
    </member>
    <member name="T:NHibernate.Loader.Custom.EntityFetchReturn">
      <summary> Specifically a fetch return that refers to an entity association. </summary>
    </member>
    <member name="T:NHibernate.Loader.Custom.RootReturn">
      <summary> 
            Represents a return which names a "root" entity.
            </summary>
      <remarks>
            A root entity means it is explicitly a "column" in the result, as opposed to
            a fetched association.
            </remarks>
    </member>
    <member name="T:NHibernate.Loader.Custom.ScalarReturn">
      <summary> Represent a scalar (AKA simple value) return within a query result. </summary>
    </member>
    <member name="T:NHibernate.Loader.Entity.IUniqueEntityLoader">
      <summary>
             Loads entities for a <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /></summary>
    </member>
    <member name="M:NHibernate.Loader.Entity.IUniqueEntityLoader.Load(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Load an entity instance. If <c>OptionalObject</c> is supplied, load the entity
            state into the given (uninitialized) object
            </summary>
    </member>
    <member name="T:NHibernate.Loader.Entity.AbstractEntityLoader">
      <summary>
            Abstract superclass for entity loaders that use outer joins
            </summary>
    </member>
    <member name="T:NHibernate.Loader.Entity.BatchingEntityLoader">
      <summary>
            "Batch" loads entities, using multiple primary key values in the
            SQL <c>where</c> clause.
            </summary>
      <seealso cref="T:NHibernate.Loader.Entity.EntityLoader" />
    </member>
    <member name="T:NHibernate.Loader.Entity.EntityJoinWalker">
      <summary>
            A walker for loaders that fetch entities
            </summary>
      <seealso cref="T:NHibernate.Loader.Entity.EntityLoader" />
    </member>
    <member name="M:NHibernate.Loader.Entity.EntityJoinWalker.IsJoinedFetchEnabled(NHibernate.Type.IAssociationType,NHibernate.FetchMode,NHibernate.Engine.CascadeStyle)">
      <summary>
            Disable outer join fetching if this loader obtains an
            upgrade lock mode
            </summary>
    </member>
    <member name="T:NHibernate.Loader.Entity.EntityLoader">
      <summary>
            Load an entity using outerjoin fetching to fetch associated entities.
            </summary>
      <remarks>
            The <see cref="T:NHibernate.Persister.Entity.IEntityPersister" /> must implement <see cref="T:NHibernate.Persister.Entity.ILoadable" />. For other entities,
            create a customized subclass of <see cref="T:NHibernate.Loader.Loader" />.
            </remarks>
    </member>
    <member name="T:NHibernate.Loader.GeneratedCollectionAliases">
      <summary>
            CollectionAliases which handles the logic of selecting user provided aliases (via return-property),
            before using the default aliases.
            </summary>
    </member>
    <member name="P:NHibernate.Loader.GeneratedCollectionAliases.SuffixedKeyAliases">
      <summary>
            Returns the suffixed result-set column-aliases for columns making up the key for this collection (i.e., its FK to
            its owner).
            </summary>
    </member>
    <member name="P:NHibernate.Loader.GeneratedCollectionAliases.SuffixedIndexAliases">
      <summary>
            Returns the suffixed result-set column-aliases for the columns making up the collection's index (map or list).
            </summary>
    </member>
    <member name="P:NHibernate.Loader.GeneratedCollectionAliases.SuffixedElementAliases">
      <summary>
            Returns the suffixed result-set column-aliases for the columns making up the collection's elements.
            </summary>
    </member>
    <member name="P:NHibernate.Loader.GeneratedCollectionAliases.SuffixedIdentifierAlias">
      <summary>
            Returns the suffixed result-set column-aliases for the column defining the collection's identifier (if any).
            </summary>
    </member>
    <member name="P:NHibernate.Loader.GeneratedCollectionAliases.Suffix">
      <summary>
            Returns the suffix used to unique the column aliases for this particular alias set.
            </summary>
    </member>
    <member name="M:NHibernate.Loader.OuterJoinableAssociation.GetPosition(System.String,System.Collections.Generic.IEnumerable{NHibernate.Loader.OuterJoinableAssociation})">
      <summary>
            Get the position of the join with the given alias in the
            list of joins
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.IRelationalModel">
      <summary>
            Operations to create/drop the mapping element in the database.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.IRelationalModel.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String,System.String)">
      <summary>
            When implemented by a class, generates the SQL string to create 
            the mapping element in the database.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="p">
      </param>
      <param name="defaultSchema">
      </param>
      <param name="defaultCatalog">
      </param>
      <returns>
            A string that contains the SQL to create an object.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.IRelationalModel.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
      <summary>
            When implemented by a class, generates the SQL string to drop 
            the mapping element from the database.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="defaultCatalog">
      </param>
      <param name="defaultSchema">
      </param>
      <returns>
            A string that contains the SQL to drop an object.
            </returns>
    </member>
    <member name="T:NHibernate.Mapping.IAuxiliaryDatabaseObject">
      <summary> 
            Auxiliary database objects (i.e., triggers, stored procedures, etc) defined
            in the mappings.  Allows Hibernate to manage their lifecycle as part of
            creating/dropping the schema. 
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.IAuxiliaryDatabaseObject.AddDialectScope(System.String)">
      <summary> 
            Add the given dialect name to the scope of dialects to which
            this database object applies. 
            </summary>
      <param name="dialectName">The name of a dialect. </param>
    </member>
    <member name="M:NHibernate.Mapping.IAuxiliaryDatabaseObject.AppliesToDialect(NHibernate.Dialect.Dialect)">
      <summary> 
            Does this database object apply to the given dialect? 
            </summary>
      <param name="dialect">The dialect to check against. </param>
      <returns> True if this database object does apply to the given dialect. </returns>
    </member>
    <member name="M:NHibernate.Mapping.IAuxiliaryDatabaseObject.SetParameterValues(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Gets called by NHibernate to pass the configured type parameters to the implementation.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.AbstractAuxiliaryDatabaseObject">
      <summary> 
            Convenience base class for <see cref="T:NHibernate.Mapping.IAuxiliaryDatabaseObject">AuxiliaryDatabaseObjects</see>.
            </summary>
      <remarks>
            This implementation performs dialect scoping checks strictly based on
            dialect name comparisons.  Custom implementations might want to do
            instanceof-type checks. 
            </remarks>
    </member>
    <member name="T:NHibernate.Mapping.IValue">
      <summary>
            A value is anything that is persisted by value, instead of
            by reference. It is essentially a Hibernate IType, together
            with zero or more columns. Values are wrapped by things with 
            higher level semantics, for example properties, collections, 
            classes.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.IValue.CreateForeignKey">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Mapping.IValue.IsValid(NHibernate.Engine.IMapping)">
      <summary>
            Determines if the Value is part of a valid mapping.
            </summary>
      <param name="mapping">The <see cref="T:NHibernate.Engine.IMapping" /> to validate.</param>
      <returns>
        <see langword="true" /> if the Value is part of a valid mapping, <see langword="false" />
            otherwise.
            </returns>
      <exception cref="T:NHibernate.MappingException">
      </exception>
      <remarks>
            Mainly used to make sure that Value maps to the correct number
            of columns.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.IValue.ColumnSpan">
      <summary>
            Gets the number of columns that this value spans in the table.
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.IValue.ColumnIterator">
      <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:NHibernate.Mapping.Column" /> objects
            that this value is stored in.
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.IValue.Type">
      <summary>
            Gets the <see cref="T:NHibernate.Type.IType" /> to read/write the Values.
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.IValue.Table">
      <summary>
            Gets the <see cref="P:NHibernate.Mapping.IValue.Table" /> this Value is stored in.
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.IValue.IsAlternateUniqueKey">
      <summary>
            Gets a <see cref="T:System.Boolean" /> indicating if this Value is unique.
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.IValue.IsNullable">
      <summary>
            Gets a <see cref="T:System.Boolean" /> indicating if this Value can have
            null values.
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.IValue.IsSimpleValue">
      <summary>
            Gets a <see cref="T:System.Boolean" /> indicating if this is a SimpleValue
            that does not involve foreign keys.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.IKeyValue">
      <summary>
            Represents an identifying key of a table: the value for primary key
            of an entity, or a foreign key of a collection or join table or
            joined subclass table.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.SimpleValue">
      <summary>
            Any value that maps to columns.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.Any">
      <summary>
            A NHibernate <c>any</c> type.
            </summary>
      <remarks>
            Polymorphic association to one of several tables.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.Any.IdentifierTypeName">
      <summary>
            Get or set the identifier type name
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.Any.MetaType">
      <summary>
            Get or set the metatype 
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.Any.MetaValues">
      <summary>
            Represent the relation between a meta-value and the related entityName
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.IFetchable">
      <summary>
            Any mapping with an outer-join attribute
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.IFilterable">
      <summary>
            Defines mapping elements to which filters may be applied.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.Collection">
      <summary>
            Base class that stores the mapping information for <c>&lt;array&gt;</c>, <c>&lt;bag&gt;</c>, 
            <c>&lt;id-bag&gt;</c>, <c>&lt;list&gt;</c>, <c>&lt;map&gt;</c>, and <c>&lt;set&gt;</c>
            collections.
            </summary>
      <remarks> 
            Subclasses are responsible for the specialization required for the particular
            collection style.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.Collection.IsGeneric">
      <summary>
            Gets or sets a <see cref="T:System.Boolean" /> indicating if this is a 
            mapping for a generic collection.
            </summary>
      <value>
        <see langword="true" /> if a collection from the System.Collections.Generic namespace
            should be used, <see langword="false" /> if a collection from the System.Collections 
            namespace should be used.
            </value>
      <remarks>
            This has no affect on any versions of the .net framework before .net-2.0.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.Collection.GenericArguments">
      <summary>
            Gets or sets an array of <see cref="T:System.Type" /> that contains the arguments
            needed to construct an instance of a closed type.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.IndexedCollection">
      <summary>
            Indexed collections include IList, IDictionary, Arrays
            and primitive Arrays.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.List">
      <summary>
            A list has a primary key consisting of the key columns + index column
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.List.#ctor(NHibernate.Mapping.PersistentClass)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.List" /> class.
            </summary>
      <param name="owner">The <see cref="T:NHibernate.Mapping.PersistentClass" /> that contains this list mapping.</param>
    </member>
    <member name="P:NHibernate.Mapping.List.DefaultCollectionType">
      <summary>
            Gets the appropriate <see cref="T:NHibernate.Type.CollectionType" /> that is 
            specialized for this list mapping.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.Array">
      <summary>
            An array has a primary key consisting of the key columns + index column
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.IMetaAttributable">
      <summary> Common interface for things that can handle meta attributes. </summary>
    </member>
    <member name="M:NHibernate.Mapping.IMetaAttributable.GetMetaAttribute(System.String)">
      <summary>
            Retrieve the <see cref="T:NHibernate.Mapping.MetaAttribute" /></summary>
      <param name="attributeName">The attribute name</param>
      <returns>The <see cref="T:NHibernate.Mapping.MetaAttribute" /> if exists; null otherwise</returns>
    </member>
    <member name="P:NHibernate.Mapping.IMetaAttributable.MetaAttributes">
      <summary>
            Meta-Attribute collection.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.Property">
      <summary>
            Mapping for a property of a .NET class (entity
            or component).
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.Property.ColumnSpan">
      <summary>
            Gets the number of columns this property uses in the db.
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.Property.ColumnIterator">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> of <see cref="T:NHibernate.Mapping.Column" />s.
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.Property.Name">
      <summary>
            Gets or Sets the name of the Property in the class.
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.Property.IsNullable">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Mapping.Bag">
      <summary>
            A bag permits duplicates, so it has no primary key
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.Bag.#ctor(NHibernate.Mapping.PersistentClass)">
      <summary>
            A bag permits duplicates, so it has no primary key.
            </summary>
      <param name="owner">The <see cref="T:NHibernate.Mapping.PersistentClass" /> that contains this bag mapping.</param>
    </member>
    <member name="P:NHibernate.Mapping.Bag.DefaultCollectionType">
      <summary>
            Gets the appropriate <see cref="T:NHibernate.Type.CollectionType" /> that is 
            specialized for this bag mapping.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.Column">
      <summary>
            Represents the mapping to a column in a database.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.Column.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Mapping.Column" />.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.Column.#ctor(System.String)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Mapping.Column" />.
            </summary>
      <param name="columnName">The name of the column.</param>
    </member>
    <member name="M:NHibernate.Mapping.Column.GetQuotedName(NHibernate.Dialect.Dialect)">
      <summary>
            Gets the name of this Column in quoted form if it is necessary.
            </summary>
      <param name="d">
            The <see cref="T:NHibernate.Dialect.Dialect" /> that knows how to quote
            the column name.
            </param>
      <returns>
            The column name in a form that is safe to use inside of a SQL statement.
            Quoted if it needs to be, not quoted if it does not need to be.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Column.GetAlias(NHibernate.Dialect.Dialect)">
            For any column name, generate an alias that is unique
            to that column name, and also 10 characters or less
            in length.
        </member>
    <member name="M:NHibernate.Mapping.Column.GetSqlType(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping)">
      <summary>
            Gets the name of the data type for the column.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to use to get the valid data types.</param>
      <param name="mapping">
      </param>
      <returns>
            The name of the data type for the column. 
            </returns>
      <remarks>
            If the mapping file contains a value of the attribute <c>sql-type</c> this will
            return the string contained in that attribute.  Otherwise it will use the 
            typename from the <see cref="T:NHibernate.Dialect.Dialect" /> of the <see cref="P:NHibernate.Mapping.Column.SqlType" /> object. 
            </remarks>
    </member>
    <member name="M:NHibernate.Mapping.Column.Equals(System.Object)">
      <summary>
            Determines if this instance of <see cref="T:NHibernate.Mapping.Column" /> and a specified object, 
            which must be a <b>Column</b> can be considered the same.
            </summary>
      <param name="obj">An <see cref="T:System.Object" /> that should be a <see cref="T:NHibernate.Mapping.Column" />.</param>
      <returns>
        <see langword="true" /> if the name of this Column and the other Column are the same, 
            otherwise <see langword="false" />.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Column.Equals(NHibernate.Mapping.Column)">
      <summary>
            Determines if this instance of <see cref="T:NHibernate.Mapping.Column" /> and the specified Column 
            can be considered the same.
            </summary>
      <param name="column">A <see cref="T:NHibernate.Mapping.Column" /> to compare to this Column.</param>
      <returns>
        <see langword="true" /> if the name of this Column and the other Column are the same, 
            otherwise <see langword="false" />.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Column.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.Column.GetQuotedName">
      <summary>returns quoted name as it would be in the mapping file. </summary>
    </member>
    <member name="M:NHibernate.Mapping.Column.Clone">
      <summary> Shallow copy, the value is not copied</summary>
    </member>
    <member name="P:NHibernate.Mapping.Column.Length">
      <summary>
            Gets or sets the length of the datatype in the database.
            </summary>
      <value>The length of the datatype in the database.</value>
    </member>
    <member name="P:NHibernate.Mapping.Column.Name">
      <summary>
            Gets or sets the name of the column in the database.
            </summary>
      <value>
            The name of the column in the database.  The get does 
            not return a Quoted column name.
            </value>
      <remarks>
        <p>
            If a value is passed in that is wrapped by <c>`</c> then 
            NHibernate will Quote the column whenever SQL is generated
            for it.  How the column is quoted depends on the Dialect.
            </p>
        <p>
            The value returned by the getter is not Quoted.  To get the
            column name in quoted form use <see cref="M:NHibernate.Mapping.Column.GetQuotedName(NHibernate.Dialect.Dialect)" />.
            </p>
      </remarks>
    </member>
    <member name="P:NHibernate.Mapping.Column.IsNullable">
      <summary>
            Gets or sets if the column can have null values in it.
            </summary>
      <value>
        <see langword="true" /> if the column can have a null value in it.</value>
    </member>
    <member name="P:NHibernate.Mapping.Column.TypeIndex">
      <summary>
            Gets or sets the index of the column in the <see cref="T:NHibernate.Type.IType" />.
            </summary>
      <value>
            The index of the column in the <see cref="T:NHibernate.Type.IType" />.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Column.IsUnique">
      <summary>
            Gets or sets if the column contains unique values.
            </summary>
      <value>
        <see langword="true" /> if the column contains unique values.</value>
    </member>
    <member name="P:NHibernate.Mapping.Column.SqlType">
      <summary>
            Gets or sets the sql data type name of the column.
            </summary>
      <value>
            The sql data type name of the column. 
            </value>
      <remarks>
            This is usually read from the <c>sql-type</c> attribute.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.Column.IsQuoted">
      <summary>
            Gets or sets if the column needs to be quoted in SQL statements.
            </summary>
      <value>
        <see langword="true" /> if the column is quoted.</value>
    </member>
    <member name="P:NHibernate.Mapping.Column.Unique">
      <summary>
            Gets or sets whether the column is unique.
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.Column.CheckConstraint">
      <summary>
            Gets or sets a check constraint on the column
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.Column.HasCheckConstraint">
      <summary>
            Do we have a check constraint?
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.Column.SqlTypeCode">
      <summary> 
            The underlying columns SqlType.
            </summary>
      <remarks>
            If null, it is because the sqltype code is unknown.
            
            Use <see cref="M:NHibernate.Mapping.Column.GetSqlTypeCode(NHibernate.Engine.IMapping)" /> to retreive the sqltypecode used
            for the columns associated Value/Type.
            </remarks>
    </member>
    <member name="T:NHibernate.Mapping.Component">
      <summary>
            The mapping for a component, composite element, composite identifier,
            etc.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.Component.AddProperty(NHibernate.Mapping.Property)">
      <summary>
      </summary>
      <param name="p">
      </param>
    </member>
    <member name="M:NHibernate.Mapping.Component.AddColumn(NHibernate.Mapping.Column)">
      <summary>
      </summary>
      <param name="column">
      </param>
    </member>
    <member name="M:NHibernate.Mapping.Component.#ctor(NHibernate.Mapping.PersistentClass)">
      <summary>
      </summary>
      <param name="owner">
      </param>
    </member>
    <member name="P:NHibernate.Mapping.Component.PropertySpan">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.Component.PropertyIterator">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.Component.ColumnSpan">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.Component.ColumnIterator">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.Component.IsEmbedded">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.Component.IsDynamic">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.Component.ComponentClass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.Component.Owner">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.Component.ParentProperty">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Mapping.Constraint">
      <summary>
            Base class for relational constraints in the database.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.Constraint.AddColumn(NHibernate.Mapping.Column)">
      <summary>
            Adds the <see cref="T:NHibernate.Mapping.Column" /> to the <see cref="T:System.Collections.ICollection" /> of 
            Columns that are part of the constraint.
            </summary>
      <param name="column">The <see cref="T:NHibernate.Mapping.Column" /> to include in the Constraint.</param>
    </member>
    <member name="M:NHibernate.Mapping.Constraint.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
      <summary>
            Generates the SQL string to drop this Constraint in the database.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="defaultSchema">
      </param>
      <param name="defaultCatalog">
      </param>
      <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Constraint.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String,System.String)">
      <summary>
            Generates the SQL string to create this Constraint in the database.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="p">
      </param>
      <param name="defaultSchema">
      </param>
      <param name="defaultCatalog">
      </param>
      <returns>
            A string that contains the SQL to create this Constraint.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Constraint.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String,System.String)">
      <summary>
            When implemented by a class, generates the SQL string to create the named
            Constraint in the database.
            </summary>
      <param name="d">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="constraintName">The name to use as the identifier of the constraint in the database.</param>
      <param name="defaultSchema">
      </param>
      <param name="defaultCatalog">
      </param>
      <returns>
            A string that contains the SQL to create the named Constraint.
            </returns>
    </member>
    <member name="P:NHibernate.Mapping.Constraint.Name">
      <summary>
            Gets or sets the Name used to identify the constraint in the database.
            </summary>
      <value>The Name used to identify the constraint in the database.</value>
    </member>
    <member name="P:NHibernate.Mapping.Constraint.ColumnIterator">
      <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:NHibernate.Mapping.Column" /> objects that are part of the constraint.
            </summary>
      <value>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:NHibernate.Mapping.Column" /> objects that are part of the constraint.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Constraint.ColumnSpan">
      <summary>
            Gets the number of columns that this Constraint contains.
            </summary>
      <value>
            The number of columns that this Constraint contains.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Constraint.Table">
      <summary>
            Gets or sets the <see cref="P:NHibernate.Mapping.Constraint.Table" /> this Constraint is in.
            </summary>
      <value>
            The <see cref="P:NHibernate.Mapping.Constraint.Table" /> this Constraint is in.
            </value>
    </member>
    <member name="T:NHibernate.Mapping.Table">
      <summary>
            Represents a Table in a database that an object gets mapped against.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.Table.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Mapping.Table" />.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.Table.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String,System.String)">
      <summary>
            Generates the SQL string to create this Table in the database.
            </summary>
      <param name="dialect">The <see cref="N:NHibernate.Dialect" /> to use for SQL rules.</param>
      <param name="p">
      </param>
      <param name="defaultCatalog">
      </param>
      <param name="defaultSchema">
      </param>
      <returns>
            A string that contains the SQL to create this Table, Primary Key Constraints
            , and Unique Key Constraints.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Table.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
      <summary>
            Generates the SQL string to drop this Table in the database.
            </summary>
      <param name="dialect">The <see cref="N:NHibernate.Dialect" /> to use for SQL rules.</param>
      <param name="defaultCatalog">
      </param>
      <param name="defaultSchema">
      </param>
      <returns>
            A string that contains the SQL to drop this Table and to cascade the drop to 
            the constraints if the database supports it.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Table.GetQualifiedName(NHibernate.Dialect.Dialect)">
      <summary>
            Gets the schema qualified name of the Table.
            </summary>
      <param name="dialect">The <see cref="N:NHibernate.Dialect" /> that knows how to Quote the Table name.</param>
      <returns>The name of the table qualified with the schema if one is specified.</returns>
    </member>
    <member name="M:NHibernate.Mapping.Table.GetQualifiedName(NHibernate.Dialect.Dialect,System.String,System.String)">
      <summary>
            Gets the schema qualified name of the Table using the specified qualifier
            </summary>
      <param name="dialect">The <see cref="N:NHibernate.Dialect" /> that knows how to Quote the Table name.</param>
      <param name="defaultCatalog">The catalog name.</param>
      <param name="defaultSchema">The schema name.</param>
      <returns>A String representing the Qualified name.</returns>
      <remarks>If this were used with MSSQL it would return a dbo.table_name.</remarks>
    </member>
    <member name="M:NHibernate.Mapping.Table.GetQuotedName">
      <summary> returns quoted name as it would be in the mapping file.</summary>
    </member>
    <member name="M:NHibernate.Mapping.Table.GetQuotedName(NHibernate.Dialect.Dialect)">
      <summary>
            Gets the name of this Table in quoted form if it is necessary.
            </summary>
      <param name="dialect">
            The <see cref="T:NHibernate.Dialect.Dialect" /> that knows how to quote the Table name.
            </param>
      <returns>
            The Table name in a form that is safe to use inside of a SQL statement.
            Quoted if it needs to be, not quoted if it does not need to be.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Table.GetQuotedSchema">
      <summary> returns quoted name as it is in the mapping file.</summary>
    </member>
    <member name="M:NHibernate.Mapping.Table.GetQuotedSchemaName(NHibernate.Dialect.Dialect)">
      <summary>
            Gets the schema for this table in quoted form if it is necessary.
            </summary>
      <param name="dialect">
            The <see cref="T:NHibernate.Dialect.Dialect" /> that knows how to quote the table name.
            </param>
      <returns>
            The schema name for this table in a form that is safe to use inside
            of a SQL statement. Quoted if it needs to be, not quoted if it does not need to be.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Table.GetColumn(System.Int32)">
      <summary>
            Gets the <see cref="T:NHibernate.Mapping.Column" /> at the specified index.
            </summary>
      <param name="n">The index of the Column to get.</param>
      <returns> 
            The <see cref="T:NHibernate.Mapping.Column" /> at the specified index.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Table.AddColumn(NHibernate.Mapping.Column)">
      <summary>
            Adds the <see cref="T:NHibernate.Mapping.Column" /> to the <see cref="T:System.Collections.ICollection" /> of 
            Columns that are part of the Table.
            </summary>
      <param name="column">The <see cref="T:NHibernate.Mapping.Column" /> to include in the Table.</param>
    </member>
    <member name="M:NHibernate.Mapping.Table.GetIndex(System.String)">
      <summary>
            Gets the <see cref="T:NHibernate.Mapping.Index" /> identified by the name.
            </summary>
      <param name="indexName">The name of the <see cref="T:NHibernate.Mapping.Index" /> to get.</param>
      <returns>
            The <see cref="T:NHibernate.Mapping.Index" /> identified by the name.  If the <see cref="T:NHibernate.Mapping.Index" />
            identified by the name does not exist then it is created.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Table.GetUniqueKey(System.String)">
      <summary>
            Gets the <see cref="T:NHibernate.Mapping.UniqueKey" /> identified by the name.
            </summary>
      <param name="keyName">The name of the <see cref="T:NHibernate.Mapping.UniqueKey" /> to get.</param>
      <returns>
            The <see cref="T:NHibernate.Mapping.UniqueKey" /> identified by the name.  If the <see cref="T:NHibernate.Mapping.UniqueKey" />
            identified by the name does not exist then it is created.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Table.CreateForeignKey(System.String,System.Collections.Generic.IEnumerable{NHibernate.Mapping.Column},System.String,System.Collections.Generic.IEnumerable{NHibernate.Mapping.Column})">
      <summary>
            Create a <see cref="T:NHibernate.Mapping.ForeignKey" /> for the columns in the Table.
            </summary>
      <param name="keyName">
      </param>
      <param name="keyColumns">An <see cref="T:System.Collections.IList" /> of <see cref="T:NHibernate.Mapping.Column" /> objects.</param>
      <param name="referencedEntityName">
      </param>
      <param name="referencedColumns">
      </param>
      <returns>
            A <see cref="T:NHibernate.Mapping.ForeignKey" /> for the columns in the Table.  
            </returns>
      <remarks>
            This does not necessarily create a <see cref="T:NHibernate.Mapping.ForeignKey" />, if
            one already exists for the columns then it will return an 
            existing <see cref="T:NHibernate.Mapping.ForeignKey" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Mapping.Table.UniqueColumnString(System.Collections.IEnumerable)">
      <summary>
            Generates a unique string for an <see cref="T:System.Collections.ICollection" /> of 
            <see cref="T:NHibernate.Mapping.Column" /> objects.
            </summary>
      <param name="uniqueColumns">An <see cref="T:System.Collections.ICollection" /> of <see cref="T:NHibernate.Mapping.Column" /> objects.</param>
      <returns>
            An unique string for the <see cref="T:NHibernate.Mapping.Column" /> objects.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Table.SetIdentifierValue(NHibernate.Mapping.SimpleValue)">
      <summary>
            Sets the Identifier of the Table.
            </summary>
      <param name="identifierValue">The <see cref="T:NHibernate.Mapping.SimpleValue" /> that represents the Identifier.</param>
    </member>
    <member name="M:NHibernate.Mapping.Table.AddCheckConstraint(System.String)">
      <summary>
      </summary>
      <param name="constraint">
      </param>
    </member>
    <member name="M:NHibernate.Mapping.Table.GetColumn(NHibernate.Mapping.Column)">
      <summary> Return the column which is identified by column provided as argument. </summary>
      <param name="column">column with atleast a name. </param>
      <returns> 
            The underlying column or null if not inside this table.
            Note: the instance *can* be different than the input parameter, but the name will be the same.
            </returns>
    </member>
    <member name="P:NHibernate.Mapping.Table.Name">
      <summary>
            Gets or sets the name of the Table in the database.
            </summary>
      <value>
            The name of the Table in the database.  The get does 
            not return a Quoted Table name.
            </value>
      <remarks>
        <p>
            If a value is passed in that is wrapped by <c>`</c> then 
            NHibernate will Quote the Table whenever SQL is generated
            for it.  How the Table is quoted depends on the Dialect.
            </p>
        <p>
            The value returned by the getter is not Quoted.  To get the
            column name in quoted form use <see cref="M:NHibernate.Mapping.Table.GetQuotedName(NHibernate.Dialect.Dialect)" />.
            </p>
      </remarks>
    </member>
    <member name="P:NHibernate.Mapping.Table.ColumnSpan">
      <summary>
            Gets the number of columns that this Table contains.
            </summary>
      <value>
            The number of columns that this Table contains.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Table.ColumnIterator">
      <summary>
            Gets an <see cref="T:System.Collections.IEnumerable" /> of <see cref="T:NHibernate.Mapping.Column" /> objects that 
            are part of the Table.
            </summary>
      <value>
            An <see cref="T:System.Collections.IEnumerable" /> of <see cref="T:NHibernate.Mapping.Column" /> objects that are 
            part of the Table.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Table.IndexIterator">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> of <see cref="T:NHibernate.Mapping.Index" /> objects that 
            are part of the Table.
            </summary>
      <value>
            An <see cref="T:System.Collections.ICollection" /> of <see cref="T:NHibernate.Mapping.Index" /> objects that are 
            part of the Table.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Table.ForeignKeyIterator">
      <summary>
            Gets an <see cref="T:System.Collections.IEnumerable" /> of <see cref="T:NHibernate.Mapping.ForeignKey" /> objects that 
            are part of the Table.
            </summary>
      <value>
            An <see cref="T:System.Collections.IEnumerable" /> of <see cref="T:NHibernate.Mapping.ForeignKey" /> objects that are 
            part of the Table.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Table.UniqueKeyIterator">
      <summary>
            Gets an <see cref="T:System.Collections.IEnumerable" /> of <see cref="T:NHibernate.Mapping.UniqueKey" /> objects that 
            are part of the Table.
            </summary>
      <value>
            An <see cref="T:System.Collections.IEnumerable" /> of <see cref="T:NHibernate.Mapping.UniqueKey" /> objects that are 
            part of the Table.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Table.PrimaryKey">
      <summary>
            Gets or sets the <see cref="P:NHibernate.Mapping.Table.PrimaryKey" /> of the Table.
            </summary>
      <value>The <see cref="P:NHibernate.Mapping.Table.PrimaryKey" /> of the Table.</value>
    </member>
    <member name="P:NHibernate.Mapping.Table.Schema">
      <summary>
            Gets or sets the schema the table is in.
            </summary>
      <value>
            The schema the table is in or <see langword="null" /> if no schema is specified.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Table.UniqueInteger">
      <summary>
            Gets the unique number of the Table.
            </summary>
      <value>The unique number of the Table.</value>
    </member>
    <member name="P:NHibernate.Mapping.Table.IsQuoted">
      <summary>
            Gets or sets if the column needs to be quoted in SQL statements.
            </summary>
      <value>
        <see langword="true" /> if the column is quoted.</value>
    </member>
    <member name="T:NHibernate.Mapping.DependantValue">
      <summary> 
            A value which is "typed" by reference to some other value 
            (for example, a foreign key is typed by the referenced primary key). 
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.ForeignKey">
      <summary>
            A Foreign Key constraint in the database.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.ForeignKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String,System.String)">
      <summary>
            Generates the SQL string to create the named Foreign Key Constraint in the database.
            </summary>
      <param name="d">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="constraintName">The name to use as the identifier of the constraint in the database.</param>
      <param name="defaultSchema">
      </param>
      <param name="defaultCatalog">
      </param>
      <returns>
            A string that contains the SQL to create the named Foreign Key Constraint.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.ForeignKey.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
      <summary>
            Get the SQL string to drop this Constraint in the database.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="defaultSchema">
      </param>
      <param name="defaultCatalog">
      </param>
      <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.ForeignKey.AlignColumns">
      <summary> 
            Validates that columnspan of the foreignkey and the primarykey is the same.
             Furthermore it aligns the length of the underlying tables columns.
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.ForeignKey.ReferencedTable">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Table" /> that the Foreign Key is referencing.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.Table" /> the Foreign Key is referencing.</value>
      <exception cref="T:NHibernate.MappingException">
            Thrown when the number of columns in this Foreign Key is not the same
            amount of columns as the Primary Key in the ReferencedTable.
            </exception>
    </member>
    <member name="P:NHibernate.Mapping.ForeignKey.IsReferenceToPrimaryKey">
      <summary>Does this foreignkey reference the primary key of the reference table </summary>
    </member>
    <member name="T:NHibernate.Mapping.Formula">
      <summary>
            A formula is a derived column value.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.Formula.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Mapping.Formula.GetTemplate(NHibernate.Dialect.Dialect,NHibernate.Dialect.Function.SQLFunctionRegistry)">
      <summary>
      </summary>
      <param name="dialect">
      </param>
      <param name="functionRegistry">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Mapping.Formula.FormulaString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Mapping.IdentifierCollection">
      <summary>
            A collection with a synthetic "identifier" column.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.IdentifierCollection.#ctor(NHibernate.Mapping.PersistentClass)">
      <summary>
      </summary>
      <param name="owner">
      </param>
    </member>
    <member name="M:NHibernate.Mapping.IdentifierCollection.CreatePrimaryKey">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Mapping.IdentifierCollection.Validate(NHibernate.Engine.IMapping)">
      <summary>
      </summary>
      <param name="mapping">
      </param>
    </member>
    <member name="P:NHibernate.Mapping.IdentifierCollection.Identifier">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.IdentifierCollection.IsIdentified">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Mapping.IdentifierBag">
      <summary>
            An <c>PersistentIdentifierBag</c> has a primary key consistenting of just
            the identifier column.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.Index">
      <summary>
            An Index in the database.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.Index.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String,System.String)">
      <summary>
            Generates the SQL string to create this Index in the database.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="p">
      </param>
      <param name="defaultCatalog">
      </param>
      <param name="defaultSchema">
      </param>
      <returns>
            A string that contains the SQL to create this Index.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Index.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
      <summary>
            Generates the SQL string to drop this Index in the database.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="defaultCatalog">
      </param>
      <param name="defaultSchema">
      </param>
      <returns>
            A string that contains the SQL to drop this Index.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.Index.AddColumn(NHibernate.Mapping.Column)">
      <summary>
            Adds the <see cref="T:NHibernate.Mapping.Column" /> to the <see cref="T:System.Collections.ICollection" /> of 
            Columns that are part of the Index.
            </summary>
      <param name="column">The <see cref="T:NHibernate.Mapping.Column" /> to include in the Index.</param>
    </member>
    <member name="P:NHibernate.Mapping.Index.Table">
      <summary>
            Gets or sets the <see cref="P:NHibernate.Mapping.Index.Table" /> this Index is in.
            </summary>
      <value>
            The <see cref="P:NHibernate.Mapping.Index.Table" /> this Index is in.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Index.ColumnIterator">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> of <see cref="T:NHibernate.Mapping.Column" /> objects that are 
            part of the Index.
            </summary>
      <value>
            An <see cref="T:System.Collections.ICollection" /> of <see cref="T:NHibernate.Mapping.Column" /> objects that are 
            part of the Index.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Index.Name">
      <summary>
            Gets or sets the Name used to identify the Index in the database.
            </summary>
      <value>The Name used to identify the Index in the database.</value>
    </member>
    <member name="T:NHibernate.Mapping.PersistentClass">
      <summary>
            Base class for the <see cref="P:NHibernate.Mapping.PersistentClass.RootClazz" /> mapped by <c>&lt;class&gt;</c> and a 
            <see cref="T:NHibernate.Mapping.Subclass" /> that is mapped by <c>&lt;subclass&gt;</c> or 
            <c>&lt;joined-subclass&gt;</c>.
            </summary>
    </member>
    <member name="F:NHibernate.Mapping.PersistentClass.NullDiscriminatorMapping">
      <summary>
      </summary>
    </member>
    <member name="F:NHibernate.Mapping.PersistentClass.NotNullDiscriminatorMapping">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Mapping.PersistentClass.AddSubclass(NHibernate.Mapping.Subclass)">
      <summary>
            Adds a <see cref="T:NHibernate.Mapping.Subclass" /> to the class hierarchy.
            </summary>
      <param name="subclass">The <see cref="T:NHibernate.Mapping.Subclass" /> to add to the hierarchy.</param>
    </member>
    <member name="M:NHibernate.Mapping.PersistentClass.AddProperty(NHibernate.Mapping.Property)">
      <summary>
            Change the property definition or add a new property definition
            </summary>
      <param name="p">The <see cref="T:NHibernate.Mapping.Property" /> to add.</param>
    </member>
    <member name="M:NHibernate.Mapping.PersistentClass.AddSubclassProperty(NHibernate.Mapping.Property)">
      <summary>
            Adds a <see cref="T:NHibernate.Mapping.Property" /> that is implemented by a subclass.
            </summary>
      <param name="p">The <see cref="T:NHibernate.Mapping.Property" /> implemented by a subclass.</param>
    </member>
    <member name="M:NHibernate.Mapping.PersistentClass.AddSubclassTable(NHibernate.Mapping.Table)">
      <summary>
            Adds a <see cref="P:NHibernate.Mapping.PersistentClass.Table" /> that a subclass is stored in.
            </summary>
      <param name="table">The <see cref="P:NHibernate.Mapping.PersistentClass.Table" /> the subclass is stored in.</param>
    </member>
    <member name="M:NHibernate.Mapping.PersistentClass.CreatePrimaryKey(NHibernate.Dialect.Dialect)">
      <summary>
            Creates the <see cref="T:NHibernate.Mapping.PrimaryKey" /> for the <see cref="P:NHibernate.Mapping.PersistentClass.Table" />
            this type is persisted in.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> that is used to Alias columns.</param>
    </member>
    <member name="M:NHibernate.Mapping.PersistentClass.GetReferencedProperty(System.String)">
      <summary>
            Given a property path, locate the appropriate referenceable property reference.
            </summary>
      <remarks>
            A referenceable property is a property  which can be a target of a foreign-key
            mapping (an identifier or explicitly named in a property-ref).
            </remarks>
      <param name="propertyPath">The property path to resolve into a property reference.</param>
      <returns>The property reference (never null).</returns>
      <exception cref="T:NHibernate.MappingException">If the property could not be found.</exception>
    </member>
    <member name="M:NHibernate.Mapping.PersistentClass.Validate(NHibernate.Engine.IMapping)">
      <summary>
      </summary>
      <param name="mapping">
      </param>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.MappedClass">
      <summary>
            Gets the <see cref="T:System.Type" /> that is being mapped.
            </summary>
      <value>The <see cref="T:System.Type" /> that is being mapped.</value>
      <remarks>
            The value of this is set by the <c>name</c> attribute on the <c>&lt;class&gt;</c> 
            element.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.ProxyInterface">
      <summary>
            Gets or sets the <see cref="T:System.Type" /> to use as a Proxy.
            </summary>
      <value>The <see cref="T:System.Type" /> to use as a Proxy.</value>
      <remarks>
            The value of this is set by the <c>proxy</c> attribute. 
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.DynamicInsert">
      <summary>
            Gets or Sets if the Insert Sql is built dynamically.
            </summary>
      <value>
        <see langword="true" /> if the Sql is built at runtime.</value>
      <remarks>
            The value of this is set by the <c>dynamic-insert</c> attribute. 
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.DynamicUpdate">
      <summary>
            Gets or Sets if the Update Sql is built dynamically.
            </summary>
      <value>
        <see langword="true" /> if the Sql is built at runtime.</value>
      <remarks>
            The value of this is set by the <c>dynamic-update</c> attribute. 
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.DiscriminatorValue">
      <summary>
            Gets or Sets the value to use as the discriminator for the Class.
            </summary>
      <value>
            A value that distinguishes this subclass in the database.
            </value>
      <remarks>
            The value of this is set by the <c>discriminator-value</c> attribute.  Each <c>&lt;subclass&gt;</c>
            in a hierarchy must define a unique <c>discriminator-value</c>.  The default value 
            is the class name if no value is supplied.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.SubclassSpan">
      <summary>
            Gets the number of subclasses that inherit either directly or indirectly.
            </summary>
      <value>The number of subclasses that inherit from this PersistentClass.</value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.SubclassIterator">
      <summary>
            Iterate over subclasses in a special 'order', most derived subclasses first.
            </summary>
      <value>
            It will recursively go through Subclasses so that if a SubclassType has Subclasses
            it will pick those up also.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.DirectSubclasses">
      <summary>
            Gets an <see cref="T:System.Collections.IEnumerable" /> of <see cref="T:NHibernate.Mapping.Subclass" /> objects
            that directly inherit from this PersistentClass.
            </summary>
      <value>
            An <see cref="T:System.Collections.IEnumerable" /> of <see cref="T:NHibernate.Mapping.Subclass" /> objects
            that directly inherit from this PersistentClass.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.IsInherited">
      <summary>
            When implemented by a class, gets a boolean indicating if this
            mapped class is inherited from another. 
            </summary>
      <value>
        <see langword="true" /> if this class is a <c>subclass</c> or <c>joined-subclass</c>
            that inherited from another <c>class</c>.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.IsVersioned">
      <summary>
            When implemented by a class, gets a boolean indicating if the mapped class
            has a version property.
            </summary>
      <value>
        <see langword="true" /> if there is a <c>&lt;version&gt;</c> property.</value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.PropertyClosureIterator">
      <summary>
            When implemented by a class, gets an <see cref="T:System.Collections.IEnumerable" /> 
            of <see cref="T:NHibernate.Mapping.Property" /> objects that this mapped class contains.
            </summary>
      <value>
            An <see cref="T:System.Collections.IEnumerable" /> of <see cref="T:NHibernate.Mapping.Property" /> objects that 
            this mapped class contains.
            </value>
      <remarks>
            This is all of the properties of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.TableClosureIterator">
      <summary>
            When implemented by a class, gets an <see cref="T:System.Collections.IEnumerable" /> 
            of <see cref="P:NHibernate.Mapping.PersistentClass.Table" /> objects that this mapped class reads from
            and writes to.
            </summary>
      <value>
            An <see cref="T:System.Collections.IEnumerable" /> of <see cref="P:NHibernate.Mapping.PersistentClass.Table" /> objects that 
            this mapped class reads from and writes to.
            </value>
      <remarks>
            This is all of the tables of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.SubclassPropertyClosureIterator">
      <summary>
            Gets an <see cref="T:System.Collections.IEnumerable" /> of <see cref="T:NHibernate.Mapping.Property" /> objects that
            this mapped class contains and that all of its subclasses contain.
            </summary>
      <value>
            An <see cref="T:System.Collections.IEnumerable" /> of <see cref="T:NHibernate.Mapping.Property" /> objects that
            this mapped class contains and that all of its subclasses contain.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.SubclassTableClosureIterator">
      <summary>
            Gets an <see cref="T:System.Collections.IEnumerable" /> of all of the <see cref="P:NHibernate.Mapping.PersistentClass.Table" /> objects that the 
            subclass finds its information in.  
            </summary>
      <value>An <see cref="T:System.Collections.IEnumerable" /> of <see cref="P:NHibernate.Mapping.PersistentClass.Table" /> objects.</value>
      <remarks>It adds the TableClosureIterator and the subclassTables into the IEnumerable.</remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.EntityPersisterClass">
      <summary>
            When implemented by a class, gets or sets the <see cref="T:System.Type" /> of the Persister.
            </summary>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.RootTable">
      <summary>
            When implemented by a class, gets the <see cref="P:NHibernate.Mapping.PersistentClass.Table" /> of the class
            that is mapped in the <c>class</c> element.
            </summary>
      <value>
            The <see cref="P:NHibernate.Mapping.PersistentClass.Table" /> of the class that is mapped in the <c>class</c> element.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.BatchSize">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.SelectBeforeUpdate">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.ReferenceablePropertyIterator">
      <summary>
            Build a collection of properties which are "referenceable".
            </summary>
      <remarks>
            See <see cref="M:NHibernate.Mapping.PersistentClass.GetReferencedProperty(System.String)" /> for a discussion of "referenceable".
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.IsDiscriminatorValueNotNull">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.IsDiscriminatorValueNull">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.PropertyIterator">
      <summary> 
            Build an iterator over the properties defined on this class.  The returned
            iterator only accounts for "normal" properties (i.e. non-identifier
            properties).
            </summary>
      <value>
            An <see cref="T:System.Collections.IEnumerable" /> of <see cref="T:NHibernate.Mapping.Property" /> objects.
            </value>
      <remarks>
            Differs from <see cref="P:NHibernate.Mapping.PersistentClass.UnjoinedPropertyIterator" /> in that the iterator
            we return here will include properties defined as part of a join.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.UnjoinedPropertyIterator">
      <summary> 
            Build an enumerable over the properties defined on this class <b>which
            are not defined as part of a join</b>.  
            As with <see cref="P:NHibernate.Mapping.PersistentClass.PropertyIterator" /> the returned iterator only accounts 
            for non-identifier properties.
            </summary>
      <returns> An enumerable over the non-joined "normal" properties.</returns>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.IsJoinedSubclass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.HasSubclasses">
      <summary>
            Gets a boolean indicating if this PersistentClass has any subclasses.
            </summary>
      <value>
        <see langword="true" /> if this PeristentClass has any subclasses.</value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.Table">
      <summary>
            Gets or Sets the <see cref="P:NHibernate.Mapping.PersistentClass.Table" /> that this class is stored in.
            </summary>
      <value>The <see cref="P:NHibernate.Mapping.PersistentClass.Table" /> this class is stored in.</value>
      <remarks>
            The value of this is set by the <c>table</c> attribute. 
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.IsMutable">
      <summary>
            When implemented by a class, gets or set a boolean indicating 
            if the mapped class has properties that can be changed.
            </summary>
      <value>
        <see langword="true" /> if the object is mutable.</value>
      <remarks>
            The value of this is set by the <c>mutable</c> attribute. 
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.HasIdentifierProperty">
      <summary>
            When implemented by a class, gets a boolean indicating
            if the mapped class has a Property for the <c>id</c>.
            </summary>
      <value>
        <see langword="true" /> if there is a Property for the <c>id</c>.</value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.IdentifierProperty">
      <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.Property" />
            that is used as the <c>id</c>.
            </summary>
      <value>
            The <see cref="T:NHibernate.Mapping.Property" /> that is used as the <c>id</c>.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.Identifier">
      <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue" />
            that contains information about the identifier.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the identifier.</value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.Version">
      <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.Property" />
            that is used as the version.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.Property" /> that is used as the version.</value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.Discriminator">
      <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue" />
            that contains information about the discriminator.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the discriminator.</value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.IsPolymorphic">
      <summary>
            When implemented by a class, gets or sets if the mapped class has subclasses or is
            a subclass.
            </summary>
      <value>
        <see langword="true" /> if the mapped class has subclasses or is a subclass.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.CacheConcurrencyStrategy">
      <summary>
            When implemented by a class, gets or sets the CacheConcurrencyStrategy
            to use to read/write instances of the persistent class to the Cache.
            </summary>
      <value>The CacheConcurrencyStrategy used with the Cache.</value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.Superclass">
      <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.PersistentClass" />
            that this mapped class is extending.
            </summary>
      <value>
            The <see cref="T:NHibernate.Mapping.PersistentClass" /> that this mapped class is extending.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.IsExplicitPolymorphism">
      <summary>
            When implemented by a class, gets or sets a boolean indicating if 
            explicit polymorphism should be used in Queries.
            </summary>
      <value>
        <see langword="true" /> if only classes queried on should be returned, <see langword="false" />
            if any class in the heirarchy should implicitly be returned.</value>
      <remarks>
            The value of this is set by the <c>polymorphism</c> attribute. 
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.IsDiscriminatorInsertable">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.HasEmbeddedIdentifier">
      <summary>
            When implemented by a class, gets or sets a boolean indicating if the identifier is 
            embedded in the class.
            </summary>
      <value>
        <see langword="true" /> if the class identifies itself.</value>
      <remarks>
            An embedded identifier is true when using a <c>composite-id</c> specifying
            properties of the class as the <c>key-property</c> instead of using a class
            as the <c>composite-id</c>.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.RootClazz">
      <summary>
            When implemented by a class, gets the <see cref="T:NHibernate.Mapping.RootClass" /> of the class
            that is mapped in the <c>class</c> element.
            </summary>
      <value>
            The <see cref="T:NHibernate.Mapping.RootClass" /> of the class that is mapped in the <c>class</c> element.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.Key">
      <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue" />
            that contains information about the Key.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the Key.</value>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.Where">
      <summary>
            When implemented by a class, gets or sets the sql string that should 
            be a part of the where clause.
            </summary>
      <value>
            The sql string that should be a part of the where clause.
            </value>
      <remarks>
            The value of this is set by the <c>where</c> attribute. 
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.PersistentClass.IsForceDiscriminator">
      <summary>
            Gets or sets a boolean indicating if only values in the discriminator column that
            are mapped will be included in the sql.
            </summary>
      <value>
        <see langword="true" /> if the mapped discriminator values should be forced.</value>
      <remarks>
            The value of this is set by the <c>force</c> attribute on the <c>discriminator</c> element. 
            </remarks>
    </member>
    <member name="T:NHibernate.Mapping.Subclass">
      <summary>
            Declaration of a System.Type mapped with the <c>&lt;subclass&gt;</c> or 
            <c>&lt;joined-subclass&gt;</c> element.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.Subclass.#ctor(NHibernate.Mapping.PersistentClass)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.Subclass" /> class.
            </summary>
      <param name="superclass">The <see cref="T:NHibernate.Mapping.PersistentClass" /> that is the superclass.</param>
    </member>
    <member name="M:NHibernate.Mapping.Subclass.AddProperty(NHibernate.Mapping.Property)">
      <summary>
            Add the <see cref="T:NHibernate.Mapping.Property" /> to this PersistentClass.
            </summary>
      <param name="p">The <see cref="T:NHibernate.Mapping.Property" /> to add.</param>
      <remarks>
            This also adds the <see cref="T:NHibernate.Mapping.Property" /> to the Superclass' collection
            of SubclassType Properties.
            </remarks>
    </member>
    <member name="M:NHibernate.Mapping.Subclass.AddSubclassProperty(NHibernate.Mapping.Property)">
      <summary>
            Adds a <see cref="T:NHibernate.Mapping.Property" /> that is implemented by a subclass.
            </summary>
      <param name="p">The <see cref="T:NHibernate.Mapping.Property" /> implemented by a subclass.</param>
      <remarks>
            This also adds the <see cref="T:NHibernate.Mapping.Property" /> to the Superclass' collection
            of SubclassType Properties.
            </remarks>
    </member>
    <member name="M:NHibernate.Mapping.Subclass.AddSubclassTable(NHibernate.Mapping.Table)">
      <summary>
            Adds a <see cref="P:NHibernate.Mapping.Subclass.Table" /> that a subclass is stored in.
            </summary>
      <param name="table">The <see cref="P:NHibernate.Mapping.Subclass.Table" /> the subclass is stored in.</param>
      <remarks>
            This also adds the <see cref="P:NHibernate.Mapping.Subclass.Table" /> to the Superclass' collection
            of SubclassType Tables.
            </remarks>
    </member>
    <member name="M:NHibernate.Mapping.Subclass.CreateForeignKey">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.IsInherited">
      <summary>
            Gets a boolean indicating if this mapped class is inherited from another. 
            </summary>
      <value>
        <see langword="true" /> because this is a SubclassType.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.PropertyClosureIterator">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> of <see cref="T:NHibernate.Mapping.Property" /> objects that this mapped class contains.
            </summary>
      <value>
            An <see cref="T:System.Collections.ICollection" /> of <see cref="T:NHibernate.Mapping.Property" /> objects that 
            this mapped class contains.
            </value>
      <remarks>
            This is all of the properties of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.TableClosureIterator">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> of <see cref="P:NHibernate.Mapping.Subclass.Table" /> objects that this 
            mapped class reads from and writes to.
            </summary>
      <value>
            An <see cref="T:System.Collections.ICollection" /> of <see cref="P:NHibernate.Mapping.Subclass.Table" /> objects that 
            this mapped class reads from and writes to.
            </value>
      <remarks>
            This is all of the tables of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.IsVersioned">
      <summary>
            Gets a boolean indicating if the mapped class has a version property.
            </summary>
      <value>
        <see langword="true" /> if for the Superclass there is a Property for a <c>version</c>.</value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.EntityPersisterClass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.RootTable">
      <summary>
            Gets the <see cref="P:NHibernate.Mapping.Subclass.Table" /> of the class
            that is mapped in the <c>class</c> element.
            </summary>
      <value>
            The <see cref="P:NHibernate.Mapping.Subclass.Table" /> of the Superclass that is mapped in the <c>class</c> element.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.IsJoinedSubclass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.CacheConcurrencyStrategy">
      <summary>
            Gets or sets the CacheConcurrencyStrategy
            to use to read/write instances of the persistent class to the Cache.
            </summary>
      <value>The CacheConcurrencyStrategy used with the Cache.</value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.RootClazz">
      <summary>
            Gets the <see cref="P:NHibernate.Mapping.Subclass.RootClazz" /> of the class that is mapped in the <c>class</c> element.
            </summary>
      <value>
            The <see cref="P:NHibernate.Mapping.Subclass.RootClazz" /> of the Superclass that is mapped in the <c>class</c> element.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.Superclass">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.PersistentClass" /> that this mapped class is extending.
            </summary>
      <value>
            The <see cref="T:NHibernate.Mapping.PersistentClass" /> that this mapped class is extending.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.IdentifierProperty">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property" /> that is used as the <c>id</c>.
            </summary>
      <value>
            The <see cref="T:NHibernate.Mapping.Property" /> from the Superclass that is used as the <c>id</c>.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.Identifier">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the identifier.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.SimpleValue" /> from the Superclass that contains information about the identifier.</value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.HasIdentifierProperty">
      <summary>
            Gets a boolean indicating if the mapped class has a Property for the <c>id</c>.
            </summary>
      <value>
        <see langword="true" /> if in the Superclass there is a Property for the <c>id</c>.</value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.Discriminator">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the discriminator.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.SimpleValue" /> from the Superclass that contains information about the discriminator.</value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.IsMutable">
      <summary>
            Gets or set a boolean indicating if the mapped class has properties that can be changed.
            </summary>
      <value>
        <see langword="true" /> if the Superclass is mutable.</value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.IsPolymorphic">
      <summary>
            Gets or sets if the mapped class is a subclass.
            </summary>
      <value>
        <see langword="true" /> since this mapped class is a subclass.
            </value>
      <remarks>
            The setter should not be used to set the value to anything but <see langword="true" />.  
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.Version">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property" /> that is used as the version.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.Property" /> from the Superclass that is used as the version.</value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.HasEmbeddedIdentifier">
      <summary>
            Gets or sets a boolean indicating if the identifier is 
            embedded in the class.
            </summary>
      <value>
        <see langword="true" /> if the Superclass has an embedded identifier.</value>
      <remarks>
            An embedded identifier is true when using a <c>composite-id</c> specifying
            properties of the class as the <c>key-property</c> instead of using a class
            as the <c>composite-id</c>.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.Key">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the Key.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the Key.</value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.IsExplicitPolymorphism">
      <summary>
            Gets or sets a boolean indicating if explicit polymorphism should be used in Queries.
            </summary>
      <value>
            The value of the Superclasses <c>IsExplicitPolymorphism</c> property.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.Where">
      <summary>
            Gets the sql string that should be a part of the where clause.
            </summary>
      <value>
            The sql string that should be a part of the where clause.
            </value>
      <exception cref="T:System.InvalidOperationException">
            Thrown when the setter is called.  The where clause can not be set on the 
            SubclassType, only the RootClass.
            </exception>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.Table">
      <summary>
            Gets or Sets the <see cref="P:NHibernate.Mapping.Subclass.Table" /> that this class is stored in.
            </summary>
      <value>The <see cref="P:NHibernate.Mapping.Subclass.Table" /> this class is stored in.</value>
      <remarks>
            This also adds the <see cref="P:NHibernate.Mapping.Subclass.Table" /> to the Superclass' collection
            of SubclassType Tables.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.Subclass.IsDiscriminatorInsertable">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Mapping.ToOne">
      <summary>
            A simple-point association (ie. a reference to another entity).
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.ToOne.#ctor(NHibernate.Mapping.Table)">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Mapping.ToOne.CreateForeignKey">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.ToOne.FetchMode">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.ToOne.ReferencedPropertyName">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Mapping.ManyToOne">
      <summary> A many-to-one association mapping</summary>
    </member>
    <member name="M:NHibernate.Mapping.ManyToOne.#ctor(NHibernate.Mapping.Table)">
      <summary>
      </summary>
      <param name="table">
      </param>
    </member>
    <member name="M:NHibernate.Mapping.ManyToOne.CreateForeignKey">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Mapping.Map">
      <summary>
            A map has a primary key consisting of the key columns 
            + index columns.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.Map.#ctor(NHibernate.Mapping.PersistentClass)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.Map" /> class.
            </summary>
      <param name="owner">The <see cref="T:NHibernate.Mapping.PersistentClass" /> that contains this map mapping.</param>
    </member>
    <member name="P:NHibernate.Mapping.Map.DefaultCollectionType">
      <summary>
            Gets the appropriate <see cref="P:NHibernate.Mapping.Map.CollectionType" /> that is 
            specialized for this list mapping.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.MetaAttribute">
      <summary>
            A meta attribute is a named value or values.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.OneToMany">
      <summary>
            A mapping for a <c>one-to-many</c> association.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.OneToMany.IsValid(NHibernate.Engine.IMapping)">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Mapping.OneToMany.CreateForeignKey">
      <summary>
      </summary>
      <remarks>No foreign key element for a one-to-many</remarks>
    </member>
    <member name="P:NHibernate.Mapping.OneToMany.ColumnIterator">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToMany.ColumnSpan">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToMany.AssociatedClass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToMany.Formula">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToMany.Table">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToMany.IsNullable">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToMany.IsSimpleValue">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToMany.IsUnique">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToMany.FetchMode">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Mapping.OneToOne">
      <summary>
            A mapping for a <c>one-to-one</c> association.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.OneToOne.#ctor(NHibernate.Mapping.Table,NHibernate.Mapping.PersistentClass)">
      <summary>
      </summary>
      <param name="table">
      </param>
      <param name="owner">
      </param>
    </member>
    <member name="M:NHibernate.Mapping.OneToOne.CreateForeignKey">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToOne.ConstraintColumns">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToOne.IsConstrained">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToOne.ForeignKeyType">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToOne.Identifier">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.OneToOne.IsNullable">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Mapping.PrimaryKey">
      <summary>
            A Primary Key constraint in the database.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.PrimaryKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String)">
      <summary>
            Generates the SQL string to create the Primary Key Constraint in the database.
            </summary>
      <param name="d">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="defaultSchema">
      </param>
      <returns>
            A string that contains the SQL to create the Primary Key Constraint.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.PrimaryKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String,System.String)">
      <summary>
            Generates the SQL string to create the named Primary Key Constraint in the database.
            </summary>
      <param name="d">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="constraintName">The name to use as the identifier of the constraint in the database.</param>
      <param name="defaultCatalog">
      </param>
      <param name="defaultSchema">
      </param>
      <returns>
            A string that contains the SQL to create the named Primary Key Constraint.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.PrimaryKey.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
      <summary>
            Get the SQL string to drop this Constraint in the database.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="defaultCatalog">
      </param>
      <param name="defaultSchema">
      </param>
      <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
    </member>
    <member name="T:NHibernate.Mapping.PrimitiveArray">
      <summary>
            A primitive array has a primary key consisting 
            of the key columns + index column.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.PropertyGeneration">
      <summary>
             Indicates whether given properties are generated by the database and, if
            so, at what time(s) they are generated.
            </summary>
    </member>
    <member name="F:NHibernate.Mapping.PropertyGeneration.Never">
      <summary>
            Values for this property are never generated by the database.
            </summary>
    </member>
    <member name="F:NHibernate.Mapping.PropertyGeneration.Insert">
      <summary>
            Values for this property are generated by the database on insert.
            </summary>
    </member>
    <member name="F:NHibernate.Mapping.PropertyGeneration.Always">
      <summary>
            Values for this property are generated by the database on both insert and update.
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.RootClass">
      <summary>
            Declaration of a System.Type mapped with the <c>&lt;class&gt;</c> element that
            is the root class of a table-per-subclass, or table-per-concrete-class 
            inheritance heirarchy.
            </summary>
    </member>
    <member name="F:NHibernate.Mapping.RootClass.DefaultIdentifierColumnName">
      <summary>
            The default name of the column for the Identifier
            </summary>
      <value>
        <c>id</c> is the default column name for the Identifier.</value>
    </member>
    <member name="F:NHibernate.Mapping.RootClass.DefaultDiscriminatorColumnName">
      <summary>
            The default name of the column for the Discriminator
            </summary>
      <value>
        <c>class</c> is the default column name for the Discriminator.</value>
    </member>
    <member name="M:NHibernate.Mapping.RootClass.AddSubclass(NHibernate.Mapping.Subclass)">
      <summary>
            Adds a <see cref="T:NHibernate.Mapping.Subclass" /> to the class hierarchy.
            </summary>
      <param name="subclass">The <see cref="T:NHibernate.Mapping.Subclass" /> to add to the hierarchy.</param>
      <remarks>
            When a <see cref="T:NHibernate.Mapping.Subclass" /> is added this mapped class has the property <see cref="P:NHibernate.Mapping.RootClass.IsPolymorphic" />
            set to <see langword="true" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Mapping.RootClass.Validate(NHibernate.Engine.IMapping)">
      <summary>
      </summary>
      <param name="mapping">
      </param>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.IsInherited">
      <summary>
            Gets a boolean indicating if this mapped class is inherited from another. 
            </summary>
      <value>
        <see langword="false" /> because this is the root mapped class.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.PropertyClosureIterator">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> of <see cref="T:NHibernate.Mapping.Property" /> objects that this mapped class contains.
            </summary>
      <value>
            An <see cref="T:System.Collections.ICollection" /> of <see cref="T:NHibernate.Mapping.Property" /> objects that 
            this mapped class contains.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.TableClosureIterator">
      <summary>
            Gets an <see cref="T:System.Collections.ICollection" /> of <see cref="P:NHibernate.Mapping.RootClass.Table" /> objects that this 
            mapped class reads from and writes to.
            </summary>
      <value>
            An <see cref="T:System.Collections.ICollection" /> of <see cref="P:NHibernate.Mapping.RootClass.Table" /> objects that 
            this mapped class reads from and writes to.
            </value>
      <remarks>
            There is only one <see cref="P:NHibernate.Mapping.RootClass.Table" /> in the <see cref="T:System.Collections.ICollection" /> since
            this is the root class.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.IsVersioned">
      <summary>
            Gets a boolean indicating if the mapped class has a version property.
            </summary>
      <value>
        <see langword="true" /> if there is a Property for a <c>version</c>.</value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.RootTable">
      <summary>
            Gets the <see cref="P:NHibernate.Mapping.RootClass.Table" /> of the class
            that is mapped in the <c>class</c> element.
            </summary>
      <value>
            The <see cref="P:NHibernate.Mapping.RootClass.Table" /> of the class this mapped class.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.HasEmbeddedIdentifier">
      <summary>
            Gets or sets a boolean indicating if the identifier is 
            embedded in the class.
            </summary>
      <value>
        <see langword="true" /> if the class identifies itself.</value>
      <remarks>
            An embedded identifier is true when using a <c>composite-id</c> specifying
            properties of the class as the <c>key-property</c> instead of using a class
            as the <c>composite-id</c>.
            </remarks>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.CacheRegionName">
      <summary>
            Gets or sets the cache region name.
            </summary>
      <value>The region name used with the Cache.</value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.IsJoinedSubclass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.IdentifierProperty">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property" /> that is used as the <c>id</c>.
            </summary>
      <value>
            The <see cref="T:NHibernate.Mapping.Property" /> that is used as the <c>id</c>.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.Identifier">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the identifier.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the identifier.</value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.HasIdentifierProperty">
      <summary>
            Gets a boolean indicating if the mapped class has a Property for the <c>id</c>.
            </summary>
      <value>
        <see langword="true" /> if there is a Property for the <c>id</c>.</value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.Discriminator">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the discriminator.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the discriminator.</value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.IsPolymorphic">
      <summary>
            Gets or sets if the mapped class has subclasses.
            </summary>
      <value>
        <see langword="true" /> if the mapped class has subclasses.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.RootClazz">
      <summary>
            Gets the <see cref="P:NHibernate.Mapping.RootClass.RootClazz" /> of the class that is mapped in the <c>class</c> element.
            </summary>
      <value>
        <c>this</c> since this is the root mapped class.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.IsExplicitPolymorphism">
      <summary>
            Gets or sets a boolean indicating if explicit polymorphism should be used in Queries.
            </summary>
      <value>
        <see langword="true" /> if only classes queried on should be returned, <see langword="false" />
            if any class in the hierarchy should implicitly be returned.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.Version">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property" /> that is used as the version.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.Property" /> that is used as the version.</value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.IsMutable">
      <summary>
            Gets or set a boolean indicating if the mapped class has properties that can be changed.
            </summary>
      <value>
        <see langword="true" /> if the object is mutable.</value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.Superclass">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.PersistentClass" /> that this mapped class is extending.
            </summary>
      <value>
        <see langword="null" /> since this is the root class.
            </value>
      <exception cref="T:System.InvalidOperationException">
            Thrown when the setter is called.  The Superclass can not be set on the 
            RootClass, only the SubclassType can have a Superclass set.
            </exception>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.Key">
      <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the Key.
            </summary>
      <value>The <see cref="T:NHibernate.Mapping.SimpleValue" /> that contains information about the Key.</value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.IsDiscriminatorInsertable">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.IsForceDiscriminator">
      <summary>
            Gets or sets a boolean indicating if only values in the discriminator column that
            are mapped will be included in the sql.
            </summary>
      <value>
        <see langword="true" /> if the mapped discriminator values should be forced.</value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.Where">
      <summary>
            Gets or sets the sql string that should be a part of the where clause.
            </summary>
      <value>
            The sql string that should be a part of the where clause.
            </value>
    </member>
    <member name="P:NHibernate.Mapping.RootClass.CacheConcurrencyStrategy">
      <summary>
            Gets or sets the CacheConcurrencyStrategy
            to use to read/write instances of the persistent class to the Cache.
            </summary>
      <value>The CacheConcurrencyStrategy used with the Cache.</value>
    </member>
    <member name="T:NHibernate.Mapping.Set">
      <summary>
            A Set with no nullable element columns will have a primary
            key consisting of all table columns (ie - key columns + 
            element columns).
            </summary>
    </member>
    <member name="T:NHibernate.Mapping.SimpleAuxiliaryDatabaseObject">
      <summary> 
            A simple implementation of AbstractAuxiliaryDatabaseObject in which the CREATE and DROP strings are
            provided up front.
            </summary>
      <remarks>
            Contains simple facilities for templating the catalog and schema
            names into the provided strings.
            This is the form created when the mapping documents use &lt;create/&gt; and &lt;drop/&gt;.
            </remarks>
    </member>
    <member name="T:NHibernate.Mapping.TypeDef">
      <summary> Placeholder for typedef information</summary>
    </member>
    <member name="T:NHibernate.Mapping.UniqueKey">
      <summary>
            An Unique Key constraint in the database.
            </summary>
    </member>
    <member name="M:NHibernate.Mapping.UniqueKey.SqlConstraintString(NHibernate.Dialect.Dialect)">
      <summary>
            Generates the SQL string to create the Unique Key Constraint in the database.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <returns> A string that contains the SQL to create the Unique Key Constraint. </returns>
    </member>
    <member name="M:NHibernate.Mapping.UniqueKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String,System.String)">
      <summary>
            Generates the SQL string to create the Unique Key Constraint in the database.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="constraintName">
      </param>
      <param name="defaultCatalog">
      </param>
      <param name="defaultSchema">
      </param>
      <returns>
            A string that contains the SQL to create the Unique Key Constraint.
            </returns>
    </member>
    <member name="M:NHibernate.Mapping.UniqueKey.SqlDropString(NHibernate.Dialect.Dialect,System.String,System.String)">
      <summary>
            Get the SQL string to drop this Constraint in the database.
            </summary>
      <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect" /> to use for SQL rules.</param>
      <param name="defaultCatalog">
      </param>
      <param name="defaultSchema">
      </param>
      <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
    </member>
    <member name="T:NHibernate.Metadata.IClassMetadata">
      <summary>
            Exposes entity class metadata to the application
            </summary>
      <seealso cref="M:NHibernate.ISessionFactory.GetClassMetadata(System.Type)" />
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyType(System.String)">
      <summary> Get the type of a particular (named) property </summary>
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyValuesToInsert(System.Object,System.Collections.IDictionary,NHibernate.Engine.ISessionImplementor)">
      <summary> Return the values of the mapped properties of the object</summary>
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.GetMappedClass(NHibernate.EntityMode)">
      <summary>
            The persistent class
            </summary>
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.Instantiate(System.Object,NHibernate.EntityMode)">
      <summary>
            Create a class instance initialized with the given identifier
            </summary>
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyValue(System.Object,System.String,NHibernate.EntityMode)">
      <summary>
            Get the value of a particular (named) property 
            </summary>
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyValues(System.Object,NHibernate.EntityMode)">
      <summary> Extract the property values from the given entity. </summary>
      <param name="entity">The entity from which to extract the property values. </param>
      <param name="entityMode">The entity-mode of the given entity </param>
      <returns> The property values. </returns>
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.SetPropertyValue(System.Object,System.String,System.Object,NHibernate.EntityMode)">
      <summary>
            Set the value of a particular (named) property 
            </summary>
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.SetPropertyValues(System.Object,System.Object[],NHibernate.EntityMode)">
      <summary>
            Set the given values to the mapped properties of the given object
            </summary>
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.GetIdentifier(System.Object,NHibernate.EntityMode)">
      <summary>
            Get the identifier of an instance (throw an exception if no identifier property)
            </summary>
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.SetIdentifier(System.Object,System.Object,NHibernate.EntityMode)">
      <summary>
            Set the identifier of an instance (or do nothing if no identifier property)
            </summary>
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.ImplementsLifecycle(NHibernate.EntityMode)">
      <summary> Does the class implement the <see cref="T:NHibernate.Classic.ILifecycle" /> interface?</summary>
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.ImplementsValidatable(NHibernate.EntityMode)">
      <summary> Does the class implement the <see cref="T:NHibernate.Classic.IValidatable" /> interface?</summary>
    </member>
    <member name="M:NHibernate.Metadata.IClassMetadata.GetVersion(System.Object,NHibernate.EntityMode)">
      <summary>
            Get the version number (or timestamp) from the object's version property 
            (or return null if not versioned)
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.EntityName">
      <summary>
            The name of the entity
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.IdentifierPropertyName">
      <summary>
            The name of the identifier property (or return null)
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.PropertyNames">
      <summary>
            The names of the class' persistent properties
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.IdentifierType">
      <summary>
            The identifier Hibernate type
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.PropertyTypes">
      <summary>
            The Hibernate types of the classes properties
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.IsMutable">
      <summary>
            Are instances of this class mutable?
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.IsVersioned">
      <summary>
            Are instances of this class versioned by a timestamp or version number column?
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.VersionProperty">
      <summary>
            Gets the index of the version property
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.PropertyNullability">
      <summary>
            Get the nullability of the class' persistent properties
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.PropertyLaziness">
      <summary> Get the "laziness" of the properties of this class</summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.NaturalIdentifierProperties">
      <summary> Which properties hold the natural id?</summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.IsInherited">
      <summary> Does this entity extend a mapped superclass?</summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.HasProxy">
      <summary> Does the class support dynamic proxies? </summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.HasIdentifierProperty">
      <summary> Does the class have an identifier property? </summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.HasNaturalIdentifier">
      <summary> Does this entity declare a natural id?</summary>
    </member>
    <member name="P:NHibernate.Metadata.IClassMetadata.HasSubclasses">
      <summary> Does this entity have mapped subclasses?</summary>
    </member>
    <member name="T:NHibernate.Metadata.ICollectionMetadata">
      <summary>
            Exposes collection metadata to the application
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.ICollectionMetadata.KeyType">
      <summary>
            The collection key type
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.ICollectionMetadata.ElementType">
      <summary>
            The collection element type
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.ICollectionMetadata.IndexType">
      <summary>
            The collection index type (or null if the collection has no index)
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.ICollectionMetadata.HasIndex">
      <summary>
            Is the collection indexed?
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.ICollectionMetadata.Role">
      <summary>
            The name of this collection role
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.ICollectionMetadata.IsArray">
      <summary>
            Is the collection an array?
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.ICollectionMetadata.IsPrimitiveArray">
      <summary>
            Is the collection a primitive array?
            </summary>
    </member>
    <member name="P:NHibernate.Metadata.ICollectionMetadata.IsLazy">
      <summary>
            Is the collection lazily initialized?
            </summary>
    </member>
    <member name="T:NHibernate.Param.IParameterSpecification">
      <summary>
            Maintains information relating to parameters which need to get bound into a
            JDBC {@link PreparedStatement}.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Param.IParameterSpecification.Bind(System.Data.IDbCommand,NHibernate.Engine.QueryParameters,NHibernate.Engine.ISessionImplementor,System.Int32)">
      <summary>
            Bind the appropriate value into the given statement at the specified position.
            </summary>
      <param name="statement">The statement into which the value should be bound.</param>
      <param name="qp">The defined values for the current query execution.</param>
      <param name="session">The session against which the current execution is occuring.</param>
      <param name="position">The position from which to start binding value(s).</param>
      <returns>The number of sql bind positions "eaten" by this bind operation.</returns>
    </member>
    <member name="M:NHibernate.Param.IParameterSpecification.RenderDisplayInfo">
      <summary>
            Render this parameter into displayable info (for logging, etc).
            </summary>
      <returns>The displayable info</returns>
    </member>
    <member name="P:NHibernate.Param.IParameterSpecification.ExpectedType">
      <summary>
            Get or set the type which we are expeting for a bind into this parameter based
            on translated contextual information.
            </summary>
    </member>
    <member name="T:NHibernate.Param.IExplicitParameterSpecification">
      <summary>
            An additional contract for parameters which originate from parameters explicitly encountered in the source statement
            (HQL or native-SQL).
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="P:NHibernate.Param.IExplicitParameterSpecification.SourceLine">
      <summary>
            Retrieves the line number on which this parameter occurs in the source query.
            </summary>
    </member>
    <member name="P:NHibernate.Param.IExplicitParameterSpecification.SourceColumn">
      <summary>
            Retrieves the column number (within the {@link #getSourceLine()}) where this parameter occurs.
            </summary>
    </member>
    <member name="M:NHibernate.Param.AbstractExplicitParameterSpecification.#ctor(System.Int32,System.Int32)">
      <summary>
            Constructs an AbstractExplicitParameterSpecification.
            </summary>
      <param name="sourceLine">sourceLine</param>
      <param name="sourceColumn">sourceColumn</param>
    </member>
    <member name="M:NHibernate.Param.CollectionFilterKeyParameterSpecification.#ctor(System.String,NHibernate.Type.IType,System.Int32)">
      <summary>
            Creates a specialized collection-filter collection-key parameter spec.
            </summary>
      <param name="collectionRole">The collection role being filtered.</param>
      <param name="keyType">The mapped collection-key type.</param>
      <param name="queryParameterPosition">The position within QueryParameters where we can find the appropriate param value to bind.</param>
    </member>
    <member name="M:NHibernate.Param.DynamicFilterParameterSpecification.#ctor(System.String,System.String,NHibernate.Type.IType)">
      <summary>
            Constructs a parameter specification for a particular filter parameter.
            </summary>
      <param name="filterName">The name of the filter</param>
      <param name="parameterName">The name of the parameter</param>
      <param name="definedParameterType">The paremeter type specified on the filter metadata</param>
    </member>
    <member name="T:NHibernate.Param.NamedParameterSpecification">
      <summary>
            Parameter bind specification for an explicit named parameter.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Param.NamedParameterSpecification.#ctor(System.Int32,System.Int32,System.String)">
      <summary>
            Constructs a named parameter bind specification.
            </summary>
      <param name="sourceLine">sourceLine</param>
      <param name="sourceColumn">sourceColumn</param>
      <param name="name">The named parameter name.</param>
    </member>
    <member name="M:NHibernate.Param.NamedParameterSpecification.Bind(System.Data.IDbCommand,NHibernate.Engine.QueryParameters,NHibernate.Engine.ISessionImplementor,System.Int32)">
      <summary>
            Bind the appropriate value into the given statement at the specified position.
            </summary>
      <param name="statement">The statement into which the value should be bound.</param>
      <param name="qp">The defined values for the current query execution.</param>
      <param name="session">The session against which the current execution is occuring.</param>
      <param name="position">The position from which to start binding value(s).</param>
      <returns>The number of sql bind positions "eaten" by this bind operation.</returns>
    </member>
    <member name="P:NHibernate.Param.NamedParameterSpecification.Name">
      <summary>
            Getter for property 'name'.
            </summary>
    </member>
    <member name="T:NHibernate.Param.ParameterTranslationsImpl">
      <summary>
            Defines the information available for parameters encountered during
            query translation through the antlr-based parser.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="T:NHibernate.Param.PositionalParameterSpecification">
      <summary>
            Parameter bind specification for an explicit  positional (or ordinal) parameter.
            Author: Steve Ebersole
            Ported by: Steve Strong
            </summary>
    </member>
    <member name="M:NHibernate.Param.PositionalParameterSpecification.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
            Constructs a position/ordinal parameter bind specification.
            </summary>
      <param name="sourceLine">sourceLine</param>
      <param name="sourceColumn">sourceColumn</param>
      <param name="hqlPosition">The position in the source query, relative to the other source positional parameters.</param>
    </member>
    <member name="M:NHibernate.Param.PositionalParameterSpecification.Bind(System.Data.IDbCommand,NHibernate.Engine.QueryParameters,NHibernate.Engine.ISessionImplementor,System.Int32)">
      <summary>
            Bind the appropriate value into the given statement at the specified position.
            </summary>
      <param name="statement">The statement into which the value should be bound.</param>
      <param name="qp">The defined values for the current query execution.</param>
      <param name="session">The session against which the current execution is occuring.</param>
      <param name="position">The position from which to start binding value(s).</param>
      <returns>The number of sql bind positions "eaten" by this bind operation.</returns>
    </member>
    <member name="P:NHibernate.Param.PositionalParameterSpecification.HqlPosition">
      <summary>
            Getter for property 'hqlPosition'.
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.IPropertyMapping">
      <summary>
            Abstraction of all mappings that define properties: entities, collection elements.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IPropertyMapping.ToType(System.String)">
      <summary>
            Given a component path expression, get the type of the property
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IPropertyMapping.TryToType(System.String,NHibernate.Type.IType@)">
      <summary>
            Given a component path expression, get the type of the property. 
            </summary>
      <param name="propertyName">
      </param>
      <param name="type">
      </param>
      <returns>true if a type was found, false if not</returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IPropertyMapping.ToColumns(System.String,System.String)">
      <summary>
            Given a query alias and a property path, return the qualified column name
            </summary>
      <param name="alias">
      </param>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IPropertyMapping.ToColumns(System.String)">
      <summary> Given a property path, return the corresponding column name(s).</summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IPropertyMapping.Type">
      <summary>
            Get the type of the thing containing the properties
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.IJoinable">
      <summary>
            Anything that can be loaded by outer join - namely persisters for classes or collections.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IJoinable.SelectFragment(NHibernate.Persister.Entity.IJoinable,System.String,System.String,System.String,System.String,System.Boolean)">
      <summary>
            All columns to select, when loading.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IJoinable.WhereJoinFragment(System.String,System.Boolean,System.Boolean)">
      <summary>
            Get the where clause part of any joins (optional operation)
            </summary>
      <param name="alias">
      </param>
      <param name="innerJoin">
      </param>
      <param name="includeSubclasses">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IJoinable.FromJoinFragment(System.String,System.Boolean,System.Boolean)">
      <summary>
            Get the from clause part of any joins (optional operation)
            </summary>
      <param name="alias">
      </param>
      <param name="innerJoin">
      </param>
      <param name="includeSubclasses">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IJoinable.FilterFragment(System.String,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
      <summary>
            Get the where clause filter, given a query alias and considering enabled session filters
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IJoinable.ConsumesEntityAlias">
      <summary>
            Very, very, very ugly...
            </summary>
      <value>Does this persister "consume" entity column aliases in the result
            set?</value>
    </member>
    <member name="M:NHibernate.Persister.Entity.IJoinable.ConsumesCollectionAlias">
      <summary>
            Very, very, very ugly...
            </summary>
      <value>Does this persister "consume" collection column aliases in the result
            set?</value>
    </member>
    <member name="P:NHibernate.Persister.Entity.IJoinable.Name">
      <summary>
            An identifying name; a class name or collection role name.
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IJoinable.KeyColumnNames">
      <summary>
            The columns to join on.
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IJoinable.IsCollection">
      <summary>
            Is this instance actually a ICollectionPersister?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IJoinable.TableName">
      <summary>
            The table to join to.
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Collection.ICollectionPersister">
      <summary>
            A strategy for persisting a collection role.
            </summary>
      <remarks>
            Defines a contract between the persistence strategy and the actual persistent collection framework
            and session. Does not define operations that are required for querying collections, or loading by outer join.
            <para />
            Implements persistence of a collection instance while the instance is
            referenced in a particular role.
            <para />
            This class is highly coupled to the <see cref="T:NHibernate.Collection.IPersistentCollection" />
            hierarchy, since double dispatch is used to load and update collection 
            elements.
            <para />
            May be considered an immutable view of the mapping object
            </remarks>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.Initialize(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Initialize the given collection with the given key
            </summary>
      <param name="key">
      </param>
      <param name="session">
      </param>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.ReadKey(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor)">
      <summary>
            Read the key from a row of the <see cref="T:System.Data.IDataReader" /></summary>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.ReadElement(System.Data.IDataReader,System.Object,System.String[],NHibernate.Engine.ISessionImplementor)">
      <summary>
            Read the element from a row of the <see cref="T:System.Data.IDataReader" /></summary>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.ReadIndex(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor)">
      <summary>
            Read the index from a row of the <see cref="T:System.Data.IDataReader" /></summary>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.ReadIdentifier(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Read the identifier from a row of the <see cref="T:System.Data.IDataReader" /></summary>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.Remove(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Completely remove the persistent state of the collection
            </summary>
      <param name="id">
      </param>
      <param name="session">
      </param>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.Recreate(NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            (Re)create the collection's persistent state
            </summary>
      <param name="collection">
      </param>
      <param name="key">
      </param>
      <param name="session">
      </param>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.DeleteRows(NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Delete the persistent state of any elements that were removed from the collection
            </summary>
      <param name="collection">
      </param>
      <param name="key">
      </param>
      <param name="session">
      </param>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.UpdateRows(NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Update the persistent state of any elements that were modified
            </summary>
      <param name="collection">
      </param>
      <param name="key">
      </param>
      <param name="session">
      </param>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.InsertRows(NHibernate.Collection.IPersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Insert the persistent state of any new collection elements
            </summary>
      <param name="collection">
      </param>
      <param name="key">
      </param>
      <param name="session">
      </param>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetKeyColumnAliases(System.String)">
      <summary>
            Generates the collection's key column aliases, based on the given
            suffix.
            </summary>
      <param name="suffix">The suffix to use in the key column alias generation.</param>
      <returns>The key column aliases.</returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetIndexColumnAliases(System.String)">
      <summary>
            Generates the collection's index column aliases, based on the given
            suffix.
            </summary>
      <param name="suffix">The suffix to use in the index column alias generation.</param>
      <returns>The index column aliases, or null if not indexed.</returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetElementColumnAliases(System.String)">
      <summary>
            Generates the collection's element column aliases, based on the given
            suffix.
            </summary>
      <param name="suffix">The suffix to use in the element column alias generation.</param>
      <returns>The element column aliases.</returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.ICollectionPersister.GetIdentifierColumnAlias(System.String)">
      <summary>
            Generates the collection's identifier column aliases, based on the given
            suffix.
            </summary>
      <param name="suffix">The suffix to use in the identifier column alias generation.</param>
      <returns>The identifier column aliases.</returns>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.Cache">
      <summary>
            Get the cache
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.CacheEntryStructure">
      <summary> Get the cache structure</summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.CollectionType">
      <summary>
            Get the associated <c>IType</c></summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.KeyType">
      <summary>
            Get the "key" type (the type of the foreign key)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IndexType">
      <summary>
            Get the "index" type for a list or map (optional operation)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.ElementType">
      <summary>
            Get the "element" type
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.ElementClass">
      <summary>
            Return the element class of an array, or null otherwise
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsPrimitiveArray">
      <summary>
            Is this an array or primitive values?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsArray">
      <summary>
            Is this an array?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsOneToMany">
      <summary> Is this a one-to-many association?</summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsManyToMany">
      <summary> 
            Is this a many-to-many association?  Note that this is mainly
            a convenience feature as the single persister does not
            contain all the information needed to handle a many-to-many
            itself, as internally it is looked at as two many-to-ones.
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsLazy">
      <summary>
            Is this collection lazily initialized?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsInverse">
      <summary>
            Is this collection "inverse", so state changes are not propogated to the database.
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.Role">
      <summary>
            Get the name of this collection role (the fully qualified class name, extended by a "property path")
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.OwnerEntityPersister">
      <summary> Get the persister of the entity that "owns" this collection</summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IdentifierGenerator">
      <summary>
            Get the surrogate key generation strategy (optional operation)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IdentifierType">
      <summary>
            Get the type of the surrogate key
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.CollectionSpaces">
      <summary> Get the "space" that holds the persistent state</summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.CascadeDeleteEnabled">
      <summary> 
            Is cascade delete handled by the database-level
            foreign key constraint definition?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsVersioned">
      <summary> 
            Does this collection cause version increment of the owning entity?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.IsMutable">
      <summary> Can the elements of this collection change?</summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.HasCache">
      <summary>
            Is this collection role cacheable
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.HasIndex">
      <summary>
            Is this an "indexed" collection? (list or map)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.HasOrphanDelete">
      <summary>
            Does this collection implement "orphan delete"?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.ICollectionPersister.HasOrdering">
      <summary>
            Is this an ordered collection? (An ordered collection is
            ordered by the initialization operation, not by sorting
            that happens in memory, as in the case of a sorted collection.)
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Collection.IQueryableCollection">
      <summary>
            A collection role that may be queried or loaded by outer join.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Collection.IQueryableCollection.SelectFragment(System.String,System.String)">
      <summary>
            Generate a list of collection index and element columns
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetIndexColumnNames(System.String)">
      <summary> 
            Get the names of the collection index columns if
            this is an indexed collection (optional operation),
            aliased by the given table alias
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetElementColumnNames(System.String)">
      <summary>
            Get the names of the collection element columns (or the primary
            key columns in the case of a one-to-many association),
            aliased by the given table alias
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetSQLWhereString(System.String)">
      <summary>
            Get the extra where clause filter SQL
            </summary>
      <param name="alias">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetSQLOrderByString(System.String)">
      <summary>
            Get the order by SQL
            </summary>
      <param name="alias">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.IQueryableCollection.GetManyToManyOrderByString(System.String)">
      <summary>
            Get the order-by to be applied at the target table of a many to many
            </summary>
      <param name="alias">The alias for the many-to-many target table</param>
      <returns>Appropriate order-by fragment or empty string.</returns>
    </member>
    <member name="P:NHibernate.Persister.Collection.IQueryableCollection.IndexFormulas">
      <summary> 
            Get the index formulas if this is an indexed collection 
            (optional operation)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.IQueryableCollection.ElementPersister">
      <summary>
            Get the persister of the element class, if this is a
            collection of entities (optional operation).  Note that
            for a one-to-many association, the returned persister
            must be <c>OuterJoinLoadable</c>.
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.IQueryableCollection.FetchMode">
      <summary>
            Should we load this collection role by outer joining?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.IQueryableCollection.IndexColumnNames">
      <summary>
            Get the names of the collection index columns if this is an indexed collection (optional operation)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.IQueryableCollection.ElementColumnNames">
      <summary>
            Get the names of the collection element columns (or the primary key columns in the case of a one-to-many association)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.IQueryableCollection.HasWhere">
      <summary>
            Does this collection role have a where clause filter?
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Collection.AbstractCollectionPersister">
      <summary>
            Summary description for AbstractCollectionPersister.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Collection.AbstractCollectionPersister.ReadElement(System.Data.IDataReader,System.Object,System.String[],NHibernate.Engine.ISessionImplementor)">
      <summary>
            Reads the Element from the IDataReader.  The IDataReader will probably only contain
            the id of the Element.
            </summary>
      <remarks>See ReadElementIdentifier for an explanation of why this method will be depreciated.</remarks>
    </member>
    <member name="M:NHibernate.Persister.Collection.AbstractCollectionPersister.PerformInsert(System.Object,NHibernate.Collection.IPersistentCollection,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Perform an SQL INSERT, and then retrieve a generated identifier.
            </summary>
      <returns> the id of the collection entry </returns>
      <remarks>
            This form is used for PostInsertIdentifierGenerator-style ids (IDENTITY, select, etc).
            </remarks>
    </member>
    <member name="P:NHibernate.Persister.Collection.AbstractCollectionPersister.ElementClass">
      <summary>
            Return the element class of an array, or null otherwise
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Collection.AbstractCollectionPersister.Role">
      <summary>
            Get the name of this collection role (the fully qualified class name,
            extended by a "property path")
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Collection.BasicCollectionPersister">
      <summary>
            Collection persister for collections of values and many-to-many associations.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.GenerateDeleteString">
      <summary>
            Generate the SQL DELETE that deletes all rows
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.GenerateInsertRowString">
      <summary>
            Generate the SQL INSERT that creates a new row
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.GenerateUpdateRowString">
      <summary>
            Generate the SQL UPDATE that updates a row
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.GenerateDeleteRowString">
      <summary>
            Generate the SQL DELETE that deletes a particular row
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.BasicCollectionPersister.CreateCollectionInitializer(System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
      <summary>
            Create the <see cref="T:NHibernate.Loader.Collection.CollectionLoader" /></summary>
    </member>
    <member name="T:NHibernate.Persister.Collection.CollectionPropertyMapping">
      <summary>
            Summary description for CollectionPropertyMapping.
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Collection.CollectionPropertyNames">
      <summary>
            The names of all the collection properties.
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.AbstractPropertyMapping">
      <summary>
            Base implementation of a PropertyMapping.
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Collection.CompositeElementPropertyMapping">
      <summary>
            Summary description for CompositeElementPropertyMapping.
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Collection.ElementPropertyMapping">
      <summary>
            Summary description for ElementPropertyMapping.
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Collection.OneToManyPersister">
      <summary>
            Summary description for OneToManyPersister.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Collection.OneToManyPersister.GenerateDeleteString">
      <summary>
            Generate the SQL UPDATE that updates all the foreign keys to null
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.OneToManyPersister.GenerateInsertRowString">
      <summary>
            Generate the SQL UPDATE that updates a foreign key to a value
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.OneToManyPersister.GenerateUpdateRowString">
      <summary>
            Not needed for one-to-many association
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.OneToManyPersister.GenerateDeleteRowString">
      <summary>
            Generate the SQL UPDATE that updates a particular row's foreign
            key to null
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Collection.OneToManyPersister.CreateCollectionInitializer(System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
      <summary>
            Create the <see cref="T:NHibernate.Loader.Collection.OneToManyLoader" /></summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.IEntityPersister">
      <summary>
            Concrete <c>IEntityPersister</c>s implement mapping and persistence logic for a particular class.
            </summary>
      <remarks>
            Implementors must be threadsafe (preferably immutable) and must provide a constructor of type
            matching the signature of: (PersistentClass, SessionFactoryImplementor)
            </remarks>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.PostInstantiate">
      <summary>
            Finish the initialization of this object, once all <c>ClassPersisters</c> have been
            instantiated. Called only once, before any other method.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsSubclassEntityName(System.String)">
      <summary> 
            Determine whether the given name represents a subclass entity
            (or this entity itself) of the entity mapped by this persister. 
            </summary>
      <param name="entityName">The entity name to be checked. </param>
      <returns> 
            True if the given entity name represents either the entity mapped by this persister or one of its subclass entities; 
            false otherwise.
            </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyType(System.String)">
      <summary>
            Get the type of a particular property
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.FindDirty(System.Object[],System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> Locate the property-indices of all properties considered to be dirty. </summary>
      <param name="currentState">The current state of the entity (the state to be checked). </param>
      <param name="previousState">The previous state of the entity (the state to be checked against). </param>
      <param name="entity">The entity for which we are checking state dirtiness. </param>
      <param name="session">The session in which the check is ccurring. </param>
      <returns>
        <see langword="null" /> or the indices of the dirty properties </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.FindModified(System.Object[],System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> Locate the property-indices of all properties considered to be dirty. </summary>
      <param name="old">The old state of the entity.</param>
      <param name="current">The current state of the entity. </param>
      <param name="entity">The entity for which we are checking state modification. </param>
      <param name="session">The session in which the check is ccurring. </param>
      <returns>return <see langword="null" /> or the indicies of the modified properties</returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetNaturalIdentifierSnapshot(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Retrieve the current state of the natural-id properties from the database. 
            </summary>
      <param name="id">
            The identifier of the entity for which to retrieve the naturak-id values.
            </param>
      <param name="session">
            The session from which the request originated.
            </param>
      <returns> The natural-id snapshot. </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.Load(System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Load an instance of the persistent class.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.Lock(System.Object,System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Do a version check (optional operation)
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.Insert(System.Object,System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Persist an instance
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.Insert(System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Persist an instance, using a natively generated identifier (optional operation)
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.Delete(System.Object,System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Delete a persistent instance
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.Update(System.Object,System.Object[],System.Int32[],System.Boolean,System.Object[],System.Object,System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Update a persistent instance
            </summary>
      <param name="id">The id.</param>
      <param name="fields">The fields.</param>
      <param name="dirtyFields">The dirty fields.</param>
      <param name="hasDirtyCollection">if set to <see langword="true" /> [has dirty collection].</param>
      <param name="oldFields">The old fields.</param>
      <param name="oldVersion">The old version.</param>
      <param name="obj">The obj.</param>
      <param name="rowId">The rowId</param>
      <param name="session">The session.</param>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetDatabaseSnapshot(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Get the current database state of the object, in a "hydrated" form, without resolving identifiers
            </summary>
      <param name="id">
      </param>
      <param name="session">
      </param>
      <returns>
        <see langword="null" /> if select-before-update is not enabled or not supported</returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetCurrentVersion(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Get the current version of the object, or return null if there is no row for
            the given identifier. In the case of unversioned data, return any object
            if the row exists.
            </summary>
      <param name="id">
      </param>
      <param name="session">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GuessEntityMode(System.Object)">
      <summary> Try to discover the entity mode from the entity instance</summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsInstrumented(NHibernate.EntityMode)">
      <summary> Has the class actually been bytecode instrumented?</summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.AfterInitialize(System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
      <summary> Called just after the entities properties have been initialized</summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.AfterReassociate(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> Called just after the entity has been reassociated with the session</summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.CreateProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Create a new proxy instance
            </summary>
      <param name="id">
      </param>
      <param name="session">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsTransient(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> Is this a new transient instance?</summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyValuesToInsert(System.Object,System.Collections.IDictionary,NHibernate.Engine.ISessionImplementor)">
      <summary> Return the values of the insertable properties of the object (including backrefs)</summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.ProcessInsertGeneratedProperties(System.Object,System.Object,System.Object[],NHibernate.Engine.ISessionImplementor)">
      <summary>
            Perform a select to retrieve the values of any generated properties
            back from the database, injecting these generated values into the
            given entity as well as writing this state to the persistence context.
            </summary>
      <remarks>
            Note, that because we update the persistence context here, callers
            need to take care that they have already written the initial snapshot
            to the persistence context before calling this method. 
            </remarks>
      <param name="id">The entity's id value.</param>
      <param name="entity">The entity for which to get the state.</param>
      <param name="state">The entity state (at the time of Save).</param>
      <param name="session">The session.</param>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.ProcessUpdateGeneratedProperties(System.Object,System.Object,System.Object[],NHibernate.Engine.ISessionImplementor)">
      <summary>
            Perform a select to retrieve the values of any generated properties
            back from the database, injecting these generated values into the
            given entity as well as writing this state to the persistence context.
            </summary>
      <remarks>
            Note, that because we update the persistence context here, callers
            need to take care that they have already written the initial snapshot
            to the persistence context before calling this method. 
            </remarks>
      <param name="id">The entity's id value.</param>
      <param name="entity">The entity for which to get the state.</param>
      <param name="state">The entity state (at the time of Save).</param>
      <param name="session">The session.</param>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetMappedClass(NHibernate.EntityMode)">
      <summary>
            The persistent class, or null
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.ImplementsLifecycle(NHibernate.EntityMode)">
      <summary>
            Does the class implement the <c>ILifecycle</c> inteface?
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.ImplementsValidatable(NHibernate.EntityMode)">
      <summary>
            Does the class implement the <c>IValidatable</c> interface?
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetConcreteProxyClass(NHibernate.EntityMode)">
      <summary>
            Get the proxy interface that instances of <c>this</c> concrete class will be cast to
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.SetPropertyValues(System.Object,System.Object[],NHibernate.EntityMode)">
      <summary>
            Set the given values to the mapped properties of the given object
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.SetPropertyValue(System.Object,System.Int32,System.Object,NHibernate.EntityMode)">
      <summary>
            Set the value of a particular property
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyValues(System.Object,NHibernate.EntityMode)">
      <summary>
            Return the values of the mapped properties of the object
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyValue(System.Object,System.Int32,NHibernate.EntityMode)">
      <summary>
            Get the value of a particular property
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetPropertyValue(System.Object,System.String,NHibernate.EntityMode)">
      <summary>
            Get the value of a particular property
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetIdentifier(System.Object,NHibernate.EntityMode)">
      <summary>
            Get the identifier of an instance ( throw an exception if no identifier property)
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.SetIdentifier(System.Object,System.Object,NHibernate.EntityMode)">
      <summary>
            Set the identifier of an instance (or do nothing if no identifier property)
            </summary>
      <param name="obj">The object to set the Id property on.</param>
      <param name="id">The value to set the Id property to.</param>
      <param name="entityMode">The EntityMode</param>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetVersion(System.Object,NHibernate.EntityMode)">
      <summary>
            Get the version number (or timestamp) from the object's version property (or return null if not versioned)
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.Instantiate(System.Object,NHibernate.EntityMode)">
      <summary>
            Create a class instance initialized with the given identifier
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsInstance(System.Object,NHibernate.EntityMode)">
      <summary>
            Determines whether the specified entity is an instance of the class
            managed by this persister.
            </summary>
      <param name="entity">The entity.</param>
      <param name="entityMode">The EntityMode</param>
      <returns>
        <see langword="true" /> if the specified entity is an instance; otherwise, <see langword="false" />.
            </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.HasUninitializedLazyProperties(System.Object,NHibernate.EntityMode)">
      <summary> Does the given instance have any uninitialized lazy properties?</summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.ResetIdentifier(System.Object,System.Object,System.Object,NHibernate.EntityMode)">
      <summary> 
            Set the identifier and version of the given instance back
            to its "unsaved" value, returning the id
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.GetSubclassEntityPersister(System.Object,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.EntityMode)">
      <summary> Get the persister for an instance of this class or a subclass</summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IEntityPersister.IsUnsavedVersion(System.Object)">
      <summary>
            Check the version value trough <see cref="T:NHibernate.Engine.VersionValue" />.
            </summary>
      <param name="version">The snapshot entity state</param>
      <returns>The result of <see cref="M:NHibernate.Engine.VersionValue.IsUnsaved(System.Object)" />.</returns>
      <remarks>NHibernate-specific feature, not present in H3.2</remarks>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.Factory">
      <summary>
            The ISessionFactory to which this persister "belongs".
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.RootEntityName">
      <summary> 
            Returns an object that identifies the space in which identifiers of
            this entity hierarchy are unique.
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.EntityName">
      <summary>
            The entity name which this persister maps.
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.EntityMetamodel">
      <summary> 
            Retrieve the underlying entity metamodel instance... 
            </summary>
      <returns> The metamodel </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertySpaces">
      <summary>
            Returns an array of objects that identify spaces in which properties of
            this entity are persisted, for instances of this class only.
            </summary>
      <returns>The property spaces.</returns>
      <remarks>
            For most implementations, this returns the complete set of table names
            to which instances of the mapped entity are persisted (not accounting
            for superclass entity mappings).
            </remarks>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.QuerySpaces">
      <summary>
            Returns an array of objects that identify spaces in which properties of
            this entity are persisted, for instances of this class and its subclasses.
            </summary>
      <remarks>
            Much like <see cref="P:NHibernate.Persister.Entity.IEntityPersister.PropertySpaces" />, except that here we include subclass
            entity spaces.
            </remarks>
      <returns> The query spaces. </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsMutable">
      <summary>
            Are instances of this class mutable?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsInherited">
      <summary> 
            Determine whether the entity is inherited one or more other entities.
            In other words, is this entity a subclass of other entities. 
            </summary>
      <returns> True if other entities extend this entity; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsIdentifierAssignedByInsert">
      <summary>
            Is the identifier assigned before the insert by an <c>IDGenerator</c> or is it returned
            by the <c>Insert()</c> method?
            </summary>
      <remarks>
            This determines which form of <c>Insert()</c> will be called.
            </remarks>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsVersioned">
      <summary>
            Are instances of this class versioned by a timestamp or version number column?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.VersionType">
      <summary>
            Get the type of versioning (optional operation)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.VersionProperty">
      <summary>
            Which property holds the version number? (optional operation)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.NaturalIdentifierProperties">
      <summary> 
            If the entity defines a natural id (<see cref="P:NHibernate.Persister.Entity.IEntityPersister.HasNaturalIdentifier" />), which
            properties make up the natural id. 
            </summary>
      <returns> 
            The indices of the properties making of the natural id; or
            null, if no natural id is defined.
            </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.IdentifierGenerator">
      <summary>
            Return the <c>IIdentifierGenerator</c> for the class
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyTypes">
      <summary>
            Get the Hibernate types of the class properties
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyNames">
      <summary>
            Get the names of the class properties - doesn't have to be the names of the actual
            .NET properties (used for XML generation only)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyInsertability">
      <summary>
            Gets if the Property is insertable.
            </summary>
      <value>
        <see langword="true" /> if the Property's value can be inserted.</value>
      <remarks>
            This is for formula columns and if the user sets the insert attribute on the &lt;property&gt; element.
            </remarks>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyInsertGenerationInclusions">
      <summary> Which of the properties of this class are database generated values on insert?</summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyUpdateGenerationInclusions">
      <summary> Which of the properties of this class are database generated values on update?</summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyCheckability">
      <summary>
            Properties that may be dirty (and thus should be dirty-checked). These
            include all updatable properties and some associations.
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyNullability">
      <summary>
            Get the nullability of the properties of this class
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyVersionability">
      <summary>
            Get the "versionability" of the properties of this class (is the property optimistic-locked)
            </summary>
      <value>
        <see langword="true" /> if the property is optimistic-locked; otherwise, <see langword="false" />.</value>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyCascadeStyles">
      <summary>
            Get the cascade styles of the properties (optional operation)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.IdentifierType">
      <summary>
            Get the identifier type
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.IdentifierPropertyName">
      <summary>
            Get the name of the indentifier property (or return null) - need not return the
            name of an actual .NET property
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsCacheInvalidationRequired">
      <summary>
            Should we always invalidate the cache instead of recaching updated state
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsLazyPropertiesCacheable">
      <summary>
            Should lazy properties of this entity be cached?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.Cache">
      <summary>
            Get the cache (optional operation)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.CacheEntryStructure">
      <summary> Get the cache structure</summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.ClassMetadata">
      <summary>
            Get the user-visible metadata for the class (optional operation)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsBatchLoadable">
      <summary>
            Is batch loading enabled?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsSelectBeforeUpdateRequired">
      <summary> Is select snapshot before update enabled?</summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.IsVersionPropertyGenerated">
      <summary>
            Does this entity contain a version property that is defined
            to be database generated?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasProxy">
      <summary>
            Does this class support dynamic proxies?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasCollections">
      <summary>
            Do instances of this class contain collections?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasMutableProperties">
      <summary> 
            Determine whether any properties of this entity are considered mutable. 
            </summary>
      <returns> 
            True if any properties of the entity are mutable; false otherwise (meaning none are).
            </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasSubselectLoadableCollections">
      <summary> 
            Determine whether this entity contains references to persistent collections
            which are fetchable by subselect? 
            </summary>
      <returns> 
            True if the entity contains collections fetchable by subselect; false otherwise.
            </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasCascades">
      <summary>
            Does this class declare any cascading save/update/deletes?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasIdentifierProperty">
      <summary>
            Does the class have a property holding the identifier value?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.CanExtractIdOutOfEntity">
      <summary> 
            Determine whether detahced instances of this entity carry their own
            identifier value.
            </summary>
      <returns> 
            True if either (1) <see cref="P:NHibernate.Persister.Entity.IEntityPersister.HasIdentifierProperty" /> or
            (2) the identifier is an embedded composite identifier; false otherwise.
            </returns>
      <remarks>
            The other option is the deprecated feature where users could supply
            the id during session calls.
            </remarks>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasNaturalIdentifier">
      <summary> 
            Determine whether this entity defines a natural identifier. 
            </summary>
      <returns> True if the entity defines a natural id; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasLazyProperties">
      <summary> 
            Determine whether this entity defines any lazy properties (ala
            bytecode instrumentation). 
            </summary>
      <returns> 
            True if the entity has properties mapped as lazy; false otherwise.
            </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.PropertyUpdateability">
      <summary>
            Gets if the Property is updatable
            </summary>
      <value>
        <see langword="true" /> if the Property's value can be updated.</value>
      <remarks>
            This is for formula columns and if the user sets the update attribute on the &lt;property&gt; element.
            </remarks>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasCache">
      <summary>
            Does this class have a cache?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasInsertGeneratedProperties">
      <summary>
            Does this entity define any properties as being database-generated on insert?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IEntityPersister.HasUpdateGeneratedProperties">
      <summary>
            Does this entity define any properties as being database-generated on update?
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.ILoadable">
      <summary>
            Implemented by <c>ClassPersister</c> that uses <c>Loader</c>. There are several optional
            operations used only by loaders that inherit <c>OuterJoinLoader</c></summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.ILoadable.GetSubclassForDiscriminatorValue(System.Object)">
      <summary>
            Get the concrete subclass corresponding to the given discriminator value
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.ILoadable.GetIdentifierAliases(System.String)">
      <summary>
            Get the result set aliases used for the identifier columns, given a suffix
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.ILoadable.GetPropertyAliases(System.String,System.Int32)">
      <summary>
            Get the result set aliases used for the property columns, given a suffix (properties of this class, only).
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.ILoadable.GetPropertyColumnNames(System.Int32)">
      <summary>
            Get the result set column names mapped for this property (properties of this class, only).
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.ILoadable.GetDiscriminatorAlias(System.String)">
      <summary>
            Get the alias used for the discriminator column, given a suffix
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.ILoadable.Hydrate(System.Data.IDataReader,System.Object,System.Object,NHibernate.Persister.Entity.ILoadable,System.String[][],System.Boolean,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Retrieve property values from one row of a result set
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.ILoadable.DiscriminatorType">
      <summary>
            The discriminator type
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.ILoadable.IdentifierColumnNames">
      <summary>
            Get the names of columns used to persist the identifier
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.ILoadable.DiscriminatorColumnName">
      <summary>
            Get the name of the column used as a discriminator
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.ILoadable.HasSubclasses">
      <summary>
            Does the persistent class have subclasses?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.ILoadable.HasRowId">
      <summary> Does the result set contain rowids?</summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.IOuterJoinLoadable">
      <summary>
            A <c>ClassPersister</c> that may be loaded by outer join using
            the <c>OuterJoinLoader</c> hierarchy and may be an element
            of a one-to-many association.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.SelectFragment(System.String,System.String)">
      <summary>
            Generate a list of collection index and element columns
            </summary>
      <param name="alias">
      </param>
      <param name="suffix">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.CountSubclassProperties">
      <summary>
            How many properties are there, for this class and all subclasses? (optional operation)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetFetchMode(System.Int32)">
      <summary>
            May this property be fetched using an SQL outerjoin?
            </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetCascadeStyle(System.Int32)">
      <summary>
            Get the cascade style of this (subclass closure) property
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.IsDefinedOnSubclass(System.Int32)">
      <summary>
            Is this property defined on a subclass of the mapped class?
            </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetSubclassPropertyType(System.Int32)">
      <summary>
            Get an array of the types of all properties of all subclasses (optional operation)
            </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetSubclassPropertyName(System.Int32)">
      <summary>
            Get the name of the numbered property of the class or a subclass
            (optional operation)
            </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.IsSubclassPropertyNullable(System.Int32)">
      <summary>
            Is the numbered property of the class of subclass nullable?
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetSubclassPropertyColumnNames(System.Int32)">
      <summary>
            Return the column names used to persist all properties of all sublasses of the persistent class
            (optional operation)
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetSubclassPropertyTableName(System.Int32)">
      <summary>
            Return the table name used to persist the numbered property of 
            the class or a subclass
            (optional operation)
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.ToColumns(System.String,System.Int32)">
      <summary>
            Given the number of a property of a subclass, and a table alias, return the aliased column names
            (optional operation)
            </summary>
      <param name="name">
      </param>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.FromTableFragment(System.String)">
      <summary>
            Get the main from table fragment, given a query alias (optional operation)
            </summary>
      <param name="alias">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetPropertyColumnNames(System.String)">
      <summary>
            Get the column names for the given property path
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IOuterJoinLoadable.GetPropertyTableName(System.String)">
      <summary>
            Get the table name for the given property path
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.IQueryable">
      <summary>
            Extends the generic <c>ILoadable</c> contract to add operations required by HQL
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IQueryable.IdentifierSelectFragment(System.String,System.String)">
      <summary>
            Given a query alias and an identifying suffix, render the intentifier select fragment.
            </summary>
      <param name="name">
      </param>
      <param name="suffix">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IQueryable.PropertySelectFragment(System.String,System.String,System.Boolean)">
      <summary>
            Given a query alias and an identifying suffix, render the property select fragment.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IQueryable.GetSubclassPropertyTableNumber(System.String)">
      <summary> 
            Given a property name, determine the number of the table which contains the column
            to which this property is mapped.
            </summary>
      <param name="propertyPath">The name of the property. </param>
      <returns> The number of the table to which the property is mapped. </returns>
      <remarks>
            Note that this is <b>not</b> relative to the results from {@link #getConstraintOrderedTableNameClosure()}.
            It is relative to the subclass table name closure maintained internal to the persister (yick!).
            It is also relative to the indexing used to resolve {@link #getSubclassTableName}...
            </remarks>
    </member>
    <member name="M:NHibernate.Persister.Entity.IQueryable.GetSubclassPropertyDeclarer(System.String)">
      <summary> Determine whether the given property is declared by our
            mapped class, our super class, or one of our subclasses...
            <p />
            Note: the method is called 'subclass property...' simply
            for consistency sake (e.g. {@link #getSubclassPropertyTableNumber}
             </summary>
      <param name="propertyPath">The property name. </param>
      <returns> The property declarer </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IQueryable.GetSubclassTableName(System.Int32)">
      <summary> 
            Get the name of the table with the given index from the internal array. 
            </summary>
      <param name="number">The index into the internal array. </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Persister.Entity.IQueryable.GenerateFilterConditionAlias(System.String)">
      <summary> 
            The alias used for any filter conditions (mapped where-fragments or
            enabled-filters).
            </summary>
      <param name="rootAlias">The root alias </param>
      <returns> The alias used for "filter conditions" within the where clause. </returns>
      <remarks>
            This may or may not be different from the root alias depending upon the
            inheritance mapping strategy. 
            </remarks>
    </member>
    <member name="P:NHibernate.Persister.Entity.IQueryable.IsExplicitPolymorphism">
      <summary>
            Is this class explicit polymorphism only?
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IQueryable.MappedSuperclass">
      <summary>
            The class that this class is mapped as a subclass of - not necessarily the direct superclass
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IQueryable.DiscriminatorSQLValue">
      <summary>
            The discriminator value for this particular concrete subclass, as a string that may be
            embedded in a select statement
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.IQueryable.DiscriminatorValue">
      <summary>
            The discriminator value for this particular concrete subclass
            </summary>
      <remarks>The DiscriminatorValue is specific of NH since we are using strongly typed parameters for SQL query.</remarks>
    </member>
    <member name="P:NHibernate.Persister.Entity.IQueryable.IsMultiTable">
      <summary> 
            Is the inheritance hierarchy described by this persister contained across
            multiple tables? 
            </summary>
      <returns> True if the inheritance hierarchy is spread across multiple tables; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IQueryable.ConstraintOrderedTableNameClosure">
      <summary> 
            Get the names of all tables used in the hierarchy (up and down) ordered such
            that deletes in the given order would not cause constraint violations. 
            </summary>
      <returns> The ordered array of table names. </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IQueryable.ContraintOrderedTableKeyColumnClosure">
      <summary> 
            For each table specified in <see cref="P:NHibernate.Persister.Entity.IQueryable.ConstraintOrderedTableNameClosure" />, get
            the columns that define the key between the various hierarchy classes.
            </summary>
      <returns>
            The first dimension here corresponds to the table indexes returned in
            <see cref="P:NHibernate.Persister.Entity.IQueryable.ConstraintOrderedTableNameClosure" />.
            <para />
            The second dimension should have the same length across all the elements in
            the first dimension.  If not, that'd be a problem ;) 
            </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IQueryable.TemporaryIdTableName">
      <summary> 
            Get the name of the temporary table to be used to (potentially) store id values
            when performing bulk update/deletes. 
            </summary>
      <returns> The appropriate temporary table name. </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IQueryable.TemporaryIdTableDDL">
      <summary> 
            Get the appropriate DDL command for generating the temporary table to
            be used to (potentially) store id values when performing bulk update/deletes. 
            </summary>
      <returns> The appropriate temporary table creation command. </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.IQueryable.VersionPropertyInsertable">
      <summary> Is the version property included in insert statements?</summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.IUniqueKeyLoadable">
      <summary>
            Describes a class that may be loaded via a unique key.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IUniqueKeyLoadable.LoadByUniqueKey(System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Load an instance of the persistent class, by a unique key other than the primary key.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.IUniqueKeyLoadable.GetPropertyIndex(System.String)">
      <summary>
            Get the property number of the unique key property
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.ISqlLoadable">
      <summary>
            A class persister that supports queries expressed in the platform native SQL dialect.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.ISqlLoadable.GetSubclassPropertyColumnAliases(System.String,System.String)">
      <summary>
            Returns the column alias names used to persist/query the numbered property of the class or a subclass (optional operation).
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.ISqlLoadable.GetSubclassPropertyColumnNames(System.String)">
      <summary> 
            Return the column names used to persist/query the named property of the class or a subclass (optional operation).
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.ISqlLoadable.SelectFragment(System.String,System.String)">
      <summary>
            All columns to select, when loading.
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.ISqlLoadable.Type">
      <summary>
            Get the type
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.ILockable">
      <summary> 
            Contract for things that can be locked via a <see cref="T:NHibernate.Dialect.Lock.ILockingStrategy" />.
            </summary>
      <remarks>
            Currently only the root table gets locked, except for the case of HQL and Criteria queries
            against dialects which do not support either (1) FOR UPDATE OF or (2) support hint locking
            (in which case *all* queried tables would be locked).
            </remarks>
    </member>
    <member name="M:NHibernate.Persister.Entity.ILockable.GetRootTableAlias(System.String)">
      <summary> 
            Get the SQL alias this persister would use for the root table
            given the passed driving alias. 
            </summary>
      <param name="drivingAlias">
            The driving alias; or the alias for the table mapped by this persister in the hierarchy.
            </param>
      <returns> The root table alias. </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.ILockable.RootTableName">
      <summary> 
            Locks are always applied to the "root table".
             </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.ILockable.RootTableIdentifierColumnNames">
      <summary> 
            Get the names of columns on the root table used to persist the identifier. 
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.ILockable.VersionColumnName">
      <summary> 
            For versioned entities, get the name of the column (again, expected on the
            root table) used to store the version values. 
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.ILockable.IdAndVersionSqlTypes">
      <summary>
            To build the SQL command in pessimistic lock
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.AbstractEntityPersister">
      <summary>
            Superclass for built-in mapping strategies. Implements functionalty common to both mapping
            strategies
            </summary>
      <remarks>
            May be considered an immutable view of the mapping object
            </remarks>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetTableUpdateNeeded(System.Int32[],System.Boolean)">
      <summary>
            Decide which tables need to be updated
            </summary>
      <param name="dirtyProperties">The indices of all the entity properties considered dirty.</param>
      <param name="hasDirtyCollection">Whether any collections owned by the entity which were considered dirty. </param>
      <returns> Array of booleans indicating which table require updating. </returns>
      <remarks>
            The return here is an array of boolean values with each index corresponding
            to a given table in the scope of this persister.
            </remarks>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GenerateSelectVersionString">
      <summary>
            Generate the SQL that selects the version number by id
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetCurrentVersion(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Retrieve the version number
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetSubclassPropertyTableNumber(System.String)">
      <remarks>
            Warning:
            When there are duplicated property names in the subclasses
            of the class, this method may return the wrong table
            number for the duplicated subclass property (note that
            SingleTableEntityPersister defines an overloaded form
            which takes the entity name.
            </remarks>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetPropertyColumnNames(System.Int32)">
      <summary>
            Get the column names for the numbered property of <em>this</em> class
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.InitSubclassPropertyAliasesMap(NHibernate.Mapping.PersistentClass)">
      <summary>
            Must be called by subclasses, at the end of their constructors
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GenerateUpdateString(System.Boolean[],System.Int32,System.Object[],System.Boolean)">
      <summary> Generate the SQL that updates a row by id (and version)</summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GenerateInsertString(System.Boolean,System.Boolean[],System.Int32)">
      <summary> Generate the SQL that inserts a row</summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Dehydrate(System.Object,System.Object[],System.Object,System.Boolean[],System.Boolean[][],System.Int32,System.Data.IDbCommand,NHibernate.Engine.ISessionImplementor,System.Int32)">
      <summary> Marshall the fields of a persistent instance to a prepared statement</summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Hydrate(System.Data.IDataReader,System.Object,System.Object,NHibernate.Persister.Entity.ILoadable,System.String[][],System.Boolean,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Unmarshall the fields of a persistent instance from a result set,
            without resolving associations or collections
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Insert(System.Object[],System.Boolean[],NHibernate.SqlCommand.SqlCommandInfo,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Perform an SQL INSERT, and then retrieve a generated identifier.
            </summary>
      <remarks>
            This form is used for PostInsertIdentifierGenerator-style ids (IDENTITY, select, etc).
            </remarks>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Insert(System.Object,System.Object[],System.Boolean[],System.Int32,NHibernate.SqlCommand.SqlCommandInfo,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Perform an SQL INSERT.
            </summary>
      <remarks>
            This for is used for all non-root tables as well as the root table
            in cases where the identifier value is known before the insert occurs.
            </remarks>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.UpdateOrInsert(System.Object,System.Object[],System.Object[],System.Object,System.Boolean[],System.Int32,System.Object,System.Object,NHibernate.SqlCommand.SqlCommandInfo,NHibernate.Engine.ISessionImplementor)">
      <summary> Perform an SQL UPDATE or SQL INSERT</summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Delete(System.Object,System.Object,System.Int32,System.Object,NHibernate.SqlCommand.SqlCommandInfo,NHibernate.Engine.ISessionImplementor,System.Object[])">
      <summary>
            Perform an SQL DELETE
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.Load(System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Load an instance using the appropriate loader (as determined by <see cref="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetAppropriateLoader(NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)" /></summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetPropertiesToUpdate(System.Int32[],System.Boolean)">
      <summary> 
            Transform the array of property indexes to an array of booleans, true when the property is dirty
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.GetPropertyUpdateability(System.Object,NHibernate.EntityMode)">
      <summary> Which properties appear in the SQL update? (Initialized, updateable ones!) </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.AbstractEntityPersister.IsInstance(System.Object,NHibernate.EntityMode)">
      <summary>
            Determines whether the specified entity is an instance of the class
            managed by this persister.
            </summary>
      <param name="entity">The entity.</param>
      <param name="entityMode">The entity mode.</param>
      <returns>
        <see langword="true" /> if the specified entity is an instance; otherwise, <see langword="false" />.
            </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.SqlDeleteStrings">
      <summary>
            The queries that delete rows by id (and version)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.SqlInsertStrings">
      <summary>
            The queries that insert rows with a given id
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.SqlUpdateStrings">
      <summary>
            The queries that update rows by id (and version)
            </summary>
    </member>
    <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.SQLIdentityInsertString">
      <summary> 
            The query that inserts a row, letting the database generate an id 
            </summary>
      <returns> The IDENTITY-based insertion query. </returns>
    </member>
    <member name="P:NHibernate.Persister.Entity.AbstractEntityPersister.IsCacheInvalidationRequired">
      <summary> 
            We can't immediately add to the cache if we have formulas
            which must be evaluated, or if we have the possibility of
            two concurrent updates to the same item being merged on
            the database. This can happen if (a) the item is not
            versioned and either (b) we have dynamic update enabled
            or (c) we have multiple tables holding the state of the
            item.
            </summary>
    </member>
    <member name="F:NHibernate.Persister.Entity.EntityPersister.EntityID">
      <summary> The property name of the "special" identifier property in HQL</summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.JoinedSubclassEntityPersister">
      <summary>
            A <c>IEntityPersister</c> implementing the normalized "table-per-subclass" mapping strategy
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.JoinedSubclassEntityPersister.#ctor(NHibernate.Mapping.PersistentClass,NHibernate.Cache.ICacheConcurrencyStrategy,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.Engine.IMapping)">
      <summary>
            Constructs the NormalizedEntityPerister for the PersistentClass.
            </summary>
      <param name="persistentClass">The PersistentClass to create the EntityPersister for.</param>
      <param name="cache">The configured <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy" />.</param>
      <param name="factory">The SessionFactory that this EntityPersister will be stored in.</param>
      <param name="mapping">The mapping used to retrieve type information.</param>
    </member>
    <member name="M:NHibernate.Persister.Entity.JoinedSubclassEntityPersister.GetTableId(System.String,System.String[])">
      <summary>
            Find the Index of the table name from a list of table names.
            </summary>
      <param name="tableName">The name of the table to find.</param>
      <param name="tables">The array of table names</param>
      <returns>The Index of the table in the array.</returns>
      <exception cref="T:NHibernate.AssertionFailure">Thrown when the tableName specified can't be found</exception>
    </member>
    <member name="T:NHibernate.Persister.Entity.NamedQueryLoader">
      <summary> 
            Not really a <tt>Loader</tt>, just a wrapper around a named query.
            </summary>
    </member>
    <member name="T:NHibernate.Persister.Entity.SingleTableEntityPersister">
      <summary>
            Default implementation of the <c>ClassPersister</c> interface. Implements the
            "table-per-class hierarchy" mapping strategy for an entity class.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.Entity.UnionSubclassEntityPersister.GenerateSelectString(NHibernate.LockMode)">
      <summary> Generate the SQL that selects a row by id</summary>
    </member>
    <member name="T:NHibernate.Persister.PersisterFactory">
      <summary>
            Factory for <c>IEntityPersister</c> and <c>ICollectionPersister</c> instances.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.PersisterFactory.CreateClassPersister(NHibernate.Mapping.PersistentClass,NHibernate.Cache.ICacheConcurrencyStrategy,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.Engine.IMapping)">
      <summary>
            Creates a built in Entity Persister or a custom Persister.
            </summary>
    </member>
    <member name="M:NHibernate.Persister.PersisterFactory.Create(System.Type,NHibernate.Mapping.PersistentClass,NHibernate.Cache.ICacheConcurrencyStrategy,NHibernate.Engine.ISessionFactoryImplementor,NHibernate.Engine.IMapping)">
      <summary>
            Creates a specific Persister - could be a built in or custom persister.
            </summary>
    </member>
    <member name="T:NHibernate.Properties.IFieldNamingStrategy">
      <summary>
            A Strategy for converting a mapped property name to a Field name.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.IFieldNamingStrategy.GetFieldName(System.String)">
      <summary>
            When implemented by a class, converts the Property's name into a Field name
            </summary>
      <param name="propertyName">The name of the mapped property.</param>
      <returns>The name of the Field.</returns>
    </member>
    <member name="T:NHibernate.Properties.IPropertyAccessor">
      <summary>
            Abstracts the notion of a "property". Defines a strategy for accessing the
            value of a mapped property.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.IPropertyAccessor.GetGetter(System.Type,System.String)">
      <summary>
            When implemented by a class, create a "getter" for the mapped property.
            </summary>
      <param name="theClass">The <see cref="T:System.Type" /> to find the Property in.</param>
      <param name="propertyName">The name of the mapped Property to get.</param>
      <returns>
            The <see cref="T:NHibernate.Properties.IGetter" /> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type" />.</returns>
      <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type" />.
            </exception>
    </member>
    <member name="M:NHibernate.Properties.IPropertyAccessor.GetSetter(System.Type,System.String)">
      <summary>
            When implemented by a class, create a "setter" for the mapped property.
            </summary>
      <param name="theClass">The <see cref="T:System.Type" /> to find the Property in.</param>
      <param name="propertyName">The name of the mapped Property to set.</param>
      <returns>
            The <see cref="T:NHibernate.Properties.ISetter" /> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type" />.
            </returns>
      <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type" />.
            </exception>
    </member>
    <member name="P:NHibernate.Properties.IPropertyAccessor.CanAccessThroughReflectionOptimizer">
      <summary>
            Allow embedded and custom accessors to define if the ReflectionOptimizer can be used.
            </summary>
    </member>
    <member name="T:NHibernate.Properties.BackrefPropertyAccessor">
      <summary> Represents a "back-reference" to the id of a collection owner. </summary>
    </member>
    <member name="T:NHibernate.Properties.BackrefPropertyAccessor.BackrefSetter">
      <summary> The Setter implementation for id backrefs.</summary>
    </member>
    <member name="T:NHibernate.Properties.BackrefPropertyAccessor.BackrefGetter">
      <summary> The Getter implementation for id backrefs.</summary>
    </member>
    <member name="T:NHibernate.Properties.ISetter">
      <summary>
            Sets values of a particular mapped property.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.ISetter.Set(System.Object,System.Object)">
      <summary>
            When implemented by a class, sets the value of the Property/Field on the object.
            </summary>
      <param name="target">The object to set the Property value in.</param>
      <param name="value">The value to set the Property to.</param>
      <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem setting the value in the target.
            </exception>
    </member>
    <member name="P:NHibernate.Properties.ISetter.PropertyName">
      <summary>
            When implemented by a class, gets the name of the Property.
            </summary>
      <value>The name of the Property or <see langword="null" />.</value>
      <remarks>
            This is an optional operation - if it is not implemented then 
            <see langword="null" /> is an acceptable value to return.
            </remarks>
    </member>
    <member name="P:NHibernate.Properties.ISetter.Method">
      <summary>
            When implemented by a class, gets the <see cref="T:System.Reflection.MethodInfo" /> for the <c>set</c>
            accessor of the property.
            </summary>
      <remarks>
            This is an optional operation - if the <see cref="T:NHibernate.Properties.ISetter" /> is not 
            for a property <c>set</c> then <see langword="null" /> is an acceptable value to return.
            It is used by the proxies to determine which setter to intercept for the
            identifier property.
            </remarks>
    </member>
    <member name="T:NHibernate.Properties.IGetter">
      <summary>
            Gets values of a particular mapped property.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.IGetter.Get(System.Object)">
      <summary>
            When implemented by a class, gets the value of the Property/Field from the object.
            </summary>
      <param name="target">The object to get the Property/Field value from.</param>
      <returns>
            The value of the Property for the target.
            </returns>
      <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem getting the value from the target.
            </exception>
    </member>
    <member name="M:NHibernate.Properties.IGetter.GetForInsert(System.Object,System.Collections.IDictionary,NHibernate.Engine.ISessionImplementor)">
      <summary> Get the property value from the given owner instance. </summary>
      <param name="owner">The instance containing the value to be retrieved. </param>
      <param name="mergeMap">a map of merged persistent instances to detached instances </param>
      <param name="session">The session from which this request originated. </param>
      <returns> The extracted value. </returns>
    </member>
    <member name="P:NHibernate.Properties.IGetter.ReturnType">
      <summary>
            When implemented by a class, gets the <see cref="T:System.Type" /> that the Property/Field returns.
            </summary>
      <value>The <see cref="T:System.Type" /> that the Property returns.</value>
    </member>
    <member name="P:NHibernate.Properties.IGetter.PropertyName">
      <summary>
            When implemented by a class, gets the name of the Property.
            </summary>
      <value>The name of the Property or <see langword="null" />.</value>
      <remarks>
            This is an optional operation - if the <see cref="T:NHibernate.Properties.IGetter" /> is not 
            for a Property <c>get</c> then <see langword="null" /> is an acceptable value to return.
            </remarks>
    </member>
    <member name="P:NHibernate.Properties.IGetter.Method">
      <summary>
            When implemented by a class, gets the <see cref="T:System.Reflection.MethodInfo" /> for the <c>get</c>
            accessor of the property.
            </summary>
      <remarks>
            This is an optional operation - if the <see cref="T:NHibernate.Properties.IGetter" /> is not 
            for a property <c>get</c> then <see langword="null" /> is an acceptable value to return.
            It is used by the proxies to determine which getter to intercept for the
            identifier property.
            </remarks>
    </member>
    <member name="T:NHibernate.Properties.BasicPropertyAccessor">
      <summary>
            Accesses mapped property values via a get/set pair, which may be nonpublic.
            The default (and recommended strategy).
            </summary>
    </member>
    <member name="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter">
      <summary>
            An <see cref="T:NHibernate.Properties.IGetter" /> for a Property <c>get</c>.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.BasicPropertyAccessor.BasicGetter.#ctor(System.Type,System.Reflection.PropertyInfo,System.String)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter" />.
            </summary>
      <param name="clazz">The <see cref="T:System.Type" /> that contains the Property <c>get</c>.</param>
      <param name="property">The <see cref="T:System.Reflection.PropertyInfo" /> for reflection.</param>
      <param name="propertyName">The name of the Property.</param>
    </member>
    <member name="M:NHibernate.Properties.BasicPropertyAccessor.BasicGetter.Get(System.Object)">
      <summary>
            Gets the value of the Property from the object.
            </summary>
      <param name="target">The object to get the Property value from.</param>
      <returns>
            The value of the Property for the target.
            </returns>
    </member>
    <member name="P:NHibernate.Properties.BasicPropertyAccessor.BasicGetter.ReturnType">
      <summary>
            Gets the <see cref="T:System.Type" /> that the Property returns.
            </summary>
      <value>The <see cref="T:System.Type" /> that the Property returns.</value>
    </member>
    <member name="P:NHibernate.Properties.BasicPropertyAccessor.BasicGetter.PropertyName">
      <summary>
            Gets the name of the Property.
            </summary>
      <value>The name of the Property.</value>
    </member>
    <member name="P:NHibernate.Properties.BasicPropertyAccessor.BasicGetter.Method">
      <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo" /> for the Property.
            </summary>
      <value>
            The <see cref="T:System.Reflection.PropertyInfo" /> for the Property.
            </value>
    </member>
    <member name="T:NHibernate.Properties.BasicPropertyAccessor.BasicSetter">
      <summary>
            An <see cref="T:NHibernate.Properties.ISetter" /> for a Property <c>set</c>.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.BasicPropertyAccessor.BasicSetter.#ctor(System.Type,System.Reflection.PropertyInfo,System.String)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicSetter" />.
            </summary>
      <param name="clazz">The <see cref="T:System.Type" /> that contains the Property <c>set</c>.</param>
      <param name="property">The <see cref="T:System.Reflection.PropertyInfo" /> for reflection.</param>
      <param name="propertyName">The name of the mapped Property.</param>
    </member>
    <member name="M:NHibernate.Properties.BasicPropertyAccessor.BasicSetter.Set(System.Object,System.Object)">
      <summary>
            Sets the value of the Property on the object.
            </summary>
      <param name="target">The object to set the Property value in.</param>
      <param name="value">The value to set the Property to.</param>
      <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem setting the value in the target.
            </exception>
    </member>
    <member name="P:NHibernate.Properties.BasicPropertyAccessor.BasicSetter.PropertyName">
      <summary>
            Gets the name of the mapped Property.
            </summary>
      <value>The name of the mapped Property or <see langword="null" />.</value>
    </member>
    <member name="P:NHibernate.Properties.BasicPropertyAccessor.BasicSetter.Method">
      <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo" /> for the mapped Property.
            </summary>
      <value>The <see cref="T:System.Reflection.PropertyInfo" /> for the mapped Property.</value>
    </member>
    <member name="M:NHibernate.Properties.BasicPropertyAccessor.GetGetter(System.Type,System.String)">
      <summary>
            Create a <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter" /> for the mapped property.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to find the Property in.</param>
      <param name="propertyName">The name of the mapped Property to get.</param>
      <returns>
            The <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter" /> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type" />.</returns>
      <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type" />.
            </exception>
    </member>
    <member name="M:NHibernate.Properties.BasicPropertyAccessor.GetSetter(System.Type,System.String)">
      <summary>
            Create a <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicSetter" /> for the mapped property.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to find the Property in.</param>
      <param name="propertyName">The name of the mapped Property to get.</param>
      <returns>
            The <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicSetter" /> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type" />.
            </returns>
      <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type" />.
            </exception>
    </member>
    <member name="M:NHibernate.Properties.BasicPropertyAccessor.GetGetterOrNull(System.Type,System.String)">
      <summary>
            Helper method to find the Property <c>get</c>.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to find the Property in.</param>
      <param name="propertyName">The name of the mapped Property to get.</param>
      <returns>
            The <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter" /> for the Property <c>get</c> or <see langword="null" />
            if the Property could not be found.
            </returns>
    </member>
    <member name="M:NHibernate.Properties.BasicPropertyAccessor.GetSetterOrNull(System.Type,System.String)">
      <summary>
            Helper method to find the Property <c>set</c>.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to find the Property in.</param>
      <param name="propertyName">The name of the mapped Property to set.</param>
      <returns>
            The <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicSetter" /> for the Property <c>set</c> or <see langword="null" />
            if the Property could not be found.
            </returns>
    </member>
    <member name="T:NHibernate.Properties.IOptimizableGetter">
      <summary>
            An <see cref="T:NHibernate.Properties.IGetter" /> that can emit IL to get the property value.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.IOptimizableGetter.Emit(System.Reflection.Emit.ILGenerator)">
      <summary>
            Emit IL to get the property value from the object on top of the stack.
            </summary>
    </member>
    <member name="T:NHibernate.Properties.IOptimizableSetter">
      <summary>
            An <see cref="T:NHibernate.Properties.ISetter" /> that can emit IL to set the property value.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.IOptimizableSetter.Emit(System.Reflection.Emit.ILGenerator)">
      <summary>
            Emit IL to set the property of an object to the value. The object
            is loaded onto the stack first, then the value, then this method
            is called.
            </summary>
    </member>
    <member name="T:NHibernate.Properties.CamelCaseStrategy">
      <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> for fields that are the 
            camelCase version of the PropertyName
            </summary>
    </member>
    <member name="M:NHibernate.Properties.CamelCaseStrategy.GetFieldName(System.String)">
      <summary>
            Converts the Property's name into a Field name by making the first character
            lower case.
            </summary>
      <param name="propertyName">The name of the mapped property.</param>
      <returns>The name of the Field in CamelCase format.</returns>
    </member>
    <member name="T:NHibernate.Properties.CamelCaseUnderscoreStrategy">
      <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> for fields that are prefixed with
            an underscore and the PropertyName is changed to camelCase.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.CamelCaseUnderscoreStrategy.GetFieldName(System.String)">
      <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> lowercase and prefixing it with an underscore.
            </summary>
      <param name="propertyName">The name of the mapped property.</param>
      <returns>The name of the Field in CamelCase format prefixed with an underscore.</returns>
    </member>
    <member name="T:NHibernate.Properties.FieldAccessor">
      <summary>
            Access the mapped property by using a Field to <c>get</c> and <c>set</c> the value.
            </summary>
      <remarks>
            The <see cref="T:NHibernate.Properties.FieldAccessor" /> is useful when you expose <c>getter</c> and <c>setters</c>
            for a Property, but they have extra code in them that shouldn't be executed when NHibernate
            is setting or getting the values for loads or saves.
            </remarks>
    </member>
    <member name="T:NHibernate.Properties.FieldAccessor.FieldGetter">
      <summary>
            An <see cref="T:NHibernate.Properties.IGetter" /> that uses a Field instead of the Property <c>get</c>.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.FieldAccessor.FieldGetter.#ctor(System.Reflection.FieldInfo,System.Type,System.String)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.FieldAccessor.FieldGetter" />.
            </summary>
      <param name="clazz">The <see cref="T:System.Type" /> that contains the field to use for the Property <c>get</c>.</param>
      <param name="field">The <see cref="T:System.Reflection.FieldInfo" /> for reflection.</param>
      <param name="name">The name of the Field.</param>
    </member>
    <member name="M:NHibernate.Properties.FieldAccessor.FieldGetter.Get(System.Object)">
      <summary>
            Gets the value of the Field from the object.
            </summary>
      <param name="target">The object to get the Field value from.</param>
      <returns>
            The value of the Field for the target.
            </returns>
    </member>
    <member name="P:NHibernate.Properties.FieldAccessor.FieldGetter.ReturnType">
      <summary>
            Gets the <see cref="T:System.Type" /> that the Field returns.
            </summary>
      <value>The <see cref="T:System.Type" /> that the Field returns.</value>
    </member>
    <member name="P:NHibernate.Properties.FieldAccessor.FieldGetter.PropertyName">
      <summary>
            Gets the name of the Property.
            </summary>
      <value>
        <see langword="null" /> since this is a Field - not a Property.</value>
    </member>
    <member name="P:NHibernate.Properties.FieldAccessor.FieldGetter.Method">
      <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo" /> for the Property.
            </summary>
      <value>
        <see langword="null" /> since this is a Field - not a Property.</value>
    </member>
    <member name="T:NHibernate.Properties.FieldAccessor.FieldSetter">
      <summary>
            An <see cref="T:NHibernate.Properties.IGetter" /> that uses a Field instead of the Property <c>set</c>.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.FieldAccessor.FieldSetter.#ctor(System.Reflection.FieldInfo,System.Type,System.String)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.FieldAccessor.FieldSetter" />.
            </summary>
      <param name="clazz">The <see cref="T:System.Type" /> that contains the Field to use for the Property <c>set</c>.</param>
      <param name="field">The <see cref="T:System.Reflection.FieldInfo" /> for reflection.</param>
      <param name="name">The name of the Field.</param>
    </member>
    <member name="M:NHibernate.Properties.FieldAccessor.FieldSetter.Set(System.Object,System.Object)">
      <summary>
            Sets the value of the Field on the object.
            </summary>
      <param name="target">The object to set the Field value in.</param>
      <param name="value">The value to set the Field to.</param>
      <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem setting the value in the target.
            </exception>
    </member>
    <member name="P:NHibernate.Properties.FieldAccessor.FieldSetter.PropertyName">
      <summary>
            Gets the name of the Property.
            </summary>
      <value>
        <see langword="null" /> since this is a Field - not a Property.</value>
    </member>
    <member name="P:NHibernate.Properties.FieldAccessor.FieldSetter.Method">
      <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo" /> for the Property.
            </summary>
      <value>
        <see langword="null" /> since this is a Field - not a Property.</value>
    </member>
    <member name="M:NHibernate.Properties.FieldAccessor.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.FieldAccessor" />.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.FieldAccessor.#ctor(NHibernate.Properties.IFieldNamingStrategy)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.FieldAccessor" />.
            </summary>
      <param name="namingStrategy">The <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> to use.</param>
    </member>
    <member name="M:NHibernate.Properties.FieldAccessor.GetGetter(System.Type,System.String)">
      <summary>
            Create a <see cref="T:NHibernate.Properties.FieldAccessor.FieldGetter" /> to <c>get</c> the value of the mapped Property
            through a <c>Field</c>.
            </summary>
      <param name="theClass">The <see cref="T:System.Type" /> to find the Property in.</param>
      <param name="propertyName">The name of the mapped Property to get.</param>
      <returns>
            The <see cref="T:NHibernate.Properties.FieldAccessor.FieldGetter" /> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type" />.</returns>
      <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Field specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type" />.
            </exception>
    </member>
    <member name="M:NHibernate.Properties.FieldAccessor.GetSetter(System.Type,System.String)">
      <summary>
            Create a <see cref="T:NHibernate.Properties.FieldAccessor.FieldSetter" /> to <c>set</c> the value of the mapped Property
            through a <c>Field</c>.
            </summary>
      <param name="theClass">The <see cref="T:System.Type" /> to find the mapped Property in.</param>
      <param name="propertyName">The name of the mapped Property to set.</param>
      <returns>
            The <see cref="T:NHibernate.Properties.FieldAccessor.FieldSetter" /> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type" />.
            </returns>
      <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Field for the Property specified by the <c>propertyName</c> using the
            <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> could not be found in the <see cref="T:System.Type" />.
            </exception>
    </member>
    <member name="M:NHibernate.Properties.FieldAccessor.GetField(System.Type,System.String)">
      <summary>
            Helper method to find the Field.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to find the Field in.</param>
      <param name="fieldName">The name of the Field to find.</param>
      <returns>
            The <see cref="T:System.Reflection.FieldInfo" /> for the field.
            </returns>
      <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a field could not be found.
            </exception>
    </member>
    <member name="M:NHibernate.Properties.FieldAccessor.GetFieldName(System.String)">
      <summary>
            Converts the mapped property's name into a Field using 
            the <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> if one exists.
            </summary>
      <param name="propertyName">The name of the Property.</param>
      <returns>The name of the Field.</returns>
    </member>
    <member name="P:NHibernate.Properties.FieldAccessor.NamingStrategy">
      <summary>
            Gets the <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> used to convert the name of the
            mapped Property in the hbm.xml file to the name of the field in the class.
            </summary>
      <value>The <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> or <see langword="null" />.</value>
    </member>
    <member name="T:NHibernate.Properties.IndexPropertyAccessor">
      <summary> Represents a "back-reference" to the index of a collection. </summary>
    </member>
    <member name="T:NHibernate.Properties.IndexPropertyAccessor.IndexSetter">
      <summary> The Setter implementation for index backrefs.</summary>
    </member>
    <member name="T:NHibernate.Properties.IndexPropertyAccessor.IndexGetter">
      <summary> The Getter implementation for index backrefs.</summary>
    </member>
    <member name="M:NHibernate.Properties.IndexPropertyAccessor.#ctor(System.String,System.String)">
      <summary> Constructs a new instance of IndexPropertyAccessor. </summary>
      <param name="collectionRole">The collection role which this back ref references. </param>
      <param name="entityName">The owner entity name.</param>
    </member>
    <member name="T:NHibernate.Properties.LowerCaseStrategy">
      <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> for fields that are  
            the PropertyName in all LowerCase characters.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.LowerCaseStrategy.GetFieldName(System.String)">
      <summary>
            Converts the Property's name into a Field name by making the all characters 
            of the <c>propertyName</c> lowercase.
            </summary>
      <param name="propertyName">The name of the mapped property.</param>
      <returns>The name of the Field in lowercase.</returns>
    </member>
    <member name="T:NHibernate.Properties.LowerCaseUnderscoreStrategy">
      <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> for fields that are prefixed with
            an underscore and the PropertyName is changed to lower case.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.LowerCaseUnderscoreStrategy.GetFieldName(System.String)">
      <summary>
            Converts the Property's name into a Field name by making the all characters 
            of the <c>propertyName</c> lowercase and prefixing it with an underscore.
            </summary>
      <param name="propertyName">The name of the mapped property.</param>
      <returns>The name of the Field in lowercase prefixed with an underscore.</returns>
    </member>
    <member name="T:NHibernate.Properties.NoopAccessor">
      <summary> Used to declare properties not represented at the pojo level </summary>
    </member>
    <member name="T:NHibernate.Properties.NoopAccessor.NoopGetter">
      <summary> A Getter which will always return null. It should not be called anyway.</summary>
    </member>
    <member name="T:NHibernate.Properties.NoopAccessor.NoopSetter">
      <summary> A Setter which will just do nothing.</summary>
    </member>
    <member name="T:NHibernate.Properties.NoSetterAccessor">
      <summary>
            Access the mapped property through a Property <c>get</c> to get the value 
            and go directly to the Field to set the value.
            </summary>
      <remarks>
            This is most useful because Classes can provider a get for the Property
            that is the <c>&lt;id&gt;</c> but tell NHibernate there is no setter for the Property
            so the value should be written directly to the field.
            </remarks>
    </member>
    <member name="M:NHibernate.Properties.NoSetterAccessor.#ctor(NHibernate.Properties.IFieldNamingStrategy)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.NoSetterAccessor" />.
            </summary>
      <param name="namingStrategy">The <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> to use.</param>
    </member>
    <member name="M:NHibernate.Properties.NoSetterAccessor.GetGetter(System.Type,System.String)">
      <summary>
            Creates an <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter" /> to <c>get</c> the value from the Property.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to find the Property in.</param>
      <param name="propertyName">The name of the mapped Property to get.</param>
      <returns>
            The <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter" /> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type" />.</returns>
      <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type" />.
            </exception>
    </member>
    <member name="M:NHibernate.Properties.NoSetterAccessor.GetSetter(System.Type,System.String)">
      <summary>
            Create a <see cref="T:NHibernate.Properties.FieldAccessor.FieldSetter" /> to <c>set</c> the value of the mapped Property
            through a <c>Field</c>.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to find the mapped Property in.</param>
      <param name="propertyName">The name of the mapped Property to set.</param>
      <returns>
            The <see cref="T:NHibernate.Properties.FieldAccessor.FieldSetter" /> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type" />.
            </returns>
      <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Field for the Property specified by the <c>propertyName</c> using the
            <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> could not be found in the <see cref="T:System.Type" />.
            </exception>
    </member>
    <member name="M:NHibernate.Properties.PascalCaseMStrategy.GetFieldName(System.String)">
      <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> uppercase and prefixing it with the letter 'm'.
            </summary>
      <param name="propertyName">The name of the mapped property.</param>
      <returns>The name of the Field in PascalCase format prefixed with an 'm'.</returns>
    </member>
    <member name="T:NHibernate.Properties.PascalCaseMUnderscoreStrategy">
      <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> for fields that are prefixed with
            an <c>m_</c> and the first character in PropertyName capitalized.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.PascalCaseMUnderscoreStrategy.GetFieldName(System.String)">
      <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> uppercase and prefixing it with the letter 'm' 
            and an underscore.
            </summary>
      <param name="propertyName">The name of the mapped property.</param>
      <returns>The name of the Field in PascalCase format prefixed with an 'm' and an underscore.</returns>
    </member>
    <member name="T:NHibernate.Properties.PascalCaseUnderscoreStrategy">
      <summary>
            Implementation of <see cref="T:NHibernate.Properties.IFieldNamingStrategy" /> for fields that are prefixed with
            an <c>_</c> and the first character in PropertyName capitalized.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.PascalCaseUnderscoreStrategy.GetFieldName(System.String)">
      <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> uppercase and prefixing it with an underscore.
            </summary>
      <param name="propertyName">The name of the mapped property.</param>
      <returns>The name of the Field in PascalCase format prefixed with an underscore.</returns>
    </member>
    <member name="T:NHibernate.Properties.PropertyAccessorFactory">
      <summary>
            Factory for creating the various PropertyAccessor strategies.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.PropertyAccessorFactory.GetPropertyAccessor(System.String)">
      <summary>
            Gets or creates the <see cref="T:NHibernate.Properties.IPropertyAccessor" /> specified by the type.
            </summary>
      <param name="type">
      </param>
      <returns>The <see cref="T:NHibernate.Properties.IPropertyAccessor" /> specified by the type.</returns>
      <remarks>
        <para>
            The built in ways of accessing the values of Properties in your domain class are:
            </para>
        <list type="table">
          <listheader>
            <term>Access Method</term>
            <description>How NHibernate accesses the Mapped Class.</description>
          </listheader>
          <item>
            <term>property</term>
            <description>
            			The <c>name</c> attribute is the name of the Property.  This is the 
            			default implementation.
            		</description>
          </item>
          <item>
            <term>field</term>
            <description>
            			The <c>name</c> attribute is the name of the field.  If you have any Properties
            			in the Mapped Class those will be bypassed and NHibernate will go straight to the
            			field.  This is a good option if your setters have business rules attached to them
            			or if you don't want to expose a field through a Getter &amp; Setter.
            		</description>
          </item>
          <item>
            <term>nosetter</term>
            <description>
            			The <c>name</c> attribute is the name of the Property.  NHibernate will use the 
            			Property's get method to retrieve the value and will use the field
            			to set the value.  This is a good option for &lt;id&gt; Properties because this access method 
            			allows users of the Class to get the value of the Id but not set the value.
            		</description>
          </item>
          <item>
            <term>readonly</term>
            <description>
            			The <c>name</c> attribute is the name of the Property.  NHibernate will use the 
            			Property's get method to retrieve the value but will never set the value back in the domain.
            			This is used for read-only calculated properties with only a get method.
            		</description>
          </item>
          <item>
            <term>Assembly Qualified Name</term>
            <description>
            			If NHibernate's built in <see cref="T:NHibernate.Properties.IPropertyAccessor" />s are not what is needed for your 
            			situation then you are free to build your own.  Provide an Assembly Qualified Name so that 
            			NHibernate can call <c>Activator.CreateInstance(AssemblyQualifiedName)</c> to create it.  
            		</description>
          </item>
        </list>
        <para>
            In order for the <c>nosetter</c> to know the name of the field to access NHibernate needs to know
            what the naming strategy is.  The following naming strategies are built into NHibernate:
            </para>
        <list type="table">
          <listheader>
            <term>Naming Strategy</term>
            <description>How NHibernate converts the value of the <c>name</c> attribute to a field name.</description>
          </listheader>
          <item>
            <term>camelcase</term>
            <description>
            			The <c>name</c> attribute should be changed to CamelCase to find the field.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>foo</c>.
            		</description>
          </item>
          <item>
            <term>camelcase-underscore</term>
            <description>
            			The <c>name</c> attribute should be changed to CamelCase and prefixed with
            			an underscore to find the field.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>_foo</c>.
            		</description>
          </item>
          <item>
            <term>pascalcase-underscore</term>
            <description>
            			The <c>name</c> attribute should be prefixed with an underscore
            			to find the field.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>_Foo</c>.
            		</description>
          </item>
          <item>
            <term>pascalcase-m-underscore</term>
            <description>
            			The <c>name</c> attribute should be prefixed with an 'm' and underscore
            			to find the field.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>m_Foo</c>.
            		</description>
          </item>
          <item>
            <term>pascalcase-m</term>
            <description>
            			The <c>name</c> attribute should be prefixed with an 'm'.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>mFoo</c>.
            		</description>
          </item>
          <item>
            <term>lowercase</term>
            <description>
            			The <c>name</c> attribute should be changed to lowercase to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>foobar</c>.
            		</description>
          </item>
          <item>
            <term>lowercase-underscore</term>
            <description>
            			The <c>name</c> attribute should be changed to lowercase and prefixed with
            			and underscore to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>_foobar</c>.
            		</description>
          </item>
        </list>
        <para>
            The naming strategy can also be appended at the end of the <c>field</c> access method.  Where
            this could be useful is a scenario where you do expose a get and set method in the Domain Class 
            but NHibernate should only use the fields.  
            </para>
        <para>
            With a naming strategy and a get/set for the Property available the user of the Domain Class 
            could write an Hql statement <c>from Foo as foo where foo.SomeProperty = 'a'</c>.   If no naming 
            strategy was specified the Hql statement would have to be <c>from Foo as foo where foo._someProperty</c>
             (assuming CamelCase with an underscore field naming strategy is used).  
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Properties.PropertyAccessorFactory.GetPropertyAccessor(NHibernate.Mapping.Property,System.Nullable{NHibernate.EntityMode})">
      <summary> Retrieves a PropertyAccessor instance based on the given property definition and entity mode. </summary>
      <param name="property">The property for which to retrieve an accessor. </param>
      <param name="mode">The mode for the resulting entity. </param>
      <returns> An appropriate accessor. </returns>
    </member>
    <member name="T:NHibernate.Properties.ReadOnlyAccessor">
      <summary>
            Access the mapped property through a Property <c>get</c> to get the value 
            and do nothing to set the value.
            </summary>
      <remarks>
            This is useful to allow calculated properties in the domain that will never
            be recovered from the DB but can be used for querying.
            </remarks>
    </member>
    <member name="M:NHibernate.Properties.ReadOnlyAccessor.#ctor">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Properties.ReadOnlyAccessor" />.
            </summary>
    </member>
    <member name="M:NHibernate.Properties.ReadOnlyAccessor.GetGetter(System.Type,System.String)">
      <summary>
            Creates an <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter" /> to <c>get</c> the value from the Property.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to find the Property in.</param>
      <param name="propertyName">The name of the mapped Property to get.</param>
      <returns>
            The <see cref="T:NHibernate.Properties.BasicPropertyAccessor.BasicGetter" /> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type" />.</returns>
      <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type" />.
            </exception>
    </member>
    <member name="M:NHibernate.Properties.ReadOnlyAccessor.GetSetter(System.Type,System.String)">
      <summary>
            Create a <see cref="T:NHibernate.Properties.NoopAccessor.NoopSetter" /> to do nothing when trying to
            se the value of the mapped Property
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to find the mapped Property in.</param>
      <param name="propertyName">The name of the mapped Property to set.</param>
      <returns>
            An instance of <see cref="T:NHibernate.Properties.NoopAccessor.NoopSetter" />.
            </returns>
    </member>
    <member name="T:NHibernate.Properties.XmlAccessor">
      <summary> 
            Responsible for accessing property values represented as a XmlElement
            or XmlAttribute. 
            </summary>
    </member>
    <member name="T:NHibernate.Properties.XmlAccessor.XmlGetter">
      <summary> Defines the strategy for getting property values out of a dom4j Node.</summary>
    </member>
    <member name="P:NHibernate.Properties.XmlAccessor.XmlGetter.ReturnType">
      <summary> Get the declared type</summary>
    </member>
    <member name="P:NHibernate.Properties.XmlAccessor.XmlGetter.PropertyName">
      <summary> Optional operation (return null)</summary>
    </member>
    <member name="P:NHibernate.Properties.XmlAccessor.XmlGetter.Method">
      <summary> Optional operation (return null)</summary>
    </member>
    <member name="T:NHibernate.Properties.XmlAccessor.AttributeGetter">
      <summary> For nodes like <tt>"@bar"</tt></summary>
    </member>
    <member name="P:NHibernate.Properties.XmlAccessor.XmlSetter.PropertyName">
      <summary> Optional operation (return null)</summary>
    </member>
    <member name="P:NHibernate.Properties.XmlAccessor.XmlSetter.Method">
      <summary> Optional operation (return null)</summary>
    </member>
    <member name="T:NHibernate.Properties.XmlAccessor.AttributeSetter">
      <summary> For nodes like <tt>"@bar"</tt></summary>
    </member>
    <member name="T:NHibernate.Properties.XmlAccessor.ElementAttributeGetter">
      <summary> For nodes like <tt>"foo/@bar"</tt></summary>
    </member>
    <member name="T:NHibernate.Properties.XmlAccessor.ElementAttributeSetter">
      <summary> For nodes like <tt>"foo/@bar"</tt></summary>
    </member>
    <member name="T:NHibernate.Properties.XmlAccessor.ElementGetter">
      <summary> For nodes like <tt>"foo"</tt></summary>
    </member>
    <member name="T:NHibernate.Properties.XmlAccessor.ElementSetter">
      <summary> For nodes like <tt>"foo"</tt></summary>
    </member>
    <member name="T:NHibernate.Properties.XmlAccessor.TextGetter">
      <summary> For nodes like <tt>"."</tt></summary>
    </member>
    <member name="T:NHibernate.Properties.XmlAccessor.TextSetter">
      <summary> For nodes like <tt>"."</tt></summary>
    </member>
    <member name="M:NHibernate.Proxy.ILazyInitializer.Initialize">
      <summary>
            Perform an ImmediateLoad of the actual object for the Proxy.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the Proxy has no Session or the Session is closed or disconnected.
            </exception>
    </member>
    <member name="M:NHibernate.Proxy.ILazyInitializer.GetImplementation">
      <summary>
            Return the Underlying Persistent Object, initializing if necessary.
            </summary>
      <returns>The Persistent Object this proxy is Proxying.</returns>
    </member>
    <member name="M:NHibernate.Proxy.ILazyInitializer.GetImplementation(NHibernate.Engine.ISessionImplementor)">
      <summary>
            Return the Underlying Persistent Object in a given <see cref="T:NHibernate.ISession" />, or null.
            </summary>
      <param name="s">The Session to get the object from.</param>
      <returns>The Persistent Object this proxy is Proxying, or <see langword="null" />.</returns>
    </member>
    <member name="P:NHibernate.Proxy.ILazyInitializer.Identifier">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Proxy.ILazyInitializer.EntityName">
      <summary> Get the entity name</summary>
    </member>
    <member name="P:NHibernate.Proxy.ILazyInitializer.PersistentClass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Proxy.ILazyInitializer.IsUninitialized">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Proxy.ILazyInitializer.Session">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Proxy.AbstractLazyInitializer">
      <summary>
            Provides the base functionality to Handle Member calls into a dynamically
            generated NHibernate Proxy.
            </summary>
      <remarks>
            This could be an extension point later if the .net framework ever gets a Proxy
            class that is similar to the java.lang.reflect.Proxy or if a library similar
            to cglib was made in .net.
            </remarks>
    </member>
    <member name="F:NHibernate.Proxy.AbstractLazyInitializer.InvokeImplementation">
      <summary>
            If this is returned by Invoke then the subclass needs to Invoke the
            method call against the object that is being proxied.
            </summary>
    </member>
    <member name="M:NHibernate.Proxy.AbstractLazyInitializer.#ctor(System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Create a LazyInitializer to handle all of the Methods/Properties that are called
            on the Proxy.
            </summary>
      <param name="entityName">The entityName</param>
      <param name="id">The Id of the Object we are Proxying.</param>
      <param name="session">The ISession this Proxy is in.</param>
    </member>
    <member name="M:NHibernate.Proxy.AbstractLazyInitializer.Initialize">
      <summary>
            Perform an ImmediateLoad of the actual object for the Proxy.
            </summary>
      <exception cref="T:NHibernate.HibernateException">
            Thrown when the Proxy has no Session or the Session is closed or disconnected.
            </exception>
    </member>
    <member name="M:NHibernate.Proxy.AbstractLazyInitializer.GetImplementation">
      <summary>
            Return the Underlying Persistent Object, initializing if necessary.
            </summary>
      <returns>The Persistent Object this proxy is Proxying.</returns>
    </member>
    <member name="M:NHibernate.Proxy.AbstractLazyInitializer.GetImplementation(NHibernate.Engine.ISessionImplementor)">
      <summary>
            Return the Underlying Persistent Object in a given <see cref="T:NHibernate.ISession" />, or null.
            </summary>
      <param name="s">The Session to get the object from.</param>
      <returns>The Persistent Object this proxy is Proxying, or <see langword="null" />.</returns>
    </member>
    <member name="P:NHibernate.Proxy.AbstractLazyInitializer.Identifier">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Proxy.AbstractLazyInitializer.Session">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Proxy.Map.MapLazyInitializer">
      <summary> Lazy initializer for "dynamic-map" entity representations. </summary>
    </member>
    <member name="T:NHibernate.Proxy.INHibernateProxy">
      <summary>
            A marker interface so NHibernate can know if it is dealing with
            an object that is a Proxy. 
            </summary>
      <remarks>
        <para>
            This interface should not be implemented by anything other than
            the Dynamically generated Proxy.  If it is implemented by a class then
            NHibernate will think that class is a Proxy and will not work.
            </para>
        <para>
            It has to be public scope because
            the Proxies are created in a separate DLL than NHibernate. 
            </para>
      </remarks>
    </member>
    <member name="P:NHibernate.Proxy.INHibernateProxy.HibernateLazyInitializer">
      <summary> Get the underlying lazy initialization handler. </summary>
    </member>
    <member name="T:NHibernate.Proxy.Map.MapProxy">
      <summary> Proxy for "dynamic-map" entity representations. </summary>
    </member>
    <member name="T:NHibernate.Proxy.IProxyFactory">
      <summary> Contract for run-time, proxy-based lazy initialization proxies. </summary>
    </member>
    <member name="M:NHibernate.Proxy.IProxyFactory.PostInstantiate(System.String,System.Type,Iesi.Collections.Generic.ISet{System.Type},System.Reflection.MethodInfo,System.Reflection.MethodInfo,NHibernate.Type.IAbstractComponentType)">
      <summary> Called immediately after instantiation of this factory. </summary>
      <param name="entityName">
            The name of the entity for which this factory should generate proxies. 
            </param>
      <param name="persistentClass">
            The entity class for which to generate proxies; not always the same as the entityName.
            </param>
      <param name="interfaces">
            The interfaces to expose in the generated proxy;
            <see cref="T:NHibernate.Proxy.INHibernateProxy" /> is already included in this collection.
            </param>
      <param name="getIdentifierMethod">
            Reference to the identifier getter method; invocation on this method should not force initialization
            </param>
      <param name="setIdentifierMethod">
            Reference to the identifier setter method; invocation on this method should not force initialization
            </param>
      <param name="componentIdType">
            For composite identifier types, a reference to
            the <see cref="T:NHibernate.Type.ComponentType">type</see> of the identifier
            property; again accessing the id should generally not cause
            initialization - but need to bear in mind key-many-to-one
            mappings.
            </param>
      <exception cref="T:NHibernate.HibernateException"> Indicates a problem completing post </exception>
      <remarks>
            Essentially equivalent to constructor injection, but contracted
            here via interface.
            </remarks>
    </member>
    <member name="M:NHibernate.Proxy.IProxyFactory.GetProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Create a new proxy
            </summary>
      <param name="id">The id value for the proxy to be generated.</param>
      <param name="session">The session to which the generated proxy will be associated.</param>
      <returns>The generated proxy.</returns>
      <exception cref="T:NHibernate.HibernateException">Indicates problems generating requested proxy.</exception>
    </member>
    <member name="T:NHibernate.Proxy.Poco.BasicLazyInitializer">
      <summary> Lazy initializer for POCOs</summary>
    </member>
    <member name="M:NHibernate.Proxy.Poco.BasicLazyInitializer.AddSerializationInfo(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Adds all of the information into the SerializationInfo that is needed to
            reconstruct the proxy during deserialization or to replace the proxy
            with the instantiated target.
            </summary>
      <remarks>
            This will only be called if the Dynamic Proxy generator does not handle serialization
            itself or delegates calls to the method GetObjectData to the LazyInitializer.
            </remarks>
    </member>
    <member name="M:NHibernate.Proxy.Poco.BasicLazyInitializer.Invoke(System.Reflection.MethodInfo,System.Object[],System.Object)">
      <summary>
            Invokes the method if this is something that the LazyInitializer can handle
            without the underlying proxied object being instantiated.
            </summary>
      <param name="method">The name of the method/property to Invoke.</param>
      <param name="args">The arguments to pass the method/property.</param>
      <param name="proxy">The proxy object that the method is being invoked on.</param>
      <returns>
            The result of the Invoke if the underlying proxied object is not needed.  If the 
            underlying proxied object is needed then it returns the result <see cref="F:NHibernate.Proxy.AbstractLazyInitializer.InvokeImplementation" />
            which indicates that the Proxy will need to forward to the real implementation.
            </returns>
    </member>
    <member name="T:NHibernate.Proxy.AbstractProxyFactory">
      <summary>
            Convenient common implementation for ProxyFactory
            </summary>
    </member>
    <member name="T:NHibernate.Proxy.IProxyValidator">
      <summary>
            Proxeability validator.
            </summary>
    </member>
    <member name="M:NHibernate.Proxy.IProxyValidator.ValidateType(System.Type)">
      <summary>
            Validates whether <paramref name="type" /> can be specified as the base class
            (or an interface) for a dynamically-generated proxy.
            </summary>
      <param name="type">The type to validate.</param>
      <returns>
            A collection of errors messages, if any, or <see langword="null" /> if none were found.
            </returns>
      <remarks>
            When the configuration property "use_proxy_validator" is set to true(default), the result of this method
            is used to throw a detailed exception about the proxeability of the given <paramref name="type" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Proxy.IProxyValidator.IsProxeable(System.Reflection.MethodInfo)">
      <summary>
            Validate if a single method can be intercepted by proxy.
            </summary>
      <param name="method">The given method to check.</param>
      <returns>
        <see langword="true" /> if the method can be intercepted by proxy.
            <see langword="false" /> otherwise.
            </returns>
      <remarks>
            This method can be used internally by the <see cref="M:NHibernate.Proxy.IProxyValidator.ValidateType(System.Type)" /> and is used
            by <see cref="T:NHibernate.Tuple.Entity.PocoEntityTuplizer" /> to log errors when
            a property accessor can't be intercepted by proxy.
            The validation of property accessors is fairly enough if you ecampsulate each property.
            </remarks>
    </member>
    <member name="M:NHibernate.Proxy.DynProxyTypeValidator.ValidateType(System.Type)">
      <summary>
            Validates whether <paramref name="type" /> can be specified as the base class
            (or an interface) for a dynamically-generated proxy.
            </summary>
      <param name="type">The type to validate.</param>
      <returns>
            A collection of errors messages, if any, or <see langword="null" /> if none were found.
            </returns>
    </member>
    <member name="T:NHibernate.Proxy.NHibernateProxyHelper">
      <summary>
            NHibernateProxyHelper provides convenience methods for working with
            objects that might be instances of Classes or the Proxied version of 
            the Class.
            </summary>
    </member>
    <member name="M:NHibernate.Proxy.NHibernateProxyHelper.GetClassWithoutInitializingProxy(System.Object)">
      <summary> 
            Get the class of an instance or the underlying class of a proxy (without initializing the proxy!). 
            It is almost always better to use the entity name!
            </summary>
      <param name="obj">The object to get the type of.</param>
      <returns>The Underlying Type for the object regardless of if it is a Proxy.</returns>
    </member>
    <member name="M:NHibernate.Proxy.NHibernateProxyHelper.GuessClass(System.Object)">
      <summary>
            Get the true, underlying class of a proxied persistent class. This operation
            will NOT initialize the proxy and thus may return an incorrect result.
            </summary>
      <param name="entity">a persistable object or proxy</param>
      <returns>guessed class of the instance</returns>
      <remarks>
            This method is approximate match for Session.bestGuessEntityName in H3.2
            </remarks>
    </member>
    <member name="T:NHibernate.SqlCommand.Alias">
      <summary>
            Aliases tables and fields for Sql Statements.
            </summary>
      <remarks>
            Several methods of this class take an additional
            <see cref="T:NHibernate.Dialect.Dialect" /> parameter, while their Java counterparts
            do not. The dialect is used to correctly quote and unquote identifiers.
            Java versions do the quoting and unquoting themselves and fail to
            consider dialect-specific rules, such as escaping closing brackets in
            identifiers on MS SQL 2000.
            </remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.Alias.#ctor(System.Int32,System.String)">
      <summary>
      </summary>
      <param name="length">
      </param>
      <param name="suffix">
      </param>
    </member>
    <member name="M:NHibernate.SqlCommand.Alias.#ctor(System.String)">
      <summary>
      </summary>
      <param name="suffix">
      </param>
    </member>
    <member name="M:NHibernate.SqlCommand.Alias.ToAliasString(System.String,NHibernate.Dialect.Dialect)">
      <summary>
      </summary>
      <param name="sqlIdentifier">
      </param>
      <param name="dialect">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.SqlCommand.Alias.ToUnquotedAliasString(System.String,NHibernate.Dialect.Dialect)">
      <summary>
      </summary>
      <param name="sqlIdentifier">
      </param>
      <param name="dialect">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.SqlCommand.Alias.ToUnquotedAliasStrings(System.String[],NHibernate.Dialect.Dialect)">
      <summary>
      </summary>
      <param name="sqlIdentifiers">
      </param>
      <param name="dialect">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.SqlCommand.Alias.ToAliasStrings(System.String[],NHibernate.Dialect.Dialect)">
      <summary>
      </summary>
      <param name="sqlIdentifiers">
      </param>
      <param name="dialect">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.SqlCommand.CaseFragment">
      <summary> Abstract SQL case fragment renderer </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.ANSICaseFragment">
      <summary>An ANSI SQL CASE expression.
            <code>case when ... then ... end as ...</code></summary>
      <remarks>This class looks StringHelper.SqlParameter safe...</remarks>
    </member>
    <member name="T:NHibernate.SqlCommand.ANSIJoinFragment">
      <summary>
            An ANSI-style Join.
            </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.ConditionalFragment">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetOp(System.String)">
      <summary>
            Sets the op
            </summary>
      <param name="op">The op to set</param>
    </member>
    <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetTableAlias(System.String)">
      <summary>
      </summary>
      <param name="tableAlias">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetCondition(System.String[],System.String[])">
      <summary>
      </summary>
      <param name="lhs">
      </param>
      <param name="rhs">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetCondition(System.String[],System.String)">
      <summary>
      </summary>
      <param name="lhs">
      </param>
      <param name="rhs">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.SqlCommand.ConditionalFragment.ToSqlStringFragment">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.DecodeCaseFragment">
      <summary>An Oracle-style DECODE function. </summary>
      <example>
        <code>decode(pkvalue, key1, 1, key2, 2, ..., 0)</code>
      </example>
    </member>
    <member name="M:NHibernate.SqlCommand.DecodeCaseFragment.ToSqlStringFragment">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.ForUpdateFragment">
      <summary>
            Represents an SQL <c>for update of ... nowait</c> statement
            </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.InformixJoinFragment">
      <summary>
            An Informix-style (theta) Join
            </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.InFragment">
      <summary>
            Represents an <c>... in (...)</c> expression
            </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.InFragment.AddValue(System.Object)">
      <summary>
            Add a value to the value list. Value may be a string,
            a <see cref="T:NHibernate.SqlCommand.Parameter" />, or one of special values
            <see cref="F:NHibernate.SqlCommand.InFragment.Null" /> or <see cref="F:NHibernate.SqlCommand.InFragment.NotNull" />.
            </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.JoinType">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.OracleJoinFragment">
      <summary>
            An Oracle-style (theta) Join
            </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.OracleJoinFragment.AddLeftOuterJoinCondition(System.String)">
      <summary>
            This method is a bit of a hack, and assumes
            that the column on the "right" side of the
            join appears on the "left" side of the
            operator, which is extremely weird if this
            was a normal join condition, but is natural
            for a filter.
            </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.Parameter">
      <summary>
            A placeholder for an ADO.NET parameter in an <see cref="T:NHibernate.SqlCommand.SqlString" />.
            </summary>
    </member>
    <member name="F:NHibernate.SqlCommand.Parameter.OriginalPositionInQuery">
      <summary>
            We need to know what the position of the parameter was in a query
            before we rearranged the query.
            This is used only by dialects that rearrange the query, unfortunately, 
            the MS SQL 2005 dialect have to re shuffle the query (and ruin positional parameter
            support) because the SQL 2005 and 2008 SQL dialects have a completely broken
            support for paging, which is just a tad less important than SELECT.
            See  	 NH-1528
            </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.Parameter.GenerateParameters(System.Int32)">
      <summary>
            Generates an array of parameters for the given <see cref="T:NHibernate.SqlTypes.SqlType">SqlTypes</see>.
            </summary>
      <param name="count">The number of parameters to generate.</param>
      <returns>An array of <see cref="T:NHibernate.SqlCommand.Parameter" /> objects</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.Parameter.Equals(System.Object)">
      <summary>
            Determines whether this instance and the specified object 
            are of the same type and have the same values.
            </summary>
      <param name="obj">An object to compare to this instance.</param>
      <returns>
        <see langword="true" /> if the object equals the current instance.
            </returns>
    </member>
    <member name="M:NHibernate.SqlCommand.Parameter.GetHashCode">
      <summary>
            Gets a hash code for the parameter.
            </summary>
      <returns>
            An <see cref="T:System.Int32" /> value for the hash code.
            </returns>
    </member>
    <member name="P:NHibernate.SqlCommand.Parameter.Placeholder">
      <summary>
            Used as a placeholder when parsing HQL or SQL queries.
            </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.QueryJoinFragment">
      <summary>
            Summary description for QueryJoinFragment.
            </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.QuerySelect">
      <summary>
            Summary description for QuerySelect.
            </summary>
    </member>
    <member name="F:NHibernate.SqlCommand.QuerySelect.dontSpace">
      <summary>
            Certain databases don't like spaces around these operators.
            </summary>
      <remarks>
            This needs to contain both a plain string and a 
            SqlString version of the operator because the portions in 
            the WHERE clause will come in as SqlStrings since there
            might be parameters, other portions of the clause come in
            as strings since there are no parameters.
            </remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.QuerySelect.#ctor(NHibernate.Dialect.Dialect)">
      <summary>
      </summary>
      <param name="dialect">
      </param>
    </member>
    <member name="M:NHibernate.SqlCommand.QuerySelect.AddSelectFragmentString(NHibernate.SqlCommand.SqlString)">
      <summary>
      </summary>
      <param name="fragment">
      </param>
    </member>
    <member name="M:NHibernate.SqlCommand.QuerySelect.AddSelectColumn(System.String,System.String)">
      <summary>
      </summary>
      <param name="columnName">
      </param>
      <param name="alias">
      </param>
    </member>
    <member name="M:NHibernate.SqlCommand.QuerySelect.SetWhereTokens(System.Collections.ICollection)">
      <summary>
      </summary>
      <param name="tokens">
      </param>
    </member>
    <member name="M:NHibernate.SqlCommand.QuerySelect.SetGroupByTokens(System.Collections.ICollection)">
      <summary>
      </summary>
      <param name="tokens">
      </param>
    </member>
    <member name="M:NHibernate.SqlCommand.QuerySelect.SetOrderByTokens(System.Collections.ICollection)">
      <summary>
      </summary>
      <param name="tokens">
      </param>
    </member>
    <member name="M:NHibernate.SqlCommand.QuerySelect.SetHavingTokens(System.Collections.ICollection)">
      <summary>
      </summary>
      <param name="tokens">
      </param>
    </member>
    <member name="M:NHibernate.SqlCommand.QuerySelect.AddOrderBy(System.String)">
      <summary>
            Adds a string containing a valid "order by" sql statement
            to this QuerySelect
            </summary>
      <param name="orderBySql">The "order by" sql statement.</param>
    </member>
    <member name="M:NHibernate.SqlCommand.QuerySelect.AppendTokens(NHibernate.SqlCommand.SqlStringBuilder,System.Collections.ICollection)">
      <summary>
      </summary>
      <param name="builder">
      </param>
      <param name="iter">
      </param>
    </member>
    <member name="P:NHibernate.SqlCommand.QuerySelect.JoinFragment">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.SqlCommand.QuerySelect.Distinct">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.SelectFragment">
      <summary>
            Represents part of an SQL <c>SELECT</c> clause
            </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.SelectFragment.ToFragmentString">
      <summary>
            Equivalent to ToSqlStringFragment.
            </summary>
      <returns>
      </returns>
      <remarks>
            In H3, it is called ToFragmentString(). It appears to be 
            functionally equivalent as ToSqlStringFragment() here.
            </remarks>
    </member>
    <member name="T:NHibernate.SqlCommand.SqlBaseBuilder">
      <summary>
            The base class for all of the SqlBuilders.
            </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String[])">
      <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
      <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
      <returns>A SqlString that contains the WhereFragment</returns>
      <remarks>This just calls the overloaded ToWhereFragment() with the operator as " = " and the tableAlias null.</remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String,System.String[])">
      <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
      <param name="tableAlias">The Alias for the Table.</param>
      <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
      <returns>A SqlString that contains the WhereFragment</returns>
      <remarks>This defaults the op to " = "</remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String[],System.String)">
      <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
      <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
      <param name="op">The operator to use between the names &amp; values.  For example " = " or "!="</param>
      <returns>A SqlString that contains the WhereFragment</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String,System.String[],System.String)">
      <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
      <param name="tableAlias">The Alias for the Table.</param>
      <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
      <param name="op">The operator to use between the names &amp; values.  For example " = " or "!="</param>
      <returns>A SqlString that contains the WhereFragment</returns>
    </member>
    <member name="T:NHibernate.SqlCommand.SqlDeleteBuilder">
      <summary>
            A class that builds an <c>DELETE</c> sql statement.
            </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.SetIdentityColumn(System.String[],NHibernate.Type.IType)">
      <summary>
            Sets the IdentityColumn for the <c>DELETE</c> sql to use.
            </summary>
      <param name="columnNames">An array of the column names for the Property</param>
      <param name="identityType">The IType of the Identity Property.</param>
      <returns>The SqlDeleteBuilder.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.SetVersionColumn(System.String[],NHibernate.Type.IVersionType)">
      <summary>
            Sets the VersionColumn for the <c>DELETE</c> sql to use.
            </summary>
      <param name="columnNames">An array of the column names for the Property</param>
      <param name="versionType">The IVersionType of the Version Property.</param>
      <returns>The SqlDeleteBuilder.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.AddWhereFragment(System.String[],NHibernate.Type.IType,System.String)">
      <summary>
            Adds the columns for the Type to the WhereFragment
            </summary>
      <param name="columnNames">The names of the columns to add.</param>
      <param name="type">The IType of the property.</param>
      <param name="op">The operator to put between the column name and value.</param>
      <returns>The SqlDeleteBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.AddWhereFragment(System.String)">
      <summary>
            Adds a string to the WhereFragement
            </summary>
      <param name="whereSql">A well formed sql statement with no parameters.</param>
      <returns>The SqlDeleteBuilder</returns>
    </member>
    <member name="T:NHibernate.SqlCommand.SqlSelectBuilder">
      <summary>
            Builds a <c>SELECT</c> SQL statement.
            </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetFromClause(System.String)">
      <summary>
            Sets the text that should appear after the FROM 
            </summary>
      <param name="fromClause">The fromClause to set</param>
      <returns>The SqlSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetFromClause(System.String,System.String)">
      <summary>
            Sets the text that should appear after the FROM 
            </summary>
      <param name="tableName">The name of the Table to get the data from</param>
      <param name="alias">The Alias to use for the table name.</param>
      <returns>The SqlSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetFromClause(NHibernate.SqlCommand.SqlString)">
      <summary>
            Sets the text that should appear after the FROM
            </summary>
      <param name="fromClause">The fromClause in a SqlString</param>
      <returns>The SqlSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetOrderByClause(NHibernate.SqlCommand.SqlString)">
      <summary>
            Sets the text that should appear after the ORDER BY.
            </summary>
      <param name="orderByClause">The orderByClause to set</param>
      <returns>The SqlSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetGroupByClause(System.String)">
      <summary>
            Sets the text that should appear after the GROUP BY.
            </summary>
      <param name="groupByClause">The groupByClause to set</param>
      <returns>The SqlSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetOuterJoins(NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString)">
      <summary>
            Sets the SqlString for the OUTER JOINs.  
            </summary>
      <remarks>
            All of the Sql needs to be included in the SELECT.  No OUTER JOINS will automatically be
            added.
            </remarks>
      <param name="outerJoinsAfterFrom">The outerJoinsAfterFrom to set</param>
      <param name="outerJoinsAfterWhere">The outerJoinsAfterWhere to set</param>
      <returns>The SqlSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetSelectClause(NHibernate.SqlCommand.SqlString)">
      <summary>
            Sets the text for the SELECT
            </summary>
      <param name="selectClause">The selectClause to set</param>
      <returns>The SqlSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetSelectClause(System.String)">
      <summary>
            Sets the text for the SELECT
            </summary>
      <param name="selectClause">The selectClause to set</param>
      <returns>The SqlSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetWhereClause(System.String,System.String[],NHibernate.Type.IType)">
      <summary>
            Sets the criteria to use for the WHERE.  It joins all of the columnNames together with an AND.
            </summary>
      <param name="tableAlias">
      </param>
      <param name="columnNames">The names of the columns</param>
      <param name="whereType">The Hibernate Type</param>
      <returns>The SqlSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetWhereClause(NHibernate.SqlCommand.SqlString)">
      <summary>
            Sets the prebuilt SqlString to the Where clause
            </summary>
      <param name="whereSqlString">The SqlString that contains the sql and parameters to add to the WHERE</param>
      <returns>This SqlSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetHavingClause(System.String,System.String[],NHibernate.Type.IType)">
      <summary>
            Sets the criteria to use for the WHERE.  It joins all of the columnNames together with an AND.
            </summary>
      <param name="tableAlias">
      </param>
      <param name="columnNames">The names of the columns</param>
      <param name="whereType">The Hibernate Type</param>
      <returns>The SqlSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetHavingClause(NHibernate.SqlCommand.SqlString)">
      <summary>
            Sets the prebuilt SqlString to the Having clause
            </summary>
      <param name="havingSqlString">The SqlString that contains the sql and parameters to add to the HAVING</param>
      <returns>This SqlSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.ToStatementString">
      <summary>
            ToSqlString() is named ToStatementString() in H3
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.ToSqlString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.SqlSimpleSelectBuilder">
      <summary>
            Summary description for SqlSimpleSelectBuilder.
            </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetTableName(System.String)">
      <summary>
      </summary>
      <param name="tableName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumn(System.String)">
      <summary>
            Adds a columnName to the SELECT fragment.
            </summary>
      <param name="columnName">The name of the column to add.</param>
      <returns>The SqlSimpleSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumn(System.String,System.String)">
      <summary>
            Adds a columnName and its Alias to the SELECT fragment.
            </summary>
      <param name="columnName">The name of the column to add.</param>
      <param name="alias">The alias to use for the column</param>
      <returns>The SqlSimpleSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumns(System.String[])">
      <summary>
            Adds an array of columnNames to the SELECT fragment.
            </summary>
      <param name="columnNames">The names of the columns to add.</param>
      <returns>The SqlSimpleSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumns(System.String[],System.String[])">
      <summary>
            Adds an array of columnNames with their Aliases to the SELECT fragment.
            </summary>
      <param name="columnNames">The names of the columns to add.</param>
      <param name="aliases">The aliases to use for the columns</param>
      <returns>The SqlSimpleSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.GetAlias(System.String)">
      <summary>
            Gets the Alias that should be used for the column
            </summary>
      <param name="columnName">The name of the column to get the Alias for.</param>
      <returns>The Alias if one exists, null otherwise</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetIdentityColumn(System.String[],NHibernate.Type.IType)">
      <summary>
            Sets the IdentityColumn for the <c>SELECT</c> sql to use.
            </summary>
      <param name="columnNames">An array of the column names for the Property</param>
      <param name="identityType">The IType of the Identity Property.</param>
      <returns>The SqlSimpleSelectBuilder.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetVersionColumn(System.String[],NHibernate.Type.IVersionType)">
      <summary>
            Sets the VersionColumn for the <c>SELECT</c> sql to use.
            </summary>
      <param name="columnNames">An array of the column names for the Property</param>
      <param name="versionType">The IVersionType of the Version Property.</param>
      <returns>The SqlSimpleSelectBuilder.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetOrderBy(System.String)">
      <summary>
            Set the Order By fragment of the Select Command
            </summary>
      <param name="orderBy">The OrderBy fragment.  It should include the SQL "ORDER BY"</param>
      <returns>The SqlSimpleSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddWhereFragment(System.String[],NHibernate.Type.IType,System.String)">
      <summary>
            Adds the columns for the Type to the WhereFragment
            </summary>
      <param name="columnNames">The names of the columns to add.</param>
      <param name="type">The IType of the property.</param>
      <param name="op">The operator to put between the column name and value.</param>
      <returns>The SqlSimpleSelectBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.ToSqlString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.SqlString">
      <summary>
            This is a non-modifiable SQL statement that is ready to be prepared 
            and sent to the Database for execution.
            </summary>
      <remarks>
        <para>
            If you need to modify this object pass it to a <see cref="T:NHibernate.SqlCommand.SqlStringBuilder" /> and
            get a new object back from it.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.Append(NHibernate.SqlCommand.SqlString)">
      <summary>
            Appends the SqlString parameter to the end of the current SqlString to create a 
            new SqlString object.
            </summary>
      <param name="rhs">The SqlString to append.</param>
      <returns>A new SqlString object.</returns>
      <remarks>
            A SqlString object is immutable so this returns a new SqlString.  If multiple Appends 
            are called it is better to use the SqlStringBuilder.
            </remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.Append(System.String)">
      <summary>
            Appends the string parameter to the end of the current SqlString to create a 
            new SqlString object.
            </summary>
      <param name="rhs">The string to append.</param>
      <returns>A new SqlString object.</returns>
      <remarks>
            A SqlString object is immutable so this returns a new SqlString.  If multiple Appends 
            are called it is better to use the SqlStringBuilder.
            </remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.Compact">
      <summary>
            Compacts the SqlString into the fewest parts possible.
            </summary>
      <returns>A new SqlString.</returns>
      <remarks>
            Combines all SqlParts that are strings and next to each other into
            one SqlPart.
            </remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.EndsWith(System.String)">
      <summary>
            Determines whether the end of this instance matches the specified String.
            </summary>
      <param name="value">A string to seek at the end.</param>
      <returns>
        <see langword="true" /> if the end of this instance matches value; otherwise, <see langword="false" /></returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.Replace(System.String,System.String)">
      <summary>
            Replaces all occurrences of a specified <see cref="T:System.String" /> in this instance, 
            with another specified <see cref="T:System.String" /> .
            </summary>
      <param name="oldValue">A String to be replaced.</param>
      <param name="newValue">A String to replace all occurrences of oldValue. </param>
      <returns>
            A new SqlString with oldValue replaced by the newValue.  The new SqlString is 
            in the compacted form.
            </returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.StartsWithCaseInsensitive(System.String)">
      <summary>
            Determines whether the beginning of this SqlString matches the specified System.String,
            using case-insensitive comparison.
            </summary>
      <param name="value">The System.String to seek</param>
      <returns>true if the SqlString starts with the value.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.Substring(System.Int32)">
      <summary>
            Retrieves a substring from this instance. The substring starts at a specified character position. 
            </summary>
      <param name="startIndex">The starting character position of a substring in this instance.</param>
      <returns>
            A new SqlString to the substring that begins at startIndex in this instance. 
            </returns>
      <remarks>
            If the startIndex is greater than the length of the SqlString then <see cref="F:NHibernate.SqlCommand.SqlString.Empty" /> is returned.
            </remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.IndexOfCaseInsensitive(System.String)">
      <summary>
            Returns the index of the first occurrence of <paramref name="text" />, case-insensitive.
            </summary>
      <param name="text">Text to look for in the <see cref="T:NHibernate.SqlCommand.SqlString" />. Must be in lower
            case.</param>
      <remarks>
            The text must be located entirely in a string part of the <see cref="T:NHibernate.SqlCommand.SqlString" />.
            Searching for <c>"a ? b"</c> in an <see cref="T:NHibernate.SqlCommand.SqlString" /> consisting of
            <c>"a ", Parameter, " b"</c> will result in no matches.
            </remarks>
      <returns>The index of the first occurrence of <paramref name="text" />, or -1
            if not found.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.Trim">
      <summary>
            Removes all occurrences of white space characters from the beginning and end of this instance.
            </summary>
      <returns>
            A new SqlString equivalent to this instance after white space characters 
            are removed from the beginning and end.
            </returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.Equals(System.Object)">
      <summary>
      </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.GetHashCode">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.ToString">
      <summary>
            Returns the SqlString in a string where it looks like
            SELECT col1, col2 FROM table WHERE col1 = ?
            </summary>
      <remarks>
            The question mark is used as the indicator of a parameter because at
            this point we are not using the specific provider so we don't know
            how that provider wants our parameters formatted.
            </remarks>
      <returns>A provider-neutral version of the CommandText</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.SubstringStartingWithLast(System.String)">
      <summary>
            Returns substring of this SqlString starting with the specified
            <paramref name="text" />. If the text is not found, returns an
            empty, not-null SqlString.
            </summary>
      <remarks>
            The method performs case-insensitive comparison, so the <paramref name="text" />
            passed should be in lower case.
            </remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlString.Parse(System.String)">
      <summary>
            Parse SQL in <paramref name="sql" /> and create a SqlString representing it.
            </summary>
      <remarks>
            Parameter marks in single quotes will be correctly skipped, but otherwise the
            lexer is very simple and will not parse double quotes or escape sequences
            correctly, for example.
            </remarks>
    </member>
    <member name="P:NHibernate.SqlCommand.SqlString.Count">
      <summary>
            Gets the number of SqlParts contained in this SqlString.
            </summary>
      <value>The number of SqlParts contained in this SqlString.</value>
    </member>
    <member name="T:NHibernate.SqlCommand.SqlStringBuilder">
      <summary>
            The SqlStringBuilder is used to construct a SqlString.
            </summary>
      <remarks>
        <para>
            The SqlString is a nonmutable class so it can't have sql parts added
            to it.  Instead this class should be used to generate a new SqlString.
            The SqlStringBuilder is to SqlString what the StringBuilder is to
            a String.
            </para>
        <para>
            This is different from the original version of SqlString because this does not
            hold the sql string in the form of "column1=@column1" instead it uses an array to
            build the sql statement such that 
            object[0] = "column1="
            object[1] = ref to column1 parameter
            </para>
        <para>
            What this allows us to do is to delay the generating of the parameter for the sql
            until the very end - making testing dialect indifferent.  Right now all of our test
            to make sure the correct sql is getting built are specific to MsSql2000Dialect.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.#ctor">
      <summary>
            Create an empty StringBuilder with the default capacity.  
            </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.#ctor(System.Int32)">
      <summary>
            Create a StringBuilder with a specific capacity.
            </summary>
      <param name="partsCapacity">The number of parts expected.</param>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.#ctor(NHibernate.SqlCommand.SqlString)">
      <summary>
            Create a StringBuilder to modify the SqlString
            </summary>
      <param name="sqlString">The SqlString to modify.</param>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(System.String)">
      <summary>
            Adds the preformatted sql to the SqlString that is being built.
            </summary>
      <param name="sql">The string to add.</param>
      <returns>This SqlStringBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.Parameter)">
      <summary>
            Adds the Parameter to the SqlString that is being built.
            The correct operator should be added before the Add(Parameter) is called
            because there will be no operator ( such as "=" ) placed between the last Add call
            and this Add call.
            </summary>
      <param name="parameter">The Parameter to add.</param>
      <returns>This SqlStringBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.AddObject(System.Object)">
      <summary>
            Attempts to discover what type of object this is and calls the appropriate
            method.
            </summary>
      <param name="part">The part to add when it is not known if it is a Parameter, String, or SqlString.</param>
      <returns>This SqlStringBuilder.</returns>
      <exception cref="T:System.ArgumentException">Thrown when the part is not a Parameter, String, or SqlString.</exception>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString)">
      <summary>
            Adds an existing SqlString to this SqlStringBuilder.  It does NOT add any
            prefix, postfix, operator, or wrap around this.  It is equivalent to just 
            adding a string.
            </summary>
      <param name="sqlString">The SqlString to add to this SqlStringBuilder</param>
      <returns>This SqlStringBuilder</returns>
      <remarks>This calls the overloaded Add(sqlString, null, null, null, false)</remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString,System.String,System.String,System.String)">
      <summary>
            Adds an existing SqlString to this SqlStringBuilder
            </summary>
      <param name="sqlString">The SqlString to add to this SqlStringBuilder</param>
      <param name="prefix">String to put at the beginning of the combined SqlString.</param>
      <param name="op">How these Statements should be junctioned "AND" or "OR"</param>
      <param name="postfix">String to put at the end of the combined SqlString.</param>
      <returns>This SqlStringBuilder</returns>
      <remarks>
            This calls the overloaded Add method with an array of SqlStrings and wrapStatment=false
            so it will not be wrapped with a "(" and ")"
            </remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString[],System.String,System.String,System.String)">
      <summary>
            Adds existing SqlStrings to this SqlStringBuilder
            </summary>
      <param name="sqlStrings">The SqlStrings to combine.</param>
      <param name="prefix">String to put at the beginning of the combined SqlString.</param>
      <param name="op">How these SqlStrings should be junctioned "AND" or "OR"</param>
      <param name="postfix">String to put at the end of the combined SqlStrings.</param>
      <returns>This SqlStringBuilder</returns>
      <remarks>This calls the overloaded Add method with wrapStatement=true</remarks>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString[],System.String,System.String,System.String,System.Boolean)">
      <summary>
            Adds existing SqlStrings to this SqlStringBuilder
            </summary>
      <param name="sqlStrings">The SqlStrings to combine.</param>
      <param name="prefix">String to put at the beginning of the combined SqlStrings.</param>
      <param name="op">How these SqlStrings should be junctioned "AND" or "OR"</param>
      <param name="postfix">String to put at the end of the combined SqlStrings.</param>
      <param name="wrapStatement">Wrap each SqlStrings with "(" and ")"</param>
      <returns>This SqlStringBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Insert(System.Int32,System.String)">
      <summary>
            Insert a string containing sql into the SqlStringBuilder at the specified index.
            </summary>
      <param name="index">The zero-based index at which the sql should be inserted.</param>
      <param name="sql">The string containing sql to insert.</param>
      <returns>This SqlStringBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Insert(System.Int32,NHibernate.SqlCommand.Parameter)">
      <summary>
            Insert a Parameter into the SqlStringBuilder at the specified index.
            </summary>
      <param name="index">The zero-based index at which the Parameter should be inserted.</param>
      <param name="param">The Parameter to insert.</param>
      <returns>This SqlStringBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.RemoveAt(System.Int32)">
      <summary>
            Removes the string or Parameter at the specified index.
            </summary>
      <param name="index">The zero-based index of the item to remove.</param>
      <returns>This SqlStringBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlStringBuilder.ToSqlString">
      <summary>
            Converts the mutable SqlStringBuilder into the immutable SqlString.
            </summary>
      <returns>The SqlString that was built.</returns>
    </member>
    <member name="P:NHibernate.SqlCommand.SqlStringBuilder.Count">
      <summary>
            Gets the number of SqlParts in this SqlStringBuilder.
            </summary>
      <returns>
            The number of SqlParts in this SqlStringBuilder.
            </returns>
    </member>
    <member name="P:NHibernate.SqlCommand.SqlStringBuilder.Item(System.Int32)">
      <summary>
            Gets or Sets the element at the index
            </summary>
      <value>Returns a string or Parameter.</value>
      <remarks>
      </remarks>
    </member>
    <member name="T:NHibernate.SqlCommand.SqlUpdateBuilder">
      <summary>
            A class that builds an <c>UPDATE</c> sql statement.
            </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumn(System.String,System.Object,NHibernate.Type.ILiteralType)">
      <summary>
            Add a column with a specific value to the UPDATE sql
            </summary>
      <param name="columnName">The name of the Column to add.</param>
      <param name="val">The value to set for the column.</param>
      <param name="literalType">The NHibernateType to use to convert the value to a sql string.</param>
      <returns>The SqlUpdateBuilder.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumn(System.String,System.String)">
      <summary>
            Add a column with a specific value to the UPDATE sql
            </summary>
      <param name="columnName">The name of the Column to add.</param>
      <param name="val">A valid sql string to set as the value of the column.</param>
      <returns>The SqlUpdateBuilder.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumns(System.String[],System.String)">
      <summary>
            Adds columns with a specific value to the UPDATE sql
            </summary>
      <param name="columnsName">The names of the Columns to add.</param>
      <param name="val">A valid sql string to set as the value of the column.  This value is assigned to each column.</param>
      <returns>The SqlUpdateBuilder.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumns(System.String[],NHibernate.Type.IType)">
      <summary>
            Adds the Property's columns to the UPDATE sql
            </summary>
      <param name="columnNames">An array of the column names for the Property</param>
      <param name="propertyType">The IType of the property.</param>
      <returns>The SqlUpdateBuilder.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumns(System.String[],System.Boolean[],NHibernate.Type.IType)">
      <summary>
            Adds the Property's updatable columns to the UPDATE sql
            </summary>
      <param name="columnNames">An array of the column names for the Property</param>
      <param name="updateable">An array of updatable column flags.  If this array is <c>null</c>, all supplied columns are considered updatable.</param>
      <param name="propertyType">The IType of the property.</param>
      <returns>The SqlUpdateBuilder.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.SetIdentityColumn(System.String[],NHibernate.Type.IType)">
      <summary>
            Sets the IdentityColumn for the <c>UPDATE</c> sql to use.
            </summary>
      <param name="columnNames">An array of the column names for the Property</param>
      <param name="identityType">The IType of the Identity Property.</param>
      <returns>The SqlUpdateBuilder.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.SetVersionColumn(System.String[],NHibernate.Type.IVersionType)">
      <summary>
            Sets the VersionColumn for the <c>UPDATE</c> sql to use.
            </summary>
      <param name="columnNames">An array of the column names for the Property</param>
      <param name="versionType">The IVersionType of the Version Property.</param>
      <returns>The SqlUpdateBuilder.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddWhereFragment(System.String[],NHibernate.Type.IType,System.String)">
      <summary>
            Adds the columns for the Type to the WhereFragment
            </summary>
      <param name="columnNames">The names of the columns to add.</param>
      <param name="type">The IType of the property.</param>
      <param name="op">The operator to put between the column name and value.</param>
      <returns>The SqlUpdateBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddWhereFragment(System.String)">
      <summary>
            Adds a string to the WhereFragment
            </summary>
      <param name="whereSql">A well formed sql string with no parameters.</param>
      <returns>The SqlUpdateBuilder</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.ToSqlString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.SqlCommand.SubselectClauseExtractor">
      <summary>
            Given an SQL SELECT statement, parse it to extract clauses starting with
            <c>FROM</c>, up to and not including <c>ORDER BY</c> (known collectively
            as a subselect clause).
            </summary>
    </member>
    <member name="F:NHibernate.SqlCommand.SubselectClauseExtractor.builder">
      <summary>
            Contains the subselect clause as it is being built.
            </summary>
    </member>
    <member name="M:NHibernate.SqlCommand.SubselectClauseExtractor.#ctor(System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlCommand.SubselectClauseExtractor" /> class.
            </summary>
      <param name="sqlParts">The parts of an <see cref="T:NHibernate.SqlCommand.SqlString" /> to extract the subselect clause from.</param>
    </member>
    <member name="M:NHibernate.SqlCommand.SubselectClauseExtractor.ProcessPartBeforeFrom(System.Object)">
      <summary>
            Looks for a <c>FROM</c> clause in the <paramref name="part" />
            and adds the clause to the result if found.
            </summary>
      <param name="part">A <see cref="T:System.String" /> or a <see cref="T:NHibernate.SqlCommand.Parameter" />.</param>
      <returns>
        <see langword="true" /> if the part contained a <c>FROM</c> clause,
            <see langword="false" /> otherwise.</returns>
    </member>
    <member name="M:NHibernate.SqlCommand.SubselectClauseExtractor.GetSqlString">
      <summary>
            Returns the subselect clause of the statement
            being processed.
            </summary>
      <returns>An <see cref="T:NHibernate.SqlCommand.SqlString" /> containing
            the subselect clause of the original <c>SELECT</c>
            statement.</returns>
    </member>
    <member name="T:NHibernate.SqlCommand.WhereBuilder">
      <summary>
            Allows us to construct SQL WHERE fragments
            </summary>
    </member>
    <member name="T:NHibernate.SqlTypes.SqlType">
      <summary>
            This is the base class that adds information to the <see cref="P:NHibernate.SqlTypes.SqlType.DbType" /> 
            for the <see cref="T:NHibernate.Driver.IDriver" /> and <see cref="T:NHibernate.Dialect.Dialect" />
            to use.
            </summary>
      <remarks>
        <p>
            The <see cref="T:NHibernate.Driver.IDriver" /> uses the SqlType to get enough
            information to create an <see cref="T:System.Data.IDbDataParameter" />.  
            </p>
        <p>
            The <see cref="T:NHibernate.Dialect.Dialect" /> use the SqlType to convert the <see cref="P:NHibernate.SqlTypes.SqlType.DbType" />
            to the appropriate sql type for SchemaExport.
            </p>
      </remarks>
    </member>
    <member name="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType">
      <summary>
            Describes the details of a <see cref="F:System.Data.DbType.AnsiStringFixedLength" /> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter" />.
            </summary>
      <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter" /> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter" /> correctly.
            </remarks>
    </member>
    <member name="M:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType" /> class.
            </summary>
      <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter" /> should hold.</param>
    </member>
    <member name="T:NHibernate.SqlTypes.AnsiStringSqlType">
      <summary>
            Describes the details of a <see cref="F:System.Data.DbType.AnsiString" /> with the 
            information required to generate an <see cref="T:System.Data.IDbDataParameter" />.
            </summary>
      <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter" /> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter" /> correctly.
            </remarks>
    </member>
    <member name="M:NHibernate.SqlTypes.AnsiStringSqlType.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringSqlType" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.SqlTypes.AnsiStringSqlType.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringSqlType" /> class.
            </summary>
      <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter" /> should hold.</param>
    </member>
    <member name="T:NHibernate.SqlTypes.BinarySqlType">
      <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Binary" /> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter" />.
            </summary>
      <remarks>
            This can store the binary data that the <see cref="T:System.Data.IDbDataParameter" /> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter" /> correctly.
            </remarks>
    </member>
    <member name="M:NHibernate.SqlTypes.BinarySqlType.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.BinarySqlType" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.SqlTypes.BinarySqlType.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.BinarySqlType" /> class.
            </summary>
      <param name="length">The length of the binary data the <see cref="T:System.Data.IDbDataParameter" /> should hold</param>
    </member>
    <member name="T:NHibernate.SqlTypes.BinaryBlobSqlType">
      <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Binary" /> that is stored in
            a BLOB column with the information required to generate 
            an <see cref="T:System.Data.IDbDataParameter" />.
            </summary>
      <remarks>
        <p>
            This can store the length of the binary data that the <see cref="T:System.Data.IDbDataParameter" /> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter" /> correctly.
            </p>
        <p>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a 
            BinarySqlType would work just fine.
            </p>
      </remarks>
    </member>
    <member name="T:NHibernate.SqlTypes.SqlTypeFactory">
      <summary>
            SqlTypeFactory provides Singleton access to the SqlTypes.
            </summary>
    </member>
    <member name="T:NHibernate.SqlTypes.StringSqlType">
      <summary>
            Describes the details of a <see cref="F:System.Data.DbType.String" /> with the 
            information required to generate an <see cref="T:System.Data.IDbDataParameter" />.
            </summary>
      <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter" /> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter" /> correctly.
            </remarks>
    </member>
    <member name="M:NHibernate.SqlTypes.StringSqlType.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringSqlType" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.SqlTypes.StringSqlType.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringSqlType" /> class.
            </summary>
      <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter" /> should hold.</param>
    </member>
    <member name="T:NHibernate.SqlTypes.StringClobSqlType">
      <summary>
            Describes the details of a <see cref="F:System.Data.DbType.String" /> that is stored in
            a CLOB column with the information required to generate 
            an <see cref="T:System.Data.IDbDataParameter" />.
            </summary>
      <remarks>
        <p>
            This can store the length of the binary data that the <see cref="T:System.Data.IDbDataParameter" /> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter" /> correctly.
            </p>
        <p>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a 
            StringSqlType would work just fine.
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.SqlTypes.StringClobSqlType.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringClobSqlType" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.SqlTypes.StringClobSqlType.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringClobSqlType" /> class.
            </summary>
      <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter" /> should hold.</param>
    </member>
    <member name="T:NHibernate.SqlTypes.StringFixedLengthSqlType">
      <summary>
            Describes the details of a <see cref="F:System.Data.DbType.StringFixedLength" /> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter" />.
            </summary>
      <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter" /> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter" /> correctly.
            </remarks>
    </member>
    <member name="M:NHibernate.SqlTypes.StringFixedLengthSqlType.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringFixedLengthSqlType" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.SqlTypes.StringFixedLengthSqlType.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringFixedLengthSqlType" /> class.
            </summary>
      <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter" /> should hold.</param>
    </member>
    <member name="T:NHibernate.Stat.CategorizedStatistics">
      <summary> 
            Statistics for a particular "category" (a named entity,
            collection role, second level cache region or query). 
            </summary>
    </member>
    <member name="T:NHibernate.Stat.CollectionStatistics">
      <summary> Collection related statistics </summary>
    </member>
    <member name="T:NHibernate.Stat.EntityStatistics">
      <summary> Entity related statistics </summary>
    </member>
    <member name="T:NHibernate.Stat.ISessionStatistics">
      <summary> 
            Information about the first-level (session) cache for a particular session instance
            </summary>
    </member>
    <member name="P:NHibernate.Stat.ISessionStatistics.EntityCount">
      <summary> Get the number of entity instances associated with the session</summary>
    </member>
    <member name="P:NHibernate.Stat.ISessionStatistics.CollectionCount">
      <summary> Get the number of collection instances associated with the session</summary>
    </member>
    <member name="P:NHibernate.Stat.ISessionStatistics.EntityKeys">
      <summary> Get the set of all <see cref="T:NHibernate.Engine.EntityKey">EntityKeys</see>.</summary>
    </member>
    <member name="P:NHibernate.Stat.ISessionStatistics.CollectionKeys">
      <summary> Get the set of all <see cref="T:NHibernate.Engine.CollectionKey">CollectionKeys</see>.</summary>
    </member>
    <member name="T:NHibernate.Stat.IStatistics">
      <summary> 
            Statistics for a particular <see cref="T:NHibernate.ISessionFactory" />.
            Beware of metrics, they are dependent of the <see cref="T:System.Diagnostics.Stopwatch" /> precision:
            </summary>
    </member>
    <member name="M:NHibernate.Stat.IStatistics.Clear">
      <summary> Reset all statistics</summary>
    </member>
    <member name="M:NHibernate.Stat.IStatistics.GetEntityStatistics(System.String)">
      <summary> Find entity statistics per name </summary>
      <param name="entityName">entity name </param>
      <returns> EntityStatistics object </returns>
    </member>
    <member name="M:NHibernate.Stat.IStatistics.GetCollectionStatistics(System.String)">
      <summary> Get collection statistics per role </summary>
      <param name="role">collection role </param>
      <returns> CollectionStatistics </returns>
    </member>
    <member name="M:NHibernate.Stat.IStatistics.GetSecondLevelCacheStatistics(System.String)">
      <summary> Second level cache statistics per region </summary>
      <param name="regionName">region name </param>
      <returns> SecondLevelCacheStatistics </returns>
    </member>
    <member name="M:NHibernate.Stat.IStatistics.GetQueryStatistics(System.String)">
      <summary> Query statistics from query string (HQL or SQL) </summary>
      <param name="queryString">query string </param>
      <returns> QueryStatistics </returns>
    </member>
    <member name="M:NHibernate.Stat.IStatistics.LogSummary">
      <summary> log in info level the main statistics</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.EntityDeleteCount">
      <summary> Global number of entity deletes</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.EntityInsertCount">
      <summary> Global number of entity inserts</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.EntityLoadCount">
      <summary> Global number of entity loads</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.EntityFetchCount">
      <summary> Global number of entity fetchs</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.EntityUpdateCount">
      <summary> Global number of entity updates</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.QueryExecutionCount">
      <summary> Global number of executed queries</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.QueryExecutionMaxTime">
      <summary> The <see cref="T:System.TimeSpan" /> of the slowest query.</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.QueryExecutionMaxTimeQueryString">
      <summary> The query string for the slowest query.</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.QueryCacheHitCount">
      <summary> The global number of cached queries successfully retrieved from cache</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.QueryCacheMissCount">
      <summary> The global number of cached queries *not* found in cache</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.QueryCachePutCount">
      <summary> The global number of cacheable queries put in cache</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.FlushCount">
      <summary> Get the global number of flush executed by sessions (either implicit or explicit)</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.ConnectCount">
      <summary> 
            Get the global number of connections asked by the sessions
            (the actual number of connections used may be much smaller depending
            whether you use a connection pool or not)
            </summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.SecondLevelCacheHitCount">
      <summary> Global number of cacheable entities/collections successfully retrieved from the cache</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.SecondLevelCacheMissCount">
      <summary> Global number of cacheable entities/collections not found in the cache and loaded from the database.</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.SecondLevelCachePutCount">
      <summary> Global number of cacheable entities/collections put in the cache</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.SessionCloseCount">
      <summary> Global number of sessions closed</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.SessionOpenCount">
      <summary> Global number of sessions opened</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.CollectionLoadCount">
      <summary> Global number of collections loaded</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.CollectionFetchCount">
      <summary> Global number of collections fetched</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.CollectionUpdateCount">
      <summary> Global number of collections updated</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.CollectionRemoveCount">
      <summary> Global number of collections removed</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.CollectionRecreateCount">
      <summary> Global number of collections recreated</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.StartTime">
      <summary> Start time </summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.IsStatisticsEnabled">
      <summary> Enable/Disable statistics logs (this is a dynamic parameter)</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.Queries">
      <summary> All executed query strings</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.EntityNames">
      <summary> The names of all entities</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.CollectionRoleNames">
      <summary> The names of all collection roles</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.SecondLevelCacheRegionNames">
      <summary> Get all second-level cache region names</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.SuccessfulTransactionCount">
      <summary> The number of transactions we know to have been successful</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.TransactionCount">
      <summary> The number of transactions we know to have completed</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.PrepareStatementCount">
      <summary> The number of prepared statements that were acquired</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.CloseStatementCount">
      <summary> The number of prepared statements that were released</summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.OptimisticFailureCount">
      <summary> The number of <tt>StaleObjectStateException</tt>s  that occurred </summary>
    </member>
    <member name="P:NHibernate.Stat.IStatistics.OperationThreshold">
      <summary> 
            The OperationThreshold to a value greater than <see cref="F:System.TimeSpan.MinValue" /> to enable logging of long running operations.
            </summary>
      <remarks>Operations that exceed the level will be logged.</remarks>
    </member>
    <member name="T:NHibernate.Stat.IStatisticsImplementor">
      <summary> Statistics SPI for the NHibernate core </summary>
    </member>
    <member name="T:NHibernate.Stat.QueryStatistics">
      <summary> Query statistics (HQL and SQL) </summary>
      <remarks>Note that for a cached query, the cache miss is equals to the db count</remarks>
    </member>
    <member name="M:NHibernate.Stat.QueryStatistics.Executed(System.Int64,System.TimeSpan)">
      <summary> Add statistics report of a DB query </summary>
      <param name="rows">rows count returned </param>
      <param name="time">time taken </param>
    </member>
    <member name="T:NHibernate.Stat.SecondLevelCacheStatistics">
      <summary> Second level cache statistics of a specific region </summary>
    </member>
    <member name="P:NHibernate.Stat.SecondLevelCacheStatistics.ElementCountInMemory">
      <summary>
            Not ported yet
            </summary>
    </member>
    <member name="P:NHibernate.Stat.SecondLevelCacheStatistics.ElementCountOnDisk">
      <summary>
            Not ported yet
            </summary>
    </member>
    <member name="P:NHibernate.Stat.SecondLevelCacheStatistics.SizeInMemory">
      <summary>
            Not ported yet
            </summary>
    </member>
    <member name="P:NHibernate.Stat.SecondLevelCacheStatistics.Entries">
      <summary>
            Not ported yet
            </summary>
    </member>
    <member name="T:NHibernate.Tool.hbm2ddl.IConnectionHelper">
      <summary>
            Contract for delegates responsible for managing connection used by the hbm2ddl tools.
            </summary>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.IConnectionHelper.Prepare">
      <summary>
             Prepare the helper for use.
            </summary>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.IConnectionHelper.Release">
      <summary>
            Release any resources held by this helper.
            </summary>
    </member>
    <member name="P:NHibernate.Tool.hbm2ddl.IConnectionHelper.Connection">
      <summary>
            Get a reference to the connection we are using.
            </summary>
    </member>
    <member name="T:NHibernate.Tool.hbm2ddl.ManagedProviderConnectionHelper">
      <summary>
            A <seealso cref="T:NHibernate.Tool.hbm2ddl.IConnectionHelper" /> implementation based on an internally 
            built and managed <seealso cref="T:NHibernate.Connection.ConnectionProvider" />.
            </summary>
    </member>
    <member name="T:NHibernate.Tool.hbm2ddl.SchemaExport">
      <summary>
            Generates ddl to export table schema for a configured <c>Configuration</c> to the database
            </summary>
      <remarks>
            This Class can be used directly or the command line wrapper NHibernate.Tool.hbm2ddl.exe can be
            used when a dll can not be directly used.
            </remarks>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.#ctor(NHibernate.Cfg.Configuration)">
      <summary>
            Create a schema exported for a given Configuration
            </summary>
      <param name="cfg">The NHibernate Configuration to generate the schema from.</param>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.#ctor(NHibernate.Cfg.Configuration,System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Create a schema exporter for the given Configuration, with the given
            database connection properties
            </summary>
      <param name="cfg">The NHibernate Configuration to generate the schema from.</param>
      <param name="configProperties">The Properties to use when connecting to the Database.</param>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.SetOutputFile(System.String)">
      <summary>
            Set the output filename. The generated script will be written to this file
            </summary>
      <param name="filename">The name of the file to output the ddl to.</param>
      <returns>The SchemaExport object.</returns>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.SetDelimiter(System.String)">
      <summary>
            Set the end of statement delimiter 
            </summary>
      <param name="delimiter">The end of statement delimiter.</param>
      <returns>The SchemaExport object.</returns>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Create(System.Boolean,System.Boolean)">
      <summary>
            Run the schema creation script
            </summary>
      <param name="script">
        <see langword="true" /> if the ddl should be outputted in the Console.</param>
      <param name="export">
        <see langword="true" /> if the ddl should be executed against the Database.</param>
      <remarks>
            This is a convenience method that calls <see cref="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean)" /> and sets
            the justDrop parameter to false.
            </remarks>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Drop(System.Boolean,System.Boolean)">
      <summary>
            Run the drop schema script
            </summary>
      <param name="script">
        <see langword="true" /> if the ddl should be outputted in the Console.</param>
      <param name="export">
        <see langword="true" /> if the ddl should be executed against the Database.</param>
      <remarks>
            This is a convenience method that calls <see cref="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean)" /> and sets
            the justDrop parameter to true.
            </remarks>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean,System.Data.IDbConnection,System.IO.TextWriter)">
      <summary>
            Executes the Export of the Schema in the given connection
            </summary>
      <param name="script">
        <see langword="true" /> if the ddl should be outputted in the Console.</param>
      <param name="export">
        <see langword="true" /> if the ddl should be executed against the Database.</param>
      <param name="justDrop">
        <see langword="true" /> if only the ddl to drop the Database objects should be executed.</param>
      <param name="connection">
            The connection to use when executing the commands when export is <see langword="true" />.
            Must be an opened connection. The method doesn't close the connection.
            </param>
      <param name="exportOutput">The writer used to output the generated schema</param>
      <remarks>
            This method allows for both the drop and create ddl script to be executed.
            This overload is provided mainly to enable use of in memory databases. 
            It does NOT close the given connection!
            </remarks>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Executes the Export of the Schema.
            </summary>
      <param name="script">
        <see langword="true" /> if the ddl should be outputted in the Console.</param>
      <param name="export">
        <see langword="true" /> if the ddl should be executed against the Database.</param>
      <param name="justDrop">
        <see langword="true" /> if only the ddl to drop the Database objects should be executed.</param>
      <remarks>
            This method allows for both the drop and create ddl script to be executed.
            </remarks>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.SchemaUpdate.Execute(System.Boolean,System.Boolean)">
      <summary>
            Execute the schema updates
            </summary>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.SchemaUpdate.Execute(System.Action{System.String},System.Boolean)">
      <summary>
            Execute the schema updates
            </summary>
      <param name="scriptAction">The action to write the each schema line.</param>
      <param name="doUpdate">Commit the script to DB</param>
    </member>
    <member name="P:NHibernate.Tool.hbm2ddl.SchemaUpdate.Exceptions">
      <summary>
             Returns a List of all Exceptions which occured during the export.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Tool.hbm2ddl.SchemaValidator.Validate">
            Perform the validations.
        </member>
    <member name="T:NHibernate.Tool.hbm2ddl.SuppliedConnectionHelper">
      <summary>
            A <seealso cref="T:NHibernate.Tool.hbm2ddl.IConnectionHelper" /> implementation based on an explicitly supplied
            connection.
            </summary>
    </member>
    <member name="T:NHibernate.Tool.hbm2ddl.SuppliedConnectionProviderConnectionHelper">
      <summary>
            A <seealso cref="T:NHibernate.Tool.hbm2ddl.IConnectionHelper" /> implementation based on a provided
            <seealso cref="T:NHibernate.Connection.IConnectionProvider" />.  Essentially, ensures that the connection
            gets cleaned up, but that the provider itself remains usable since it
            was externally provided to us.
            </summary>
    </member>
    <member name="T:NHibernate.Transaction.ITransactionFactory">
      <summary>
            An abstract factory for <see cref="T:NHibernate.ITransaction" /> instances.
            Concrete implementations are specified by <c>transaction.factory_class</c> 
            configuration property.
            
            Implementors must be threadsafe and should declare a public default constructor. 
            <seealso cref="T:NHibernate.Transaction.ITransactionContext" /></summary>
    </member>
    <member name="M:NHibernate.Transaction.ITransactionFactory.Configure(System.Collections.IDictionary)">
      <summary>
            Configure from the given properties
            </summary>
      <param name="props">
      </param>
    </member>
    <member name="M:NHibernate.Transaction.ITransactionFactory.CreateTransaction(NHibernate.Engine.ISessionImplementor)">
      <summary>
            Create a new transaction and return it without starting it.
            </summary>
    </member>
    <member name="T:NHibernate.Transaction.ITransactionContext">
      <summary>
            This is used as a marker interface for the different 
            transaction context required for each session
            </summary>
    </member>
    <member name="T:NHibernate.ITransaction">
      <summary>
            Allows the application to define units of work, while maintaining abstraction from the
            underlying transaction implementation
            </summary>
      <remarks>
            A transaction is associated with a <c>ISession</c> and is usually instanciated by a call to
            <c>ISession.BeginTransaction()</c>. A single session might span multiple transactions since 
            the notion of a session (a conversation between the application and the datastore) is of
            coarser granularity than the notion of a transaction. However, it is intended that there be
            at most one uncommitted <c>ITransaction</c> associated with a particular <c>ISession</c>
            at a time. Implementors are not intended to be threadsafe.
            </remarks>
    </member>
    <member name="M:NHibernate.ITransaction.Begin">
      <summary>
            Begin the transaction with the default isolation level.
            </summary>
    </member>
    <member name="M:NHibernate.ITransaction.Begin(System.Data.IsolationLevel)">
      <summary>
            Begin the transaction with the specified isolation level.
            </summary>
      <param name="isolationLevel">Isolation level of the transaction</param>
    </member>
    <member name="M:NHibernate.ITransaction.Commit">
      <summary>
            Flush the associated <c>ISession</c> and end the unit of work.
            </summary>
      <remarks>
            This method will commit the underlying transaction if and only if the transaction
            was initiated by this object.
            </remarks>
    </member>
    <member name="M:NHibernate.ITransaction.Rollback">
      <summary>
            Force the underlying transaction to roll back.
            </summary>
    </member>
    <member name="M:NHibernate.ITransaction.Enlist(System.Data.IDbCommand)">
      <summary>
            Enlist the <see cref="T:System.Data.IDbCommand" /> in the current Transaction.
            </summary>
      <param name="command">The <see cref="T:System.Data.IDbCommand" /> to enlist.</param>
      <remarks>
            It is okay for this to be a no op implementation.
            </remarks>
    </member>
    <member name="M:NHibernate.ITransaction.RegisterSynchronization(NHibernate.Transaction.ISynchronization)">
      <summary>
            Register a user synchronization callback for this transaction.
            </summary>
      <param name="synchronization">The <see cref="T:NHibernate.Transaction.ISynchronization" /> callback to register.</param>
    </member>
    <member name="P:NHibernate.ITransaction.IsActive">
      <summary>
            Is the transaction in progress
            </summary>
    </member>
    <member name="P:NHibernate.ITransaction.WasRolledBack">
      <summary>
            Was the transaction rolled back or set to rollback only?
            </summary>
    </member>
    <member name="P:NHibernate.ITransaction.WasCommitted">
      <summary>
            Was the transaction successfully committed?
            </summary>
      <remarks>
            This method could return <see langword="false" /> even after successful invocation of <c>Commit()</c></remarks>
    </member>
    <member name="T:NHibernate.Transaction.AdoTransaction">
      <summary>
            Wraps an ADO.NET <see cref="T:System.Data.IDbTransaction" /> to implement
            the <see cref="T:NHibernate.ITransaction" /> interface.
            </summary>
    </member>
    <member name="F:NHibernate.Transaction.AdoTransaction._isAlreadyDisposed">
      <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
    </member>
    <member name="M:NHibernate.Transaction.AdoTransaction.#ctor(NHibernate.Engine.ISessionImplementor)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Transaction.AdoTransaction" /> class.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> the Transaction is for.</param>
    </member>
    <member name="M:NHibernate.Transaction.AdoTransaction.Enlist(System.Data.IDbCommand)">
      <summary>
            Enlist the <see cref="T:System.Data.IDbCommand" /> in the current <see cref="T:NHibernate.ITransaction" />.
            </summary>
      <param name="command">The <see cref="T:System.Data.IDbCommand" /> to enlist in this Transaction.</param>
      <remarks>
        <para>
            This takes care of making sure the <see cref="T:System.Data.IDbCommand" />'s Transaction property 
            contains the correct <see cref="T:System.Data.IDbTransaction" /> or <see langword="null" /> if there is no
            Transaction for the ISession - ie <c>BeginTransaction()</c> not called.
            </para>
        <para>
            This method may be called even when the transaction is disposed.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Transaction.AdoTransaction.Begin(System.Data.IsolationLevel)">
      <summary>
            Begins the <see cref="T:System.Data.IDbTransaction" /> on the <see cref="T:System.Data.IDbConnection" />
            used by the <see cref="T:NHibernate.ISession" />.
            </summary>
      <exception cref="T:NHibernate.TransactionException">
            Thrown if there is any problems encountered while trying to create
            the <see cref="T:System.Data.IDbTransaction" />.
            </exception>
    </member>
    <member name="M:NHibernate.Transaction.AdoTransaction.Commit">
      <summary>
            Commits the <see cref="T:NHibernate.ITransaction" /> by flushing the <see cref="T:NHibernate.ISession" />
            and committing the <see cref="T:System.Data.IDbTransaction" />.
            </summary>
      <exception cref="T:NHibernate.TransactionException">
            Thrown if there is any exception while trying to call <c>Commit()</c> on 
            the underlying <see cref="T:System.Data.IDbTransaction" />.
            </exception>
    </member>
    <member name="M:NHibernate.Transaction.AdoTransaction.Rollback">
      <summary>
            Rolls back the <see cref="T:NHibernate.ITransaction" /> by calling the method <c>Rollback</c> 
            on the underlying <see cref="T:System.Data.IDbTransaction" />.
            </summary>
      <exception cref="T:NHibernate.TransactionException">
            Thrown if there is any exception while trying to call <c>Rollback()</c> on 
            the underlying <see cref="T:System.Data.IDbTransaction" />.
            </exception>
    </member>
    <member name="M:NHibernate.Transaction.AdoTransaction.Finalize">
      <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
    </member>
    <member name="M:NHibernate.Transaction.AdoTransaction.Dispose">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
    </member>
    <member name="M:NHibernate.Transaction.AdoTransaction.Dispose(System.Boolean)">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
      <param name="isDisposing">Indicates if this AdoTransaction is being Disposed of or Finalized.</param>
      <remarks>
            If this AdoTransaction is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this AdoTransaction back to life.
            </remarks>
    </member>
    <member name="P:NHibernate.Transaction.AdoTransaction.WasRolledBack">
      <summary>
            Gets a <see cref="T:System.Boolean" /> indicating if the transaction was rolled back.
            </summary>
      <value>
        <see langword="true" /> if the <see cref="T:System.Data.IDbTransaction" /> had <c>Rollback</c> called
            without any exceptions.
            </value>
    </member>
    <member name="P:NHibernate.Transaction.AdoTransaction.WasCommitted">
      <summary>
            Gets a <see cref="T:System.Boolean" /> indicating if the transaction was committed.
            </summary>
      <value>
        <see langword="true" /> if the <see cref="T:System.Data.IDbTransaction" /> had <c>Commit</c> called
            without any exceptions.
            </value>
    </member>
    <member name="T:NHibernate.Transaction.ISynchronization">
      <summary>
            A mimic to the javax.transaction.Synchronization callback to enable <see cref="M:NHibernate.ITransaction.RegisterSynchronization(NHibernate.Transaction.ISynchronization)" /></summary>
    </member>
    <member name="T:NHibernate.Transform.IResultTransformer">
      <summary>
            Implementors define a strategy for transforming criteria query
            results into the actual application-visible query result list.
            </summary>
      <seealso cref="M:NHibernate.ICriteria.SetResultTransformer(NHibernate.Transform.IResultTransformer)" />
    </member>
    <member name="M:NHibernate.Transform.IResultTransformer.TransformTuple(System.Object[],System.String[])">
      <summary>
      </summary>
      <param name="tuple">
      </param>
      <param name="aliases">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Transform.IResultTransformer.TransformList(System.Collections.IList)">
      <summary>
      </summary>
      <param name="collection">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Transform.AliasToBeanResultTransformer">
      <summary>
            Result transformer that allows to transform a result to 
            a user specified class which will be populated via setter  
            methods or fields matching the alias names. 
            </summary>
      <example>
        <code>
            IList resultWithAliasedBean = s.CreateCriteria(typeof(Enrollment))
            			.CreateAlias("Student", "st")
            			.CreateAlias("Course", "co")
            			.SetProjection( Projections.ProjectionList()
            					.Add( Projections.Property("co.Description"), "CourseDescription" )
            			)
            			.SetResultTransformer( new AliasToBeanResultTransformer(typeof(StudentDTO)) )
            			.List();
            
            StudentDTO dto = (StudentDTO)resultWithAliasedBean[0];
            </code>
      </example>
    </member>
    <member name="T:NHibernate.Transform.ToListResultTransformer">
      <summary> 
            Tranforms each result row from a tuple into a <see cref="T:System.Collections.IList" />, such that what
            you end up with is a <see cref="T:System.Collections.IList" /> of <see cref="T:System.Collections.IList" />.
            </summary>
    </member>
    <member name="F:NHibernate.Transform.Transformers.AliasToEntityMap">
      <summary>
            Each row of results is a map (<see cref="T:System.Collections.IDictionary" />) from alias to values/entities
            </summary>
    </member>
    <member name="F:NHibernate.Transform.Transformers.ToList">
      <summary> Each row of results is a <see cref="T:System.Collections.IList" /></summary>
    </member>
    <member name="M:NHibernate.Transform.Transformers.AliasToBean(System.Type)">
      <summary>
            Creates a resulttransformer that will inject aliased values into instances
            of <paramref name="target" /> via property methods or fields.
            </summary>
    </member>
    <member name="T:NHibernate.Tuple.ITuplizer">
      <summary> 
            A tuplizer defines the contract for things which know how to manage
            a particular representation of a piece of data, given that
            representation's <see cref="T:NHibernate.EntityMode" /> (the entity-mode
            essentially defining which representation).
            </summary>
      <remarks>
            If that given piece of data is thought of as a data structure, then a tuplizer
            is the thing which knows how to:
            <list type="bullet"><item><description>create such a data structure appropriately</description></item><item><description>extract values from and inject values into such a data structure</description></item></list><para />
            For example, a given piece of data might be represented as a POCO class.
            Here, it's representation and entity-mode is POCO.  Well a tuplizer for POCO
            entity-modes would know how to:
            <list type="bullet"><item><description>create the data structure by calling the POCO's constructor</description></item><item><description>extract and inject values through getters/setter, or by direct field access, etc</description></item></list><para />
            That same piece of data might also be represented as a DOM structure, using
            the tuplizer associated with the XML entity-mode, which would generate instances
            of <see cref="T:System.Xml.XmlElement" /> as the data structure and know how to access the
            values as either nested <see cref="T:System.Xml.XmlElement" />s or as <see cref="T:System.Xml.XmlAttribute" />s.
            </remarks>
      <seealso cref="T:NHibernate.Tuple.Entity.IEntityTuplizer" />
      <seealso cref="T:NHibernate.Tuple.Component.IComponentTuplizer" />
    </member>
    <member name="M:NHibernate.Tuple.ITuplizer.GetPropertyValues(System.Object)">
      <summary> 
            Extract the current values contained on the given entity. 
            </summary>
      <param name="entity">The entity from which to extract values. </param>
      <returns> The current property values. </returns>
      <throws>  HibernateException </throws>
    </member>
    <member name="M:NHibernate.Tuple.ITuplizer.SetPropertyValues(System.Object,System.Object[])">
      <summary> Inject the given values into the given entity. </summary>
      <param name="entity">The entity. </param>
      <param name="values">The values to be injected. </param>
    </member>
    <member name="M:NHibernate.Tuple.ITuplizer.GetPropertyValue(System.Object,System.Int32)">
      <summary> Extract the value of a particular property from the given entity. </summary>
      <param name="entity">The entity from which to extract the property value. </param>
      <param name="i">The index of the property for which to extract the value. </param>
      <returns> The current value of the given property on the given entity. </returns>
    </member>
    <member name="M:NHibernate.Tuple.ITuplizer.Instantiate">
      <summary> Generate a new, empty entity. </summary>
      <returns> The new, empty entity instance. </returns>
    </member>
    <member name="M:NHibernate.Tuple.ITuplizer.IsInstance(System.Object)">
      <summary> 
            Is the given object considered an instance of the the entity (acconting
            for entity-mode) managed by this tuplizer. 
            </summary>
      <param name="obj">The object to be checked. </param>
      <returns> True if the object is considered as an instance of this entity within the given mode. </returns>
    </member>
    <member name="P:NHibernate.Tuple.ITuplizer.MappedClass">
      <summary> 
            Return the pojo class managed by this tuplizer.
            </summary>
      <returns> The persistent class. </returns>
      <remarks>
            Need to determine how to best handle this for the Tuplizers for EntityModes
            other than POCO.
            </remarks>
    </member>
    <member name="T:NHibernate.Tuple.Component.IComponentTuplizer">
      <summary> 
            Defines further responsibilities regarding tuplization based on
            a mapped components.
            </summary>
      <remarks>
            ComponentTuplizer implementations should have the following constructor signature:
            (org.hibernate.mapping.Component)
            </remarks>
    </member>
    <member name="M:NHibernate.Tuple.Component.IComponentTuplizer.GetParent(System.Object)">
      <summary> Retrieve the current value of the parent property. </summary>
      <param name="component">
            The component instance from which to extract the parent property value. 
            </param>
      <returns> The current value of the parent property. </returns>
    </member>
    <member name="M:NHibernate.Tuple.Component.IComponentTuplizer.SetParent(System.Object,System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary> Set the value of the parent property. </summary>
      <param name="component">The component instance on which to set the parent. </param>
      <param name="parent">The parent to be set on the component. </param>
      <param name="factory">The current session factory. </param>
    </member>
    <member name="P:NHibernate.Tuple.Component.IComponentTuplizer.HasParentProperty">
      <summary> Does the component managed by this tuuplizer contain a parent property? </summary>
      <returns> True if the component does contain a parent property; false otherwise. </returns>
    </member>
    <member name="T:NHibernate.Tuple.Component.AbstractComponentTuplizer">
      <summary> Support for tuplizers relating to components. </summary>
    </member>
    <member name="M:NHibernate.Tuple.Component.AbstractComponentTuplizer.Instantiate">
      <summary> This method does not populate the component parent</summary>
    </member>
    <member name="T:NHibernate.Tuple.EntityModeToTuplizerMapping">
      <summary> Centralizes handling of <see cref="T:NHibernate.EntityMode" /> to <see cref="T:NHibernate.Tuple.ITuplizer" /> mappings. </summary>
    </member>
    <member name="M:NHibernate.Tuple.EntityModeToTuplizerMapping.GuessEntityMode(System.Object)">
      <summary> Given a supposed instance of an entity/component, guess its entity mode. </summary>
      <param name="obj">The supposed instance of the entity/component.</param>
      <returns> The guessed entity mode. </returns>
    </member>
    <member name="M:NHibernate.Tuple.EntityModeToTuplizerMapping.GetTuplizerOrNull(NHibernate.EntityMode)">
      <summary> 
            Locate the contained tuplizer responsible for the given entity-mode.  If
            no such tuplizer is defined on this mapping, then return null. 
            </summary>
      <param name="entityMode">The entity-mode for which the caller wants a tuplizer. </param>
      <returns> The tuplizer, or null if not found. </returns>
    </member>
    <member name="M:NHibernate.Tuple.EntityModeToTuplizerMapping.GetTuplizer(NHibernate.EntityMode)">
      <summary> Locate the tuplizer contained within this mapping which is responsible
            for the given entity-mode.  If no such tuplizer is defined on this
            mapping, then an exception is thrown.
            
            </summary>
      <param name="entityMode">The entity-mode for which the caller wants a tuplizer.
            </param>
      <returns> The tuplizer.
            </returns>
      <throws>  HibernateException Unable to locate the requested tuplizer. </throws>
    </member>
    <member name="T:NHibernate.Tuple.Component.ComponentEntityModeToTuplizerMapping">
      <summary> 
            Handles mapping <see cref="T:NHibernate.EntityMode" />s to <see cref="T:NHibernate.Tuple.Component.IComponentTuplizer">ComponentTuplizers</see>.
            <p />
            Most of the handling is really in the super class; here we just create
            the tuplizers and add them to the superclass
            </summary>
    </member>
    <member name="T:NHibernate.Tuple.Component.ComponentMetamodel">
      <summary> Centralizes metamodel information about a component. </summary>
    </member>
    <member name="T:NHibernate.Tuple.Component.DynamicMapComponentTuplizer">
      <summary> 
            A <see cref="T:NHibernate.Tuple.Component.IComponentTuplizer" /> specific to the dynamic-map entity mode. 
            </summary>
    </member>
    <member name="T:NHibernate.Tuple.Component.PocoComponentTuplizer">
      <summary> 
            A <see cref="T:NHibernate.Tuple.Component.IComponentTuplizer" /> specific to the POCO entity mode. 
            </summary>
    </member>
    <member name="T:NHibernate.Tuple.Entity.IEntityTuplizer">
      <summary> 
            Defines further responsibilities regarding tuplization based on a mapped entity.
            </summary>
      <remarks>
            EntityTuplizer implementations should have the following constructor signature:
            (<see cref="T:NHibernate.Tuple.Entity.EntityMetamodel" />, <see cref="T:NHibernate.Mapping.PersistentClass" />)
            </remarks>
    </member>
    <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.Instantiate(System.Object)">
      <summary> Create an entity instance initialized with the given identifier. </summary>
      <param name="id">The identifier value for the entity to be instantiated. </param>
      <returns> The instantiated entity. </returns>
    </member>
    <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.GetIdentifier(System.Object)">
      <summary> Extract the identifier value from the given entity. </summary>
      <param name="entity">The entity from which to extract the identifier value. </param>
      <returns> The identifier value. </returns>
    </member>
    <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.SetIdentifier(System.Object,System.Object)">
      <summary> 
            Inject the identifier value into the given entity.
            </summary>
      <param name="entity">The entity to inject with the identifier value.</param>
      <param name="id">The value to be injected as the identifier. </param>
      <remarks>Has no effect if the entity does not define an identifier property</remarks>
    </member>
    <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.ResetIdentifier(System.Object,System.Object,System.Object)">
      <summary> 
            Inject the given identifier and version into the entity, in order to
            "roll back" to their original values. 
            </summary>
      <param name="entity">
      </param>
      <param name="currentId">The identifier value to inject into the entity. </param>
      <param name="currentVersion">The version value to inject into the entity. </param>
    </member>
    <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.GetVersion(System.Object)">
      <summary> Extract the value of the version property from the given entity. </summary>
      <param name="entity">The entity from which to extract the version value. </param>
      <returns> The value of the version property, or null if not versioned. </returns>
    </member>
    <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.SetPropertyValue(System.Object,System.Int32,System.Object)">
      <summary> Inject the value of a particular property. </summary>
      <param name="entity">The entity into which to inject the value. </param>
      <param name="i">The property's index. </param>
      <param name="value">The property value to inject. </param>
    </member>
    <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.SetPropertyValue(System.Object,System.String,System.Object)">
      <summary> Inject the value of a particular property. </summary>
      <param name="entity">The entity into which to inject the value. </param>
      <param name="propertyName">The name of the property. </param>
      <param name="value">The property value to inject. </param>
    </member>
    <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.GetPropertyValuesToInsert(System.Object,System.Collections.IDictionary,NHibernate.Engine.ISessionImplementor)">
      <summary> Extract the values of the insertable properties of the entity (including backrefs) </summary>
      <param name="entity">The entity from which to extract. </param>
      <param name="mergeMap">a map of instances being merged to merged instances </param>
      <param name="session">The session in which the resuest is being made. </param>
      <returns> The insertable property values. </returns>
    </member>
    <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.GetPropertyValue(System.Object,System.String)">
      <summary> Extract the value of a particular property from the given entity. </summary>
      <param name="entity">The entity from which to extract the property value. </param>
      <param name="propertyName">The name of the property for which to extract the value. </param>
      <returns> The current value of the given property on the given entity. </returns>
    </member>
    <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.AfterInitialize(System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
      <summary> Called just after the entities properties have been initialized. </summary>
      <param name="entity">The entity being initialized. </param>
      <param name="lazyPropertiesAreUnfetched">Are defined lazy properties currently unfecthed </param>
      <param name="session">The session initializing this entity. </param>
    </member>
    <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.CreateProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Generates an appropriate proxy representation of this entity for this entity-mode.
             </summary>
      <param name="id">The id of the instance for which to generate a proxy. </param>
      <param name="session">The session to which the proxy should be bound. </param>
      <returns> The generate proxies. </returns>
    </member>
    <member name="M:NHibernate.Tuple.Entity.IEntityTuplizer.HasUninitializedLazyProperties(System.Object)">
      <summary> Does the given entity instance have any currently uninitialized lazy properties? </summary>
      <param name="entity">The entity to be check for uninitialized lazy properties. </param>
      <returns> True if uninitialized lazy properties were found; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Tuple.Entity.IEntityTuplizer.IsLifecycleImplementor">
      <summary> 
            Does the <see cref="P:NHibernate.Tuple.ITuplizer.MappedClass">class</see> managed by this tuplizer implement
            the <see cref="T:NHibernate.Classic.ILifecycle" /> interface. 
            </summary>
      <returns> True if the ILifecycle interface is implemented; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Tuple.Entity.IEntityTuplizer.IsValidatableImplementor">
      <summary> 
            Does the <see cref="P:NHibernate.Tuple.ITuplizer.MappedClass">class</see> managed by this tuplizer implement
            the <see cref="T:NHibernate.Classic.IValidatable" /> interface. 
            </summary>
      <returns> True if the IValidatable interface is implemented; false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Tuple.Entity.IEntityTuplizer.ConcreteProxyClass">
      <summary> Returns the java class to which generated proxies will be typed. </summary>
      <returns> The .NET class to which generated proxies will be typed </returns>
    </member>
    <member name="P:NHibernate.Tuple.Entity.IEntityTuplizer.IsInstrumented">
      <summary> Is it an instrumented POCO?</summary>
    </member>
    <member name="P:NHibernate.Tuple.Entity.IEntityTuplizer.HasProxy">
      <summary> Does this entity, for this mode, present a possibility for proxying? </summary>
      <value> True if this tuplizer can generate proxies for this entity. </value>
    </member>
    <member name="T:NHibernate.Tuple.Entity.AbstractEntityTuplizer">
      <summary> Support for tuplizers relating to entities. </summary>
    </member>
    <member name="M:NHibernate.Tuple.Entity.AbstractEntityTuplizer.#ctor(NHibernate.Tuple.Entity.EntityMetamodel,NHibernate.Mapping.PersistentClass)">
      <summary> Constructs a new AbstractEntityTuplizer instance. </summary>
      <param name="entityMetamodel">The "interpreted" information relating to the mapped entity. </param>
      <param name="mappingInfo">The parsed "raw" mapping data relating to the given entity. </param>
    </member>
    <member name="M:NHibernate.Tuple.Entity.AbstractEntityTuplizer.BuildPropertyGetter(NHibernate.Mapping.Property,NHibernate.Mapping.PersistentClass)">
      <summary> Build an appropriate Getter for the given property. </summary>
      <param name="mappedProperty">The property to be accessed via the built Getter. </param>
      <param name="mappedEntity">The entity information regarding the mapped entity owning this property. </param>
      <returns> An appropriate Getter instance. </returns>
    </member>
    <member name="M:NHibernate.Tuple.Entity.AbstractEntityTuplizer.BuildPropertySetter(NHibernate.Mapping.Property,NHibernate.Mapping.PersistentClass)">
      <summary> Build an appropriate Setter for the given property. </summary>
      <param name="mappedProperty">The property to be accessed via the built Setter. </param>
      <param name="mappedEntity">The entity information regarding the mapped entity owning this property. </param>
      <returns> An appropriate Setter instance. </returns>
    </member>
    <member name="M:NHibernate.Tuple.Entity.AbstractEntityTuplizer.BuildInstantiator(NHibernate.Mapping.PersistentClass)">
      <summary> Build an appropriate Instantiator for the given mapped entity. </summary>
      <param name="mappingInfo">The mapping information regarding the mapped entity. </param>
      <returns> An appropriate Instantiator instance. </returns>
    </member>
    <member name="M:NHibernate.Tuple.Entity.AbstractEntityTuplizer.BuildProxyFactory(NHibernate.Mapping.PersistentClass,NHibernate.Properties.IGetter,NHibernate.Properties.ISetter)">
      <summary> Build an appropriate ProxyFactory for the given mapped entity. </summary>
      <param name="mappingInfo">The mapping information regarding the mapped entity. </param>
      <param name="idGetter">The constructed Getter relating to the entity's id property. </param>
      <param name="idSetter">The constructed Setter relating to the entity's id property. </param>
      <returns> An appropriate ProxyFactory instance. </returns>
    </member>
    <member name="M:NHibernate.Tuple.Entity.AbstractEntityTuplizer.GetComponentValue(NHibernate.Type.ComponentType,System.Object,System.String)">
      <summary> Extract a component property value. </summary>
      <param name="type">The component property types. </param>
      <param name="component">The component instance itself. </param>
      <param name="propertyPath">The property path for the property to be extracted. </param>
      <returns> The property value extracted. </returns>
    </member>
    <member name="P:NHibernate.Tuple.Entity.AbstractEntityTuplizer.EntityMode">
      <summary> Return the entity-mode handled by this tuplizer instance. </summary>
    </member>
    <member name="P:NHibernate.Tuple.Entity.AbstractEntityTuplizer.EntityName">
      <summary>Retrieves the defined entity-name for the tuplized entity. </summary>
    </member>
    <member name="P:NHibernate.Tuple.Entity.AbstractEntityTuplizer.SubclassEntityNames">
      <summary> 
            Retrieves the defined entity-names for any subclasses defined for this entity. 
            </summary>
    </member>
    <member name="T:NHibernate.Tuple.Entity.EntityEntityModeToTuplizerMapping">
      <summary> 
            Handles mapping <see cref="T:NHibernate.EntityMode" />s to <see cref="T:NHibernate.Tuple.Entity.IEntityTuplizer" />s.
            </summary>
      <remarks>
            Most of the handling is really in the super class; here we just create
            the tuplizers and add them to the superclass
            </remarks>
    </member>
    <member name="M:NHibernate.Tuple.Entity.EntityEntityModeToTuplizerMapping.#ctor(NHibernate.Mapping.PersistentClass,NHibernate.Tuple.Entity.EntityMetamodel)">
      <summary> 
            Instantiates a EntityEntityModeToTuplizerMapping based on the given
            entity mapping and metamodel definitions. 
            </summary>
      <param name="mappedEntity">The entity mapping definition. </param>
      <param name="em">The entity metamodel definition. </param>
    </member>
    <member name="T:NHibernate.Tuple.Entity.PocoEntityTuplizer">
      <summary> An <see cref="T:NHibernate.Tuple.Entity.IEntityTuplizer" /> specific to the POCO entity mode. </summary>
    </member>
    <member name="T:NHibernate.Tuple.IInstantiator">
      <summary> Contract for implementors responsible for instantiating entity/component instances. </summary>
    </member>
    <member name="M:NHibernate.Tuple.IInstantiator.Instantiate(System.Object)">
      <summary> Perform the requested entity instantiation. </summary>
      <param name="id">The id of the entity to be instantiated. </param>
      <returns> An appropriately instantiated entity. </returns>
      <remarks>This form is never called for component instantiation, only entity instantiation.</remarks>
    </member>
    <member name="M:NHibernate.Tuple.IInstantiator.Instantiate">
      <summary> Perform the requested instantiation. </summary>
      <returns> The instantiated data structure.  </returns>
    </member>
    <member name="M:NHibernate.Tuple.IInstantiator.IsInstance(System.Object)">
      <summary> 
            Performs check to see if the given object is an instance of the entity
            or component which this Instantiator instantiates. 
            </summary>
      <param name="obj">The object to be checked. </param>
      <returns> True is the object does represent an instance of the underlying entity/component. </returns>
    </member>
    <member name="T:NHibernate.Tuple.Property">
      <summary>
            Defines the basic contract of a Property within the runtime metamodel.
            </summary>
    </member>
    <member name="M:NHibernate.Tuple.Property.#ctor(System.String,System.String,NHibernate.Type.IType)">
      <summary>
            Constructor for Property instances.
            </summary>
      <param name="name">The name by which the property can be referenced within its owner.</param>
      <param name="node">The node name to use for XML-based representation of this property.</param>
      <param name="type">The Hibernate Type of this property.</param>
    </member>
    <member name="T:NHibernate.Tuple.IdentifierProperty">
      <summary>
            Represents a defined entity identifier property within the Hibernate
            runtime-metamodel.
            </summary>
      <remarks>
            Author: Steve Ebersole
            </remarks>
    </member>
    <member name="M:NHibernate.Tuple.IdentifierProperty.#ctor(System.String,System.String,NHibernate.Type.IType,System.Boolean,NHibernate.Engine.IdentifierValue,NHibernate.Id.IIdentifierGenerator)">
      <summary>
            Construct a non-virtual identifier property. 
            </summary>
      <param name="name">The name of the property representing the identifier within
            its owning entity.</param>
      <param name="node">The node name to use for XML-based representation of this
            property.</param>
      <param name="type">The Hibernate Type for the identifier property.</param>
      <param name="embedded">Is this an embedded identifier.</param>
      <param name="unsavedValue">The value which, if found as the value on the identifier
            property, represents new (i.e., un-saved) instances of the owning entity.</param>
      <param name="identifierGenerator">The generator to use for id value generation.</param>
    </member>
    <member name="M:NHibernate.Tuple.IdentifierProperty.#ctor(NHibernate.Type.IType,System.Boolean,System.Boolean,NHibernate.Engine.IdentifierValue,NHibernate.Id.IIdentifierGenerator)">
      <summary>
            Construct a virtual IdentifierProperty. 
            </summary>
      <param name="type">The Hibernate Type for the identifier property.</param>
      <param name="embedded">Is this an embedded identifier.</param>
      <param name="unsavedValue">The value which, if found as the value on the identifier
            property, represents new (i.e., un-saved) instances of the owning entity.</param>
      <param name="identifierGenerator">The generator to use for id value generation.</param>
      <param name="hasIdentifierMapper">
      </param>
    </member>
    <member name="T:NHibernate.Tuple.PocoInstantiator">
      <summary> Defines a POCO-based instantiator for use from the tuplizers.</summary>
    </member>
    <member name="T:NHibernate.Tuple.PropertyFactory">
      <summary>
            Responsible for generation of runtime metamodel <see cref="T:NHibernate.Tuple.Property" /> representations.
            Makes distinction between identifier, version, and other (standard) properties.
            </summary>
      <remarks>
            Author: Steve Ebersole
            </remarks>
    </member>
    <member name="M:NHibernate.Tuple.PropertyFactory.BuildIdentifierProperty(NHibernate.Mapping.PersistentClass,NHibernate.Id.IIdentifierGenerator)">
      <summary>
            Generates an IdentifierProperty representation of the for a given entity mapping.
            </summary>
      <param name="mappedEntity">The mapping definition of the entity.</param>
      <param name="generator">The identifier value generator to use for this identifier.</param>
      <returns>The appropriate IdentifierProperty definition.</returns>
    </member>
    <member name="M:NHibernate.Tuple.PropertyFactory.BuildVersionProperty(NHibernate.Mapping.Property,System.Boolean)">
      <summary>
            Generates a VersionProperty representation for an entity mapping given its
            version mapping Property.
            </summary>
      <param name="property">The version mapping Property.</param>
      <param name="lazyAvailable">Is property lazy loading currently available.</param>
      <returns>The appropriate VersionProperty definition.</returns>
    </member>
    <member name="M:NHibernate.Tuple.PropertyFactory.BuildStandardProperty(NHibernate.Mapping.Property,System.Boolean)">
      <summary>
            Generate a "standard" (i.e., non-identifier and non-version) based on the given
            mapped property.
            </summary>
      <param name="property">The mapped property.</param>
      <param name="lazyAvailable">Is property lazy loading currently available.</param>
      <returns>The appropriate StandardProperty definition.</returns>
    </member>
    <member name="T:NHibernate.Tuple.StandardProperty">
      <summary>
            Represents a basic property within the Hibernate runtime-metamodel.
            </summary>
      <remarks>
            Author: Steve Ebersole
            </remarks>
    </member>
    <member name="M:NHibernate.Tuple.StandardProperty.#ctor(System.String,System.String,NHibernate.Type.IType,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,NHibernate.Engine.CascadeStyle,System.Nullable{NHibernate.FetchMode})">
      <summary>
            Constructs StandardProperty instances.
            </summary>
      <param name="name">The name by which the property can be referenced within
            its owner.</param>
      <param name="node">The node name to use for XML-based representation of this
            property.</param>
      <param name="type">The Hibernate Type of this property.</param>
      <param name="lazy">Should this property be handled lazily?</param>
      <param name="insertable">Is this property an insertable value?</param>
      <param name="updateable">Is this property an updateable value?</param>
      <param name="insertGenerated">Is this property generated in the database on insert?</param>
      <param name="updateGenerated">Is this property generated in the database on update?</param>
      <param name="nullable">Is this property a nullable value?</param>
      <param name="checkable">Is this property a checkable value?</param>
      <param name="versionable">Is this property a versionable value?</param>
      <param name="cascadeStyle">The cascade style for this property's value.</param>
      <param name="fetchMode">Any fetch mode defined for this property </param>
    </member>
    <member name="T:NHibernate.Tuple.VersionProperty">
      <summary>
            Represents a version property within the Hibernate runtime-metamodel.
            </summary>
      <remarks>
            Author: Steve Ebersole
            </remarks>
    </member>
    <member name="M:NHibernate.Tuple.VersionProperty.#ctor(System.String,System.String,NHibernate.Type.IType,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,NHibernate.Engine.CascadeStyle,NHibernate.Engine.VersionValue)">
      <summary>
            Constructs VersionProperty instances.
            </summary>
      <param name="name">The name by which the property can be referenced within
            its owner.</param>
      <param name="node">The node name to use for XML-based representation of this
            property.</param>
      <param name="type">The Hibernate Type of this property.</param>
      <param name="lazy">Should this property be handled lazily?</param>
      <param name="insertable">Is this property an insertable value?</param>
      <param name="updateable">Is this property an updateable value?</param>
      <param name="insertGenerated">Is this property generated in the database on insert?</param>
      <param name="updateGenerated">Is this property generated in the database on update?</param>
      <param name="nullable">Is this property a nullable value?</param>
      <param name="checkable">Is this property a checkable value?</param>
      <param name="versionable">Is this property a versionable value?</param>
      <param name="cascadeStyle">The cascade style for this property's value.</param>
      <param name="unsavedValue">The value which, if found as the value of
            this (i.e., the version) property, represents new (i.e., un-saved)
            instances of the owning entity.</param>
    </member>
    <member name="T:NHibernate.Type.AbstractType">
      <summary>
            The base implementation of the <see cref="T:NHibernate.Type.IType" /> interface.
            Mapping of the built in Type hierarchy.
            </summary>
    </member>
    <member name="M:NHibernate.Type.AbstractType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Disassembles the object into a cacheable representation.
            </summary>
      <param name="value">The value to disassemble.</param>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> is not used by this method.</param>
      <param name="owner">optional parent entity object (needed for collections) </param>
      <returns>The disassembled, deep cloned state of the object</returns>
      <remarks>
            This method calls DeepCopy if the value is not null.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.AbstractType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Reconstructs the object from its cached "disassembled" state.
            </summary>
      <param name="cached">The disassembled state from the cache</param>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> is not used by this method.</param>
      <param name="owner">The parent Entity object is not used by this method</param>
      <returns>The assembled object.</returns>
      <remarks>
            This method calls DeepCopy if the value is not null.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.AbstractType.IsDirty(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Should the parent be considered dirty, given both the old and current 
            field or element value?
            </summary>
      <param name="old">The old value</param>
      <param name="current">The current value</param>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> is not used by this method.</param>
      <returns>true if the field is dirty</returns>
      <remarks>This method uses <c>IType.Equals(object, object)</c> to determine the value of IsDirty.</remarks>
    </member>
    <member name="M:NHibernate.Type.AbstractType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Retrives an instance of the mapped class, or the identifier of an entity 
            or collection from a <see cref="T:System.Data.IDataReader" />.
            </summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> that contains the values.</param>
      <param name="names">
            The names of the columns in the <see cref="T:System.Data.IDataReader" /> that contain the 
            value to populate the IType with.
            </param>
      <param name="session">the session</param>
      <param name="owner">The parent Entity</param>
      <returns>An identifier or actual object mapped by this IType.</returns>
      <remarks>
            This method uses the <c>IType.NullSafeGet(IDataReader, string[], ISessionImplementor, object)</c> method
            to Hydrate this <see cref="T:NHibernate.Type.AbstractType" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.AbstractType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Maps identifiers to Entities or Collections. 
            </summary>
      <param name="value">An identifier or value returned by <c>Hydrate()</c></param>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> is not used by this method.</param>
      <param name="owner">The parent Entity is not used by this method.</param>
      <returns>The value.</returns>
      <remarks>
            There is nothing done in this method other than return the value parameter passed in.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.AbstractType.IsModified(System.Object,System.Object,System.Boolean[],NHibernate.Engine.ISessionImplementor)">
      <summary>
            Says whether the value has been modified
            </summary>
    </member>
    <member name="M:NHibernate.Type.AbstractType.DeepCopy(System.Object,NHibernate.EntityMode,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
		When implemented by a class, returns a deep copy of the persistent 
		state, stopping at entities and at collections.
		</summary>
      <param name="val">A Collection element or Entity field</param>
      <param name="entityMode">The entityMode.</param>
      <param name="factory">The session factory.</param>
      <returns>A deep copy of the object.</returns>
    </member>
    <member name="M:NHibernate.Type.AbstractType.SqlTypes(NHibernate.Engine.IMapping)">
      <summary>
		When implemented by a class, returns the SqlTypes for the columns mapped by this IType.
		</summary>
      <param name="mapping">The <see cref="T:NHibernate.Engine.IMapping" /> that uses this IType.</param>
      <returns>An array of <see cref="T:NHibernate.SqlTypes.SqlType" />s.</returns>
    </member>
    <member name="M:NHibernate.Type.AbstractType.GetColumnSpan(NHibernate.Engine.IMapping)">
      <summary>
		When implemented by a class, returns how many columns are used to persist this type.
		</summary>
      <param name="mapping">The <see cref="T:NHibernate.Engine.IMapping" /> that uses this IType.</param>
      <returns>The number of columns this IType spans.</returns>
      <exception cref="T:NHibernate.MappingException">MappingException</exception>
    </member>
    <member name="M:NHibernate.Type.AbstractType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
      <!-- No matching elements were found for the following include tag -->
      <include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.NullSafeGet(IDataReader, string[], ISessionImplementor, object)&quot;]/*" />
    </member>
    <member name="M:NHibernate.Type.AbstractType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
      <!-- No matching elements were found for the following include tag -->
      <include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.NullSafeGet(IDataReader, string, ISessionImplementor, object)&quot;]/*" />
    </member>
    <member name="M:NHibernate.Type.AbstractType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,System.Boolean[],NHibernate.Engine.ISessionImplementor)">
      <summary>
		When implemented by a class, puts the value/values from the mapped 
		class into the <see cref="T:System.Data.IDbCommand" />.
		</summary>
      <param name="st">The <see cref="T:System.Data.IDbCommand" /> to put the values into.</param>
      <param name="value">The object that contains the values.</param>
      <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter" /> to start writing the values to.</param>
      <param name="session">
      </param>
      <param name="settable">Indicates which columns are to be set.</param>
      <remarks>
		Implementors should handle possibility of null values.
		A multi-column type should be written to parameters starting from <paramref name="index" />.
		</remarks>
    </member>
    <member name="M:NHibernate.Type.AbstractType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
      <summary>
			When implemented by a class, puts the value/values from the mapped
			class into the <see cref="T:System.Data.IDbCommand" />.
		</summary>
      <param name="st">
			The <see cref="T:System.Data.IDbCommand" /> to put the values into.
		</param>
      <param name="value">The object that contains the values.</param>
      <param name="index">
			The index of the <see cref="T:System.Data.IDbDataParameter" /> to start writing the values to.
		</param>
      <param name="session">
      </param>
      <remarks>
			Implementors should handle possibility of null values.
			A multi-column type should be written to parameters starting from <paramref name="index" />.
		</remarks>
    </member>
    <member name="M:NHibernate.Type.AbstractType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
		When implemented by a class, a representation of the value to be 
		embedded in an XML element
		</summary>
      <param name="value">The object that contains the values.</param>
      <param name="factory">
      </param>
      <returns>An Xml formatted string.</returns>
    </member>
    <member name="P:NHibernate.Type.AbstractType.IsAssociationType">
      <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType" /> is an <see cref="T:NHibernate.Type.IAssociationType" />.
            </summary>
      <value>false - by default an <see cref="T:NHibernate.Type.AbstractType" /> is not an <see cref="T:NHibernate.Type.IAssociationType" />.</value>
    </member>
    <member name="P:NHibernate.Type.AbstractType.IsCollectionType">
      <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType" /> is a <see cref="T:NHibernate.Type.CollectionType" />.
            </summary>
      <value>false - by default an <see cref="T:NHibernate.Type.AbstractType" /> is not a <see cref="T:NHibernate.Type.CollectionType" />.</value>
    </member>
    <member name="P:NHibernate.Type.AbstractType.IsComponentType">
      <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType" /> is an <see cref="T:NHibernate.Type.IAbstractComponentType" />.
            </summary>
      <value>false - by default an <see cref="T:NHibernate.Type.AbstractType" /> is not an <see cref="T:NHibernate.Type.IAbstractComponentType" />.</value>
    </member>
    <member name="P:NHibernate.Type.AbstractType.IsEntityType">
      <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType" /> is a <see cref="T:NHibernate.Type.EntityType" />.
            </summary>
      <value>false - by default an <see cref="T:NHibernate.Type.AbstractType" /> is not a <see cref="T:NHibernate.Type.EntityType" />.</value>
    </member>
    <member name="P:NHibernate.Type.AbstractType.IsAnyType">
      <summary>
            Gets a value indicating if the implementation is an "object" type
             </summary>
      <value>false - by default an <see cref="T:NHibernate.Type.AbstractType" /> is not a "object" type.</value>
    </member>
    <member name="P:NHibernate.Type.AbstractType.IsMutable">
      <summary>
		When implemented by a class, gets the value indicating if the objects 
		of this IType are mutable.
		</summary>
      <value>true if the objects mapped by this IType are mutable.</value>
      <remarks>
		With respect to the referencing object...
		Entities and Collections are considered immutable because they manage their own internal state.
		</remarks>
    </member>
    <member name="P:NHibernate.Type.AbstractType.Name">
      <summary>
		When implemented by a class, gets the abbreviated name of the type.
		</summary>
      <value>The NHibernate type name.</value>
    </member>
    <member name="P:NHibernate.Type.AbstractType.ReturnedClass">
      <summary>
		When implemented by a class, gets the <see cref="T:System.Type" /> returned 
		by the <c>NullSafeGet()</c> methods.
		</summary>
      <value>
		The <see cref="T:System.Type" /> from the .NET framework.
		</value>
      <remarks>
		This is used to establish the class of an array of this Itype
		</remarks>
    </member>
    <member name="T:NHibernate.Type.NullableType">
      <summary>
            Superclass of single-column nullable types.
            </summary>
      <remarks>
            Maps the Property to a single column that is capable of storing nulls in it. If a .net Struct is
            used it will be created with its unitialized value and then on Update the uninitialized value of
            the Struct will be written to the column - not <see langword="null" />. 
            </remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.#ctor(NHibernate.SqlTypes.SqlType)">
      <summary>
            Initialize a new instance of the NullableType class using a 
            <see cref="P:NHibernate.Type.NullableType.SqlType" />. 
            </summary>
      <param name="sqlType">The underlying <see cref="P:NHibernate.Type.NullableType.SqlType" />.</param>
      <remarks>This is used when the Property is mapped to a single column.</remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
      <summary>
            When implemented by a class, put the value from the mapped 
            Property into to the <see cref="T:System.Data.IDbCommand" />.
            </summary>
      <param name="cmd">The <see cref="T:System.Data.IDbCommand" /> to put the value into.</param>
      <param name="value">The object that contains the value.</param>
      <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter" /> to start writing the values to.</param>
      <remarks>
            Implementors do not need to handle possibility of null values because this will
            only be called from <see cref="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)" /> after 
            it has checked for nulls.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.Int32)">
      <summary>
            When implemented by a class, gets the object in the 
            <see cref="T:System.Data.IDataReader" /> for the Property.
            </summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> that contains the value.</param>
      <param name="index">The index of the field to get the value from.</param>
      <returns>An object with the value from the database.</returns>
    </member>
    <member name="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.String)">
      <summary>
            When implemented by a class, gets the object in the 
            <see cref="T:System.Data.IDataReader" /> for the Property.
            </summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> that contains the value.</param>
      <param name="name">The name of the field to get the value from.</param>
      <returns>An object with the value from the database.</returns>
      <remarks>
            Most implementors just call the <see cref="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.Int32)" /> 
            overload of this method.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.ToString(System.Object)">
      <summary>
            A representation of the value to be embedded in an XML element 
            </summary>
      <param name="val">The object that contains the values.
            </param>
      <returns>An Xml formatted string.</returns>
    </member>
    <member name="M:NHibernate.Type.NullableType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
		When implemented by a class, a representation of the value to be 
		embedded in an XML element
		</summary>
      <param name="value">The object that contains the values.</param>
      <param name="factory">
      </param>
      <returns>An Xml formatted string.</returns>
      <remarks>
        <para>
            This implementation forwards the call to <see cref="M:NHibernate.Type.NullableType.ToString(System.Object)" /> if the parameter 
            value is not null.
            </para>
        <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType" />
            do not need and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.ToString(System.Object)" />.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.FromStringValue(System.String)">
      <summary>
            Parse the XML representation of an instance
            </summary>
      <param name="xml">XML string to parse, guaranteed to be non-empty</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
      <summary>
			When implemented by a class, puts the value/values from the mapped
			class into the <see cref="T:System.Data.IDbCommand" />.
		</summary>
      <param name="st">
			The <see cref="T:System.Data.IDbCommand" /> to put the values into.
		</param>
      <param name="value">The object that contains the values.</param>
      <param name="index">
			The index of the <see cref="T:System.Data.IDbDataParameter" /> to start writing the values to.
		</param>
      <param name="session">
      </param>
      <remarks>
			Implementors should handle possibility of null values.
			A multi-column type should be written to parameters starting from <paramref name="index" />.
		</remarks>
      <remarks>
        <para>
            This implementation forwards the call to <see cref="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)" />.
            </para>
        <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType" />
            do not need to and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)" />.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)">
      <summary>
            Puts the value from the mapped class into the <see cref="T:System.Data.IDbCommand" />.
            </summary>
      <param name="cmd">The <see cref="T:System.Data.IDbCommand" /> to put the values into.</param>
      <param name="value">The object that contains the values.</param>
      <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter" /> to write the value to.</param>
      <remarks>
        <para>
            This method checks to see if value is null, if it is then the value of 
            <see cref="T:System.DBNull" /> is written to the <see cref="T:System.Data.IDbCommand" />.
            </para>
        <para>
            If the value is not null, then the method <see cref="M:NHibernate.Type.NullableType.Set(System.Data.IDbCommand,System.Object,System.Int32)" /> 
            is called and that method is responsible for setting the value.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
		When implemented by a class, gets an instance of the object mapped by 
		this IType from the <see cref="T:System.Data.IDataReader" />.
		</summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> that contains the values</param>
      <param name="names">
		The names of the columns in the <see cref="T:System.Data.IDataReader" /> that contain the 
		value to populate the IType with.
		</param>
      <param name="session">
      </param>
      <param name="owner">
      </param>
      <returns>The object mapped by this IType.</returns>
      <remarks>
		Implementors should handle possibility of null values.
		</remarks>
      <remarks>
            This has been sealed because no other class should override it.  This 
            method calls <see cref="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)" /> for a single value.  
            It only takes the first name from the string[] names parameter - that is a 
            safe thing to do because a Nullable Type only has one field.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String[])">
      <summary>
            Extracts the values of the fields from the DataReader
            </summary>
      <param name="rs">The DataReader positioned on the correct record</param>
      <param name="names">An array of field names.</param>
      <returns>The value off the field from the DataReader</returns>
      <remarks>
            In this class this just ends up passing the first name to the NullSafeGet method
            that takes a string, not a string[].
            
            I don't know why this method is in here - it doesn't look like anybody that inherits
            from NullableType overrides this...
            
            TODO: determine if this is needed
            </remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)">
      <summary>
            Gets the value of the field from the <see cref="T:System.Data.IDataReader" />.
            </summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> positioned on the correct record.</param>
      <param name="name">The name of the field to get the value from.</param>
      <returns>The value of the field.</returns>
      <remarks>
        <para>
            This method checks to see if value is null, if it is then the null is returned
            from this method.
            </para>
        <para>
            If the value is not null, then the method <see cref="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.Int32)" /> 
            is called and that method is responsible for retrieving the value.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
		When implemented by a class, gets an instance of the object 
		mapped by this IType from the <see cref="T:System.Data.IDataReader" />.
		</summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> that contains the values</param>
      <param name="name">The name of the column in the <see cref="T:System.Data.IDataReader" /> that contains the 
		value to populate the IType with.</param>
      <param name="session">
      </param>
      <param name="owner">
      </param>
      <returns>The object mapped by this IType.</returns>
      <remarks>
		Implementations should handle possibility of null values.
		This method might be called if the IType is known to be a single-column type.
		</remarks>
      <remarks>
        <para>
            This implementation forwards the call to <see cref="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)" />.
            </para>
        <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType" />
            do not need to and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)" />.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.SqlTypes(NHibernate.Engine.IMapping)">
      <summary>
		When implemented by a class, returns the SqlTypes for the columns mapped by this IType.
		</summary>
      <param name="mapping">The <see cref="T:NHibernate.Engine.IMapping" /> that uses this IType.</param>
      <returns>An array of <see cref="P:NHibernate.Type.NullableType.SqlType" />s.</returns>
      <remarks>
        <para>
            This implementation forwards the call to <see cref="P:NHibernate.Type.NullableType.SqlType" />.
            </para>
        <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType" />
            do not need to and should not override this method because they map to a single
            column.  All of their implementation should be in <see cref="P:NHibernate.Type.NullableType.SqlType" />.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.GetColumnSpan(NHibernate.Engine.IMapping)">
      <summary>
            Returns the number of columns spanned by this <see cref="T:NHibernate.Type.NullableType" /></summary>
      <returns>A <see cref="T:NHibernate.Type.NullableType" /> always returns 1.</returns>
      <remarks>
            This has the hard coding of 1 in there because, by definition of this class, 
            a NullableType can only map to one column in a table.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.NullableType.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this
            <see cref="T:NHibernate.Type.NullableType" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this NullableType.</param>
      <returns>true if the SqlType and Name properties are the same.</returns>
    </member>
    <member name="M:NHibernate.Type.NullableType.GetHashCode">
      <summary>
            Serves as a hash function for the <see cref="T:NHibernate.Type.NullableType" />, 
            suitable for use in hashing algorithms and data structures like a hash table.
            </summary>
      <returns>
            A hash code that is based on the <see cref="P:NHibernate.Type.NullableType.SqlType" />'s 
            hash code and the <see cref="P:NHibernate.Type.AbstractType.Name" />'s hash code.</returns>
    </member>
    <member name="P:NHibernate.Type.NullableType.SqlType">
      <summary>
            Gets the underlying <see cref="P:NHibernate.Type.NullableType.SqlType" /> for 
            the column mapped by this <see cref="T:NHibernate.Type.NullableType" />.
            </summary>
      <value>The underlying <see cref="P:NHibernate.Type.NullableType.SqlType" />.</value>
      <remarks>
            This implementation should be suitable for all subclasses unless they need to
            do some special things to get the value.  There are no built in <see cref="T:NHibernate.Type.NullableType" />s
            that override this Property.
            </remarks>
    </member>
    <member name="T:NHibernate.Type.MutableType">
      <summary>
            Superclass for mutable nullable types.
            </summary>
    </member>
    <member name="M:NHibernate.Type.MutableType.#ctor(NHibernate.SqlTypes.SqlType)">
      <summary>
            Initialize a new instance of the MutableType class using a 
            <see cref="T:NHibernate.SqlTypes.SqlType" />. 
            </summary>
      <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType" />.</param>
    </member>
    <member name="P:NHibernate.Type.MutableType.IsMutable">
      <summary>
            Gets the value indicating if this IType is mutable.
            </summary>
      <value>true - a <see cref="T:NHibernate.Type.MutableType" /> is mutable.</value>
      <remarks>
            This has been "sealed" because any subclasses are expected to be mutable.  If
            the type is immutable then they should inherit from <see cref="T:NHibernate.Type.ImmutableType" />.
            </remarks>
    </member>
    <member name="T:NHibernate.Type.IVersionType">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that may be used to version data.
            </summary>
    </member>
    <member name="M:NHibernate.Type.IVersionType.Next(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            When implemented by a class, increments the version.
            </summary>
      <param name="current">The current version</param>
      <param name="session">The current session, if available.</param>
      <returns>an instance of the <see cref="T:NHibernate.Type.IType" /> that has been incremented.</returns>
    </member>
    <member name="M:NHibernate.Type.IVersionType.Seed(NHibernate.Engine.ISessionImplementor)">
      <summary>
            When implemented by a class, gets an initial version.
            </summary>
      <param name="session">The current session, if available.</param>
      <returns>An instance of the type.</returns>
    </member>
    <member name="M:NHibernate.Type.IVersionType.IsEqual(System.Object,System.Object)">
      <summary> 
            Are the two version values considered equal? 
            </summary>
      <param name="x">One value to check. </param>
      <param name="y">The other value to check. </param>
      <returns> true if the values are equal, false otherwise. </returns>
    </member>
    <member name="P:NHibernate.Type.IVersionType.Comparator">
      <summary>
            Get a comparator for the version numbers
            </summary>
    </member>
    <member name="T:NHibernate.Type.AbstractBinaryType">
      <summary> Logic to bind stream of byte into a VARBINARY </summary>
    </member>
    <member name="M:NHibernate.Type.AbstractBinaryType.ToExternalFormat(System.Byte[])">
      <summary> Convert the byte[] into the expected object type</summary>
    </member>
    <member name="M:NHibernate.Type.AbstractBinaryType.ToInternalFormat(System.Object)">
      <summary> Convert the object into the internal byte[] representation</summary>
    </member>
    <member name="T:NHibernate.Type.ImmutableType">
      <summary>
            Superclass of nullable immutable types.
            </summary>
    </member>
    <member name="M:NHibernate.Type.ImmutableType.#ctor(NHibernate.SqlTypes.SqlType)">
      <summary>
            Initialize a new instance of the ImmutableType class using a 
            <see cref="T:NHibernate.SqlTypes.SqlType" />. 
            </summary>
      <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType" />.</param>
    </member>
    <member name="P:NHibernate.Type.ImmutableType.IsMutable">
      <summary>
            Gets the value indicating if this IType is mutable.
            </summary>
      <value>false - an <see cref="T:NHibernate.Type.ImmutableType" /> is not mutable.</value>
      <remarks>
            This has been "sealed" because any subclasses are expected to be immutable.  If
            the type is mutable then they should inherit from <see cref="T:NHibernate.Type.MutableType" />.
            </remarks>
    </member>
    <member name="T:NHibernate.Type.ILiteralType">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that may appear as an SQL literal
            </summary>
    </member>
    <member name="M:NHibernate.Type.ILiteralType.ObjectToSQLString(System.Object,NHibernate.Dialect.Dialect)">
      <summary>
            When implemented by a class, return a <see cref="T:System.String" /> representation 
            of the value, suitable for embedding in an SQL statement
            </summary>
      <param name="value">The object to convert to a string for the SQL statement.</param>
      <param name="dialect">
      </param>
      <returns>A string that contains a well formed SQL Statement.</returns>
    </member>
    <member name="T:NHibernate.Type.PrimitiveType">
      <summary>
            Superclass of <see cref="T:System.ValueType" /> types.
            </summary>
    </member>
    <member name="M:NHibernate.Type.PrimitiveType.#ctor(NHibernate.SqlTypes.SqlType)">
      <summary>
            Initialize a new instance of the PrimitiveType class using a <see cref="T:NHibernate.SqlTypes.SqlType" />. 
            </summary>
      <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType" />.</param>
    </member>
    <member name="M:NHibernate.Type.PrimitiveType.ObjectToSQLString(System.Object,NHibernate.Dialect.Dialect)">
      <summary>
            When implemented by a class, return a <see cref="T:System.String" /> representation 
            of the value, suitable for embedding in an SQL statement
            </summary>
      <param name="value">The object to convert to a string for the SQL statement.</param>
      <param name="dialect">
      </param>
      <returns>A string that containts a well formed SQL Statement.</returns>
    </member>
    <member name="M:NHibernate.Type.PrimitiveType.ToString(System.Object)">
      <summary>
            A representation of the value to be embedded in an XML element 
            </summary>
      <param name="val">The object that contains the values.
            </param>
      <returns>An Xml formatted string.</returns>
      <remarks>
            This just calls <see cref="M:System.Object.ToString" /> so if there is 
            a possibility of this PrimitiveType having any characters
            that need to be encoded then this method should be overridden.
            </remarks>
    </member>
    <member name="T:NHibernate.Type.IIdentifierType">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that may be used as an identifier.
            </summary>
    </member>
    <member name="M:NHibernate.Type.IIdentifierType.StringToObject(System.String)">
      <summary>
            When implemented by a class, converts the xml string from the 
            mapping file to the .NET object.
            </summary>
      <param name="xml">The value of <c>discriminator-value</c> or <c>unsaved-value</c> attribute.</param>
      <returns>The string converted to the object.</returns>
      <remarks>
            This method needs to be able to handle any string.  It should not just 
            call System.Type.Parse without verifying that it is a parsable value
            for the System.Type.
            </remarks>
    </member>
    <member name="T:NHibernate.Type.IDiscriminatorType">
      <summary>
            An IType that may be used for a discriminator column.
            </summary>
      <remarks>
            This interface contains no new methods but does require that an
            <see cref="T:NHibernate.Type.IType" /> that will be used in a discriminator column must implement
            both the <see cref="T:NHibernate.Type.IIdentifierType" /> and <see cref="T:NHibernate.Type.ILiteralType" /> interfaces.
            </remarks>
    </member>
    <member name="T:NHibernate.Type.AbstractCharType">
      <summary>
            Common base class for <see cref="T:NHibernate.Type.CharType" /> and <see cref="T:NHibernate.Type.AnsiCharType" />.
            </summary>
    </member>
    <member name="T:NHibernate.Type.AbstractEnumType">
      <summary>
            Base class for enum types.
            </summary>
    </member>
    <member name="T:NHibernate.Type.AnsiCharType">
      <summary>
            Maps a <see cref="T:System.Char" /> Property 
            to a <c>DbType.AnsiStringFixedLength</c> column.
            </summary>
    </member>
    <member name="T:NHibernate.Type.AnsiStringType">
      <summary>
            Maps a <see cref="T:System.String" /> Property 
            to a <see cref="F:System.Data.DbType.AnsiString" /> column.
            </summary>
    </member>
    <member name="P:NHibernate.Type.AnsiStringType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.IAbstractComponentType">
      <summary>
            Enables other Component-like types to hold collections and have cascades, etc.
            </summary>
    </member>
    <member name="M:NHibernate.Type.IAbstractComponentType.GetPropertyValues(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Get the values of the component properties of 
            a component instance
            </summary>
    </member>
    <member name="M:NHibernate.Type.IAbstractComponentType.GetPropertyValues(System.Object,NHibernate.EntityMode)">
      <summary>
            Optional Operation
            </summary>
    </member>
    <member name="M:NHibernate.Type.IAbstractComponentType.SetPropertyValues(System.Object,System.Object[],NHibernate.EntityMode)">
      <summary>
            Optional operation
            </summary>
    </member>
    <member name="P:NHibernate.Type.IAbstractComponentType.Subtypes">
      <summary>Get the types of the component properties</summary>
    </member>
    <member name="P:NHibernate.Type.IAbstractComponentType.PropertyNames">
      <summary>Get the names of the component properties</summary>
    </member>
    <member name="P:NHibernate.Type.IAbstractComponentType.PropertyNullability">
      <summary>
            Optional operation
            </summary>
      <value>nullability of component properties</value>
    </member>
    <member name="T:NHibernate.Type.IAssociationType">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that represents some kind of association between entities.
            </summary>
    </member>
    <member name="M:NHibernate.Type.IAssociationType.GetAssociatedJoinable(NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
            Get the "persister" for this association - a class or collection persister
            </summary>
      <param name="factory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.IAssociationType.GetAssociatedEntityName(NHibernate.Engine.ISessionFactoryImplementor)">
      <summary> Get the entity name of the associated entity</summary>
    </member>
    <member name="M:NHibernate.Type.IAssociationType.GetOnCondition(System.String,NHibernate.Engine.ISessionFactoryImplementor,System.Collections.Generic.IDictionary{System.String,NHibernate.IFilter})">
      <summary>
            Get the "filtering" SQL fragment that is applied in the
            SQL on clause, in addition to the usual join condition.
            </summary>
    </member>
    <member name="P:NHibernate.Type.IAssociationType.ForeignKeyDirection">
      <summary>
            When implemented by a class, gets the type of foreign key directionality 
            of this association.
            </summary>
      <value>The <see cref="P:NHibernate.Type.IAssociationType.ForeignKeyDirection" /> of this association.</value>
    </member>
    <member name="P:NHibernate.Type.IAssociationType.UseLHSPrimaryKey">
      <summary>
            Is the primary key of the owning entity table
            to be used in the join?
            </summary>
    </member>
    <member name="P:NHibernate.Type.IAssociationType.LHSPropertyName">
      <summary>
            Get the name of the property in the owning entity
            that provides the join key (null if the identifier)
            </summary>
    </member>
    <member name="P:NHibernate.Type.IAssociationType.RHSUniqueKeyPropertyName">
      <summary>
            The name of a unique property of the associated entity 
            that provides the join key (null if the identifier of
            an entity, or key of a collection)
            </summary>
    </member>
    <member name="P:NHibernate.Type.IAssociationType.IsAlwaysDirtyChecked">
      <summary>
            Do we dirty check this association, even when there are
            no columns to be updated.
            </summary>
    </member>
    <member name="T:NHibernate.Type.AnyType">
      <summary>
            	Handles "any" mappings and the old deprecated "object" type.
            </summary>
      <remarks>
            	The identifierType is any NHibernate IType that can be serailized by default.
            	For example, you can specify the identifierType as an Int32 or a custom identifier
            	type that you built.  The identifierType matches to one or many columns.
            	
            	The metaType maps to a single column.  By default it stores the name of the Type
            	that the Identifier identifies.  
            	
            	For example, we can store a link to any table.  It will have the results
            	class_name					id_col1
            	========================================
            	Simple, AssemblyName			5
            	DiffClass, AssemblyName			5
            	Simple, AssemblyName			4
            	
            	You can also provide you own type that might map the name of the class to a table
            	with a giant switch statemet or a good naming convention for your class-&gt;table.  The
            	data stored might look like
            	class_name					id_col1
            	========================================
            	simple_table					5
            	diff_table						5
            	simple_table					4
            	
            </remarks>
    </member>
    <member name="M:NHibernate.Type.AnyType.#ctor(NHibernate.Type.IType,NHibernate.Type.IType)">
      <summary>
      </summary>
      <param name="metaType">
      </param>
      <param name="identifierType">
      </param>
    </member>
    <member name="M:NHibernate.Type.AnyType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.AnyType.UseLHSPrimaryKey">
      <summary>
            Not really relevant to AnyType, since it cannot be "joined"
            </summary>
    </member>
    <member name="T:NHibernate.Type.CollectionType">
      <summary>
            The base class for an <see cref="T:NHibernate.Type.IType" /> that maps collections
            to the database.
            </summary>
    </member>
    <member name="M:NHibernate.Type.CollectionType.#ctor(System.String,System.String,System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.CollectionType" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="foreignKeyPropertyName">
            The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.
            </param>
      <param name="isEmbeddedInXML">
      </param>
    </member>
    <member name="M:NHibernate.Type.CollectionType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary> 
            Instantiate an uninitialized collection wrapper or holder. Callers MUST add the holder to the
            persistence context! 
            </summary>
      <param name="session">The session from which the request is originating. </param>
      <param name="persister">The underlying collection persister (metadata) </param>
      <param name="key">The owner key. </param>
      <returns> The instantiated collection. </returns>
    </member>
    <member name="M:NHibernate.Type.CollectionType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary> 
            Wrap the naked collection instance in a wrapper, or instantiate a
            holder. Callers <b>MUST</b> add the holder to the persistence context!
             </summary>
      <param name="session">The session from which the request is originating. </param>
      <param name="collection">The bare collection to be wrapped. </param>
      <returns>
            A subclass of <see cref="T:NHibernate.Collection.IPersistentCollection" /> that wraps the non NHibernate collection.
            </returns>
    </member>
    <member name="M:NHibernate.Type.CollectionType.GetKeyOfOwner(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Get the key value from the owning entity instance, usually the identifier, but might be some
            other unique key, in the case of property-ref
            </summary>
    </member>
    <member name="M:NHibernate.Type.CollectionType.GetIdOfOwnerOrNull(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Get the id value from the owning entity key, usually the same as the key, but might be some
            other property, in the case of property-ref 
            </summary>
      <param name="key">The collection owner key </param>
      <param name="session">The session from which the request is originating. </param>
      <returns> 
            The collection owner's id, if it can be obtained from the key;
            otherwise, null is returned
            </returns>
    </member>
    <member name="M:NHibernate.Type.CollectionType.Instantiate(System.Int32)">
      <summary> 
            Instantiate an empty instance of the "underlying" collection (not a wrapper),
            but with the given anticipated size (i.e. accounting for initial capacity
            and perhaps load factor).
            </summary>
      <param name="anticipatedSize">
            The anticipated size of the instantiated collection after we are done populating it.
            </param>
      <returns> A newly instantiated collection to be wrapped. </returns>
    </member>
    <member name="M:NHibernate.Type.CollectionType.GetElementsIterator(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Get an iterator over the element set of the collection, which may not yet be wrapped 
            </summary>
      <param name="collection">The collection to be iterated </param>
      <param name="session">The session from which the request is originating. </param>
      <returns> The iterator. </returns>
    </member>
    <member name="M:NHibernate.Type.CollectionType.GetElementsIterator(System.Object)">
      <summary> 
            Get an iterator over the element set of the collection in POCO mode 
            </summary>
      <param name="collection">The collection to be iterated </param>
      <returns> The iterator. </returns>
    </member>
    <member name="P:NHibernate.Type.CollectionType.IsAlwaysDirtyChecked">
      <summary>
            We always need to dirty check the collection because we sometimes 
            need to increment version number of owner and also because of 
            how assemble/disassemble is implemented for uks
            </summary>
    </member>
    <member name="T:NHibernate.Type.ArrayType">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that maps an <see cref="T:System.Array" /> collection
            to the database.
            </summary>
    </member>
    <member name="M:NHibernate.Type.ArrayType.#ctor(System.String,System.String,System.Type,System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.ArrayType" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="elementClass">The <see cref="T:System.Type" /> of the element contained in the array.</param>
      <param name="isEmbeddedInXML">
      </param>
      <remarks>
            This creates a bag that is non-generic.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.ArrayType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
      <summary>
      </summary>
      <param name="st">
      </param>
      <param name="value">
      </param>
      <param name="index">
      </param>
      <param name="session">
      </param>
    </member>
    <member name="M:NHibernate.Type.ArrayType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Wraps a <see cref="T:System.Array" /> in a <see cref="T:NHibernate.Collection.PersistentArrayHolder" />.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the collection to be a part of.</param>
      <param name="array">The unwrapped array.</param>
      <returns>
            An <see cref="T:NHibernate.Collection.PersistentArrayHolder" /> that wraps the non NHibernate <see cref="T:System.Array" />.
            </returns>
    </member>
    <member name="P:NHibernate.Type.ArrayType.ReturnedClass">
      <summary>
            The <see cref="T:System.Array" /> for the element.
            </summary>
    </member>
    <member name="P:NHibernate.Type.ArrayType.IsArrayType">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.BagType">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that maps an <see cref="T:System.Collections.IList" /> collection
            using bag semantics to the database.
            </summary>
    </member>
    <member name="M:NHibernate.Type.BagType.#ctor(System.String,System.String,System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.BagType" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="isEmbeddedInXML">
      </param>
    </member>
    <member name="M:NHibernate.Type.BagType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection" /> for the bag.
            </summary>
      <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the bag.</param>
      <param name="persister">
      </param>
      <param name="key">
      </param>
      <returns>A new <see cref="T:NHibernate.Collection.PersistentBag" />.</returns>
    </member>
    <member name="M:NHibernate.Type.BagType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Wraps an <see cref="T:System.Collections.IList" /> in a NHibernate <see cref="T:NHibernate.Collection.PersistentBag" />.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the collection to be a part of.</param>
      <param name="collection">The unwrapped <see cref="T:System.Collections.IList" />.</param>
      <returns>
            An <see cref="T:NHibernate.Collection.PersistentBag" /> that wraps the non NHibernate <see cref="T:System.Collections.IList" />.
            </returns>
    </member>
    <member name="P:NHibernate.Type.BagType.ReturnedClass">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.BinaryType">
      <summary>
            BinaryType.
            </summary>
    </member>
    <member name="T:NHibernate.Type.BinaryBlobType">
      <summary>
            Maps a System.Byte[] Property to an column that can store a BLOB.
            </summary>
      <remarks>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a BinaryType
            would work just fine.
            </remarks>
    </member>
    <member name="P:NHibernate.Type.BinaryBlobType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.BooleanType">
      <summary>
            Maps a <see cref="T:System.Boolean" /> Property 
            to a <see cref="F:System.Data.DbType.Boolean" /> column.
            </summary>
    </member>
    <member name="M:NHibernate.Type.BooleanType.#ctor">
      <summary>
            Initialize a new instance of the BooleanType
            </summary>
      <remarks>This is used when the Property is mapped to a native boolean type.</remarks>
    </member>
    <member name="M:NHibernate.Type.BooleanType.#ctor(NHibernate.SqlTypes.AnsiStringFixedLengthSqlType)">
      <summary>
            Initialize a new instance of the BooleanType class using a
            <see cref="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType" />.
            </summary>
      <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType" />.</param>
      <remarks>
            This is used when the Property is mapped to a string column
            that stores true or false as a string.
            </remarks>
    </member>
    <member name="T:NHibernate.Type.ByteType">
      <summary>
            Maps a <see cref="T:System.Byte" /> property 
            to a <see cref="F:System.Data.DbType.Byte" /> column.
            </summary>
    </member>
    <member name="T:NHibernate.Type.CharBooleanType">
      <summary>
            Maps a <see cref="T:System.Boolean" /> Property 
            to a <see cref="F:System.Data.DbType.AnsiStringFixedLength" /> column.
            </summary>
    </member>
    <member name="M:NHibernate.Type.CharBooleanType.#ctor(NHibernate.SqlTypes.AnsiStringFixedLengthSqlType)">
      <summary>
      </summary>
      <param name="sqlType">
      </param>
    </member>
    <member name="M:NHibernate.Type.CharBooleanType.Get(System.Data.IDataReader,System.Int32)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CharBooleanType.Get(System.Data.IDataReader,System.String)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CharBooleanType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
      <summary>
      </summary>
      <param name="cmd">
      </param>
      <param name="value">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="M:NHibernate.Type.CharBooleanType.StringToObject(System.String)">
      <summary>
      </summary>
      <param name="xml">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Type.CharBooleanType.TrueString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.CharBooleanType.FalseString">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.CharType">
      <summary>
            Maps a <see cref="T:System.Char" /> Property 
            to a <c>DbType.StringFixedLength</c> column.
            </summary>
    </member>
    <member name="T:NHibernate.Type.ClassMetaType">
      <summary>
            ClassMetaType is a NH specific type to support "any" with meta-type="class"
            </summary>
      <remarks>
            It work like a MetaType where the key is the entity-name it self
            </remarks>
    </member>
    <member name="M:NHibernate.Type.ComponentType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
      <summary>
      </summary>
      <param name="st">
      </param>
      <param name="value">
      </param>
      <param name="begin">
      </param>
      <param name="session">
      </param>
    </member>
    <member name="M:NHibernate.Type.ComponentType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
      </summary>
      <param name="value">
      </param>
      <param name="factory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.ComponentType.Instantiate(NHibernate.EntityMode)">
      <summary> This method does not populate the component parent</summary>
    </member>
    <member name="M:NHibernate.Type.ComponentType.GetCascadeStyle(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Type.ComponentType.IsCollectionType">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.ComponentType.IsComponentType">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.ComponentType.IsEntityType">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.ComponentType.ReturnedClass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.ComponentType.Subtypes">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.ComponentType.Name">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.ComponentType.PropertyNames">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.ComponentType.IsMutable">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.CompositeCustomType">
      <summary>
            Summary description for CompositeCustomType.
            </summary>
    </member>
    <member name="M:NHibernate.Type.CompositeCustomType.GetPropertyValues(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
      </summary>
      <param name="component">
      </param>
      <param name="session">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CompositeCustomType.GetCascadeStyle(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CompositeCustomType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
      </summary>
      <param name="cached">
      </param>
      <param name="session">
      </param>
      <param name="owner">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CompositeCustomType.GetColumnSpan(NHibernate.Engine.IMapping)">
      <summary>
      </summary>
      <param name="mapping">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CompositeCustomType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="name">
      </param>
      <param name="session">
      </param>
      <param name="owner">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CompositeCustomType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="names">
      </param>
      <param name="session">
      </param>
      <param name="owner">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CompositeCustomType.SqlTypes(NHibernate.Engine.IMapping)">
      <summary>
      </summary>
      <param name="mapping">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CompositeCustomType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
      </summary>
      <param name="value">
      </param>
      <param name="factory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Type.CompositeCustomType.Subtypes">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.CompositeCustomType.PropertyNames">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.CompositeCustomType.IsComponentType">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.CompositeCustomType.Name">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.CompositeCustomType.ReturnedClass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.CompositeCustomType.IsMutable">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.CultureInfoType">
      <summary>
            Maps a <see cref="T:System.Globalization.CultureInfo" /> Property 
            to a <see cref="F:System.Data.DbType.String" /> column.
            </summary>
      <remarks>
            CultureInfoType stores the culture name (not the Culture ID) of the 
            <see cref="T:System.Globalization.CultureInfo" /> in the DB.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.CultureInfoType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Type.CultureInfoType.Get(System.Data.IDataReader,System.Int32)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CultureInfoType.Get(System.Data.IDataReader,System.String)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CultureInfoType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
      <summary>
      </summary>
      <param name="cmd">
      </param>
      <param name="value">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="M:NHibernate.Type.CultureInfoType.ToString(System.Object)">
      <summary>
      </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CultureInfoType.FromStringValue(System.String)">
      <summary>
      </summary>
      <param name="xml">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Type.CultureInfoType.ReturnedClass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.CultureInfoType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.DecimalType">
      <summary>
            Maps a <see cref="T:System.Decimal" /> Property 
            to a <see cref="F:System.Data.DbType.Decimal" /> column.
            </summary>
    </member>
    <member name="T:NHibernate.Type.CustomCollectionType">
      <summary>
            A custom type for mapping user-written classes that implement
            <see cref="T:NHibernate.Collection.IPersistentCollection" />.
            </summary>
      <seealso cref="T:NHibernate.Collection.IPersistentCollection" />
      <seealso cref="T:NHibernate.UserTypes.IUserCollectionType" />
    </member>
    <member name="T:NHibernate.Type.CustomType">
      <summary>
            Adapts IUserType to the generic IType interface.
            <seealso cref="T:NHibernate.UserTypes.IUserType" /></summary>
    </member>
    <member name="M:NHibernate.Type.CustomType.SqlTypes(NHibernate.Engine.IMapping)">
      <summary>
      </summary>
      <param name="mapping">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CustomType.GetColumnSpan(NHibernate.Engine.IMapping)">
      <summary>
      </summary>
      <param name="session">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.CustomType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary>
      </summary>
      <param name="value">
      </param>
      <param name="factory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Type.CustomType.UserType">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.CustomType.ReturnedClass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.CustomType.Name">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.CustomType.IsMutable">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.DateTimeType">
      <summary>
            Maps a <see cref="T:System.DateTime" /> Property to a <see cref="F:System.Data.DbType.DateTime" /> column that 
            stores date &amp; time down to the accuracy of a second.
            </summary>
      <remarks>
            This only stores down to a second, so if you are looking for the most accurate
            date and time storage your provider can give you use the <see cref="T:NHibernate.Type.TimestampType" />. 
            or the <see cref="T:NHibernate.Type.TicksType" /></remarks>
    </member>
    <member name="M:NHibernate.Type.DateTimeType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.DateTimeType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.DateTime2Type">
      <summary>
            Maps a <see cref="T:System.DateTime" /> Property to a <see cref="F:System.Data.DbType.DateTime" /></summary>
    </member>
    <member name="M:NHibernate.Type.DateTime2Type.#ctor">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.DateTimeOffsetType">
      <summary>
            Maps a <see cref="T:System.DateTimeOffset" /> Property to a <see cref="F:System.Data.DbType.DateTimeOffset" /></summary>
    </member>
    <member name="M:NHibernate.Type.DateTimeOffsetType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.DateType">
      <summary>
            Maps the Year, Month, and Day of a <see cref="T:System.DateTime" /> Property to a 
            <see cref="F:System.Data.DbType.Date" /> column
            </summary>
    </member>
    <member name="M:NHibernate.Type.DateType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.DateType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.TimestampType">
      <summary>
            This is almost the exact same type as the DateTime except it can be used
            in the version column, stores it to the accuracy the database supports, 
            and will default to the value of DateTime.Now if the value is null.
            </summary>
      <remarks>
        <p>
            The value stored in the database depends on what your data provider is capable
            of storing.  So there is a possibility that the DateTime you save will not be
            the same DateTime you get back when you check DateTime.Equals(DateTime) because
            they will have their milliseconds off.
            </p>
        <p>
            For example - SQL Server 2000 is only accurate to 3.33 milliseconds.  So if 
            NHibernate writes a value of <c>01/01/98 23:59:59.995</c> to the Prepared Command, MsSql
            will store it as <c>1998-01-01 23:59:59.997</c>.
            </p>
        <p>
            Please review the documentation of your Database server.
            </p>
      </remarks>
    </member>
    <member name="M:NHibernate.Type.TimestampType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
      <summary>
            Sets the value of this Type in the IDbCommand.
            </summary>
      <param name="st">The IDbCommand to add the Type's value to.</param>
      <param name="value">The value of the Type.</param>
      <param name="index">The index of the IDataParameter in the IDbCommand.</param>
      <remarks>
            No null values will be written to the IDbCommand for this Type. 
            </remarks>
    </member>
    <member name="T:NHibernate.Type.DbTimestampType">
      <summary> An extension of <see cref="T:NHibernate.Type.TimestampType" /> which
            maps to the database's current timestamp, rather than the vm's
            current timestamp.
            </summary>
      <remarks>
            Note: May/may-not cause issues on dialects which do not properly support
            a true notion of timestamp
            </remarks>
    </member>
    <member name="T:NHibernate.Type.DoubleType">
      <summary>
            Maps a <see cref="T:System.Double" /> Property 
            to a <see cref="F:System.Data.DbType.Double" /> column.
            </summary>
    </member>
    <member name="M:NHibernate.Type.DoubleType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Type.DoubleType.Get(System.Data.IDataReader,System.Int32)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.DoubleType.Get(System.Data.IDataReader,System.String)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.DoubleType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
      <summary>
      </summary>
      <param name="st">
      </param>
      <param name="value">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="P:NHibernate.Type.DoubleType.ReturnedClass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.DoubleType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.EntityType">
      <summary>
            A reference to an entity class
            </summary>
    </member>
    <member name="M:NHibernate.Type.EntityType.#ctor(System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
      <summary> Constructs the requested entity type mapping. </summary>
      <param name="entityName">The name of the associated entity. </param>
      <param name="uniqueKeyPropertyName">
            The property-ref name, or null if we
            reference the PK of the associated entity.
            </param>
      <param name="eager">Is eager fetching enabled. </param>
      <param name="isEmbeddedInXML">Should values of this mapping be embedded in XML modes? </param>
      <param name="unwrapProxy">
            Is unwrapping of proxies allowed for this association; unwrapping
            says to return the "implementation target" of lazy prooxies; typically only possible
            with lazy="no-proxy".
            </param>
    </member>
    <member name="M:NHibernate.Type.EntityType.IsSame(System.Object,System.Object,NHibernate.EntityMode)">
      <summary> Two entities are considered the same when their instances are the same. </summary>
      <param name="x">One entity instance </param>
      <param name="y">Another entity instance </param>
      <param name="entityMode">The entity mode. </param>
      <returns> True if x == y; false otherwise. </returns>
    </member>
    <member name="M:NHibernate.Type.EntityType.GetIdentifier(System.Object,NHibernate.Persister.Entity.IEntityPersister,NHibernate.EntityMode)">
      <summary> 
            Get the identifier value of an instance or proxy.
            <p />
            Intended only for loggin purposes!!!
            </summary>
      <param name="obj">The object from which to extract the identifier.</param>
      <param name="persister">The entity persister </param>
      <param name="entityMode">The entity mode </param>
      <returns> The extracted identifier. </returns>
    </member>
    <member name="M:NHibernate.Type.EntityType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Converts the id contained in the <see cref="T:System.Data.IDataReader" /> to an object.
            </summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> that contains the query results.</param>
      <param name="names">A string array of column names that contain the id.</param>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this is occurring in.</param>
      <param name="owner">The object that this Entity will be a part of.</param>
      <returns>
            An instance of the object or <see langword="null" /> if the identifer was null.
            </returns>
    </member>
    <member name="M:NHibernate.Type.EntityType.GetAssociatedJoinable(NHibernate.Engine.ISessionFactoryImplementor)">
      <summary> Retrieves the {@link Joinable} defining the associated entity. </summary>
      <param name="factory">The session factory. </param>
      <returns> The associated joinable </returns>
    </member>
    <member name="M:NHibernate.Type.EntityType.GetIdentifierOrUniqueKeyType(NHibernate.Engine.IMapping)">
      <summary> 
            Determine the type of either (1) the identifier if we reference the
            associated entity's PK or (2) the unique key to which we refer (i.e.
            the property-ref). 
            </summary>
      <param name="factory">The mappings... </param>
      <returns> The appropriate type. </returns>
    </member>
    <member name="M:NHibernate.Type.EntityType.GetIdentifierOrUniqueKeyPropertyName(NHibernate.Engine.IMapping)">
      <summary> 
            The name of the property on the associated entity to which our FK refers 
            </summary>
      <param name="factory">The mappings... </param>
      <returns> The appropriate property name. </returns>
    </member>
    <member name="M:NHibernate.Type.EntityType.GetIdentifierType(NHibernate.Engine.IMapping)">
      <summary> Convenience method to locate the identifier type of the associated entity. </summary>
      <param name="factory">The mappings... </param>
      <returns> The identifier type </returns>
    </member>
    <member name="M:NHibernate.Type.EntityType.GetIdentifierType(NHibernate.Engine.ISessionImplementor)">
      <summary> Convenience method to locate the identifier type of the associated entity. </summary>
      <param name="session">The originating session </param>
      <returns> The identifier type </returns>
    </member>
    <member name="M:NHibernate.Type.EntityType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Resolves the identifier to the actual object.
            </summary>
    </member>
    <member name="M:NHibernate.Type.EntityType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Resolve an identifier or unique key value
            </summary>
      <param name="value">
      </param>
      <param name="session">
      </param>
      <param name="owner">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.EntityType.GetAssociatedEntityName(NHibernate.Engine.ISessionFactoryImplementor)">
      <summary> The name of the associated entity. </summary>
      <param name="factory">The session factory, for resolution. </param>
      <returns> The associated entity name. </returns>
    </member>
    <member name="M:NHibernate.Type.EntityType.GetAssociatedEntityName">
      <summary> The name of the associated entity. </summary>
      <returns> The associated entity name.</returns>
    </member>
    <member name="M:NHibernate.Type.EntityType.LoadByUniqueKey(System.String,System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary> 
            Load an instance by a unique key that is not the primary key. 
            </summary>
      <param name="entityName">The name of the entity to load </param>
      <param name="uniqueKeyPropertyName">The name of the property defining the uniqie key. </param>
      <param name="key">The unique key property value. </param>
      <param name="session">The originating session. </param>
      <returns> The loaded entity </returns>
    </member>
    <member name="P:NHibernate.Type.EntityType.IsEntityType">
      <summary> Explicitly, an entity type is an entity type </summary>
      <value> True. </value>
    </member>
    <member name="P:NHibernate.Type.EntityType.ReturnedClass">
      <summary> 
            This returns the wrong class for an entity with a proxy, or for a named
            entity.  Theoretically it should return the proxy class, but it doesn't.
            <p />
            The problem here is that we do not necessarily have a ref to the associated
            entity persister (nor to the session factory, to look it up) which is really
            needed to "do the right thing" here...
             </summary>
    </member>
    <member name="P:NHibernate.Type.EntityType.IsMutable">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.EntityType.IsAssociationType">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.EntityType.ForeignKeyDirection">
      <summary>
            When implemented by a class, gets the type of foreign key directionality 
            of this association.
            </summary>
      <value>The <see cref="P:NHibernate.Type.EntityType.ForeignKeyDirection" /> of this association.</value>
    </member>
    <member name="P:NHibernate.Type.EntityType.UseLHSPrimaryKey">
      <summary>
            Is the foreign key the primary key of the table?
            </summary>
    </member>
    <member name="M:NHibernate.Type.EnumCharType`1.GetValue(System.Object)">
      <summary>
            Converts the given enum instance into a basic type.
            </summary>
      <param name="instance">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Type.EnumStringType">
      <summary>
            Maps a <see cref="T:System.Enum" /> to a 
            <see cref="F:System.Data.DbType.String">DbType.String</see>.
            </summary>
      <remarks>
            If your database should store the <see cref="T:System.Enum" />
            using the named values in the enum instead of the underlying values
            then subclass this <see cref="T:NHibernate.Type.IType" />.
            
            <para>
            All that needs to be done is to provide a default constructor that
            NHibernate can use to create the specific type.  For example, if 
            you had an enum defined as.
            </para><code>
            public enum MyEnum 
            {
            	On,
            	Off,
            	Dimmed
            }
            </code><para>
            all that needs to be written for your enum string type is:
            </para><code>
            public class MyEnumStringType : NHibernate.Type.EnumStringType
            {
            	public MyEnumStringType()
            		: base( typeof( MyEnum ) )
            	{
            	}
            }
            </code><para>
            The mapping would look like:
            </para><code>
            ...
            	&lt;property name="Status" type="MyEnumStringType, AssemblyContaining" /&gt;
            ...
            </code><para>
            The TestFixture that shows the working code can be seen
            in <c>NHibernate.Test.TypesTest.EnumStringTypeFixture.cs</c>
            , <c>NHibernate.Test.TypesTest.EnumStringClass.cs</c>
            , and <c>NHibernate.Test.TypesTest.EnumStringClass.hbm.xml</c></para></remarks>
    </member>
    <member name="F:NHibernate.Type.EnumStringType.MaxLengthForEnumString">
      <summary>
            Hardcoding of <c>255</c> for the maximum length
            of the Enum name that will be saved to the db.
            </summary>
      <value>
        <c>255</c> because that matches the default length that hbm2ddl will
            use to create the column.
            </value>
    </member>
    <member name="M:NHibernate.Type.EnumStringType.#ctor(System.Type)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Type.EnumStringType" />.
            </summary>
      <param name="enumClass">The <see cref="T:System.Type" /> of the Enum.</param>
    </member>
    <member name="M:NHibernate.Type.EnumStringType.#ctor(System.Type,System.Int32)">
      <summary>
            Initializes a new instance of <see cref="T:NHibernate.Type.EnumStringType" />.
            </summary>
      <param name="enumClass">The <see cref="T:System.Type" /> of the Enum.</param>
      <param name="length">The length of the string that can be written to the column.</param>
    </member>
    <member name="M:NHibernate.Type.EnumStringType.GetInstance(System.Object)">
      <summary>
      </summary>
      <param name="code">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.EnumStringType.GetValue(System.Object)">
      <summary>
      </summary>
      <param name="code">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.EnumStringType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
      <summary>
      </summary>
      <param name="cmd">
      </param>
      <param name="value">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="M:NHibernate.Type.EnumStringType.Get(System.Data.IDataReader,System.Int32)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.EnumStringType.Get(System.Data.IDataReader,System.String)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.EnumStringType.ToString(System.Object)">
      <summary>
      </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.EnumStringType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
      </summary>
      <param name="cached">
      </param>
      <param name="session">
      </param>
      <param name="owner">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Type.EnumStringType.Name">
      <summary>
      </summary>
      <remarks>
            This appends <c>enumstring - </c> to the beginning of the underlying
            enums name so that <see cref="T:System.Enum" /> could still be stored
            using the underlying value through the <see cref="T:NHibernate.Type.PersistentEnumType" />
            also.
            </remarks>
    </member>
    <member name="T:NHibernate.Type.ForeignKeyDirection">
      <summary>
            Represents directionality of the foreign key constraint
            </summary>
    </member>
    <member name="F:NHibernate.Type.ForeignKeyDirection.ForeignKeyFromParent">
      <summary>
            A foreign key from parent to child
            </summary>
    </member>
    <member name="F:NHibernate.Type.ForeignKeyDirection.ForeignKeyToParent">
      <summary>
            A foreign key from child to parent
            </summary>
    </member>
    <member name="M:NHibernate.Type.ForeignKeyDirection.CascadeNow(NHibernate.Engine.CascadePoint)">
      <summary>
            Should we cascade at this cascade point?
            </summary>
    </member>
    <member name="T:NHibernate.Type.GenericBagType`1">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that maps an <see cref="T:System.Collections.Generic.IList`1" /> collection
            to the database using bag semantics.
            </summary>
    </member>
    <member name="M:NHibernate.Type.GenericBagType`1.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericBagType`1" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
    </member>
    <member name="M:NHibernate.Type.GenericBagType`1.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection" /> for the bag.
            </summary>
      <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the bag.</param>
      <param name="persister">The current <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> for the bag.</param>
      <param name="key">
      </param>
    </member>
    <member name="M:NHibernate.Type.GenericBagType`1.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Wraps an <see cref="T:System.Collections.Generic.IList`1" /> in a <see cref="T:NHibernate.Collection.Generic.PersistentGenericBag`1" />.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the collection to be a part of.</param>
      <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentGenericBag`1" /> that wraps the non NHibernate <see cref="T:System.Collections.Generic.IList`1" />.
            </returns>
    </member>
    <member name="T:NHibernate.Type.IdentifierBagType">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that maps an <see cref="T:System.Collections.IList" /> collection
            using bag semantics with an identifier to the database.
            </summary>
    </member>
    <member name="M:NHibernate.Type.IdentifierBagType.#ctor(System.String,System.String,System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.IdentifierBagType" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="isEmbeddedInXML">
      </param>
    </member>
    <member name="M:NHibernate.Type.IdentifierBagType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection" /> for the identifier bag.
            </summary>
      <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the identifier bag.</param>
      <param name="persister">
      </param>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.IdentifierBagType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Wraps an <see cref="T:System.Collections.IList" /> in a <see cref="T:NHibernate.Collection.PersistentIdentifierBag" />.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the collection to be a part of.</param>
      <param name="collection">The unwrapped <see cref="T:System.Collections.IList" />.</param>
      <returns>
            An <see cref="T:NHibernate.Collection.PersistentIdentifierBag" /> that wraps the non NHibernate <see cref="T:System.Collections.IList" />.
            </returns>
    </member>
    <member name="P:NHibernate.Type.IdentifierBagType.ReturnedClass">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.ListType">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that maps an <see cref="T:System.Collections.IList" /> collection
            using list semantics to the database.
            </summary>
    </member>
    <member name="M:NHibernate.Type.ListType.#ctor(System.String,System.String,System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.ListType" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="isEmbeddedInXML">
      </param>
    </member>
    <member name="M:NHibernate.Type.ListType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection" /> for the bag.
            </summary>
      <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the bag.</param>
      <param name="persister">
      </param>
      <param name="key">
      </param>
      <returns>A new <see cref="T:NHibernate.Collection.PersistentList" />.</returns>
    </member>
    <member name="M:NHibernate.Type.ListType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Wraps an exist <see cref="T:System.Collections.IList" /> in a NHibernate <see cref="T:NHibernate.Collection.PersistentList" />.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the collection to be a part of.</param>
      <param name="collection">The unwrapped <see cref="T:System.Collections.IList" />.</param>
      <returns>
            An <see cref="T:NHibernate.Collection.PersistentList" /> that wraps the non NHibernate <see cref="T:System.Collections.IList" />.
            </returns>
    </member>
    <member name="P:NHibernate.Type.ListType.ReturnedClass">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.GenericListType`1">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that maps an <see cref="T:System.Collections.Generic.IList`1" /> collection
            to the database using list semantics.
            </summary>
    </member>
    <member name="M:NHibernate.Type.GenericListType`1.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericListType`1" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
    </member>
    <member name="M:NHibernate.Type.GenericListType`1.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection" /> for the list.
            </summary>
      <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the list.</param>
      <param name="persister">The current <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> for the list.</param>
      <param name="key">
      </param>
    </member>
    <member name="M:NHibernate.Type.GenericListType`1.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Wraps an <see cref="T:System.Collections.Generic.IList`1" /> in a <see cref="T:NHibernate.Collection.Generic.PersistentGenericList`1" />.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the collection to be a part of.</param>
      <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentGenericList`1" /> that wraps the non NHibernate <see cref="T:System.Collections.Generic.IList`1" />.
            </returns>
    </member>
    <member name="T:NHibernate.Type.MapType">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that maps an <see cref="T:System.Collections.IDictionary" /> collection
            to the database.
            </summary>
    </member>
    <member name="M:NHibernate.Type.MapType.#ctor(System.String,System.String,System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.MapType" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="isEmbeddedInXML">
      </param>
    </member>
    <member name="M:NHibernate.Type.MapType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection" /> for the map.
            </summary>
      <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the map.</param>
      <param name="persister">
      </param>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.MapType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Wraps an <see cref="T:System.Collections.IDictionary" /> in a <see cref="T:NHibernate.Collection.PersistentMap" />.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the collection to be a part of.</param>
      <param name="collection">The unwrapped <see cref="T:System.Collections.IDictionary" />.</param>
      <returns>
            An <see cref="T:NHibernate.Collection.PersistentMap" /> that wraps the non NHibernate <see cref="T:System.Collections.IDictionary" />.
            </returns>
    </member>
    <member name="P:NHibernate.Type.MapType.ReturnedClass">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.GenericMapType`2">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that maps an <see cref="T:System.Collections.Generic.IDictionary`2" /> collection
            to the database.
            </summary>
    </member>
    <member name="M:NHibernate.Type.GenericMapType`2.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericMapType`2" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
    </member>
    <member name="M:NHibernate.Type.GenericMapType`2.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection" /> for the map.
            </summary>
      <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the map.</param>
      <param name="persister">
      </param>
      <param name="key">Not used.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.GenericMapType`2.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Wraps an <see cref="T:System.Collections.Generic.IDictionary`2" /> in a <see cref="T:NHibernate.Collection.Generic.PersistentGenericMap`2" />.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the collection to be a part of.</param>
      <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IDictionary`2" />.</param>
      <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentGenericMap`2" /> that wraps the 
            non NHibernate <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </returns>
    </member>
    <member name="T:NHibernate.Type.SetType">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that maps an <see cref="T:Iesi.Collections.ISet" /> collection
            to the database.
            </summary>
    </member>
    <member name="M:NHibernate.Type.SetType.#ctor(System.String,System.String,System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.SetType" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="isEmbeddedInXML">
      </param>
    </member>
    <member name="M:NHibernate.Type.SetType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection" /> for the set.
            </summary>
      <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the set.</param>
      <param name="persister">
      </param>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.SetType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Wraps an <see cref="T:Iesi.Collections.ISet" /> in a <see cref="T:NHibernate.Collection.PersistentSet" />.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the collection to be a part of.</param>
      <param name="collection">The unwrapped <see cref="T:Iesi.Collections.ISet" />.</param>
      <returns>
            An <see cref="T:NHibernate.Collection.PersistentSet" /> that wraps the non NHibernate <see cref="T:Iesi.Collections.ISet" />.
            </returns>
    </member>
    <member name="P:NHibernate.Type.SetType.ReturnedClass">
      <summary>
        <see cref="P:NHibernate.Type.AbstractType.ReturnedClass" />
      </summary>
    </member>
    <member name="T:NHibernate.Type.GenericSetType`1">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that maps an <see cref="T:Iesi.Collections.Generic.ISet`1" /> collection
            to the database.
            </summary>
    </member>
    <member name="M:NHibernate.Type.GenericSetType`1.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericSetType`1" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
    </member>
    <member name="M:NHibernate.Type.GenericSetType`1.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister,System.Object)">
      <summary>
            Instantiates a new <see cref="T:NHibernate.Collection.IPersistentCollection" /> for the set.
            </summary>
      <param name="session">The current <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the set.</param>
      <param name="persister">The current <see cref="T:NHibernate.Persister.Collection.ICollectionPersister" /> for the set.</param>
      <param name="key">
      </param>
    </member>
    <member name="M:NHibernate.Type.GenericSetType`1.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Wraps an <see cref="T:System.Collections.Generic.IList`1" /> in a <see cref="T:NHibernate.Collection.Generic.PersistentGenericSet`1" />.
            </summary>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> for the collection to be a part of.</param>
      <param name="collection">The unwrapped <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <returns>
            An <see cref="T:NHibernate.Collection.Generic.PersistentGenericSet`1" /> that wraps the non NHibernate <see cref="T:System.Collections.Generic.IList`1" />.
            </returns>
    </member>
    <member name="T:NHibernate.Type.GenericOrderedSetType`1">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that maps a sorted <see cref="T:Iesi.Collections.Generic.ISet`1" /> collection
            to the database.
            </summary>
    </member>
    <member name="M:NHibernate.Type.GenericOrderedSetType`1.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericOrderedSetType`1" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
    </member>
    <member name="T:NHibernate.Type.GenericSortedSetType`1">
      <summary>
            An <see cref="T:NHibernate.Type.IType" /> that maps a sorted <see cref="T:Iesi.Collections.Generic.ISet`1" /> collection
            to the database.
            </summary>
    </member>
    <member name="M:NHibernate.Type.GenericSortedSetType`1.#ctor(System.String,System.String,System.Collections.Generic.IComparer{`0})">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.GenericSortedSetType`1" /> class for
            a specific role.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> to use to compare
            set elements.</param>
    </member>
    <member name="T:NHibernate.Type.GuidType">
      <summary>
            Maps a <see cref="T:System.Guid" /> Property 
            to a <see cref="F:System.Data.DbType.Guid" /> column.
            </summary>
    </member>
    <member name="M:NHibernate.Type.GuidType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Type.GuidType.Get(System.Data.IDataReader,System.Int32)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.GuidType.Get(System.Data.IDataReader,System.String)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Type.GuidType.ReturnedClass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.GuidType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.Int16Type">
      <summary>
            Maps a <see cref="T:System.Int16" /> Property 
            to a <see cref="F:System.Data.DbType.Int16" /> column.
            </summary>
    </member>
    <member name="M:NHibernate.Type.Int16Type.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.Int16Type.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.Int32Type">
      <summary>
            Maps a <see cref="T:System.Int32" /> Property 
            to a <see cref="F:System.Data.DbType.Int32" /> column.
            </summary>
    </member>
    <member name="M:NHibernate.Type.Int32Type.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.Int32Type.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.Int64Type">
      <summary>
            Maps a <see cref="T:System.Int64" /> Property 
            to a <see cref="F:System.Data.DbType.Int64" /> column.
            </summary>
    </member>
    <member name="M:NHibernate.Type.Int64Type.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.Int64Type.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.ManyToOneType">
      <summary>
            A many-to-one association to an entity
            </summary>
    </member>
    <member name="M:NHibernate.Type.ManyToOneType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Hydrates the Identifier from <see cref="T:System.Data.IDataReader" />.
            </summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> that contains the query results.</param>
      <param name="names">A string array of column names to read from.</param>
      <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor" /> this is occurring in.</param>
      <param name="owner">The object that this Entity will be a part of.</param>
      <returns>
            An instantiated object that used as the identifier of the type.
            </returns>
    </member>
    <member name="T:NHibernate.Type.OneToOneType">
      <summary>
            A one-to-one association to an entity
            </summary>
    </member>
    <member name="P:NHibernate.Type.OneToOneType.IsAlwaysDirtyChecked">
      <summary>
            We don't need to dirty check one-to-one because of how 
            assemble/disassemble is implemented and because a one-to-one 
            association is never dirty
            </summary>
    </member>
    <member name="T:NHibernate.Type.OrderedMapType">
      <summary>
            A <see cref="T:NHibernate.Type.MapType" /> implemented using a collection that maintains
            the order in which elements are inserted into it.
            </summary>
    </member>
    <member name="M:NHibernate.Type.OrderedMapType.#ctor(System.String,System.String,System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.OrderedMapType" /> class.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">
      </param>
      <param name="isEmbeddedInXML">
      </param>
    </member>
    <member name="T:NHibernate.Type.OrderedSetType">
      <summary>
            A <see cref="T:NHibernate.Type.SetType" /> implemented using a collection that maintains
            the order in which elements are inserted into it.
            </summary>
    </member>
    <member name="M:NHibernate.Type.OrderedSetType.#ctor(System.String,System.String,System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.OrderedSetType" /> class
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">
      </param>
      <param name="isEmbeddedInXML">
      </param>
    </member>
    <member name="T:NHibernate.Type.PersistentEnumType">
      <summary>
            PersistentEnumType
            </summary>
    </member>
    <member name="M:NHibernate.Type.PersistentEnumType.GetInstance(System.Object)">
      <summary>
            Gets an instance of the Enum
            </summary>
      <param name="code">The underlying value of an item in the Enum.</param>
      <returns>
            An instance of the Enum set to the <c>code</c> value.
            </returns>
    </member>
    <member name="M:NHibernate.Type.PersistentEnumType.GetValue(System.Object)">
      <summary>
            Gets the correct value for the Enum.
            </summary>
      <param name="code">The value to convert (an enum instance).</param>
      <returns>A boxed version of the code, converted to the correct type.</returns>
      <remarks>
            This handles situations where the DataProvider returns the value of the Enum
            from the db in the wrong underlying type.  It uses <see cref="T:System.Convert" /> to 
            convert it to the correct type.
            </remarks>
    </member>
    <member name="T:NHibernate.Type.SByteType">
      <summary>
            Maps a <see cref="T:System.SByte" /> Property 
            to a <see cref="F:System.Data.DbType.SByte" /> column.
            </summary>
    </member>
    <member name="M:NHibernate.Type.SByteType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.SByteType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.SerializableType">
      <summary>
            Maps an instance of a <see cref="T:System.Object" /> that has the <see cref="T:System.SerializableAttribute" />
            to a <see cref="F:System.Data.DbType.Binary" /> column.  
            </summary>
      <remarks>
        <para>
            The SerializableType should be used when you know that Bytes are 
            not going to be greater than 8,000.
            </para>
        <para>
            The base class is <see cref="T:NHibernate.Type.MutableType" /> because the data is stored in 
            a byte[].  The System.Array does not have a nice "equals" method so we must
            do a custom implementation.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Type.SerializableType.DeepCopyNotNull(System.Object)">
      <summary>
      </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.SerializableType.FromBytes(System.Byte[])">
      <summary>
      </summary>
      <param name="bytes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Type.SerializableType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.SerializationException">
      <summary>
            Thrown when a property cannot be serialized/deserialized
            </summary>
    </member>
    <member name="M:NHibernate.Type.SerializationException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.Type.SerializationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException" /> class.
            </summary>
      <param name="message">The message that describes the error.</param>
    </member>
    <member name="M:NHibernate.Type.SerializationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException" /> class.
            </summary>
      <param name="message">The message that describes the error.</param>
      <param name="e">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.Type.SerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.Type.SingleType">
      <summary>
            Maps a <see cref="T:System.Single" /> Property to an 
            <see cref="F:System.Data.DbType.Single" /> column.
            </summary>
      <remarks>
            Verify through your database's documentation if there is a column type that
            matches up with the capabilities of <see cref="T:System.Single" /></remarks>
    </member>
    <member name="M:NHibernate.Type.SingleType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.SingleType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.SortedMapType">
      <summary>
            Extends the <see cref="T:NHibernate.Type.MapType" /> to provide sorting.
            </summary>
    </member>
    <member name="M:NHibernate.Type.SortedMapType.#ctor(System.String,System.String,System.Collections.IComparer,System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.SortedMapType" /> class for
            a specific role using the <see cref="T:System.Collections.IComparer" /> to do the sorting.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="comparer">The <see cref="T:System.Collections.IComparer" /> to use for the sorting.</param>
      <param name="isEmbeddedInXML">
      </param>
    </member>
    <member name="T:NHibernate.Type.SortedSetType">
      <summary>
            Extends the <see cref="T:NHibernate.Type.SetType" /> to provide sorting.
            </summary>
    </member>
    <member name="M:NHibernate.Type.SortedSetType.#ctor(System.String,System.String,System.Collections.IComparer,System.Boolean)">
      <summary>
            Initializes a new instance of a <see cref="T:NHibernate.Type.SortedSetType" /> class for
            a specific role using the <see cref="T:System.Collections.IComparer" /> to do the sorting.
            </summary>
      <param name="role">The role the persistent collection is in.</param>
      <param name="propertyRef">The name of the property in the
            owner object containing the collection ID, or <see langword="null" /> if it is
            the primary key.</param>
      <param name="comparer">The <see cref="T:System.Collections.IComparer" /> to use for the sorting.</param>
      <param name="isEmbeddedInXML">
      </param>
    </member>
    <member name="T:NHibernate.Type.SpecialOneToOneType">
      <summary> 
            A one-to-one association that maps to specific formula(s)
            instead of the primary key column of the owning entity. 
            </summary>
    </member>
    <member name="T:NHibernate.Type.StringType">
      <summary>
            Maps a <see cref="T:System.String" /> to a <see cref="F:System.Data.DbType.String" /> column.
            </summary>
    </member>
    <member name="T:NHibernate.Type.StringClobType">
      <summary>
            Maps a <see cref="T:System.String" /> Property to an 
            <see cref="T:System.String" /> column that can store a CLOB.
            </summary>
      <remarks>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a StringType
            would work just fine.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.StringClobType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Type.StringClobType.#ctor(NHibernate.SqlTypes.StringSqlType)">
      <summary>
      </summary>
      <param name="sqlType">
      </param>
    </member>
    <member name="P:NHibernate.Type.StringClobType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.TicksType">
      <summary>
            Maps a <see cref="T:System.DateTime" /> Property to an <see cref="F:System.Data.DbType.Int64" /> column 
            that stores the DateTime using the Ticks property.
            </summary>
      <remarks>
            This is the recommended way to "timestamp" a column.  
            The System.DateTime.Ticks is accurate to 100-nanosecond intervals. 
            </remarks>
    </member>
    <member name="M:NHibernate.Type.TicksType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Type.TicksType.Get(System.Data.IDataReader,System.Int32)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.TicksType.Get(System.Data.IDataReader,System.String)">
      <summary>
      </summary>
      <param name="rs">
      </param>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.TicksType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
      <summary>
      </summary>
      <param name="st">
      </param>
      <param name="value">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="P:NHibernate.Type.TicksType.ReturnedClass">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.TicksType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.TimeAsTimeSpanType">
      <summary>
            Maps a <see cref="T:System.TimeSpan" /> Property to an <see cref="F:System.Data.DbType.Time" /> column 
            This is an extra way to map a <see cref="F:System.Data.DbType.Time" />. You already have <see cref="T:NHibernate.Type.TimeType" />
            but mapping against a <see cref="T:System.DateTime" />.
            </summary>
    </member>
    <member name="T:NHibernate.Type.TimeSpanType">
      <summary>
            Maps a <see cref="T:System.TimeSpan" /> Property to an <see cref="F:System.Data.DbType.Int64" /> column 
            </summary>
    </member>
    <member name="M:NHibernate.Type.TimeSpanType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Type.TimeSpanType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
      <summary>
      </summary>
      <param name="st">
      </param>
      <param name="value">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="M:NHibernate.Type.TimeSpanType.Seed(NHibernate.Engine.ISessionImplementor)">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.TimeSpanType.Name">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.TimeSpanType.ReturnedClass">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.TimeType">
      <summary>
            Maps a <see cref="T:System.DateTime" /> Property to an DateTime column that only stores the 
            Hours, Minutes, and Seconds of the DateTime as significant.
            Also you have for <see cref="F:System.Data.DbType.Time" /> handling, the NHibernate Type <see cref="T:NHibernate.Type.TimeAsTimeSpanType" />,
            the which maps to a <see cref="T:System.TimeSpan" />.
            </summary>
      <remarks>
        <para>
            This defaults the Date to "1753-01-01" - that should not matter because
            using this Type indicates that you don't care about the Date portion of the DateTime.
            </para>
        <para>
            A more appropriate choice to store the duration/time is the <see cref="T:NHibernate.Type.TimeSpanType" />.
            The underlying <see cref="F:System.Data.DbType.Time" /> tends to be handled differently by different
            DataProviders.
            </para>
      </remarks>
    </member>
    <member name="T:NHibernate.Type.TrueFalseType">
      <summary>
            Maps a <see cref="T:System.Boolean" /> to a 1 char <see cref="F:System.Data.DbType.AnsiStringFixedLength" /> column 
            that stores a <code>'T'/'F'</code> to indicate <code>true/false</code>.
            </summary>
      <remarks>
            If you are using schema-export to generate your tables then you need
            to set the column attributes: <c>length=1</c> or <c>sql-type="char(1)"</c>.
            
            This needs to be done because in Java's JDBC there is a type for CHAR and 
            in ADO.NET there is not one specifically for char, so you need to tell schema
            export to create a char(1) column.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.TrueFalseType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.TrueFalseType.TrueString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.TrueFalseType.FalseString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.TrueFalseType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.TypeFactory">
      <summary>
            Used internally to obtain instances of IType.
            </summary>
      <remarks>
            Applications should use static methods and constants on NHibernate.NHibernateUtil if the default
            IType is good enough.  For example, the TypeFactory should only be used when the String needs
            to have a length of 300 instead of 255.  At this point NHibernate.String does not get you the 
            correct IType.  Instead use TypeFactory.GetString(300) and keep a local variable that holds
            a reference to the IType.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.RegisterDefaultNetTypes">
      <summary>
            Register other Default .NET type
            </summary>
      <remarks>
            These type will be used, as default, even when the "type" attribute was NOT specified in the mapping
            </remarks>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.RegisterBuiltInTypes">
      <summary>
            Register other NO Default .NET type
            </summary>
      <remarks>
            These type will be used only when the "type" attribute was is specified in the mapping.
            These are in here because needed to NO override default CLR types and be available in mappings
            </remarks>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.GetTypeClassification(System.String)">
      <summary>
            Gets the classification of the Type based on the string.
            </summary>
      <param name="typeName">The name of the Type to get the classification for.</param>
      <returns>The Type of Classification</returns>
      <remarks>
            This parses through the string and makes the assumption that no class
            name and no assembly name will contain the <c>"("</c>.  
            <para>
            If it finds 
            the <c>"("</c> and then finds a <c>","</c> afterwards then it is a 
            <c>TypeClassification.PrecisionScale</c>.  
            </para><para>
            If it finds the <c>"("</c>
            and doesn't find a <c>","</c> afterwards, then it is a 
            <c>TypeClassification.Length</c>.
            </para><para>
            If it doesn't find the <c>"("</c> then it assumes that it is a
            <c>TypeClassification.Plain</c>.
            </para></remarks>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.Basic(System.String)">
      <summary>
            Given the name of a Hibernate type such as Decimal, Decimal(19,0)
            , Int32, or even NHibernate.Type.DecimalType, NHibernate.Type.DecimalType(19,0), 
            NHibernate.Type.Int32Type, then return an instance of NHibernate.Type.IType
            </summary>
      <param name="name">The name of the type.</param>
      <returns>The instance of the IType that the string represents.</returns>
      <remarks>
            This method will return null if the name is not found in the basicNameMap.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.HeuristicType(System.String)">
      <summary>
            Uses heuristics to deduce a NHibernate type given a string naming the 
            type. 
            </summary>
      <param name="typeName">
      </param>
      <returns>An instance of <c>NHibernate.Type.IType</c></returns>
      <remarks>
            When looking for the NHibernate type it will look in the cache of the Basic types first.
            If it doesn't find it in the cache then it uses the typeName to get a reference to the
            Class (Type in .NET).  Once we get the reference to the .NET class we check to see if it
            implements IType, ICompositeUserType, IUserType, ILifecycle (Association), or 
            IPersistentEnum.  If none of those are implemented then we will serialize the Type to the
            database using NHibernate.Type.SerializableType(typeName)  
            </remarks>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.HeuristicType(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Uses heuristics to deduce a NHibernate type given a string naming the 
            type. 
            </summary>
      <param name="typeName">the type name</param>
      <param name="parameters">parameters for the type</param>
      <returns>An instance of <c>NHibernate.Type.IType</c></returns>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.GetBinaryType(System.Int32)">
      <summary>
            Gets the BinaryType with the specified length.
            </summary>
      <param name="length">The length of the data to store in the database.</param>
      <returns>A BinaryType</returns>
      <remarks>
            In addition to returning the BinaryType it will also ensure that it has
            been added to the basicNameMap with the keys <c>Byte[](length)</c> and 
            <c>NHibernate.Type.BinaryType(length)</c>.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.GetSerializableType(System.Type)">
      <summary>
            Gets the SerializableType for the specified Type
            </summary>
      <param name="serializableType">The Type that will be Serialized to the database.</param>
      <returns>A SerializableType</returns>
      <remarks>
        <para>
            In addition to returning the SerializableType it will also ensure that it has
            been added to the basicNameMap with the keys <c>Type.FullName</c> (the result
            of <c>IType.Name</c> and <c>Type.AssemblyQualifiedName</c>.  This is different 
            from the other items put in the basicNameMap because it is uses the AQN and the
            FQN as opposed to the short name used in the maps and the FQN.
            </para>
        <para>
            Since this method calls the method
            <see cref="M:NHibernate.Type.TypeFactory.GetSerializableType(System.Type,System.Int32)">GetSerializableType(System.Type, Int32)</see>
            with the default length, those keys will also be added.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.OneToOne(System.String,NHibernate.Type.ForeignKeyDirection,System.String,System.Boolean,System.Boolean,System.Boolean,System.String,System.String)">
      <summary>
            A one-to-one association type for the given class and cascade style.
            </summary>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.ManyToOne(System.String)">
      <summary>
            A many-to-one association type for the given class and cascade style.
            </summary>
      <param name="persistentClass">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.ManyToOne(System.String,System.Boolean)">
      <summary>
            A many-to-one association type for the given class and cascade style.
            </summary>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.ManyToOne(System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            A many-to-one association type for the given class and cascade style.
            </summary>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.DeepCopy(System.Object[],NHibernate.Type.IType[],System.Boolean[],System.Object[],NHibernate.Engine.ISessionImplementor)">
      <summary> Deep copy a series of values from one array to another... </summary>
      <param name="values">The values to copy (the source) </param>
      <param name="types">The value types </param>
      <param name="copy">an array indicating which values to include in the copy </param>
      <param name="target">The array into which to copy the values </param>
      <param name="session">The originating session </param>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.BeforeAssemble(System.Object[],NHibernate.Type.ICacheAssembler[],NHibernate.Engine.ISessionImplementor)">
      <summary> Apply the <see cref="M:NHibernate.Type.ICacheAssembler.BeforeAssemble(System.Object,NHibernate.Engine.ISessionImplementor)" /> operation across a series of values. </summary>
      <param name="row">The values </param>
      <param name="types">The value types </param>
      <param name="session">The originating session </param>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.FindDirty(NHibernate.Tuple.StandardProperty[],System.Object[],System.Object[],System.Boolean[][],System.Boolean,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Determine if any of the given field values are dirty,
            returning an array containing indexes of
            the dirty fields or null if no fields are dirty.
            </summary>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.FindModified(NHibernate.Tuple.StandardProperty[],System.Object[],System.Object[],System.Boolean[][],System.Boolean,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Determine if any of the given field values are modified,
            returning an array containing indexes of
            the dirty fields or null if no fields are modified.
            </summary>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.Assemble(System.Object[],NHibernate.Type.ICacheAssembler[],NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
      </summary>
      <param name="row">
      </param>
      <param name="types">
      </param>
      <param name="session">
      </param>
      <param name="owner">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.Disassemble(System.Object[],NHibernate.Type.ICacheAssembler[],System.Boolean[],NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary> Apply the {@link Type#disassemble} operation across a series of values. </summary>
      <param name="row">The values </param>
      <param name="types">The value types </param>
      <param name="nonCacheable">An array indicating which values to include in the disassembled state </param>
      <param name="session">The originating session </param>
      <param name="owner">The entity "owning" the values </param>
      <returns> The disassembled state </returns>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.Replace(System.Object[],System.Object[],NHibernate.Type.IType[],NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)">
      <summary>
             Apply the <see cref="M:NHibernate.Type.IType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)" /> operation across a series of values.
            </summary>
      <param name="original">The source of the state </param>
      <param name="target">The target into which to replace the source values. </param>
      <param name="types">The value types </param>
      <param name="session">The originating session </param>
      <param name="owner">The entity "owning" the values </param>
      <param name="copiedAlready">Represent a cache of already replaced state </param>
      <returns> The replaced state </returns>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.Replace(System.Object[],System.Object[],NHibernate.Type.IType[],NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary,NHibernate.Type.ForeignKeyDirection)">
      <summary>
            Apply the <see cref="M:NHibernate.Type.IType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary,NHibernate.Type.ForeignKeyDirection)" /> 
            operation across a series of values.
            </summary>
      <param name="original">The source of the state </param>
      <param name="target">The target into which to replace the source values. </param>
      <param name="types">The value types </param>
      <param name="session">The originating session </param>
      <param name="owner">The entity "owning" the values </param>
      <param name="copyCache">A map representing a cache of already replaced state </param>
      <param name="foreignKeyDirection">FK directionality to be applied to the replacement </param>
      <returns> The replaced state </returns>
    </member>
    <member name="M:NHibernate.Type.TypeFactory.ReplaceAssociations(System.Object[],System.Object[],NHibernate.Type.IType[],NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary,NHibernate.Type.ForeignKeyDirection)">
      <summary> 
            Apply the <see cref="M:NHibernate.Type.IType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary,NHibernate.Type.ForeignKeyDirection)" /> 
            operation across a series of values, as
            long as the corresponding <see cref="T:NHibernate.Type.IType" /> is an association.
            </summary>
      <param name="original">The source of the state </param>
      <param name="target">The target into which to replace the source values. </param>
      <param name="types">The value types </param>
      <param name="session">The originating session </param>
      <param name="owner">The entity "owning" the values </param>
      <param name="copyCache">A map representing a cache of already replaced state </param>
      <param name="foreignKeyDirection">FK directionality to be applied to the replacement </param>
      <returns> The replaced state </returns>
      <remarks>
            If the corresponding type is a component type, then apply <see cref="M:NHibernate.Type.TypeFactory.ReplaceAssociations(System.Object[],System.Object[],NHibernate.Type.IType[],NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary,NHibernate.Type.ForeignKeyDirection)" />
            across the component subtypes but do not replace the component value itself.
            </remarks>
    </member>
    <member name="T:NHibernate.Type.TypeType">
      <summary>
            Maps the Assembly Qualified Name of a <see cref="T:System.Type" /> to a 
            <see cref="F:System.Data.DbType.String" /> column.
            </summary>
    </member>
    <member name="M:NHibernate.Type.TypeType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Type.TypeType.#ctor(NHibernate.SqlTypes.StringSqlType)">
      <summary>
            Initialize a new instance of the TypeType class using a 
            <see cref="P:NHibernate.Type.TypeType.SqlType" />. 
            </summary>
      <param name="sqlType">The underlying <see cref="P:NHibernate.Type.TypeType.SqlType" />.</param>
    </member>
    <member name="M:NHibernate.Type.TypeType.Get(System.Data.IDataReader,System.Int32)">
      <summary>
            Gets the <see cref="T:System.Type" /> in the <see cref="T:System.Data.IDataReader" /> for the Property.
            </summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> that contains the value.</param>
      <param name="index">The index of the field to get the value from.</param>
      <returns>The <see cref="T:System.Type" /> from the database.</returns>
      <exception cref="T:System.TypeLoadException">
            Thrown when the value in the database can not be loaded as a <see cref="T:System.Type" /></exception>
    </member>
    <member name="M:NHibernate.Type.TypeType.Get(System.Data.IDataReader,System.String)">
      <summary>
            Gets the <see cref="T:System.Type" /> in the <see cref="T:System.Data.IDataReader" /> for the Property.
            </summary>
      <param name="rs">The <see cref="T:System.Data.IDataReader" /> that contains the value.</param>
      <param name="name">The name of the field to get the value from.</param>
      <returns>The <see cref="T:System.Type" /> from the database.</returns>
      <remarks>
            This just calls gets the index of the name in the IDataReader
            and calls the overloaded version <see cref="M:NHibernate.Type.TypeType.Get(System.Data.IDataReader,System.Int32)" />
            (IDataReader, Int32). 
            </remarks>
      <exception cref="T:System.TypeLoadException">
            Thrown when the value in the database can not be loaded as a <see cref="T:System.Type" /></exception>
    </member>
    <member name="M:NHibernate.Type.TypeType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
      <summary>
            Puts the Assembly Qualified Name of the <see cref="T:System.Type" /> 
            Property into to the <see cref="T:System.Data.IDbCommand" />.
            </summary>
      <param name="cmd">The <see cref="T:System.Data.IDbCommand" /> to put the value into.</param>
      <param name="value">The <see cref="T:System.Type" /> that contains the value.</param>
      <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter" /> to start writing the value to.</param>
      <remarks>
            This uses the <see cref="M:NHibernate.Type.NullableType.Set(System.Data.IDbCommand,System.Object,System.Int32)" /> method of the 
            <see cref="F:NHibernate.NHibernateUtil.String" /> object to do the work.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.TypeType.ToString(System.Object)">
      <summary>
            A representation of the value to be embedded in an XML element 
            </summary>
      <param name="value">The <see cref="T:System.Type" /> that contains the values.
            </param>
      <returns>An Xml formatted string that contains the Assembly Qualified Name.</returns>
    </member>
    <member name="P:NHibernate.Type.TypeType.ReturnedClass">
      <summary>
            Gets the <see cref="T:System.Type" /> that will be returned 
            by the <c>NullSafeGet()</c> methods.
            </summary>
      <value>
            A <see cref="T:System.Type" /> from the .NET framework.
            </value>
    </member>
    <member name="P:NHibernate.Type.TypeType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.UInt16Type">
      <summary>
            Maps a <see cref="T:System.UInt16" /> Property 
            to a <see cref="F:System.Data.DbType.UInt16" /> column.
            </summary>
    </member>
    <member name="M:NHibernate.Type.UInt16Type.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.UInt16Type.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.UInt32Type">
      <summary>
            Maps a <see cref="T:System.UInt32" /> Property 
            to a <see cref="F:System.Data.DbType.UInt32" /> column.
            </summary>
    </member>
    <member name="M:NHibernate.Type.UInt32Type.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.UInt32Type.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.UInt64Type">
      <summary>
            Maps a <see cref="T:System.UInt64" /> Property 
            to a <see cref="F:System.Data.DbType.UInt64" /> column.
            </summary>
    </member>
    <member name="M:NHibernate.Type.UInt64Type.#ctor">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Type.YesNoType">
      <summary>
            Maps a <see cref="T:System.Boolean" /> to a 1 char <see cref="F:System.Data.DbType.AnsiStringFixedLength" /> column 
            that stores a <code>'Y'/'N'</code> to indicate <code>true/false</code>.
            </summary>
      <remarks>
            If you are using schema-export to generate your tables then you need
            to set the column attributes: <c>length=1</c> or <c>sql-type="char(1)"</c>.
            
            This needs to be done because in Java's JDBC there is a type for CHAR and 
            in ADO.NET there is not one specifically for char, so you need to tell schema
            export to create a char(1) column.
            </remarks>
    </member>
    <member name="M:NHibernate.Type.YesNoType.#ctor">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.YesNoType.TrueString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.YesNoType.FalseString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Type.YesNoType.Name">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.UserTypes.ICompositeUserType">
      <summary>
            A UserType that may be dereferenced in a query.
            This interface allows a custom type to define "properties".
            These need not necessarily correspond to physical .NET style properties.
            
            A ICompositeUserType may be used in almost every way 
            that a component may be used. It may even contain many-to-one
            associations.
            
            Implementors must be immutable and must declare a public
            default constructor.
            
            Unlike UserType, cacheability does not depend upon
            serializability. Instead, Assemble() and 
            Disassemble() provide conversion to/from a cacheable
            representation.
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.ICompositeUserType.GetPropertyValue(System.Object,System.Int32)">
      <summary>
            Get the value of a property
            </summary>
      <param name="component">an instance of class mapped by this "type"</param>
      <param name="property">
      </param>
      <returns>the property value</returns>
    </member>
    <member name="M:NHibernate.UserTypes.ICompositeUserType.SetPropertyValue(System.Object,System.Int32,System.Object)">
      <summary>
            Set the value of a property
            </summary>
      <param name="component">an instance of class mapped by this "type"</param>
      <param name="property">
      </param>
      <param name="value">the value to set</param>
    </member>
    <member name="M:NHibernate.UserTypes.ICompositeUserType.Equals(System.Object,System.Object)">
      <summary>
            Compare two instances of the class mapped by this type for persistence
            "equality", ie. equality of persistent state.
            </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.UserTypes.ICompositeUserType.GetHashCode(System.Object)">
      <summary>
            Get a hashcode for the instance, consistent with persistence "equality"
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.ICompositeUserType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Retrieve an instance of the mapped class from a IDataReader. Implementors
            should handle possibility of null values.
            </summary>
      <param name="dr">IDataReader</param>
      <param name="names">the column names</param>
      <param name="session">
      </param>
      <param name="owner">the containing entity</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.UserTypes.ICompositeUserType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Write an instance of the mapped class to a prepared statement.
            Implementors should handle possibility of null values.
            A multi-column type should be written to parameters starting from index.
            </summary>
      <param name="cmd">
      </param>
      <param name="value">
      </param>
      <param name="index">
      </param>
      <param name="session">
      </param>
    </member>
    <member name="M:NHibernate.UserTypes.ICompositeUserType.DeepCopy(System.Object)">
      <summary>
            Return a deep copy of the persistent state, stopping at entities and at collections.
            </summary>
      <param name="value">generally a collection element or entity field</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.UserTypes.ICompositeUserType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Transform the object into its cacheable representation.
            At the very least this method should perform a deep copy.
            That may not be enough for some implementations, method should perform a deep copy. That may not be enough for some implementations, however; for example, associations must be cached as identifier values. (optional operation)
            </summary>
      <param name="value">the object to be cached</param>
      <param name="session">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.UserTypes.ICompositeUserType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Reconstruct an object from the cacheable representation.
            At the very least this method should perform a deep copy. (optional operation)
            </summary>
      <param name="cached">the object to be cached</param>
      <param name="session">
      </param>
      <param name="owner">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.UserTypes.ICompositeUserType.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            During merge, replace the existing (target) value in the entity we are merging to
            with a new (original) value from the detached entity we are merging. For immutable
            objects, or null values, it is safe to simply return the first parameter. For
            mutable objects, it is safe to return a copy of the first parameter. However, since
            composite user types often define component values, it might make sense to recursively 
            replace component values in the target object.
            </summary>
    </member>
    <member name="P:NHibernate.UserTypes.ICompositeUserType.PropertyNames">
      <summary>
            Get the "property names" that may be used in a query. 
            </summary>
    </member>
    <member name="P:NHibernate.UserTypes.ICompositeUserType.PropertyTypes">
      <summary>
            Get the corresponding "property types"
            </summary>
    </member>
    <member name="P:NHibernate.UserTypes.ICompositeUserType.ReturnedClass">
      <summary>
            The class returned by NullSafeGet().
            </summary>
    </member>
    <member name="P:NHibernate.UserTypes.ICompositeUserType.IsMutable">
      <summary>
            Are objects of this type mutable?
            </summary>
    </member>
    <member name="T:NHibernate.UserTypes.IUserType">
      <summary>
            The interface to be implemented by user-defined types.
            </summary>
      <remarks>
        <para>
            The interface abstracts user code from future changes to the <see cref="T:NHibernate.Type.IType" /> interface,
            simplifies the implementation of custom types and hides certain "internal interfaces from
            user code.
            </para>
        <para>
            Implementers must be immutable and must declare a public default constructor.
            </para>
        <para>
            The actual class mapped by a <c>IUserType</c> may be just about anything. However, if it is to
            be cacheble by a persistent cache, it must be serializable.
            </para>
        <para>
            Alternatively, custom types could implement <see cref="T:NHibernate.Type.IType" /> directly or extend one of the
            abstract classes in <c>NHibernate.Type</c>. This approach risks future incompatible changes
            to classes or interfaces in the package.
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.UserTypes.IUserType.Equals(System.Object,System.Object)">
      <summary>
            Compare two instances of the class mapped by this type for persistent "equality"
            ie. equality of persistent state
            </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.UserTypes.IUserType.GetHashCode(System.Object)">
      <summary>
            Get a hashcode for the instance, consistent with persistence "equality"
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IUserType.NullSafeGet(System.Data.IDataReader,System.String[],System.Object)">
      <summary>
            Retrieve an instance of the mapped class from a JDBC resultset.
            Implementors should handle possibility of null values.
            </summary>
      <param name="rs">a IDataReader</param>
      <param name="names">column names</param>
      <param name="owner">the containing entity</param>
      <returns>
      </returns>
      <exception cref="T:NHibernate.HibernateException">HibernateException</exception>
    </member>
    <member name="M:NHibernate.UserTypes.IUserType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)">
      <summary>
            Write an instance of the mapped class to a prepared statement.
            Implementors should handle possibility of null values.
            A multi-column type should be written to parameters starting from index.
            </summary>
      <param name="cmd">a IDbCommand</param>
      <param name="value">the object to write</param>
      <param name="index">command parameter index</param>
      <exception cref="T:NHibernate.HibernateException">HibernateException</exception>
    </member>
    <member name="M:NHibernate.UserTypes.IUserType.DeepCopy(System.Object)">
      <summary>
            Return a deep copy of the persistent state, stopping at entities and at collections.
            </summary>
      <param name="value">generally a collection element or entity field</param>
      <returns>a copy</returns>
    </member>
    <member name="M:NHibernate.UserTypes.IUserType.Replace(System.Object,System.Object,System.Object)">
      <summary>
            During merge, replace the existing (<paramref name="target" />) value in the entity
            we are merging to with a new (<paramref name="original" />) value from the detached
            entity we are merging. For immutable objects, or null values, it is safe to simply
            return the first parameter. For mutable objects, it is safe to return a copy of the
            first parameter. For objects with component values, it might make sense to
            recursively replace component values.
            </summary>
      <param name="original">the value from the detached entity being merged</param>
      <param name="target">the value in the managed entity</param>
      <param name="owner">the managed entity</param>
      <returns>the value to be merged</returns>
    </member>
    <member name="M:NHibernate.UserTypes.IUserType.Assemble(System.Object,System.Object)">
      <summary>
            Reconstruct an object from the cacheable representation. At the very least this
            method should perform a deep copy if the type is mutable. (optional operation)
            </summary>
      <param name="cached">the object to be cached</param>
      <param name="owner">the owner of the cached object</param>
      <returns>a reconstructed object from the cachable representation</returns>
    </member>
    <member name="M:NHibernate.UserTypes.IUserType.Disassemble(System.Object)">
      <summary>
            Transform the object into its cacheable representation. At the very least this
            method should perform a deep copy if the type is mutable. That may not be enough
            for some implementations, however; for example, associations must be cached as
            identifier values. (optional operation)
            </summary>
      <param name="value">the object to be cached</param>
      <returns>a cacheable representation of the object</returns>
    </member>
    <member name="P:NHibernate.UserTypes.IUserType.SqlTypes">
      <summary>
            The SQL types for the columns mapped by this type. 
            </summary>
    </member>
    <member name="P:NHibernate.UserTypes.IUserType.ReturnedType">
      <summary>
            The type returned by <c>NullSafeGet()</c></summary>
    </member>
    <member name="P:NHibernate.UserTypes.IUserType.IsMutable">
      <summary>
            Are objects of this type mutable?
            </summary>
    </member>
    <member name="T:NHibernate.UserTypes.IEnhancedUserType">
      <summary>
            A custom type that may function as an identifier or discriminator
            type, or may be marshalled to and from an XML document.
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IEnhancedUserType.FromXMLString(System.String)">
      <summary>
            Parse a string representation of this value, as it appears
            in an XML document.
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IEnhancedUserType.ObjectToSQLString(System.Object)">
      <summary>
            Return an SQL literal representation of the value
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IEnhancedUserType.ToXMLString(System.Object)">
      <summary> 
            Return a string representation of this value, as it
            should appear in an XML document
            </summary>
    </member>
    <member name="T:NHibernate.UserTypes.ILoggableUserType">
      <summary> 
            Marker interface for user types which want to perform custom
            logging of their corresponding values 
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.ILoggableUserType.ToLoggableString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
      <summary> Generate a loggable string representation of the collection (value). </summary>
      <param name="value">The collection to be logged; guaranteed to be non-null and initialized. </param>
      <param name="factory">The factory. </param>
      <returns> The loggable string representation. </returns>
    </member>
    <member name="T:NHibernate.UserTypes.IParameterizedType">
      <summary>
            Support for parameterizable types. A UserType or CustomUserType may be
            made parameterizable by implementing this interface. Parameters for a
            type may be set by using a nested type element for the property element
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IParameterizedType.SetParameterValues(System.Collections.Generic.IDictionary{System.String,System.String})">
      <summary>
            Gets called by Hibernate to pass the configured type parameters to 
            the implementation.
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IUserCollectionType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.Collection.ICollectionPersister)">
      <summary>
            Instantiate an uninitialized instance of the collection wrapper
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IUserCollectionType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
      <summary>
            Wrap an instance of a collection
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IUserCollectionType.GetElements(System.Object)">
      <summary>
            Return an <see cref="T:System.Collections.IEnumerable" /> over the elements of this collection - the passed collection
            instance may or may not be a wrapper
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IUserCollectionType.Contains(System.Object,System.Object)">
      <summary>
            Optional operation. Does the collection contain the entity instance?
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IUserCollectionType.IndexOf(System.Object,System.Object)">
      <summary>
            Optional operation. Return the index of the entity in the collection.
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IUserCollectionType.ReplaceElements(System.Object,System.Object,NHibernate.Persister.Collection.ICollectionPersister,System.Object,System.Collections.IDictionary,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Replace the elements of a collection with the elements of another collection
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IUserCollectionType.Instantiate(System.Int32)">
      <summary> 
            Instantiate an empty instance of the "underlying" collection (not a wrapper),
            but with the given anticipated size (i.e. accounting for initial size
            and perhaps load factor).
             </summary>
      <param name="anticipatedSize">
            The anticipated size of the instantiated collection
            after we are done populating it.  Note, may be negative to indicate that
            we not yet know anything about the anticipated size (i.e., when initializing
            from a result set row by row).
            </param>
    </member>
    <member name="T:NHibernate.UserTypes.IUserVersionType">
      <summary>
            A user type that may be used for a version property.
            </summary>
    </member>
    <member name="M:NHibernate.UserTypes.IUserVersionType.Seed(NHibernate.Engine.ISessionImplementor)">
      <summary>
            Generate an initial version.
            </summary>
      <param name="session">The session from which this request originates.  May be
            null; currently this only happens during startup when trying to determine
            the "unsaved value" of entities.</param>
      <returns>an instance of the type</returns>
    </member>
    <member name="M:NHibernate.UserTypes.IUserVersionType.Next(System.Object,NHibernate.Engine.ISessionImplementor)">
      <summary>
            Increment the version.
            </summary>
      <param name="current">The session from which this request originates.</param>
      <param name="session">the current version</param>
      <returns>an instance of the type</returns>
    </member>
    <member name="T:NHibernate.Util.ArrayHelper">
      <summary>
            Helper class that contains common array functions and 
            data structures used through out NHibernate.
            </summary>
    </member>
    <member name="M:NHibernate.Util.ArrayHelper.SafeSetValue(System.Collections.IList,System.Int32,System.Object)">
      <summary>
            Sets <paramref name="list" /> item at position <paramref name="index" /> to <paramref name="value" />.
            Expands the list by adding <see langword="null" /> values, if needed.
            </summary>
    </member>
    <member name="T:NHibernate.Util.CollectionHelper.EmptyMapClass">
      <summary>
            A read-only dictionary that is always empty and permits lookup by <see langword="null" /> key.
            </summary>
    </member>
    <member name="T:NHibernate.Util.CollectionHelper.EmptyMapClass`2">
      <summary>
            A read-only dictionary that is always empty and permits lookup by <see langword="null" /> key.
            </summary>
    </member>
    <member name="M:NHibernate.Util.CollectionHelper.GetHashCode(System.Collections.IEnumerable)">
      <summary>
            Computes a hash code for <paramref name="coll" />.
            </summary>
      <remarks>The hash code is computed as the sum of hash codes of
            individual elements, so that the value is independent of the
            collection iteration order.
            </remarks>
    </member>
    <member name="M:NHibernate.Util.CollectionHelper.CreateCaseInsensitiveHashtable``1">
      <summary>
            Creates a <see cref="T:System.Collections.Hashtable" /> that uses case-insensitive string comparison
            associated with invariant culture.
            </summary>
      <remarks>
            This is different from the method in <see cref="T:System.Collections.Specialized.CollectionsUtil" />
            in that the latter uses the current culture and is thus vulnerable to the "Turkish I" problem.
            </remarks>
    </member>
    <member name="M:NHibernate.Util.CollectionHelper.CreateCaseInsensitiveHashtable``1(System.Collections.Generic.IDictionary{System.String,``0})">
      <summary>
            Creates a <see cref="T:System.Collections.Hashtable" /> that uses case-insensitive string comparison
            associated with invariant culture.
            </summary>
      <remarks>
            This is different from the method in <see cref="T:System.Collections.Specialized.CollectionsUtil" />
            in that the latter uses the current culture and is thus vulnerable to the "Turkish I" problem.
            </remarks>
    </member>
    <member name="M:NHibernate.Util.CollectionHelper.GetHashCode``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes a hash code for <paramref name="coll" />.
            </summary>
      <remarks>The hash code is computed as the sum of hash codes of
            individual elements, so that the value is independent of the
            collection iteration order.
            </remarks>
    </member>
    <member name="T:NHibernate.Util.CollectionPrinter">
      <summary>
            Utility class implementing ToString for collections. All <c>ToString</c>
            overloads call <c>element.ToString()</c>.
            </summary>
      <remarks>
            To print collections of entities or typed values, use
            <see cref="T:NHibernate.Impl.Printer" />.
            </remarks>
    </member>
    <member name="T:NHibernate.Util.FilterHelper">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Util.IdentityMap">
      <summary>
            An <see cref="T:System.Collections.IDictionary" /> where keys are compared by object identity, rather than <c>equals</c>.
            
            All external users of this class need to have no knowledge of the IdentityKey - it is all
            hidden by this class.
            </summary>
      <remarks>
        <para>
            Do NOT use a System.Value type as the key for this Hashtable - only classes.  See
            the <a href="http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;threadm=bds2rm%24ruc%241%40charly.heeg.de&amp;rnum=1&amp;prev=/groups%3Fhl%3Den%26lr%3D%26ie%3DUTF-8%26oe%3DUTF-8%26q%3DSystem.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%26sa%3DN%26tab%3Dwg">google thread</a>
            about why using System.Value is a bad thing.
            </para>
        <para>
            If I understand it correctly, the first call to get an object defined by a DateTime("2003-01-01")
            would box the DateTime and return the identity key for the box.  If you were to get that Key and
            unbox it into a DateTime struct, then the next time you passed it in as the Key the IdentityMap
            would box it again (into a different box) and it would have a different IdentityKey - so you would
            not get the same value for the same DateTime value. 
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.Util.IdentityMap.Instantiate(System.Int32)">
      <summary>
            Create a new instance of the IdentityMap that has no 
            iteration order.
            </summary>
      <returns>A new IdentityMap based on a Hashtable.</returns>
    </member>
    <member name="M:NHibernate.Util.IdentityMap.InstantiateSequenced(System.Int32)">
      <summary>
            Create a new instance of the IdentityMap that has an 
            iteration order of the order the objects were added
            to the Map.
            </summary>
      <returns>A new IdentityMap based on ListDictionary.</returns>
    </member>
    <member name="M:NHibernate.Util.IdentityMap.ConcurrentEntries(System.Collections.IDictionary)">
      <summary>
            Return the Dictionary Entries (as instances of <c>DictionaryEntry</c> in a collection
            that is safe from concurrent modification).  Ie - we may safely add new instances
            to the underlying <c>IDictionary</c> during enumeration of the <c>Values</c>.
            </summary>
      <param name="map">The IDictionary to get the enumeration safe list.</param>
      <returns>A Collection of DictionaryEntries</returns>
    </member>
    <member name="M:NHibernate.Util.IdentityMap.#ctor(System.Collections.IDictionary)">
      <summary>
            Create the IdentityMap class with the correct class for the IDictionary.
            Unsorted = Hashtable
            Sorted = ListDictionary
            </summary>
      <param name="underlyingMap">A class that implements the IDictionary for storing the objects.</param>
    </member>
    <member name="M:NHibernate.Util.IdentityMap.Add(System.Object,System.Object)">
      <summary>
        <see cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </summary>
    </member>
    <member name="M:NHibernate.Util.IdentityMap.Clear">
      <summary>
        <see cref="M:System.Collections.IDictionary.Clear" />
      </summary>
    </member>
    <member name="M:NHibernate.Util.IdentityMap.Contains(System.Object)">
      <summary>
        <see cref="M:System.Collections.IDictionary.Contains(System.Object)" />
      </summary>
    </member>
    <member name="M:NHibernate.Util.IdentityMap.GetEnumerator">
      <summary>
        <see cref="M:System.Collections.IDictionary.GetEnumerator" />
      </summary>
    </member>
    <member name="M:NHibernate.Util.IdentityMap.Remove(System.Object)">
      <summary>
        <see cref="M:System.Collections.IDictionary.Remove(System.Object)" />
      </summary>
    </member>
    <member name="M:NHibernate.Util.IdentityMap.CopyTo(System.Array,System.Int32)">
      <summary>
        <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
      </summary>
      <param name="array">
      </param>
      <param name="i">
      </param>
    </member>
    <member name="M:NHibernate.Util.IdentityMap.VerifyValidKey(System.Object)">
      <summary>
            Verifies that we are not using a System.ValueType as the Key in the Dictionary
            </summary>
      <param name="obj">The object that will be the key.</param>
      <returns>An object that is safe to be a key.</returns>
      <exception cref="T:System.ArgumentException">Thrown when the obj is a System.ValueType</exception>
    </member>
    <member name="P:NHibernate.Util.IdentityMap.Count">
      <summary>
        <see cref="P:System.Collections.ICollection.Count" />
      </summary>
    </member>
    <member name="P:NHibernate.Util.IdentityMap.IsSynchronized">
      <summary>
        <see cref="P:System.Collections.ICollection.IsSynchronized" />
      </summary>
    </member>
    <member name="P:NHibernate.Util.IdentityMap.SyncRoot">
      <summary>
        <see cref="P:System.Collections.ICollection.SyncRoot" />
      </summary>
    </member>
    <member name="P:NHibernate.Util.IdentityMap.IsFixedSize">
      <summary>
        <see cref="P:System.Collections.IDictionary.IsFixedSize" />
      </summary>
    </member>
    <member name="P:NHibernate.Util.IdentityMap.IsReadOnly">
      <summary>
        <see cref="P:System.Collections.IDictionary.IsReadOnly" />
      </summary>
    </member>
    <member name="P:NHibernate.Util.IdentityMap.Keys">
      <summary>
            Returns the Keys used in this IdentityMap
            <see cref="P:System.Collections.IDictionary.IsReadOnly" /></summary>
    </member>
    <member name="P:NHibernate.Util.IdentityMap.Item(System.Object)">
      <summary>
        <see cref="P:System.Collections.IDictionary.Item(System.Object)" />
      </summary>
    </member>
    <member name="P:NHibernate.Util.IdentityMap.Values">
      <summary>
        <see cref="P:System.Collections.IDictionary.Values" />
      </summary>
    </member>
    <member name="P:NHibernate.Util.IdentityMap.EntryList">
      <summary>
            Provides a snapshot VIEW in the form of a List of the contents of the IdentityMap.
            You can safely iterate over this VIEW and modify the actual IdentityMap because the
            VIEW is a copy of the contents, not a reference to the existing Map.
            
            Contains a copy (not that actual instance stored) of the DictionaryEntries in a List.
            </summary>
    </member>
    <member name="T:NHibernate.Util.IdentitySet">
      <summary> 
            Set implementation that use == instead of equals() as its comparison mechanism
            that base its implementation of IdentityMap
            </summary>
    </member>
    <member name="T:NHibernate.Util.JoinedEnumerable">
      <summary>
            Combines multiple objects implementing <see cref="T:System.Collections.IEnumerable" /> into one.
            </summary>
    </member>
    <member name="F:NHibernate.Util.JoinedEnumerable._isAlreadyDisposed">
      <summary>
            A flag to indicate if <c>Dispose()</c> has been called.
            </summary>
    </member>
    <member name="M:NHibernate.Util.JoinedEnumerable.#ctor(System.Collections.IEnumerable[])">
      <summary>
            Creates an IEnumerable object from multiple IEnumerables.
            </summary>
      <param name="enumerables">The IEnumerables to join together.</param>
    </member>
    <member name="M:NHibernate.Util.JoinedEnumerable.MoveNext">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Util.JoinedEnumerable.Reset">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Util.JoinedEnumerable.GetEnumerator">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Util.JoinedEnumerable.Finalize">
      <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
    </member>
    <member name="M:NHibernate.Util.JoinedEnumerable.Dispose">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
    </member>
    <member name="M:NHibernate.Util.JoinedEnumerable.Dispose(System.Boolean)">
      <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
      <param name="isDisposing">Indicates if this JoinedEnumerable is being Disposed of or Finalized.</param>
      <remarks>
            The command is closed and the reader is disposed.  This allows other ADO.NET
            related actions to occur without needing to move all the way through the
            EnumerableImpl.
            </remarks>
    </member>
    <member name="P:NHibernate.Util.JoinedEnumerable.Current">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Util.LinkedHashMap`2">
      <summary>
            A map of objects whose mapping entries are sequenced based on the order in which they were
            added. This data structure has fast <c>O(1)</c> search time, deletion time, and insertion time
            </summary>
      <remarks>
            This class is not thread safe.
            This class is not a really replication of JDK LinkedHashMap{K, V}, 
            this class is an adaptation of SequencedHashMap with generics.
            </remarks>
    </member>
    <member name="M:NHibernate.Util.LinkedHashMap`2.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Util.LinkedHashMap`2" /> class that is empty, 
            has the default initial capacity, and uses the default equality comparer for the key type.
            </summary>
    </member>
    <member name="M:NHibernate.Util.LinkedHashMap`2.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Util.LinkedHashMap`2" /> class that is empty, 
            has the specified initial capacity, and uses the default equality comparer for the key type.
            </summary>
      <param name="capacity">The initial number of elements that the <see cref="T:NHibernate.Util.LinkedHashMap`2" /> can contain.</param>
    </member>
    <member name="M:NHibernate.Util.LinkedHashMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Util.LinkedHashMap`2" /> class that is empty, has the default initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.
            </summary>
      <param name="equalityComparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or null to use the default EqualityComparer for the type of the key.</param>
    </member>
    <member name="M:NHibernate.Util.LinkedHashMap`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Util.LinkedHashMap`2" /> class that is empty, has the specified initial capacity, and uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.
            </summary>
      <param name="capacity">The initial number of elements that the <see cref="T:NHibernate.Util.LinkedHashMap`2" /> can contain.</param>
      <param name="equalityComparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing keys, or null to use the default EqualityComparer for the type of the key.</param>
    </member>
    <member name="T:NHibernate.Util.SequencedHashMap">
      <summary>
            A map of objects whose mapping entries are sequenced based on the order in which they were
            added. This data structure has fast <c>O(1)</c> search time, deletion time, and insertion time
            </summary>
      <remarks>
            This class is not thread safe.
            </remarks>
    </member>
    <member name="F:NHibernate.Util.SequencedHashMap._sentinel">
      <summary>
            Sentinel used to hold the head and tail of the list of entries
            </summary>
    </member>
    <member name="F:NHibernate.Util.SequencedHashMap._entries">
      <summary>
            Map of keys to entries
            </summary>
    </member>
    <member name="F:NHibernate.Util.SequencedHashMap._modCount">
      <summary>
            Holds the number of modifications that have occurred to the map, excluding modifications
            made through a collection view's iterator.
            </summary>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.CreateSentinel">
      <summary>
            Construct an empty sentinel used to hold the head (sentinel.next) and the tail (sentinal.prev)
            of the list. The sentinal has a <see langword="null" /> key and value
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.#ctor">
      <summary>
            Construct a new sequenced hash map with default initial size and load factor
            </summary>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32)">
      <summary>
            Construct a new sequenced hash map with the specified initial size and default load factor
            </summary>
      <param name="capacity">the initial size for the hash table</param>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32,System.Single)">
      <summary>
            Construct a new sequenced hash map with the specified initial size and load factor
            </summary>
      <param name="capacity">the initial size for the hashtable</param>
      <param name="loadFactor">the load factor for the hash table</param>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32,System.Collections.IEqualityComparer)">
      <summary>
            Construct a new sequenced hash map with the specified initial size, hash code provider
            and comparer
            </summary>
      <param name="capacity">the initial size for the hashtable</param>
      <param name="equalityComparer">
      </param>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Collections.IEqualityComparer)">
      <summary>
            Creates an empty Hashtable with the default initial capacity and using the default load factor, 
            the specified hash code provider and the specified comparer
            </summary>
      <param name="equalityComparer">
      </param>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
      <summary>
            Creates an empty Hashtable with the default initial capacity and using the default load factor, 
            the specified hash code provider and the specified comparer
            </summary>
      <param name="capacity">the initial size for the hashtable</param>
      <param name="loadFactor">the load factor for the hash table</param>
      <param name="equalityComparer">
      </param>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.RemoveEntry(NHibernate.Util.SequencedHashMap.Entry)">
      <summary>
            Removes an internal entry from the linked list. THis does not remove it from the underlying
            map.
            </summary>
      <param name="entry">
      </param>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.InsertEntry(NHibernate.Util.SequencedHashMap.Entry)">
      <summary>
            Inserts a new internal entry to the tail of the linked list. This does not add the 
            entry to the underlying map.
            </summary>
      <param name="entry">
      </param>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.Add(System.Object,System.Object)">
      <summary>
      </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.Clear">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.Contains(System.Object)">
      <summary>
      </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.GetEnumerator">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.Remove(System.Object)">
      <summary>
      </summary>
      <param name="key">
      </param>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.CopyTo(System.Array,System.Int32)">
      <summary>
      </summary>
      <param name="array">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.ContainsKey(System.Object)">
      <summary>
      </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.ContainsValue(System.Object)">
      <summary>
      </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.RemoveImpl(System.Object)">
      <summary>
            Remove the Entry identified by the Key if it exists.
            </summary>
      <param name="key">The Key to remove.</param>
    </member>
    <member name="M:NHibernate.Util.SequencedHashMap.ToString">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Util.SequencedHashMap.IsFixedSize">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Util.SequencedHashMap.IsReadOnly">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Util.SequencedHashMap.Item(System.Object)">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Util.SequencedHashMap.Keys">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Util.SequencedHashMap.Values">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Util.SequencedHashMap.Count">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Util.SequencedHashMap.IsSynchronized">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Util.SequencedHashMap.SyncRoot">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Util.SequencedHashMap.FirstKey">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Util.SequencedHashMap.FirstValue">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Util.SequencedHashMap.LastKey">
      <summary>
      </summary>
    </member>
    <member name="P:NHibernate.Util.SequencedHashMap.LastValue">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Util.LRUMap">
      <summary>
            An implementation of a Map which has a maximum size and uses a Least Recently Used
            algorithm to remove items from the Map when the maximum size is reached and new items are added.
            </summary>
    </member>
    <member name="T:NHibernate.Util.ObjectUtils">
      <summary>
            Summary description for ObjectUtils.
            </summary>
    </member>
    <member name="M:NHibernate.Util.ObjectUtils.DefaultIfNull(System.Object,System.Object)">
      <summary>
      </summary>
      <param name="obj">
      </param>
      <param name="defaultVal">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.ObjectUtils.Equals(System.Object,System.Object)">
      <summary>
      </summary>
      <param name="obj1">
      </param>
      <param name="obj2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.ObjectUtils.IdentityToString(System.Object)">
      <summary>
      </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NHibernate.Util.ObjectUtils.Null">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Util.PropertiesHelper">
      <summary>
      </summary>
    </member>
    <member name="T:NHibernate.Util.ReflectHelper">
      <summary>
            Helper class for Reflection related code.
            </summary>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.OverridesEquals(System.Type)">
      <summary>
            Determine if the specified <see cref="T:System.Type" /> overrides the
            implementation of Equals from <see cref="T:System.Object" /></summary>
      <param name="clazz">The <see cref="T:System.Type" /> to reflect.</param>
      <returns>
        <see langword="true" /> if any type in the hierarchy overrides Equals(object).</returns>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.OverridesGetHashCode(System.Type)">
      <summary>
            Determine if the specified <see cref="T:System.Type" /> overrides the
            implementation of GetHashCode from <see cref="T:System.Object" /></summary>
      <param name="clazz">The <see cref="T:System.Type" /> to reflect.</param>
      <returns>
        <see langword="true" /> if any type in the hierarchy overrides GetHashCode().</returns>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.GetGetter(System.Type,System.String,System.String)">
      <summary>
            Finds the <see cref="T:NHibernate.Properties.IGetter" /> for the property in the <see cref="T:System.Type" />.
            </summary>
      <param name="theClass">The <see cref="T:System.Type" /> to find the property in.</param>
      <param name="propertyName">The name of the Property to find.</param>
      <param name="propertyAccessorName">The name of the property access strategy.</param>
      <returns>The <see cref="T:NHibernate.Properties.IGetter" /> to get the value of the Property.</returns>
      <remarks>
            This one takes a propertyAccessor name as we might know the correct strategy by now so we avoid Exceptions which are costly
            </remarks>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.ReflectedPropertyType(System.Type,System.String,System.String)">
      <summary>
            Get the NHibernate <see cref="T:NHibernate.Type.IType" /> for the named property of the <see cref="T:System.Type" />.
            </summary>
      <param name="theClass">The <see cref="T:System.Type" /> to find the Property in.</param>
      <param name="name">The name of the property/field to find in the class.</param>
      <param name="access">The name of the property accessor for the property.</param>
      <returns>
            The NHibernate <see cref="T:NHibernate.Type.IType" /> for the named property.
            </returns>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.ReflectedPropertyClass(System.Type,System.String,System.String)">
      <summary>
            Get the <see cref="T:System.Type" /> for the named property of a type.
            </summary>
      <param name="theClass">The <see cref="T:System.Type" /> to find the property in.</param>
      <param name="name">The name of the property/field to find in the class.</param>
      <param name="access">The name of the property accessor for the property.</param>
      <returns>The <see cref="T:System.Type" /> for the named property.</returns>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.ReflectedPropertyClass(System.String,System.String,System.String)">
      <summary>
            Get the <see cref="T:System.Type" /> for the named property of a type.
            </summary>
      <param name="className">The FullName to find the property in.</param>
      <param name="name">The name of the property/field to find in the class.</param>
      <param name="accessorName">The name of the property accessor for the property.</param>
      <returns>The <see cref="T:System.Type" /> for the named property.</returns>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.ClassForName(System.String)">
      <summary>
            Returns a reference to the Type.
            </summary>
      <param name="name">The name of the class or a fully qualified name.</param>
      <returns>The Type for the Class.</returns>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.ClassForFullName(System.String)">
      <summary>
            Load a System.Type given is't name.
            </summary>
      <param name="classFullName">The class FullName or AssemblyQualifiedName</param>
      <returns>The System.Type</returns>
      <remarks>
            If the <paramref name="classFullName" /> don't represent an <see cref="P:System.Type.AssemblyQualifiedName" />
            the method try to find the System.Type scanning all Assemblies of the <see cref="P:System.AppDomain.CurrentDomain" />.
            </remarks>
      <exception cref="T:System.TypeLoadException">If no System.Type was found for <paramref name="classFullName" />.</exception>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.TypeFromAssembly(NHibernate.Util.AssemblyQualifiedTypeName,System.Boolean)">
      <summary>
            Returns a <see cref="T:System.Type" /> from an already loaded Assembly or an
            Assembly that is loaded with a partial name.
            </summary>
      <param name="name">An <see cref="T:NHibernate.Util.AssemblyQualifiedTypeName" />.</param>
      <param name="throwOnError">
        <see langword="true" /> if an exception should be thrown
            in case of an error, <see langword="false" /> otherwise.</param>
      <returns>
            A <see cref="T:System.Type" /> object that represents the specified type,
            or <see langword="null" /> if the type cannot be loaded.
            </returns>
      <remarks>
            Attempts to get a reference to the type from an already loaded assembly.  If the 
            type cannot be found then the assembly is loaded using
            <see cref="M:System.Reflection.Assembly.Load(System.String)" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.GetConstantValue(System.Type,System.String)">
      <summary>
            Returns the value of the static field <paramref name="fieldName" /> of <paramref name="type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> .</param>
      <param name="fieldName">The name of the field in the <paramref name="type" />.</param>
      <returns>The value contained in the field, or <see langword="null" /> if the type or the field does not exist.</returns>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.GetDefaultConstructor(System.Type)">
      <summary>
            Gets the default no arg constructor for the <see cref="T:System.Type" />.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to find the constructor for.</param>
      <returns>
            The <see cref="T:System.Reflection.ConstructorInfo" /> for the no argument constructor, or <see langword="null" /> if the
            <c>type</c> is an abstract class.
            </returns>
      <exception cref="T:NHibernate.InstantiationException">
            Thrown when there is a problem calling the method GetConstructor on <see cref="T:System.Type" />.
            </exception>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.GetConstructor(System.Type,NHibernate.Type.IType[])">
      <summary>
            Finds the constructor that takes the parameters.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to find the constructor in.</param>
      <param name="types">The <see cref="T:NHibernate.Type.IType" /> objects to use to find the appropriate constructor.</param>
      <returns>
            An <see cref="T:System.Reflection.ConstructorInfo" /> that can be used to create the type with
            the specified parameters.
            </returns>
      <exception cref="T:NHibernate.InstantiationException">
            Thrown when no constructor with the correct signature can be found.
            </exception>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.IsAbstractClass(System.Type)">
      <summary>
            Determines if the <see cref="T:System.Type" /> is a non creatable class.
            </summary>
      <param name="type">The <see cref="T:System.Type" /> to check.</param>
      <returns>
        <see langword="true" /> if the <see cref="T:System.Type" /> is an Abstract Class or an Interface.</returns>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.UnwrapTargetInvocationException(System.Reflection.TargetInvocationException)">
      <summary>
            Unwraps the supplied <see cref="T:System.Reflection.TargetInvocationException" /> 
            and returns the inner exception preserving the stack trace.
            </summary>
      <param name="ex">
            The <see cref="T:System.Reflection.TargetInvocationException" /> to unwrap.
            </param>
      <returns>The unwrapped exception.</returns>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.TryGetMethod(System.Type,System.Reflection.MethodInfo)">
      <summary>
            Try to find a method in a given type.
            </summary>
      <param name="type">The given type.</param>
      <param name="method">The method info.</param>
      <returns>The found method or null.</returns>
      <remarks>
            The <paramref name="method" />, in general, become from another <see cref="N:NHibernate.Type" />.
            </remarks>
    </member>
    <member name="M:NHibernate.Util.ReflectHelper.TryGetMethod(System.Collections.Generic.IEnumerable{System.Type},System.Reflection.MethodInfo)">
      <summary>
            Try to find a method in a serie of given types.
            </summary>
      <param name="types">The serie of types where find.</param>
      <param name="method">The method info.</param>
      <returns>The found method or null.</returns>
      <remarks>
            The <paramref name="method" />, in general, become from another <see cref="N:NHibernate.Type" />.
            </remarks>
    </member>
    <member name="T:NHibernate.Util.SafetyEnumerable`1">
      <summary>
            Used to ensure a collection filtering a given IEnumerable by a certain type.
            </summary>
      <typeparam name="T">The type used like filter.</typeparam>
    </member>
    <member name="T:NHibernate.Util.SimpleMRUCache">
      <summary> 
            Cache following a "Most Recently Used" (MRU) algorithm for maintaining a
            bounded in-memory size; the "Least Recently Used" (LRU) entry is the first
            available for removal from the cache.
            </summary>
      <remarks>
            This implementation uses a bounded MRU Map to limit the in-memory size of
            the cache.  Thus the size of this cache never grows beyond the stated size. 
            </remarks>
    </member>
    <member name="T:NHibernate.Util.SoftLimitMRUCache">
      <summary> 
            Cache following a "Most Recently Used" (MRY) algorithm for maintaining a
            bounded in-memory size; the "Least Recently Used" (LRU) entry is the first
            available for removal from the cache.
            </summary>
      <remarks>
            This implementation uses a "soft limit" to the in-memory size of the cache,
            meaning that all cache entries are kept within a completely
            {@link java.lang.ref.SoftReference}-based map with the most recently utilized
            entries additionally kept in a hard-reference manner to prevent those cache
            entries soft references from becoming enqueued by the garbage collector.
            Thus the actual size of this cache impl can actually grow beyond the stated
            max size bound as long as GC is not actively seeking soft references for
            enqueuement.
            </remarks>
    </member>
    <member name="T:NHibernate.Util.StringHelper">
      <summary>
      </summary>
    </member>
    <member name="F:NHibernate.Util.StringHelper.Dot">
      <summary>
      </summary>
    </member>
    <member name="F:NHibernate.Util.StringHelper.Underscore">
      <summary>
      </summary>
    </member>
    <member name="F:NHibernate.Util.StringHelper.CommaSpace">
      <summary>
      </summary>
    </member>
    <member name="F:NHibernate.Util.StringHelper.Comma">
      <summary>
      </summary>
    </member>
    <member name="F:NHibernate.Util.StringHelper.OpenParen">
      <summary>
      </summary>
    </member>
    <member name="F:NHibernate.Util.StringHelper.ClosedParen">
      <summary>
      </summary>
    </member>
    <member name="F:NHibernate.Util.StringHelper.SingleQuote">
      <summary>
      </summary>
    </member>
    <member name="F:NHibernate.Util.StringHelper.SqlParameter">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Repeat(System.String,System.Int32)">
      <summary>
      </summary>
      <param name="str">
      </param>
      <param name="times">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.ReplaceOnce(System.String,System.String,System.String)">
      <summary>
      </summary>
      <param name="template">
      </param>
      <param name="placeholder">
      </param>
      <param name="replacement">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Split(System.String,System.String)">
      <summary>
            Just a façade for calling string.Split()
            We don't use our StringTokenizer because string.Split() is
            more efficient (but it only works when we don't want to retrieve the delimiters)
            </summary>
      <param name="separators">separators for the tokens of the list</param>
      <param name="list">the string that will be broken into tokens</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Split(System.String,System.String,System.Boolean)">
      <summary>
            Splits the String using the StringTokenizer.  
            </summary>
      <param name="separators">separators for the tokens of the list</param>
      <param name="list">the string that will be broken into tokens</param>
      <param name="include">true to include the separators in the tokens.</param>
      <returns>
      </returns>
      <remarks>
            This is more powerful than Split because you have the option of including or 
            not including the separators in the tokens.
            </remarks>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Unqualify(System.String)">
      <summary>
      </summary>
      <param name="qualifiedName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Unqualify(System.String,System.String)">
      <summary>
      </summary>
      <param name="qualifiedName">
      </param>
      <param name="seperator">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.GetFullClassname(System.String)">
      <summary>
            Takes a fully qualified type name and returns the full name of the 
            Class - includes namespaces.
            </summary>
      <param name="typeName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.GetClassname(System.String)">
      <summary>
            Takes a fully qualified type name (can include the assembly) and just returns
            the name of the Class.
            </summary>
      <param name="typeName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Qualifier(System.String)">
      <summary>
      </summary>
      <param name="qualifiedName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Suffix(System.String[],System.String)">
      <summary>
      </summary>
      <param name="columns">
      </param>
      <param name="suffix">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Suffix(System.String,System.String)">
      <summary>
      </summary>
      <param name="name">
      </param>
      <param name="suffix">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Prefix(System.String[],System.String)">
      <summary>
      </summary>
      <param name="columns">
      </param>
      <param name="prefix">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Root(System.String)">
      <summary>
      </summary>
      <param name="qualifiedName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.BooleanValue(System.String)">
      <summary>
            Converts a <see cref="T:System.String" /> in the format of "true", "t", "false", or "f" to
            a <see cref="T:System.Boolean" />.
            </summary>
      <param name="value">The string to convert.</param>
      <returns>
            The <c>value</c> converted to a <see cref="T:System.Boolean" /> .
            </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.ToString(System.Object[])">
      <summary>
      </summary>
      <param name="array">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Multiply(System.String,System.Collections.IEnumerator,System.Collections.IEnumerator)">
      <summary>
      </summary>
      <param name="str">
      </param>
      <param name="placeholders">
      </param>
      <param name="replacements">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Multiply(System.String[],System.String,System.String[])">
      <summary>
      </summary>
      <param name="strings">
      </param>
      <param name="placeholder">
      </param>
      <param name="replacements">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.CountUnquoted(System.String,System.Char)">
      <summary>
            Counts the unquoted instances of the character.
            </summary>
      <param name="str">
      </param>
      <param name="character">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.Qualify(System.String,System.String)">
      <summary>
      </summary>
      <param name="prefix">
      </param>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.GenerateAlias(System.String,System.Int32)">
      <summary>
            Generate a nice alias for the given class name or collection role
            name and unique integer. Subclasses do <em>not</em> have to use
            aliases of this form.
            </summary>
      <returns>an alias of the form <c>foo1_</c></returns>
    </member>
    <member name="M:NHibernate.Util.StringHelper.InternedIfPossible(System.String)">
      <summary>
            Returns the interned string equal to <paramref name="str" /> if there is one, or <paramref name="str" />
            otherwise.
            </summary>
      <param name="str">A <see cref="T:System.String" /></param>
      <returns>A <see cref="T:System.String" /></returns>
    </member>
    <member name="T:NHibernate.Util.StringTokenizer">
      <summary>
            A StringTokenizer java like object 
            </summary>
    </member>
    <member name="M:NHibernate.Util.StringTokenizer.#ctor(System.String)">
      <summary>
      </summary>
      <param name="str">
      </param>
    </member>
    <member name="M:NHibernate.Util.StringTokenizer.#ctor(System.String,System.String)">
      <summary>
      </summary>
      <param name="str">
      </param>
      <param name="delim">
      </param>
    </member>
    <member name="M:NHibernate.Util.StringTokenizer.#ctor(System.String,System.String,System.Boolean)">
      <summary>
      </summary>
      <param name="str">
      </param>
      <param name="delim">
      </param>
      <param name="returnDelims">
      </param>
    </member>
    <member name="T:NHibernate.Util.UnmodifiableDictionary`2">
      <summary>
            Returns an unmodifiable view of the specified IDictionary. 
            This method allows modules to provide users with "read-only" access to internal dictionary. 
            Query operations on the returned dictionary "read through" to the specified dictionary, 
            and attempts to modify the returned dictionary, 
            whether direct or via its collection views, result in an <see cref="T:System.NotSupportedException" />.
            </summary>
      <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
      <typeparam name="TValue">The type of values in the dictionary.</typeparam>
    </member>
    <member name="M:NHibernate.Util.UnmodifiableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <summary>
            Initializes a new instance of the UnmodifiableDictionary class that contains elements wrapped
            from the specified IDictionary. 
            </summary>
      <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2" />  whose elements are wrapped.</param>
    </member>
    <member name="P:NHibernate.Util.WeakHashtable.Count">
      <summary>
            Count of elements in the collection. Unreliable!
            </summary>
    </member>
    <member name="T:NHibernate.AssertionFailure">
      <summary>
            Indicates failure of an assertion: a possible bug in NHibernate
            </summary>
    </member>
    <member name="M:NHibernate.AssertionFailure.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.AssertionFailure.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.AssertionFailure.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.AssertionFailure.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure" /> class.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.CacheMode">
      <summary>
            Controls how the session interacts with the second-level
            cache and query cache.
            </summary>
    </member>
    <member name="F:NHibernate.CacheMode.Ignore">
      <summary> 
            The session will never interact with the cache, except to invalidate
            cache items when updates occur
            </summary>
    </member>
    <member name="F:NHibernate.CacheMode.Put">
      <summary> 
            The session will never read items from the cache, but will add items
            to the cache as it reads them from the database.
            </summary>
    </member>
    <member name="F:NHibernate.CacheMode.Get">
      <summary> 
            The session may read items from the cache, but will not add items, 
            except to invalidate items when updates occur
            </summary>
    </member>
    <member name="F:NHibernate.CacheMode.Normal">
      <summary> The session may read items from the cache, and add items to the cache</summary>
    </member>
    <member name="F:NHibernate.CacheMode.Refresh">
      <summary> 
            The session will never read items from the cache, but will add items
            to the cache as it reads them from the database. In this mode, the
            effect of <tt>hibernate.cache.use_minimal_puts</tt> is bypassed, in
            order to <em>force</em> a cache refresh
            </summary>
    </member>
    <member name="T:NHibernate.CallbackException">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.CallbackException.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException" /> class.
            </summary>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.CallbackException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.CallbackException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.CallbackException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.CriteriaTransformer">
      <summary>
            Transforms Criteria queries
            </summary>
    </member>
    <member name="M:NHibernate.CriteriaTransformer.TransformToRowCount(NHibernate.Criterion.DetachedCriteria)">
      <summary>
             Returns a clone of the original criteria, which will return the count 
             of rows that are returned by the original criteria query.
            </summary>
    </member>
    <member name="M:NHibernate.CriteriaTransformer.TransformToRowCount(NHibernate.ICriteria)">
      <summary>
             Returns a clone of the original criteria, which will return the count 
             of rows that are returned by the original criteria query.
            </summary>
    </member>
    <member name="M:NHibernate.CriteriaTransformer.Clone(NHibernate.Criterion.DetachedCriteria)">
      <summary>
            Creates an exact clone of the criteria
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.CriteriaTransformer.Clone(NHibernate.ICriteria)">
      <summary>
            Creates an exact clone of the criteria
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.DuplicateMappingException.#ctor(System.String,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException" /> class.
            </summary>
      <param name="customMessage">The message that describes the error. </param>
      <param name="name">The name of the duplicate object</param>
      <param name="type">The type of the duplicate object</param>
    </member>
    <member name="M:NHibernate.DuplicateMappingException.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException" /> class.
            </summary>
      <param name="name">The name of the duplicate object</param>
      <param name="type">The type of the duplicate object</param>
    </member>
    <member name="M:NHibernate.DuplicateMappingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="P:NHibernate.DuplicateMappingException.Type">
      <summary>
            The type of the duplicated object
            </summary>
    </member>
    <member name="P:NHibernate.DuplicateMappingException.Name">
      <summary>
            The name of the duplicated object
            </summary>
    </member>
    <member name="T:NHibernate.IInterceptor">
      <summary>
            Allows user code to inspect and/or change property values before they are written and after they
            are read from the database
            </summary>
      <remarks>
        <para>
            There might be a single instance of <c>IInterceptor</c> for a <c>SessionFactory</c>, or a new
            instance might be specified for each <c>ISession</c>. Whichever approach is used, the interceptor
            must be serializable if the <c>ISession</c> is to be serializable. This means that <c>SessionFactory</c>
            -scoped interceptors should implement <c>ReadResolve()</c>.
            </para>
        <para>
            The <c>ISession</c> may not be invoked from a callback (nor may a callback cause a collection or
            proxy to be lazily initialized).
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.IInterceptor.OnLoad(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
      <summary>
            Called just before an object is initialized
            </summary>
      <param name="entity">
      </param>
      <param name="id">
      </param>
      <param name="propertyNames">
      </param>
      <param name="state">
      </param>
      <param name="types">
      </param>
      <remarks>
            The interceptor may change the <c>state</c>, which will be propagated to the persistent
            object. Note that when this method is called, <c>entity</c> will be an empty
            uninitialized instance of the class.</remarks>
      <returns>
        <see langword="true" /> if the user modified the <c>state</c> in any way</returns>
    </member>
    <member name="M:NHibernate.IInterceptor.OnFlushDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
      <summary>
            Called when an object is detected to be dirty, during a flush.
            </summary>
      <param name="currentState">
      </param>
      <param name="entity">
      </param>
      <param name="id">
      </param>
      <param name="previousState">
      </param>
      <param name="propertyNames">
      </param>
      <param name="types">
      </param>
      <remarks>
            The interceptor may modify the detected <c>currentState</c>, which will be propagated to
            both the database and the persistent object. Note that all flushes end in an actual
            synchronization with the database, in which as the new <c>currentState</c> will be propagated
            to the object, but not necessarily (immediately) to the database. It is strongly recommended
            that the interceptor <b>not</b> modify the <c>previousState</c>.
            </remarks>
      <returns>
        <see langword="true" /> if the user modified the <c>currentState</c> in any way</returns>
    </member>
    <member name="M:NHibernate.IInterceptor.OnSave(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
      <summary>
            Called before an object is saved
            </summary>
      <param name="entity">
      </param>
      <param name="id">
      </param>
      <param name="propertyNames">
      </param>
      <param name="state">
      </param>
      <param name="types">
      </param>
      <remarks>
            The interceptor may modify the <c>state</c>, which will be used for the SQL <c>INSERT</c>
            and propagated to the persistent object
            </remarks>
      <returns>
        <see langword="true" /> if the user modified the <c>state</c> in any way</returns>
    </member>
    <member name="M:NHibernate.IInterceptor.OnDelete(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
      <summary>
            Called before an object is deleted
            </summary>
      <param name="entity">
      </param>
      <param name="id">
      </param>
      <param name="propertyNames">
      </param>
      <param name="state">
      </param>
      <param name="types">
      </param>
      <remarks>
            It is not recommended that the interceptor modify the <c>state</c>.
            </remarks>
    </member>
    <member name="M:NHibernate.IInterceptor.OnCollectionRecreate(System.Object,System.Object)">
      <summary> Called before a collection is (re)created.</summary>
    </member>
    <member name="M:NHibernate.IInterceptor.OnCollectionRemove(System.Object,System.Object)">
      <summary> Called before a collection is deleted.</summary>
    </member>
    <member name="M:NHibernate.IInterceptor.OnCollectionUpdate(System.Object,System.Object)">
      <summary> Called before a collection is updated.</summary>
    </member>
    <member name="M:NHibernate.IInterceptor.PreFlush(System.Collections.ICollection)">
      <summary>
            Called before a flush
            </summary>
      <param name="entities">The entities</param>
    </member>
    <member name="M:NHibernate.IInterceptor.PostFlush(System.Collections.ICollection)">
      <summary>
            Called after a flush that actually ends in execution of the SQL statements required to
            synchronize in-memory state with the database.
            </summary>
      <param name="entities">The entitites</param>
    </member>
    <member name="M:NHibernate.IInterceptor.IsTransient(System.Object)">
      <summary>
            Called when a transient entity is passed to <c>SaveOrUpdate</c>.
            </summary>
      <remarks>
            The return value determines if the object is saved
            <list><item><see langword="true" /> - the entity is passed to <c>Save()</c>, resulting in an <c>INSERT</c></item><item><see langword="false" /> - the entity is passed to <c>Update()</c>, resulting in an <c>UPDATE</c></item><item><see langword="null" /> - Hibernate uses the <c>unsaved-value</c> mapping to determine if the object is unsaved</item></list></remarks>
      <param name="entity">A transient entity</param>
      <returns>Boolean or <see langword="null" /> to choose default behaviour</returns>
    </member>
    <member name="M:NHibernate.IInterceptor.FindDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
      <summary>
            Called from <c>Flush()</c>. The return value determines whether the entity is updated
            </summary>
      <remarks>
        <list>
          <item>an array of property indicies - the entity is dirty</item>
          <item>an empty array - the entity is not dirty</item>
          <item>
            <see langword="null" /> - use Hibernate's default dirty-checking algorithm</item>
        </list>
      </remarks>
      <param name="entity">A persistent entity</param>
      <param name="currentState">
      </param>
      <param name="id">
      </param>
      <param name="previousState">
      </param>
      <param name="propertyNames">
      </param>
      <param name="types">
      </param>
      <returns>An array of dirty property indicies or <see langword="null" /> to choose default behavior</returns>
    </member>
    <member name="M:NHibernate.IInterceptor.Instantiate(System.String,NHibernate.EntityMode,System.Object)">
      <summary>
            Instantiate the entity class. Return <see langword="null" /> to indicate that Hibernate should use the default
            constructor of the class
            </summary>
      <param name="entityName">the name of the entity </param>
      <param name="entityMode">The type of entity instance to be returned. </param>
      <param name="id">the identifier of the new instance </param>
      <returns>An instance of the class, or <see langword="null" /> to choose default behaviour</returns>
      <remarks>
            The identifier property of the returned instance
            should be initialized with the given identifier.
            </remarks>
    </member>
    <member name="M:NHibernate.IInterceptor.GetEntityName(System.Object)">
      <summary> Get the entity name for a persistent or transient instance</summary>
      <param name="entity">an entity instance </param>
      <returns> the name of the entity </returns>
    </member>
    <member name="M:NHibernate.IInterceptor.GetEntity(System.String,System.Object)">
      <summary> Get a fully loaded entity instance that is cached externally</summary>
      <param name="entityName">the name of the entity </param>
      <param name="id">the instance identifier </param>
      <returns> a fully initialized entity </returns>
    </member>
    <member name="M:NHibernate.IInterceptor.AfterTransactionBegin(NHibernate.ITransaction)">
      <summary>
            Called when a NHibernate transaction is begun via the NHibernate <see cref="T:NHibernate.ITransaction" />
            API. Will not be called if transactions are being controlled via some other mechanism.
            </summary>
    </member>
    <member name="M:NHibernate.IInterceptor.BeforeTransactionCompletion(NHibernate.ITransaction)">
      <summary>
            Called before a transaction is committed (but not before rollback).
            </summary>
    </member>
    <member name="M:NHibernate.IInterceptor.AfterTransactionCompletion(NHibernate.ITransaction)">
      <summary>
            Called after a transaction is committed or rolled back.
            </summary>
    </member>
    <member name="M:NHibernate.IInterceptor.OnPrepareStatement(NHibernate.SqlCommand.SqlString)">
      <summary> Called when sql string is being prepared. </summary>
      <param name="sql">sql to be prepared </param>
      <returns> original or modified sql </returns>
    </member>
    <member name="M:NHibernate.IInterceptor.SetSession(NHibernate.ISession)">
      <summary>
            Called when a session-scoped (and <b>only</b> session scoped) interceptor is attached
            to a session
            </summary>
      <remarks>
            session-scoped-interceptor is an instance of the interceptor used only for one session.
            The use of singleton-interceptor may cause problems in multi-thread scenario. 
            </remarks>
      <seealso cref="M:NHibernate.ISessionFactory.OpenSession(NHibernate.IInterceptor)" />
      <seealso cref="M:NHibernate.ISessionFactory.OpenSession(System.Data.IDbConnection,NHibernate.IInterceptor)" />
    </member>
    <member name="T:NHibernate.EntityMode">
      <summary> Defines the representation modes available for entities. </summary>
    </member>
    <member name="T:NHibernate.FetchMode">
      <summary>
            Represents a fetching strategy.
            </summary>
      <remarks>
            This is used together with the <see cref="T:NHibernate.ICriteria" /> API to specify
            runtime fetching strategies.
            <para>
            For Hql queries, use the <c>FETCH</c> keyword instead.
            </para></remarks>
    </member>
    <member name="F:NHibernate.FetchMode.Default">
      <summary>
            Default to the setting configured in the mapping file.
            </summary>
    </member>
    <member name="F:NHibernate.FetchMode.Select">
      <summary>
            Fetch eagerly, using a separate select. Equivalent to
            <c>fetch="select"</c> (and <c>outer-join="false"</c>)
            </summary>
    </member>
    <member name="F:NHibernate.FetchMode.Join">
      <summary>
            Fetch using an outer join.  Equivalent to
            <c>fetch="join"</c> (and <c>outer-join="true"</c>)
            </summary>
    </member>
    <member name="T:NHibernate.FKUnmatchingColumnsException">
      <summary>
            Indicates that an expected getter or setter method could not be found on a class
            </summary>
    </member>
    <member name="M:NHibernate.FKUnmatchingColumnsException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.FKUnmatchingColumnsException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.FKUnmatchingColumnsException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.FlushMode">
      <summary>
            Represents a flushing strategy.
            </summary>
      <remarks>
            The flush process synchronizes database state with session state by detecting state
            changes and executing SQL statements
            </remarks>
    </member>
    <member name="F:NHibernate.FlushMode.Unspecified">
      <summary>
            Special value for unspecified flush mode (like <see langword="null" /> in Java).
            </summary>
    </member>
    <member name="F:NHibernate.FlushMode.Never">
      <summary>
            The <c>ISession</c> is never flushed unless <c>Flush()</c> is explicitly
            called by the application. This mode is very efficient for read only
            transactions
            </summary>
    </member>
    <member name="F:NHibernate.FlushMode.Commit">
      <summary>
            The <c>ISession</c> is flushed when <c>Transaction.Commit()</c> is called
            </summary>
    </member>
    <member name="F:NHibernate.FlushMode.Auto">
      <summary>
            The <c>ISession</c> is sometimes flushed before query execution in order to
            ensure that queries never return stale state. This is the default flush mode.
            </summary>
    </member>
    <member name="F:NHibernate.FlushMode.Always">
      <summary> 
            The <see cref="T:NHibernate.ISession" /> is flushed before every query. This is
            almost always unnecessary and inefficient.
            </summary>
    </member>
    <member name="T:NHibernate.IDatabinder">
      <summary>
            Provides XML marshalling for classes registered with a <c>SessionFactory</c></summary>
      <remarks>
        <para>
            Hibernate defines a generic XML format that may be used to represent any class
            (<c>hibernate-generic.dtd</c>). The user configures an XSLT stylesheet for marshalling
            data from this generic format to an application and/or user readable format. By default,
            Hibernate will use <c>hibernate-default.xslt</c> which maps data to a useful human-
            readable format.
            </para>
        <para>
            The property <c>xml.output_stylesheet</c> specifies a user-written stylesheet.
            Hibernate will attempt to load the stylesheet from the classpath first and if not found,
            will attempt to load it as a file
            </para>
        <para>
            It is not intended that implementors be threadsafe
            </para>
      </remarks>
    </member>
    <member name="M:NHibernate.IDatabinder.Bind(System.Object)">
      <summary>
            Add an object to the output document.
            </summary>
      <param name="obj">A transient or persistent instance</param>
      <returns>Databinder</returns>
    </member>
    <member name="M:NHibernate.IDatabinder.BindAll(System.Collections.ICollection)">
      <summary>
            Add a collection of objects to the output document
            </summary>
      <param name="objs">A collection of transient or persistent instance</param>
      <returns>Databinder</returns>
    </member>
    <member name="M:NHibernate.IDatabinder.ToGenericXml">
      <summary>
            Output the generic XML representation of the bound objects
            </summary>
      <returns>Generic Xml representation</returns>
    </member>
    <member name="M:NHibernate.IDatabinder.ToGenericXmlDocument">
      <summary>
            Output the generic XML Representation of the bound objects
            to a <c>XmlDocument</c></summary>
      <returns>A generic Xml tree</returns>
    </member>
    <member name="M:NHibernate.IDatabinder.ToXML">
      <summary>
            Output the custom XML representation of the bound objects
            </summary>
      <returns>Custom Xml representation</returns>
    </member>
    <member name="M:NHibernate.IDatabinder.ToXmlDocument">
      <summary>
            Output the custom XML representation of the bound objects as
            an <c>XmlDocument</c></summary>
      <returns>A custom Xml Tree</returns>
    </member>
    <member name="P:NHibernate.IDatabinder.InitializeLazy">
      <summary>
            Controls whether bound objects (and their associated objects) that are lazily instanciated
            are explicityl initialized or left as they are
            </summary>
      <value>True to explicitly initilize lazy objects, false to leave them in the state they are in</value>
    </member>
    <member name="M:NHibernate.IdentityEqualityComparer.Equals(System.Object,System.Object)">
      <summary>
             Performs a null safe comparison using "==" instead of Object.Equals()
             </summary>
      <param name="x">First object to compare.</param>
      <param name="y">Second object to compare.</param>
      <returns>
             true if x is the same instance as y or if both are null references; otherwise, false.
            </returns>
      <remarks>
             This is Lazy collection safe since it uses <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />, 
             unlike <c>Object.Equals()</c> which currently causes NHibernate to load up the collection.
             This behaivior of Collections is likely to change because Java's collections override Equals() and 
             .net's collections don't. So in .net there is no need to override Equals() and 
             GetHashCode() on the NHibernate Collection implementations.
             </remarks>
    </member>
    <member name="T:NHibernate.InstantiationException">
      <summary>
            Thrown if Hibernate can't instantiate an entity or component class at runtime.
            </summary>
    </member>
    <member name="M:NHibernate.InstantiationException.#ctor(System.String,System.Exception,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.InstantiationException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
      <param name="type">The <see cref="T:System.Type" /> that NHibernate was trying to instantiate.</param>
    </member>
    <member name="M:NHibernate.InstantiationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.InstantiationException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="M:NHibernate.InstantiationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Sets the serialization info for <see cref="T:NHibernate.InstantiationException" /> after 
            getting the info from the base Exception.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="P:NHibernate.InstantiationException.PersistentType">
      <summary>
            Gets the <see cref="T:System.Type" /> that NHibernate was trying to instantiate.
            </summary>
    </member>
    <member name="P:NHibernate.InstantiationException.Message">
      <summary>
            Gets a message that describes the current <see cref="T:NHibernate.InstantiationException" />.
            </summary>
      <value>
            The error message that explains the reason for this exception and the Type that
            was trying to be instantiated.
            </value>
    </member>
    <member name="T:NHibernate.InvalidProxyTypeException">
      <summary>
            Thrown when an invalid type is specified as a proxy for a class.
            The exception is also thrown when a class is specified as lazy,
            but cannot be used as a proxy for itself.
            </summary>
    </member>
    <member name="T:NHibernate.LazyInitializationException">
      <summary>
            A problem occurred trying to lazily initialize a collection or proxy (for example the session
            was closed) or iterate query results.
            </summary>
    </member>
    <member name="M:NHibernate.LazyInitializationException.#ctor(System.String,System.Object,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException" /> class.
            </summary>
      <param name="entityName">The name of the entity where the exception was thrown</param>
      <param name="entityId">The id of the entity where the exception was thrown</param>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.LazyInitializationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.LazyInitializationException.#ctor(System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException" /> class.
            </summary>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.LazyInitializationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.LazyInitializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.LockMode">
      <summary>
            Instances represent a lock mode for a row of a relational database table.
            </summary>
      <remarks>
            It is not intended that users spend much time worrying about locking since Hibernate
            usually obtains exactly the right lock level automatically. Some "advanced" users may
            wish to explicitly specify lock levels.
            </remarks>
    </member>
    <member name="F:NHibernate.LockMode.None">
      <summary>
            No lock required. 
            </summary>
      <remarks>
            If an object is requested with this lock mode, a <c>Read</c> lock
            might be obtained if necessary.
            </remarks>
    </member>
    <member name="F:NHibernate.LockMode.Read">
      <summary>
            A shared lock. 
            </summary>
      <remarks>
            Objects are loaded in <c>Read</c> mode by default
            </remarks>
    </member>
    <member name="F:NHibernate.LockMode.Upgrade">
      <summary>
            An upgrade lock. 
            </summary>
      <remarks>
            Objects loaded in this lock mode are materialized using an
            SQL <c>SELECT ... FOR UPDATE</c></remarks>
    </member>
    <member name="F:NHibernate.LockMode.UpgradeNoWait">
      <summary>
            Attempt to obtain an upgrade lock, using an Oracle-style
            <c>SELECT ... FOR UPGRADE NOWAIT</c>. 
            </summary>
      <remarks>
            The semantics of this lock mode, once obtained, are the same as <c>Upgrade</c></remarks>
    </member>
    <member name="F:NHibernate.LockMode.Write">
      <summary>
            A <c>Write</c> lock is obtained when an object is updated or inserted.
            </summary>
      <remarks>
            This is not a valid mode for <c>Load()</c> or <c>Lock()</c>.
            </remarks>
    </member>
    <member name="F:NHibernate.LockMode.Force">
      <summary> 
            Similar to <see cref="F:NHibernate.LockMode.Upgrade" /> except that, for versioned entities,
            it results in a forced version increment.
            </summary>
    </member>
    <member name="M:NHibernate.LockMode.#ctor(System.Int32,System.String)">
      <summary>
      </summary>
      <param name="level">
      </param>
      <param name="name">
      </param>
    </member>
    <member name="M:NHibernate.LockMode.ToString">
      <summary>
      </summary>
    </member>
    <member name="M:NHibernate.LockMode.GreaterThan(NHibernate.LockMode)">
      <summary>
            Is this lock mode more restrictive than the given lock mode?
            </summary>
      <param name="mode">
      </param>
    </member>
    <member name="M:NHibernate.LockMode.LessThan(NHibernate.LockMode)">
      <summary>
            Is this lock mode less restrictive than the given lock mode?
            </summary>
      <param name="mode">
      </param>
    </member>
    <member name="T:NHibernate.NHibernateUtil">
      <summary>
            Provides access to the full range of NHibernate built-in types.
            IType instances may be used to bind values to query parameters.
            Also a factory for new Blobs and Clobs.
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.AnsiString">
      <summary>
            NHibernate Ansi String type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Binary">
      <summary>
            NHibernate binary type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.BinaryBlob">
      <summary>
            NHibernate binary blob type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Boolean">
      <summary>
            NHibernate boolean type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Byte">
      <summary>
            NHibernate byte type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Character">
      <summary>
            NHibernate character type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.CultureInfo">
      <summary>
            NHibernate Culture Info type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.DateTime">
      <summary>
            NHibernate date type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.DateTime2">
      <summary>
            NHibernate date type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.DateTimeOffset">
      <summary>
            NHibernate date type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Date">
      <summary>
            NHibernate date type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Decimal">
      <summary>
            NHibernate decimal type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Double">
      <summary>
            NHibernate double type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Currency">
      <summary>
            NHibernate Currency type (System.Decimal - DbType.Currency)
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Guid">
      <summary>
            NHibernate Guid type.
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Int16">
      <summary>
            NHibernate System.Int16 (short in C#) type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Int32">
      <summary>
            NHibernate System.Int32 (int in C#) type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Int64">
      <summary>
            NHibernate System.Int64 (long in C#) type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.SByte">
      <summary>
            NHibernate System.SByte type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.UInt16">
      <summary>
            NHibernate System.UInt16 (ushort in C#) type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.UInt32">
      <summary>
            NHibernate System.UInt32 (uint in C#) type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.UInt64">
      <summary>
            NHibernate System.UInt64 (ulong in C#) type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Single">
      <summary>
            NHibernate System.Single (float in C#) Type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.String">
      <summary>
            NHibernate String type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.StringClob">
      <summary>
            NHibernate string clob type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Time">
      <summary>
            NHibernate Time type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Ticks">
      <summary>
            NHibernate Ticks type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.TimeAsTimeSpan">
      <summary>
            NHibernate Ticks type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.TimeSpan">
      <summary>
            NHibernate Ticks type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Timestamp">
      <summary>
            NHibernate Timestamp type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.TrueFalse">
      <summary>
            NHibernate TrueFalse type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.YesNo">
      <summary>
            NHibernate YesNo type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Class">
      <summary>
            NHibernate class type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.ClassMetaType">
      <summary>
            NHibernate class meta type for association of kind <code>any</code>.
            </summary>
      <seealso cref="T:NHibernate.Type.AnyType" />
    </member>
    <member name="F:NHibernate.NHibernateUtil.Serializable">
      <summary>
            NHibernate serializable type
            </summary>
    </member>
    <member name="F:NHibernate.NHibernateUtil.Object">
      <summary>
            NHibernate System.Object type
            </summary>
    </member>
    <member name="M:NHibernate.NHibernateUtil.GuessType(System.Object)">
      <summary>
            Guesses the IType of this object
            </summary>
      <param name="obj">The obj.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.NHibernateUtil.GuessType(System.Type)">
      <summary>
            Guesses the IType by the type
            </summary>
      <param name="type">The type.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.NHibernateUtil.Enum(System.Type)">
      <summary>
            A NHibernate persistent enum type
            </summary>
      <param name="enumClass">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.NHibernateUtil.GetSerializable(System.Type)">
      <summary>
            A NHibernate serializable type
            </summary>
      <param name="serializableClass">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.NHibernateUtil.Any(NHibernate.Type.IType,NHibernate.Type.IType)">
      <summary>
            A NHibernate serializable type
            </summary>
      <param name="metaType">a type mapping <see cref="T:NHibernate.Type.IType" /> to a single column</param>
      <param name="identifierType">the entity identifier type</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.NHibernateUtil.Association(System.Type)">
      <summary>
            A NHibernate persistent object (entity) type
            </summary>
      <param name="persistentClass">a mapped entity class</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.NHibernateUtil.Entity(System.Type)">
      <summary>
            A NHibernate persistent object (entity) type
            </summary>
      <param name="persistentClass">a mapped entity class</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.NHibernateUtil.Entity(System.String)">
      <summary> A Hibernate persistent object (entity) type. </summary>
      <param name="entityName">a mapped entity class </param>
    </member>
    <member name="M:NHibernate.NHibernateUtil.Custom(System.Type)">
      <summary>
            A NHibernate custom type
            </summary>
      <param name="userTypeClass">a class that implements UserType</param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.NHibernateUtil.Initialize(System.Object)">
      <summary>
            Force initialization of a proxy or persistent collection.
            </summary>
      <param name="proxy">a persistable object, proxy, persistent collection or null</param>
      <exception cref="T:NHibernate.HibernateException">if we can't initialize the proxy at this time, eg. the Session was closed</exception>
    </member>
    <member name="M:NHibernate.NHibernateUtil.IsInitialized(System.Object)">
      <summary>
            Is the proxy or persistent collection initialized?
            </summary>
      <param name="proxy">a persistable object, proxy, persistent collection or null</param>
      <returns>true if the argument is already initialized, or is not a proxy or collection</returns>
    </member>
    <member name="M:NHibernate.NHibernateUtil.GetClass(System.Object)">
      <summary>
            Get the true, underlying class of a proxied persistent class. This operation
            will initialize a proxy by side-effect.
            </summary>
      <param name="proxy">a persistable object or proxy</param>
      <returns>the true class of the instance</returns>
    </member>
    <member name="M:NHibernate.NHibernateUtil.Close(System.Collections.IEnumerator)">
      <summary>
            Close an <see cref="T:System.Collections.IEnumerator" /> obtained from an <see cref="T:System.Collections.IEnumerable" />
            returned by NHibernate immediately, instead of waiting until the session is
            closed or disconnected.
            </summary>
    </member>
    <member name="M:NHibernate.NHibernateUtil.Close(System.Collections.IEnumerable)">
      <summary>
            Close an <see cref="T:System.Collections.IEnumerable" /> returned by NHibernate immediately,
            instead of waiting until the session is closed or disconnected.
            </summary>
    </member>
    <member name="M:NHibernate.NHibernateUtil.IsPropertyInitialized(System.Object,System.String)">
      <summary> 
            Check if the property is initialized. If the named property does not exist
            or is not persistent, this method always returns <tt>true</tt>. 
            </summary>
      <param name="proxy">The potential proxy </param>
      <param name="propertyName">the name of a persistent attribute of the object </param>
      <returns> 
            true if the named property of the object is not listed as uninitialized;
            false if the object is an uninitialized proxy, or the named property is uninitialized 
            </returns>
    </member>
    <member name="T:NHibernate.NonUniqueObjectException">
      <summary>
            This exception is thrown when an operation would
            break session-scoped identity. This occurs if the
            user tries to associate two different instances of
            the same class with a particular identifier,
            in the scope of a single <see cref="T:NHibernate.ISession" />.
            </summary>
    </member>
    <member name="M:NHibernate.NonUniqueObjectException.#ctor(System.String,System.Object,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueObjectException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="id">The identifier of the object that caused the exception.</param>
      <param name="entityName">The EntityName of the object attempted to be loaded.</param>
    </member>
    <member name="M:NHibernate.NonUniqueObjectException.#ctor(System.Object,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueObjectException" /> class.
            </summary>
      <param name="id">The identifier of the object that caused the exception.</param>
      <param name="entityName">The EntityName of the object attempted to be loaded.</param>
    </member>
    <member name="M:NHibernate.NonUniqueObjectException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueObjectException" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.NonUniqueObjectException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Sets the serialization info for <see cref="T:NHibernate.InstantiationException" /> after 
            getting the info from the base Exception.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.NonUniqueResultException">
      <summary>
            Thrown when the application calls <see cref="M:NHibernate.IQuery.UniqueResult">IQuery.UniqueResult()</see> 
            and the query returned more than one result. Unlike all other NHibernate 
            exceptions, this one is recoverable!
            </summary>
    </member>
    <member name="M:NHibernate.NonUniqueResultException.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueResultException" /> class.
            </summary>
      <param name="resultCount">The number of items in the result.</param>
    </member>
    <member name="M:NHibernate.NonUniqueResultException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueResultException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.UnresolvableObjectException">
      <summary>
            Thrown when Hibernate could not resolve an object by id, especially when
            loading an association.
            </summary>
    </member>
    <member name="M:NHibernate.UnresolvableObjectException.#ctor(System.Object,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.UnresolvableObjectException" /> class.
            </summary>
      <param name="identifier">The identifier of the object that caused the exception.</param>
      <param name="clazz">The <see cref="T:System.Type" /> of the object attempted to be loaded.</param>
    </member>
    <member name="M:NHibernate.UnresolvableObjectException.#ctor(System.String,System.Object,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.UnresolvableObjectException" /> class.
            </summary>
      <param name="message">The message that describes the error.</param>
      <param name="identifier">The identifier of the object that caused the exception.</param>
      <param name="clazz">The <see cref="T:System.Type" /> of the object attempted to be loaded.</param>
    </member>
    <member name="T:NHibernate.ObjectDeletedException">
      <summary>
            Thrown when the user tries to pass a deleted object to the <c>ISession</c>.
            </summary>
    </member>
    <member name="M:NHibernate.ObjectDeletedException.#ctor(System.String,System.Object,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectDeletedException" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.ObjectDeletedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectDeletedException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.ObjectNotFoundException">
      <summary>
            Thrown when <c>ISession.Load()</c> fails to select a row with
            the given primary key (identifier value). This exception might not
            be thrown when <c>Load()</c> is called, even if there was no
            row on the database, because <c>Load()</c> returns a proxy if
            possible. Applications should use <c>ISession.Get()</c> to test if 
            a row exists in the database.
            </summary>
    </member>
    <member name="M:NHibernate.ObjectNotFoundException.#ctor(System.Object,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectNotFoundException" /> class.
            </summary>
      <param name="identifier">The identifier of the object that was attempting to be loaded.</param>
      <param name="type">The <see cref="T:System.Type" /> that NHibernate was trying to find a row for in the database.</param>
    </member>
    <member name="M:NHibernate.ObjectNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectNotFoundException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.PersistentObjectException">
      <summary>
            Thrown when the user passes a persistent instance to a <c>ISession</c> method that expects a
            transient instance
            </summary>
    </member>
    <member name="M:NHibernate.PersistentObjectException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PersistentObjectException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.PersistentObjectException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PersistentObjectException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.PropertyAccessException">
      <summary>
            A problem occurred accessing a property of an instance of a persistent class by reflection
            </summary>
    </member>
    <member name="M:NHibernate.PropertyAccessException.#ctor(System.Exception,System.String,System.Boolean,System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyAccessException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
      <param name="wasSetter">A <see cref="T:System.Boolean" /> indicating if this was a "setter" operation.</param>
      <param name="persistentType">The <see cref="T:System.Type" /> that NHibernate was trying find the Property or Field in.</param>
      <param name="propertyName">The mapped property name that was trying to be accessed.</param>
    </member>
    <member name="M:NHibernate.PropertyAccessException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyAccessException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="M:NHibernate.PropertyAccessException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Sets the serialization info for <see cref="T:NHibernate.PropertyAccessException" /> after 
            getting the info from the base Exception.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="P:NHibernate.PropertyAccessException.PersistentType">
      <summary>
            Gets the <see cref="T:System.Type" /> that NHibernate was trying find the Property or Field in.
            </summary>
    </member>
    <member name="P:NHibernate.PropertyAccessException.Message">
      <summary>
            Gets a message that describes the current <see cref="T:NHibernate.PropertyAccessException" />.
            </summary>
      <value>
            The error message that explains the reason for this exception and 
            information about the mapped property and its usage.
            </value>
    </member>
    <member name="T:NHibernate.PropertyNotFoundException">
      <summary>
            Indicates that an expected getter or setter method could not be found on a class
            </summary>
    </member>
    <member name="M:NHibernate.PropertyNotFoundException.#ctor(System.Type,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException" /> class,
            used when a property get/set accessor is missing.
            </summary>
      <param name="targetType">The <see cref="T:System.Type" /> that is missing the property</param>
      <param name="propertyName">The name of the missing property</param>
      <param name="accessorType">The type of the missing accessor
            ("getter" or "setter")</param>
    </member>
    <member name="M:NHibernate.PropertyNotFoundException.#ctor(System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException" /> class,
            used when a field is missing.
            </summary>
      <param name="targetType">The <see cref="T:System.Type" /> that is missing the field</param>
      <param name="propertyName">The name of the missing property</param>
    </member>
    <member name="M:NHibernate.PropertyNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="M:NHibernate.PropertyValueException.#ctor(System.String,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyValueException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="entityName">The <see cref="T:System.Type" /> that NHibernate was trying to access.</param>
      <param name="propertyName">The name of the Property that was being get/set.</param>
    </member>
    <member name="M:NHibernate.PropertyValueException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyValueException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="M:NHibernate.PropertyValueException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Sets the serialization info for <see cref="T:NHibernate.PropertyValueException" /> after 
            getting the info from the base Exception.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.ReplicationMode">
      <summary> 
            Represents a replication strategy. 
            </summary>
      <seealso cref="M:NHibernate.ISession.Replicate(System.Object,NHibernate.ReplicationMode)" />
    </member>
    <member name="M:NHibernate.ReplicationMode.ExceptionReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
      <summary>
            Throw an exception when a row already exists
            </summary>
    </member>
    <member name="M:NHibernate.ReplicationMode.IgnoreReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
      <summary>
            Ignore replicated entities when a row already exists
            </summary>
    </member>
    <member name="M:NHibernate.ReplicationMode.LatestVersionReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
      <summary>
            When a row already exists, choose the latest version
            </summary>
    </member>
    <member name="M:NHibernate.ReplicationMode.OverwriteReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
      <summary>
            Overwrite existing rows when a row already exists
            </summary>
    </member>
    <member name="T:NHibernate.StaleObjectStateException">
      <summary>
            Thrown when a version number check failed, indicating that the 
            <see cref="T:NHibernate.ISession" /> contained stale data (when using long transactions with
            versioning).
            </summary>
    </member>
    <member name="M:NHibernate.StaleObjectStateException.#ctor(System.String,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.StaleObjectStateException" /> class.
            </summary>
      <param name="entityName">The EntityName that NHibernate was trying to update in the database.</param>
      <param name="identifier">The identifier of the object that is stale.</param>
    </member>
    <member name="M:NHibernate.StaleObjectStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.StaleObjectStateException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="M:NHibernate.StaleObjectStateException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Sets the serialization info for <see cref="T:NHibernate.StaleObjectStateException" /> after 
            getting the info from the base Exception.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="P:NHibernate.StaleObjectStateException.EntityName">
      <summary>
            Gets the EntityName that NHibernate was trying to update in the database.
            </summary>
    </member>
    <member name="P:NHibernate.StaleObjectStateException.Identifier">
      <summary>
            Gets the identifier of the object that is stale.
            </summary>
    </member>
    <member name="P:NHibernate.StaleObjectStateException.Message">
      <summary>
            Gets a message that describes the current <see cref="T:NHibernate.StaleObjectStateException" />.
            </summary>
      <value>The error message that explains the reason for this exception.</value>
    </member>
    <member name="T:NHibernate.TransactionException">
      <summary>
            Indicated that a transaction could not be begun, committed, or rolled back
            </summary>
    </member>
    <member name="M:NHibernate.TransactionException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransactionException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.TransactionException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransactionException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
    </member>
    <member name="M:NHibernate.TransactionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransactionException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.TransientObjectException">
      <summary>
            Throw when the user passes a transient instance to a <c>ISession</c> method that expects
            a persistent instance
            </summary>
    </member>
    <member name="M:NHibernate.TransientObjectException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransientObjectException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:NHibernate.TransientObjectException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransientObjectException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="T:NHibernate.TypeMismatchException">
      <summary> 
            Used when a user provided type does not match the expected one 
            </summary>
    </member>
    <member name="T:NHibernate.WrongClassException">
      <summary>
            Thrown when <c>ISession.Load()</c> selects a row with the given primary key (identifier value)
            but the row's discriminator value specifies a different subclass from the one requested
            </summary>
    </member>
    <member name="M:NHibernate.WrongClassException.#ctor(System.String,System.Object,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.WrongClassException" /> class.
            </summary>
      <param name="message">The message that describes the error. </param>
      <param name="identifier">The identifier of the object that was being loaded.</param>
      <param name="entityName">The name of entity that NHibernate was told to load.</param>
    </member>
    <member name="M:NHibernate.WrongClassException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.WrongClassException" /> class
            with serialized data.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="M:NHibernate.WrongClassException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Sets the serialization info for <see cref="T:NHibernate.WrongClassException" /> after 
            getting the info from the base Exception.
            </summary>
      <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object 
            data about the exception being thrown.
            </param>
      <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.
            </param>
    </member>
    <member name="P:NHibernate.WrongClassException.Identifier">
      <summary>
            Gets the identifier of the object that was being loaded.
            </summary>
    </member>
    <member name="P:NHibernate.WrongClassException.EntityName">
      <summary>
            Gets the name of entity that NHibernate was told to load.
            </summary>
    </member>
    <member name="P:NHibernate.WrongClassException.Message">
      <summary>
            Gets a message that describes the current <see cref="T:NHibernate.WrongClassException" />.
            </summary>
      <value>The error message that explains the reason for this exception.</value>
    </member>
    <member name="T:NHibernate.Linq.Expressions.NHibernateExpressionType">
      <summary>
            Extended node types for custom expressions
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Expressions.SqlFunctionAttribute">
      <summary>
            Associates a method with a corresponding SQL function.
            </summary>
    </member>
    <member name="M:NHibernate.Linq.Expressions.SqlFunctionAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Linq.Expressions.SqlFunctionAttribute" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.Linq.Expressions.SqlFunctionAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Linq.Expressions.SqlFunctionAttribute" /> class.
            </summary>
      <param name="owner">The name of the schema that owns the SQL function.</param>
    </member>
    <member name="P:NHibernate.Linq.Expressions.SqlFunctionAttribute.Owner">
      <summary>
            Gets or sets the name of the schema that owns the SQL function.
            </summary>
    </member>
    <member name="P:NHibernate.Linq.Expressions.SqlFunctionAttribute.PropertyPosition">
      <summary>
            Gets or sets the position of the function parameter that accepts the property name.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.SqlClient.SqlClientExtensions">
      <summary>
            Provides static methods that represent functionality provided by MS SQL Server.
            </summary>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Day(NHibernate.Linq.IDbMethods,System.DateTime)">
      <summary>
            Returns an integer representing the day datepart of the specified date.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Day(NHibernate.Linq.IDbMethods,System.Nullable{System.DateTime})">
      <summary>
            Returns an integer representing the day datepart of the specified date.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Month(NHibernate.Linq.IDbMethods,System.DateTime)">
      <summary>
            Returns an integer that represents the month part of a specified date.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Month(NHibernate.Linq.IDbMethods,System.Nullable{System.DateTime})">
      <summary>
            Returns an integer that represents the month part of a specified date.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Year(NHibernate.Linq.IDbMethods,System.DateTime)">
      <summary>
            Returns an integer that represents the year part of a specified date.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Year(NHibernate.Linq.IDbMethods,System.Nullable{System.DateTime})">
      <summary>
            Returns an integer that represents the year part of a specified date.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Ascii(NHibernate.Linq.IDbMethods,System.String)">
      <summary>
            Returns the ASCII code value of the leftmost character of a character expression.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Ascii(NHibernate.Linq.IDbMethods,System.Char)">
      <summary>
            Returns the ASCII code value of the leftmost character of a character expression.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Ascii(NHibernate.Linq.IDbMethods,System.Nullable{System.Char})">
      <summary>
            Returns the ASCII code value of the leftmost character of a character expression.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Char(NHibernate.Linq.IDbMethods,System.Int32)">
      <summary>
            Converts an int ASCII code to a character.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Char(NHibernate.Linq.IDbMethods,System.Nullable{System.Int32})">
      <summary>
            Converts an int ASCII code to a character.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.CharIndex(NHibernate.Linq.IDbMethods,System.String,System.Char)">
      <summary>
            Returns the starting position of the specified expression in a character string.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <param name="search">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.CharIndex(NHibernate.Linq.IDbMethods,System.String,System.Char,System.Int32)">
      <summary>
            Returns the starting position of the specified expression in a character string.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <param name="search">
      </param>
      <param name="start">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.CharIndex(NHibernate.Linq.IDbMethods,System.String,System.String)">
      <summary>
            Returns the starting position of the specified expression in a character string.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <param name="search">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.CharIndex(NHibernate.Linq.IDbMethods,System.String,System.String,System.Int32)">
      <summary>
            Returns the starting position of the specified expression in a character string.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <param name="search">
      </param>
      <param name="start">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Left(NHibernate.Linq.IDbMethods,System.String,System.Int32)">
      <summary>
            Returns the left part of a character string with the specified number of characters.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <param name="length">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Len(NHibernate.Linq.IDbMethods,System.String)">
      <summary>
            Returns the number of characters of the specified string expression, excluding trailing blanks.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Lower(NHibernate.Linq.IDbMethods,System.String)">
      <summary>
            Returns a character expression after converting uppercase character data to lowercase.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.LTrim(NHibernate.Linq.IDbMethods,System.String)">
      <summary>
            Returns a character expression after it removes leading blanks.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Replace(NHibernate.Linq.IDbMethods,System.String,System.String,System.String)">
      <summary>
            Replaces all occurrences of a specified string value with another string value.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <param name="search">
      </param>
      <param name="replace">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Replicate(NHibernate.Linq.IDbMethods,System.String,System.Int32)">
      <summary>
            Repeats a string value a specified number of times.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <param name="count">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Reverse(NHibernate.Linq.IDbMethods,System.String)">
      <summary>
            Returns the reverse of a character expression.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Right(NHibernate.Linq.IDbMethods,System.String,System.Int32)">
      <summary>
            Returns the right part of a character string with the specified number of characters.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <param name="length">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.RTrim(NHibernate.Linq.IDbMethods,System.String)">
      <summary>
            Returns a character string after truncating all trailing blanks.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Substring(NHibernate.Linq.IDbMethods,System.String,System.Int32,System.Int32)">
      <summary>
            Returns part of a character, binary, text, or image expression.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <param name="start">
      </param>
      <param name="length">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.SqlClient.SqlClientExtensions.Upper(NHibernate.Linq.IDbMethods,System.String)">
      <summary>
            Returns a character expression with lowercase character data converted to uppercase.
            </summary>
      <param name="methods">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NHibernate.Linq.Transform.LinqGroupingResultTransformer">
      <summary>
            Transforms critieria query results into a collection of grouped objects.
            </summary>
    </member>
    <member name="M:NHibernate.Linq.Transform.LinqGroupingResultTransformer.#ctor(System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Linq.LinqGroupingResultTransformer" /> class.
            </summary>
      <param name="type">A <see cref="T:System.Type" /> representing the type of collection to transform.</param>
      <param name="propertyName">The name of the property to be used as a key for the purpose of grouping.</param>
    </member>
    <member name="M:NHibernate.Linq.Transform.LinqGroupingResultTransformer.TransformList(System.Collections.IList)">
      <summary>
            Transforms the query result collection.
            </summary>
      <param name="collection">An <see cref="T:System.Collections.IList" /> of objects.</param>
      <returns>A transformed <see cref="T:System.Collections.IList" /> object.</returns>
    </member>
    <member name="M:NHibernate.Linq.Transform.LinqGroupingResultTransformer.TransformTuple(System.Object[],System.String[])">
      <summary>
            Transforms each query result.
            </summary>
      <param name="tuple">An <see cref="T:System.Object" /> array of query result values.</param>
      <param name="aliases">A <see cref="T:System.String" /> array of column aliases.</param>
      <returns>An <see cref="T:System.Object" /> initialized with the values from the specified tuple.</returns>
    </member>
    <member name="T:NHibernate.Linq.Transform.IGrouping">
      <summary>
            Provides a method for adding individual objects to a collection of grouped objects.
            </summary>
    </member>
    <member name="M:NHibernate.Linq.Transform.IGrouping.Add(System.Object)">
      <summary>
            Adds an object to the current group.
            </summary>
      <param name="item">The <see cref="T:System.Object" /> to add.</param>
    </member>
    <member name="T:NHibernate.Linq.Transform.Grouping`2">
      <summary>
            Represents a collection of objects that have a common key.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TElement">
      </typeparam>
    </member>
    <member name="M:NHibernate.Linq.Transform.Grouping`2.#ctor(`0)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Linq.Grouping" /> class.
            </summary>
      <param name="key">
      </param>
    </member>
    <member name="M:NHibernate.Linq.Transform.Grouping`2.Add(System.Object)">
      <summary>
            Adds an object to the current group.
            </summary>
      <param name="item">The <see cref="T:System.Object" /> to add.</param>
    </member>
    <member name="M:NHibernate.Linq.Transform.Grouping`2.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
    </member>
    <member name="M:NHibernate.Linq.Transform.Grouping`2.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:NHibernate.Linq.Transform.Grouping`2.Key">
      <summary>
            Gets the key of the <see cref="T:System.Linq.IGrouping`2" />.
            </summary>
    </member>
    <member name="M:NHibernate.Transform.TypeSafeConstructorMemberInitResultTransformer.SetValue(System.Reflection.MemberInfo,System.Object,System.Object)">
      <summary>
            Sets the value of the field or property represented by the specified
            <see cref="T:System.Reflection.MemberInfo" /> for the supplied object instance.
            </summary>
      <param name="memberInfo">A <see cref="T:System.Reflection.MemberInfo" /> object.</param>
      <param name="instance">An instance of an object.</param>
      <param name="valueToSet">The value to set on the specified object.</param>
    </member>
    <member name="T:NHibernate.Linq.Util.LinqUtil">
      <summary>
            Provides static utility methods that aid in evaluating expression trees.
            </summary>
    </member>
    <member name="M:NHibernate.Linq.Util.LinqUtil.Iterate``1(System.Func{``0,``0},``0)">
      <summary>
            Creates a collection of type T by invoking a delegate method during
            enumeration that return each item, begining with an initialValue.
            </summary>
      <typeparam name="T">The type of collection being created.</typeparam>
      <param name="func">A delegate method to invoke.</param>
      <param name="initialValue">The first item in the collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type T.</returns>
    </member>
    <member name="M:NHibernate.Linq.Util.LinqUtil.ChangeType(System.Object,System.Type)">
      <summary>
            Returns an <see cref="T:System.Object" /> with the specified <see cref="T:System.Type" />
            and whose value is equivalent to the specified object.
            </summary>
      <param name="value">An <see cref="T:System.Object" /> that implements the <see cref="T:System.IConvertible" /> interface.</param>
      <param name="conversionType">A <see cref="T:System.Type" />.</param>
      <returns>An object whose <see cref="T:System.Type" /> is conversionType and whose value is equivalent
            to value, or null, if value is null and conversionType is not a value type.</returns>
    </member>
    <member name="M:NHibernate.Linq.Util.LinqUtil.IsNullableType(System.Type)">
      <summary>
            Determines if the specified type is a <see cref="T:System.Nullable`1" /> type.
            </summary>
      <param name="type">A <see cref="T:System.Type" /> to check.</param>
      <returns>True if the type is a <see cref="T:System.Nullable`1" /> type, otherwise false.</returns>
    </member>
    <member name="M:NHibernate.Linq.Util.LinqUtil.IsAnonymousType(System.Type)">
      <summary>
            Determines if the specified type is an anonymous type.
            </summary>
      <param name="type">A <see cref="T:System.Type" /> to check.</param>
      <returns>True if the type is an anonymous type, otherwise false.</returns>
    </member>
    <member name="M:NHibernate.Linq.Util.LinqUtil.SqlEncode(System.Object)">
      <summary>
            Encodes an <see cref="T:System.Object" /> for use in SQL statements.
            </summary>
      <param name="value">The value to encode.</param>
      <returns>A SQL encoded value.</returns>
    </member>
    <member name="T:NHibernate.Linq.Util.TypeSystem">
      <remarks>
            http://blogs.msdn.com/mattwar/archive/2007/07/30/linq-building-an-iqueryable-provider-part-i.aspx
            </remarks>
    </member>
    <member name="T:NHibernate.Linq.Visitors.ExpressionVisitor">
      <summary>
            Provides virtual methods that can be used by subclasses to parse an expression tree.
            </summary>
      <remarks>
            This class actually already exists in the System.Core assembly...as an internal class.
            I can only speculate as to why it is internal, but it is obviously much too dangerous
            for anyone outside of Microsoft to be using...
            </remarks>
    </member>
    <member name="T:NHibernate.Linq.Visitors.AssociationVisitor">
      <summary>
            Preprocesses an expression tree replacing MemberAccessExpressions and ParameterExpressions with
            NHibernate-specific PropertyAccessExpressions and EntityExpressions respectively.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.BinaryBooleanReducer">
      <summary>
            Preprocesses an expression tree replacing binary boolean expressions with unary expressions.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.ComparePropToProp">
      <summary>
            Represents a method that returns an <see cref="T:NHibernate.Criterion.ICriterion" />
            object that compares one property to another property using a binary expression.
            </summary>
      <param name="propertyName">The name of the property to compare on the left hand side of the expression.</param>
      <param name="otherPropertyName">The name of the property to compare on the right hand side of the expression.</param>
      <returns>An initialized <see cref="T:NHibernate.Criterion.ICriterion" /> object.</returns>
    </member>
    <member name="T:NHibernate.Linq.Visitors.ComparePropToValue">
      <summary>
            Represents a method that returns an <see cref="T:NHibernate.Criterion.ICriterion" />
            object that compares a property to a constant value using a binary expression.
            </summary>
      <param name="propertyName">The name of the property to compare on the left hand side of the expression.</param>
      <param name="value">The constant value used for the right hand side of the expression.</param>
      <returns>An initialized <see cref="T:NHibernate.Criterion.ICriterion" /> object.</returns>
    </member>
    <member name="T:NHibernate.Linq.Visitors.CompareValueToCriteria">
      <summary>
            Represents a method that returns an <see cref="T:NHibernate.Criterion.ICriterion" />
            object that compares a value to a criteria using a binary expression.
            </summary>
      <param name="value">The value on the left hand side of the expression.</param>
      <param name="criteria">The <see cref="T:NHibernate.Criterion.DetachedCriteria" /> used for the right hand side of the expression.</param>
      <returns>An initialized <see cref="T:NHibernate.Criterion.ICriterion" /> object.</returns>
    </member>
    <member name="T:NHibernate.Linq.Visitors.ComparePropToCriteria">
      <summary>
            Represents a method that returns an <see cref="T:NHibernate.Criterion.ICriterion" />
            object that compares a property to a criteria using a binary expression.
            </summary>
      <param name="propertyName">The name of the property to compare on the left hand side of the expression.</param>
      <param name="criteria">The <see cref="T:NHibernate.Criterion.DetachedCriteria" /> used for the right hand side of the expression.</param>
      <returns>An initialized <see cref="T:NHibernate.Criterion.ICriterion" /> object.</returns>
    </member>
    <member name="T:NHibernate.Linq.Visitors.NHibernateExpressionVisitor">
      <summary>
            NHibernate-specific base expression visitor.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.BinaryCriterionVisitor">
      <summary>
            Visits a BinaryExpression providing the appropriate NHibernate ICriterion.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.BinaryExpressionOrderer">
      <summary>
            Preprocesses an expression tree ordering binary expressions in accordance with the <see cref="T:NHibernate.Linq.Visitors.BinaryCriterionVisitor" />.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.CollectionAliasVisitor">
      <summary>
            Assigns the appropriate aliases to a collection access.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.EntityExpressionVisitor">
      <summary>
            Retrieves the first (or root) instance of EntityExpression found in the given Expression.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.Evaluator.Nominator">
      <summary>
            Performs bottom-up analysis to determine which nodes can possibly
            be part of an evaluated sub-tree.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.GroupingArgumentsVisitor">
      <summary>
            Visits an expression tree providing the appropriate projections for grouping arguments.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.ImmediateResultsVisitor`1">
      <summary>
            Visits any expression calls that require immediate results.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.MemberNameVisitor">
      <summary>
            Visits an expression providing the member name being accessed based on the EntityExpressions and
            PropertyAccessExpressions in the expression tree. Any entity associations encountered are added
            as subcriteria to the query.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.NHibernateQueryTranslator">
      <summary>
            Translates a Linq Expression into an NHibernate ICriteria object.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.PropertyToMethodVisitor">
      <summary>
            Converts calls to an IEnumerable.Count property to IEnumerable.Count() extension method.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.RootVisitor">
      <summary>
            Translates a Linq Expression into an NHibernate ICriteria object.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.SelectArgumentsVisitor">
      <summary>
            Provides the appropriate NHibernate selection projections and/or IResultTransformers
            based on a given expression tree.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.SelectManyVisitor">
      <summary>
            Adds the appropriate subcriteria to the query based on a SelectMany expression tree.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Visitors.WhereArgumentsVisitor">
      <summary>
            Provides ICriterion for a query given a Linq expression tree.
            </summary>
    </member>
    <member name="P:NHibernate.Linq.Visitors.WhereArgumentsVisitor.CurrentCriterions">
      <summary>
            Gets the current collection of <see cref="T:NHibernate.Criterion.ICriterion" /> objects.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.CriteriaResultReader`1">
      <summary>
            Wraps an ICriteria object providing results when necessary.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NHibernate.Linq.IDbMethods">
      <summary>
            Marker interface used to conditionally include database provider specific methods.
            </summary>
    </member>
    <member name="T:NHibernate.Linq.NHibernateContext">
      <summary>
            Wraps an <see cref="T:NHibernate.ISession" /> object to provide base functionality
            for custom, database-specific context classes.
            </summary>
    </member>
    <member name="F:NHibernate.Linq.NHibernateContext.Methods">
      <summary>
            Provides access to database provider specific methods.
            </summary>
    </member>
    <member name="M:NHibernate.Linq.NHibernateContext.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Linq.NHibernateContext" /> class.
            </summary>
    </member>
    <member name="M:NHibernate.Linq.NHibernateContext.#ctor(NHibernate.ISession)">
      <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Linq.NHibernateContext" /> class.
            </summary>
      <param name="session">An initialized <see cref="T:NHibernate.ISession" /> object.</param>
    </member>
    <member name="M:NHibernate.Linq.NHibernateContext.ProvideSession">
      <summary>
            Allows for empty construction but provides an interface for an interface to have the derived 
            classes provide a session object late in the cycle. 
            </summary>
      <returns>The Required <see cref="T:NHibernate.ISession" /> object.</returns>
    </member>
    <member name="M:NHibernate.Linq.NHibernateContext.Clone">
      <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NHibernate.Linq.NHibernateContext.Dispose">
      <summary>
            Disposes the wrapped <see cref="T:NHibernate.ISession" /> object.
            </summary>
    </member>
    <member name="P:NHibernate.Linq.NHibernateContext.Session">
      <summary>
            Gets a reference to the <see cref="T:NHibernate.ISession" /> associated with this object.
            </summary>
    </member>
    <member name="P:NHibernate.Linq.NHibernateContext.UpdateCache">
      <summary>
            Gets the update cache.
            </summary>
      <value>The update cache.</value>
    </member>
    <member name="T:NHibernate.Linq.NHibernateExtensions">
      <summary>
            Provides a static method that enables LINQ syntax for NHibernate Criteria Queries.
            </summary>
    </member>
    <member name="M:NHibernate.Linq.NHibernateExtensions.Linq``1(NHibernate.ISession)">
      <summary>
            Creates a new <see cref="T:NHibernate.Linq.NHibernateQueryProvider" /> object used to evaluate an expression tree.
            </summary>
      <typeparam name="T">An NHibernate entity type.</typeparam>
      <param name="session">An initialized <see cref="T:NHibernate.ISession" /> object.</param>
      <returns>An <see cref="T:NHibernate.Linq.NHibernateQueryProvider" /> used to evaluate an expression tree.</returns>
    </member>
    <member name="T:NHibernate.Linq.QueryProvider">
      <summary>
            Generic IQueryProvider base class. See http://blogs.msdn.com/mattwar/archive/2007/07/30/linq-building-an-iqueryable-provider-part-i.aspx
            </summary>
    </member>
    <member name="T:NHibernate.Linq.Query`1">
      <summary>
             Generic IQueryable base class. See http://blogs.msdn.com/mattwar/archive/2007/07/30/linq-building-an-iqueryable-provider-part-i.aspx
             </summary>
    </member>
    <member name="T:NHibernate.Linq.QueryOptions">
      <summary>
            It provides methods for caching the results, and some extension methods for them.
            </summary>
    </member>
  </members>
</doc>